// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	internal "github.com/hassan-ptpal/vapi-server-sdk-go/internal"
)

type AnalyticsQueryDto struct {
	// This is the list of metric queries you want to perform.
	Queries []*AnalyticsQuery `json:"queries,omitempty" url:"-"`
}

type AnalyticsOperation struct {
	// This is the aggregation operation you want to perform.
	Operation AnalyticsOperationOperation `json:"operation" url:"operation"`
	// This is the columns you want to perform the aggregation operation on.
	Column AnalyticsOperationColumn `json:"column" url:"column"`
	// This is the alias for column name returned. Defaults to `${operation}${column}`.
	Alias *string `json:"alias,omitempty" url:"alias,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsOperation) GetOperation() AnalyticsOperationOperation {
	if a == nil {
		return ""
	}
	return a.Operation
}

func (a *AnalyticsOperation) GetColumn() AnalyticsOperationColumn {
	if a == nil {
		return ""
	}
	return a.Column
}

func (a *AnalyticsOperation) GetAlias() *string {
	if a == nil {
		return nil
	}
	return a.Alias
}

func (a *AnalyticsOperation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsOperation) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the columns you want to perform the aggregation operation on.
type AnalyticsOperationColumn string

const (
	AnalyticsOperationColumnId                               AnalyticsOperationColumn = "id"
	AnalyticsOperationColumnCost                             AnalyticsOperationColumn = "cost"
	AnalyticsOperationColumnCostBreakdownLlm                 AnalyticsOperationColumn = "costBreakdown.llm"
	AnalyticsOperationColumnCostBreakdownStt                 AnalyticsOperationColumn = "costBreakdown.stt"
	AnalyticsOperationColumnCostBreakdownTts                 AnalyticsOperationColumn = "costBreakdown.tts"
	AnalyticsOperationColumnCostBreakdownVapi                AnalyticsOperationColumn = "costBreakdown.vapi"
	AnalyticsOperationColumnCostBreakdownTtsCharacters       AnalyticsOperationColumn = "costBreakdown.ttsCharacters"
	AnalyticsOperationColumnCostBreakdownLlmPromptTokens     AnalyticsOperationColumn = "costBreakdown.llmPromptTokens"
	AnalyticsOperationColumnCostBreakdownLlmCompletionTokens AnalyticsOperationColumn = "costBreakdown.llmCompletionTokens"
	AnalyticsOperationColumnDuration                         AnalyticsOperationColumn = "duration"
	AnalyticsOperationColumnConcurrency                      AnalyticsOperationColumn = "concurrency"
	AnalyticsOperationColumnMinutesUsed                      AnalyticsOperationColumn = "minutesUsed"
)

func NewAnalyticsOperationColumnFromString(s string) (AnalyticsOperationColumn, error) {
	switch s {
	case "id":
		return AnalyticsOperationColumnId, nil
	case "cost":
		return AnalyticsOperationColumnCost, nil
	case "costBreakdown.llm":
		return AnalyticsOperationColumnCostBreakdownLlm, nil
	case "costBreakdown.stt":
		return AnalyticsOperationColumnCostBreakdownStt, nil
	case "costBreakdown.tts":
		return AnalyticsOperationColumnCostBreakdownTts, nil
	case "costBreakdown.vapi":
		return AnalyticsOperationColumnCostBreakdownVapi, nil
	case "costBreakdown.ttsCharacters":
		return AnalyticsOperationColumnCostBreakdownTtsCharacters, nil
	case "costBreakdown.llmPromptTokens":
		return AnalyticsOperationColumnCostBreakdownLlmPromptTokens, nil
	case "costBreakdown.llmCompletionTokens":
		return AnalyticsOperationColumnCostBreakdownLlmCompletionTokens, nil
	case "duration":
		return AnalyticsOperationColumnDuration, nil
	case "concurrency":
		return AnalyticsOperationColumnConcurrency, nil
	case "minutesUsed":
		return AnalyticsOperationColumnMinutesUsed, nil
	}
	var t AnalyticsOperationColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsOperationColumn) Ptr() *AnalyticsOperationColumn {
	return &a
}

// This is the aggregation operation you want to perform.
type AnalyticsOperationOperation string

const (
	AnalyticsOperationOperationSum     AnalyticsOperationOperation = "sum"
	AnalyticsOperationOperationAvg     AnalyticsOperationOperation = "avg"
	AnalyticsOperationOperationCount   AnalyticsOperationOperation = "count"
	AnalyticsOperationOperationMin     AnalyticsOperationOperation = "min"
	AnalyticsOperationOperationMax     AnalyticsOperationOperation = "max"
	AnalyticsOperationOperationHistory AnalyticsOperationOperation = "history"
)

func NewAnalyticsOperationOperationFromString(s string) (AnalyticsOperationOperation, error) {
	switch s {
	case "sum":
		return AnalyticsOperationOperationSum, nil
	case "avg":
		return AnalyticsOperationOperationAvg, nil
	case "count":
		return AnalyticsOperationOperationCount, nil
	case "min":
		return AnalyticsOperationOperationMin, nil
	case "max":
		return AnalyticsOperationOperationMax, nil
	case "history":
		return AnalyticsOperationOperationHistory, nil
	}
	var t AnalyticsOperationOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsOperationOperation) Ptr() *AnalyticsOperationOperation {
	return &a
}

type AnalyticsQuery struct {
	// This is the table you want to query.
	Table AnalyticsQueryTable `json:"table" url:"table"`
	// This is the list of columns you want to group by.
	GroupBy []AnalyticsQueryGroupByItem `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// This is the name of the query. This will be used to identify the query in the response.
	Name string `json:"name" url:"name"`
	// This is the time range for the query.
	TimeRange *TimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the list of operations you want to perform.
	Operations []*AnalyticsOperation `json:"operations,omitempty" url:"operations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsQuery) GetTable() AnalyticsQueryTable {
	if a == nil {
		return ""
	}
	return a.Table
}

func (a *AnalyticsQuery) GetGroupBy() []AnalyticsQueryGroupByItem {
	if a == nil {
		return nil
	}
	return a.GroupBy
}

func (a *AnalyticsQuery) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AnalyticsQuery) GetTimeRange() *TimeRange {
	if a == nil {
		return nil
	}
	return a.TimeRange
}

func (a *AnalyticsQuery) GetOperations() []*AnalyticsOperation {
	if a == nil {
		return nil
	}
	return a.Operations
}

func (a *AnalyticsQuery) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsQuery) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalyticsQueryGroupByItem string

const (
	AnalyticsQueryGroupByItemType                      AnalyticsQueryGroupByItem = "type"
	AnalyticsQueryGroupByItemAssistantId               AnalyticsQueryGroupByItem = "assistantId"
	AnalyticsQueryGroupByItemEndedReason               AnalyticsQueryGroupByItem = "endedReason"
	AnalyticsQueryGroupByItemAnalysisSuccessEvaluation AnalyticsQueryGroupByItem = "analysis.successEvaluation"
	AnalyticsQueryGroupByItemStatus                    AnalyticsQueryGroupByItem = "status"
)

func NewAnalyticsQueryGroupByItemFromString(s string) (AnalyticsQueryGroupByItem, error) {
	switch s {
	case "type":
		return AnalyticsQueryGroupByItemType, nil
	case "assistantId":
		return AnalyticsQueryGroupByItemAssistantId, nil
	case "endedReason":
		return AnalyticsQueryGroupByItemEndedReason, nil
	case "analysis.successEvaluation":
		return AnalyticsQueryGroupByItemAnalysisSuccessEvaluation, nil
	case "status":
		return AnalyticsQueryGroupByItemStatus, nil
	}
	var t AnalyticsQueryGroupByItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsQueryGroupByItem) Ptr() *AnalyticsQueryGroupByItem {
	return &a
}

type AnalyticsQueryResult struct {
	// This is the unique key for the query.
	Name string `json:"name" url:"name"`
	// This is the time range for the query.
	TimeRange *TimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the result of the query, a list of unique groups with result of their aggregations.
	//
	// Example:
	// "result": [
	//
	//	{ "date": "2023-01-01", "assistantId": "123", "endedReason": "customer-ended-call", "sumDuration": 120, "avgCost": 10.5 },
	//	{ "date": "2023-01-02", "assistantId": "123", "endedReason": "customer-did-not-give-microphone-permission", "sumDuration": 0, "avgCost": 0 },
	//	// Additional results
	//
	// ]
	Result []map[string]interface{} `json:"result,omitempty" url:"result,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsQueryResult) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AnalyticsQueryResult) GetTimeRange() *TimeRange {
	if a == nil {
		return nil
	}
	return a.TimeRange
}

func (a *AnalyticsQueryResult) GetResult() []map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Result
}

func (a *AnalyticsQueryResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsQueryResult) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsQueryResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsQueryResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsQueryResult) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the table you want to query.
type AnalyticsQueryTable string

const (
	AnalyticsQueryTableCall         AnalyticsQueryTable = "call"
	AnalyticsQueryTableSubscription AnalyticsQueryTable = "subscription"
)

func NewAnalyticsQueryTableFromString(s string) (AnalyticsQueryTable, error) {
	switch s {
	case "call":
		return AnalyticsQueryTableCall, nil
	case "subscription":
		return AnalyticsQueryTableSubscription, nil
	}
	var t AnalyticsQueryTable
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsQueryTable) Ptr() *AnalyticsQueryTable {
	return &a
}

type TimeRange struct {
	// This is the time step for aggregations.
	//
	// If not provided, defaults to returning for the entire time range.
	Step *TimeRangeStep `json:"step,omitempty" url:"step,omitempty"`
	// This is the start date for the time range.
	//
	// If not provided, defaults to the 7 days ago.
	Start *time.Time `json:"start,omitempty" url:"start,omitempty"`
	// This is the end date for the time range.
	//
	// If not provided, defaults to now.
	End *time.Time `json:"end,omitempty" url:"end,omitempty"`
	// This is the timezone you want to set for the query.
	//
	// If not provided, defaults to UTC.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimeRange) GetStep() *TimeRangeStep {
	if t == nil {
		return nil
	}
	return t.Step
}

func (t *TimeRange) GetStart() *time.Time {
	if t == nil {
		return nil
	}
	return t.Start
}

func (t *TimeRange) GetEnd() *time.Time {
	if t == nil {
		return nil
	}
	return t.End
}

func (t *TimeRange) GetTimezone() *string {
	if t == nil {
		return nil
	}
	return t.Timezone
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type embed TimeRange
	var unmarshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeRange(unmarshaler.embed)
	t.Start = unmarshaler.Start.TimePtr()
	t.End = unmarshaler.End.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) MarshalJSON() ([]byte, error) {
	type embed TimeRange
	var marshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*t),
		Start: internal.NewOptionalDateTime(t.Start),
		End:   internal.NewOptionalDateTime(t.End),
	}
	return json.Marshal(marshaler)
}

func (t *TimeRange) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the time step for aggregations.
//
// If not provided, defaults to returning for the entire time range.
type TimeRangeStep string

const (
	TimeRangeStepSecond     TimeRangeStep = "second"
	TimeRangeStepMinute     TimeRangeStep = "minute"
	TimeRangeStepHour       TimeRangeStep = "hour"
	TimeRangeStepDay        TimeRangeStep = "day"
	TimeRangeStepWeek       TimeRangeStep = "week"
	TimeRangeStepMonth      TimeRangeStep = "month"
	TimeRangeStepQuarter    TimeRangeStep = "quarter"
	TimeRangeStepYear       TimeRangeStep = "year"
	TimeRangeStepDecade     TimeRangeStep = "decade"
	TimeRangeStepCentury    TimeRangeStep = "century"
	TimeRangeStepMillennium TimeRangeStep = "millennium"
)

func NewTimeRangeStepFromString(s string) (TimeRangeStep, error) {
	switch s {
	case "second":
		return TimeRangeStepSecond, nil
	case "minute":
		return TimeRangeStepMinute, nil
	case "hour":
		return TimeRangeStepHour, nil
	case "day":
		return TimeRangeStepDay, nil
	case "week":
		return TimeRangeStepWeek, nil
	case "month":
		return TimeRangeStepMonth, nil
	case "quarter":
		return TimeRangeStepQuarter, nil
	case "year":
		return TimeRangeStepYear, nil
	case "decade":
		return TimeRangeStepDecade, nil
	case "century":
		return TimeRangeStepCentury, nil
	case "millennium":
		return TimeRangeStepMillennium, nil
	}
	var t TimeRangeStep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeRangeStep) Ptr() *TimeRangeStep {
	return &t
}
