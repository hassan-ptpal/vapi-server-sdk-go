// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	internal "github.com/hassan-ptpal/vapi-server-sdk-go/internal"
)

type AddVoiceToProviderDto struct {
	// This is the owner_id of your shared voice which you want to add to your provider Account from Provider Voice Library
	OwnerId string `json:"ownerId" url:"ownerId"`
	// This is the voice_id of the shared voice which you want to add to your provider Account from Provider Voice Library
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the new name of the voice which you want to have once you have added voice to your provider Account from Provider Voice Library
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddVoiceToProviderDto) GetOwnerId() string {
	if a == nil {
		return ""
	}
	return a.OwnerId
}

func (a *AddVoiceToProviderDto) GetVoiceId() string {
	if a == nil {
		return ""
	}
	return a.VoiceId
}

func (a *AddVoiceToProviderDto) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AddVoiceToProviderDto) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddVoiceToProviderDto) UnmarshalJSON(data []byte) error {
	type unmarshaler AddVoiceToProviderDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddVoiceToProviderDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddVoiceToProviderDto) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AiEdgeCondition struct {
	// This is the prompt for the AI edge condition. It should evaluate to a boolean.
	Prompt string `json:"prompt" url:"prompt"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AiEdgeCondition) GetPrompt() string {
	if a == nil {
		return ""
	}
	return a.Prompt
}

func (a *AiEdgeCondition) Type() string {
	return a.type_
}

func (a *AiEdgeCondition) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AiEdgeCondition) UnmarshalJSON(data []byte) error {
	type embed AiEdgeCondition
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AiEdgeCondition(unmarshaler.embed)
	if unmarshaler.Type != "ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "ai", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AiEdgeCondition) MarshalJSON() ([]byte, error) {
	type embed AiEdgeCondition
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "ai",
	}
	return json.Marshal(marshaler)
}

func (a *AiEdgeCondition) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalysisPlan struct {
	// This is the plan for generating the summary of the call. This outputs to `call.analysis.summary`.
	SummaryPlan *SummaryPlan `json:"summaryPlan,omitempty" url:"summaryPlan,omitempty"`
	// This is the plan for generating the structured data from the call. This outputs to `call.analysis.structuredData`.
	StructuredDataPlan *StructuredDataPlan `json:"structuredDataPlan,omitempty" url:"structuredDataPlan,omitempty"`
	// This is an array of structured data plan catalogs. Each entry includes a `key` and a `plan` for generating the structured data from the call. This outputs to `call.analysis.structuredDataMulti`.
	StructuredDataMultiPlan []*StructuredDataMultiPlan `json:"structuredDataMultiPlan,omitempty" url:"structuredDataMultiPlan,omitempty"`
	// This is the plan for generating the success evaluation of the call. This outputs to `call.analysis.successEvaluation`.
	SuccessEvaluationPlan *SuccessEvaluationPlan `json:"successEvaluationPlan,omitempty" url:"successEvaluationPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalysisPlan) GetSummaryPlan() *SummaryPlan {
	if a == nil {
		return nil
	}
	return a.SummaryPlan
}

func (a *AnalysisPlan) GetStructuredDataPlan() *StructuredDataPlan {
	if a == nil {
		return nil
	}
	return a.StructuredDataPlan
}

func (a *AnalysisPlan) GetStructuredDataMultiPlan() []*StructuredDataMultiPlan {
	if a == nil {
		return nil
	}
	return a.StructuredDataMultiPlan
}

func (a *AnalysisPlan) GetSuccessEvaluationPlan() *SuccessEvaluationPlan {
	if a == nil {
		return nil
	}
	return a.SuccessEvaluationPlan
}

func (a *AnalysisPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalysisPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalysisPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalysisPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalysisPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnthropicCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnthropicCredential) GetApiKey() string {
	if a == nil {
		return ""
	}
	return a.ApiKey
}

func (a *AnthropicCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AnthropicCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AnthropicCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AnthropicCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AnthropicCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AnthropicCredential) Provider() string {
	return a.provider
}

func (a *AnthropicCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnthropicCredential) UnmarshalJSON(data []byte) error {
	type embed AnthropicCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnthropicCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anthropic", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnthropicCredential) MarshalJSON() ([]byte, error) {
	type embed AnthropicCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "anthropic",
	}
	return json.Marshal(marshaler)
}

func (a *AnthropicCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnthropicModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*AnthropicModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// The specific Anthropic/Claude model that will be used.
	Model AnthropicModelModel `json:"model" url:"model"`
	// The provider identifier for Anthropic.
	// Optional configuration for Anthropic's thinking feature.
	// Only applicable for claude-3-7-sonnet-20250219 model.
	// If provided, maxTokens must be greater than thinking.budgetTokens.
	Thinking *AnthropicThinkingConfig `json:"thinking,omitempty" url:"thinking,omitempty"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnthropicModel) GetMessages() []*OpenAiMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *AnthropicModel) GetTools() []*AnthropicModelToolsItem {
	if a == nil {
		return nil
	}
	return a.Tools
}

func (a *AnthropicModel) GetToolIds() []string {
	if a == nil {
		return nil
	}
	return a.ToolIds
}

func (a *AnthropicModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if a == nil {
		return nil
	}
	return a.KnowledgeBase
}

func (a *AnthropicModel) GetKnowledgeBaseId() *string {
	if a == nil {
		return nil
	}
	return a.KnowledgeBaseId
}

func (a *AnthropicModel) GetModel() AnthropicModelModel {
	if a == nil {
		return ""
	}
	return a.Model
}

func (a *AnthropicModel) GetThinking() *AnthropicThinkingConfig {
	if a == nil {
		return nil
	}
	return a.Thinking
}

func (a *AnthropicModel) GetTemperature() *float64 {
	if a == nil {
		return nil
	}
	return a.Temperature
}

func (a *AnthropicModel) GetMaxTokens() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxTokens
}

func (a *AnthropicModel) GetEmotionRecognitionEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.EmotionRecognitionEnabled
}

func (a *AnthropicModel) GetNumFastTurns() *float64 {
	if a == nil {
		return nil
	}
	return a.NumFastTurns
}

func (a *AnthropicModel) Provider() string {
	return a.provider
}

func (a *AnthropicModel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnthropicModel) UnmarshalJSON(data []byte) error {
	type embed AnthropicModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnthropicModel(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anthropic", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnthropicModel) MarshalJSON() ([]byte, error) {
	type embed AnthropicModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (a *AnthropicModel) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The specific Anthropic/Claude model that will be used.
type AnthropicModelModel string

const (
	AnthropicModelModelClaude3Opus20240229    AnthropicModelModel = "claude-3-opus-20240229"
	AnthropicModelModelClaude3Sonnet20240229  AnthropicModelModel = "claude-3-sonnet-20240229"
	AnthropicModelModelClaude3Haiku20240307   AnthropicModelModel = "claude-3-haiku-20240307"
	AnthropicModelModelClaude35Sonnet20240620 AnthropicModelModel = "claude-3-5-sonnet-20240620"
	AnthropicModelModelClaude35Sonnet20241022 AnthropicModelModel = "claude-3-5-sonnet-20241022"
	AnthropicModelModelClaude35Haiku20241022  AnthropicModelModel = "claude-3-5-haiku-20241022"
	AnthropicModelModelClaude37Sonnet20250219 AnthropicModelModel = "claude-3-7-sonnet-20250219"
)

func NewAnthropicModelModelFromString(s string) (AnthropicModelModel, error) {
	switch s {
	case "claude-3-opus-20240229":
		return AnthropicModelModelClaude3Opus20240229, nil
	case "claude-3-sonnet-20240229":
		return AnthropicModelModelClaude3Sonnet20240229, nil
	case "claude-3-haiku-20240307":
		return AnthropicModelModelClaude3Haiku20240307, nil
	case "claude-3-5-sonnet-20240620":
		return AnthropicModelModelClaude35Sonnet20240620, nil
	case "claude-3-5-sonnet-20241022":
		return AnthropicModelModelClaude35Sonnet20241022, nil
	case "claude-3-5-haiku-20241022":
		return AnthropicModelModelClaude35Haiku20241022, nil
	case "claude-3-7-sonnet-20250219":
		return AnthropicModelModelClaude37Sonnet20250219, nil
	}
	var t AnthropicModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnthropicModelModel) Ptr() *AnthropicModelModel {
	return &a
}

type AnthropicModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (a *AnthropicModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if a == nil {
		return nil
	}
	return a.CreateApiRequestToolDto
}

func (a *AnthropicModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if a == nil {
		return nil
	}
	return a.CreateBashToolDto
}

func (a *AnthropicModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if a == nil {
		return nil
	}
	return a.CreateComputerToolDto
}

func (a *AnthropicModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if a == nil {
		return nil
	}
	return a.CreateDtmfToolDto
}

func (a *AnthropicModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateEndCallToolDto
}

func (a *AnthropicModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if a == nil {
		return nil
	}
	return a.CreateFunctionToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelCalendarEventCreateToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelContactCreateToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelContactGetToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleCalendarCreateEventToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleSheetsRowAppendToolDto
}

func (a *AnthropicModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if a == nil {
		return nil
	}
	return a.CreateMcpToolDto
}

func (a *AnthropicModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if a == nil {
		return nil
	}
	return a.CreateQueryToolDto
}

func (a *AnthropicModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if a == nil {
		return nil
	}
	return a.CreateSlackSendMessageToolDto
}

func (a *AnthropicModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if a == nil {
		return nil
	}
	return a.CreateSmsToolDto
}

func (a *AnthropicModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if a == nil {
		return nil
	}
	return a.CreateTextEditorToolDto
}

func (a *AnthropicModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateTransferCallToolDto
}

func (a *AnthropicModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		a.typ = "CreateApiRequestToolDto"
		a.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		a.typ = "CreateBashToolDto"
		a.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		a.typ = "CreateComputerToolDto"
		a.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		a.typ = "CreateDtmfToolDto"
		a.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		a.typ = "CreateEndCallToolDto"
		a.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		a.typ = "CreateFunctionToolDto"
		a.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		a.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		a.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		a.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		a.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		a.typ = "CreateGoHighLevelContactCreateToolDto"
		a.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		a.typ = "CreateGoHighLevelContactGetToolDto"
		a.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		a.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		a.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		a.typ = "CreateGoogleCalendarCreateEventToolDto"
		a.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		a.typ = "CreateGoogleSheetsRowAppendToolDto"
		a.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		a.typ = "CreateMcpToolDto"
		a.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		a.typ = "CreateQueryToolDto"
		a.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		a.typ = "CreateSlackSendMessageToolDto"
		a.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		a.typ = "CreateSmsToolDto"
		a.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		a.typ = "CreateTextEditorToolDto"
		a.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		a.typ = "CreateTransferCallToolDto"
		a.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AnthropicModelToolsItem) MarshalJSON() ([]byte, error) {
	if a.typ == "CreateApiRequestToolDto" || a.CreateApiRequestToolDto != nil {
		return json.Marshal(a.CreateApiRequestToolDto)
	}
	if a.typ == "CreateBashToolDto" || a.CreateBashToolDto != nil {
		return json.Marshal(a.CreateBashToolDto)
	}
	if a.typ == "CreateComputerToolDto" || a.CreateComputerToolDto != nil {
		return json.Marshal(a.CreateComputerToolDto)
	}
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return json.Marshal(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return json.Marshal(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return json.Marshal(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || a.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || a.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactCreateToolDto" || a.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelContactCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactGetToolDto" || a.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelContactGetToolDto)
	}
	if a.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || a.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(a.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if a.typ == "CreateGoogleCalendarCreateEventToolDto" || a.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(a.CreateGoogleCalendarCreateEventToolDto)
	}
	if a.typ == "CreateGoogleSheetsRowAppendToolDto" || a.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(a.CreateGoogleSheetsRowAppendToolDto)
	}
	if a.typ == "CreateMcpToolDto" || a.CreateMcpToolDto != nil {
		return json.Marshal(a.CreateMcpToolDto)
	}
	if a.typ == "CreateQueryToolDto" || a.CreateQueryToolDto != nil {
		return json.Marshal(a.CreateQueryToolDto)
	}
	if a.typ == "CreateSlackSendMessageToolDto" || a.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(a.CreateSlackSendMessageToolDto)
	}
	if a.typ == "CreateSmsToolDto" || a.CreateSmsToolDto != nil {
		return json.Marshal(a.CreateSmsToolDto)
	}
	if a.typ == "CreateTextEditorToolDto" || a.CreateTextEditorToolDto != nil {
		return json.Marshal(a.CreateTextEditorToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return json.Marshal(a.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnthropicModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (a *AnthropicModelToolsItem) Accept(visitor AnthropicModelToolsItemVisitor) error {
	if a.typ == "CreateApiRequestToolDto" || a.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(a.CreateApiRequestToolDto)
	}
	if a.typ == "CreateBashToolDto" || a.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(a.CreateBashToolDto)
	}
	if a.typ == "CreateComputerToolDto" || a.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(a.CreateComputerToolDto)
	}
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || a.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(a.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || a.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(a.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactCreateToolDto" || a.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(a.CreateGoHighLevelContactCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactGetToolDto" || a.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(a.CreateGoHighLevelContactGetToolDto)
	}
	if a.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || a.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(a.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if a.typ == "CreateGoogleCalendarCreateEventToolDto" || a.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(a.CreateGoogleCalendarCreateEventToolDto)
	}
	if a.typ == "CreateGoogleSheetsRowAppendToolDto" || a.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(a.CreateGoogleSheetsRowAppendToolDto)
	}
	if a.typ == "CreateMcpToolDto" || a.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(a.CreateMcpToolDto)
	}
	if a.typ == "CreateQueryToolDto" || a.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(a.CreateQueryToolDto)
	}
	if a.typ == "CreateSlackSendMessageToolDto" || a.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(a.CreateSlackSendMessageToolDto)
	}
	if a.typ == "CreateSmsToolDto" || a.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(a.CreateSmsToolDto)
	}
	if a.typ == "CreateTextEditorToolDto" || a.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(a.CreateTextEditorToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(a.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnthropicThinkingConfig struct {
	// The maximum number of tokens to allocate for thinking.
	// Must be between 1024 and 100000 tokens.
	BudgetTokens float64 `json:"budgetTokens" url:"budgetTokens"`
	type_        string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnthropicThinkingConfig) GetBudgetTokens() float64 {
	if a == nil {
		return 0
	}
	return a.BudgetTokens
}

func (a *AnthropicThinkingConfig) Type() string {
	return a.type_
}

func (a *AnthropicThinkingConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnthropicThinkingConfig) UnmarshalJSON(data []byte) error {
	type embed AnthropicThinkingConfig
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnthropicThinkingConfig(unmarshaler.embed)
	if unmarshaler.Type != "enabled" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "enabled", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnthropicThinkingConfig) MarshalJSON() ([]byte, error) {
	type embed AnthropicThinkingConfig
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "enabled",
	}
	return json.Marshal(marshaler)
}

func (a *AnthropicThinkingConfig) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnyscaleCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnyscaleCredential) GetApiKey() string {
	if a == nil {
		return ""
	}
	return a.ApiKey
}

func (a *AnyscaleCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AnyscaleCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AnyscaleCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AnyscaleCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AnyscaleCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AnyscaleCredential) Provider() string {
	return a.provider
}

func (a *AnyscaleCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnyscaleCredential) UnmarshalJSON(data []byte) error {
	type embed AnyscaleCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnyscaleCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anyscale", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnyscaleCredential) MarshalJSON() ([]byte, error) {
	type embed AnyscaleCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "anyscale",
	}
	return json.Marshal(marshaler)
}

func (a *AnyscaleCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnyscaleModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*AnyscaleModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnyscaleModel) GetMessages() []*OpenAiMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *AnyscaleModel) GetTools() []*AnyscaleModelToolsItem {
	if a == nil {
		return nil
	}
	return a.Tools
}

func (a *AnyscaleModel) GetToolIds() []string {
	if a == nil {
		return nil
	}
	return a.ToolIds
}

func (a *AnyscaleModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if a == nil {
		return nil
	}
	return a.KnowledgeBase
}

func (a *AnyscaleModel) GetKnowledgeBaseId() *string {
	if a == nil {
		return nil
	}
	return a.KnowledgeBaseId
}

func (a *AnyscaleModel) GetModel() string {
	if a == nil {
		return ""
	}
	return a.Model
}

func (a *AnyscaleModel) GetTemperature() *float64 {
	if a == nil {
		return nil
	}
	return a.Temperature
}

func (a *AnyscaleModel) GetMaxTokens() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxTokens
}

func (a *AnyscaleModel) GetEmotionRecognitionEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.EmotionRecognitionEnabled
}

func (a *AnyscaleModel) GetNumFastTurns() *float64 {
	if a == nil {
		return nil
	}
	return a.NumFastTurns
}

func (a *AnyscaleModel) Provider() string {
	return a.provider
}

func (a *AnyscaleModel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnyscaleModel) UnmarshalJSON(data []byte) error {
	type embed AnyscaleModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnyscaleModel(unmarshaler.embed)
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anyscale", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnyscaleModel) MarshalJSON() ([]byte, error) {
	type embed AnyscaleModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "anyscale",
	}
	return json.Marshal(marshaler)
}

func (a *AnyscaleModel) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnyscaleModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (a *AnyscaleModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if a == nil {
		return nil
	}
	return a.CreateApiRequestToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if a == nil {
		return nil
	}
	return a.CreateBashToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if a == nil {
		return nil
	}
	return a.CreateComputerToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if a == nil {
		return nil
	}
	return a.CreateDtmfToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateEndCallToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if a == nil {
		return nil
	}
	return a.CreateFunctionToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelCalendarEventCreateToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelContactCreateToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelContactGetToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleCalendarCreateEventToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleSheetsRowAppendToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if a == nil {
		return nil
	}
	return a.CreateMcpToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if a == nil {
		return nil
	}
	return a.CreateQueryToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if a == nil {
		return nil
	}
	return a.CreateSlackSendMessageToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if a == nil {
		return nil
	}
	return a.CreateSmsToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if a == nil {
		return nil
	}
	return a.CreateTextEditorToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateTransferCallToolDto
}

func (a *AnyscaleModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		a.typ = "CreateApiRequestToolDto"
		a.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		a.typ = "CreateBashToolDto"
		a.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		a.typ = "CreateComputerToolDto"
		a.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		a.typ = "CreateDtmfToolDto"
		a.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		a.typ = "CreateEndCallToolDto"
		a.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		a.typ = "CreateFunctionToolDto"
		a.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		a.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		a.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		a.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		a.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		a.typ = "CreateGoHighLevelContactCreateToolDto"
		a.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		a.typ = "CreateGoHighLevelContactGetToolDto"
		a.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		a.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		a.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		a.typ = "CreateGoogleCalendarCreateEventToolDto"
		a.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		a.typ = "CreateGoogleSheetsRowAppendToolDto"
		a.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		a.typ = "CreateMcpToolDto"
		a.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		a.typ = "CreateQueryToolDto"
		a.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		a.typ = "CreateSlackSendMessageToolDto"
		a.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		a.typ = "CreateSmsToolDto"
		a.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		a.typ = "CreateTextEditorToolDto"
		a.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		a.typ = "CreateTransferCallToolDto"
		a.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AnyscaleModelToolsItem) MarshalJSON() ([]byte, error) {
	if a.typ == "CreateApiRequestToolDto" || a.CreateApiRequestToolDto != nil {
		return json.Marshal(a.CreateApiRequestToolDto)
	}
	if a.typ == "CreateBashToolDto" || a.CreateBashToolDto != nil {
		return json.Marshal(a.CreateBashToolDto)
	}
	if a.typ == "CreateComputerToolDto" || a.CreateComputerToolDto != nil {
		return json.Marshal(a.CreateComputerToolDto)
	}
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return json.Marshal(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return json.Marshal(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return json.Marshal(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || a.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || a.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactCreateToolDto" || a.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelContactCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactGetToolDto" || a.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(a.CreateGoHighLevelContactGetToolDto)
	}
	if a.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || a.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(a.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if a.typ == "CreateGoogleCalendarCreateEventToolDto" || a.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(a.CreateGoogleCalendarCreateEventToolDto)
	}
	if a.typ == "CreateGoogleSheetsRowAppendToolDto" || a.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(a.CreateGoogleSheetsRowAppendToolDto)
	}
	if a.typ == "CreateMcpToolDto" || a.CreateMcpToolDto != nil {
		return json.Marshal(a.CreateMcpToolDto)
	}
	if a.typ == "CreateQueryToolDto" || a.CreateQueryToolDto != nil {
		return json.Marshal(a.CreateQueryToolDto)
	}
	if a.typ == "CreateSlackSendMessageToolDto" || a.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(a.CreateSlackSendMessageToolDto)
	}
	if a.typ == "CreateSmsToolDto" || a.CreateSmsToolDto != nil {
		return json.Marshal(a.CreateSmsToolDto)
	}
	if a.typ == "CreateTextEditorToolDto" || a.CreateTextEditorToolDto != nil {
		return json.Marshal(a.CreateTextEditorToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return json.Marshal(a.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnyscaleModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (a *AnyscaleModelToolsItem) Accept(visitor AnyscaleModelToolsItemVisitor) error {
	if a.typ == "CreateApiRequestToolDto" || a.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(a.CreateApiRequestToolDto)
	}
	if a.typ == "CreateBashToolDto" || a.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(a.CreateBashToolDto)
	}
	if a.typ == "CreateComputerToolDto" || a.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(a.CreateComputerToolDto)
	}
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || a.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(a.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if a.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || a.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(a.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactCreateToolDto" || a.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(a.CreateGoHighLevelContactCreateToolDto)
	}
	if a.typ == "CreateGoHighLevelContactGetToolDto" || a.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(a.CreateGoHighLevelContactGetToolDto)
	}
	if a.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || a.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(a.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if a.typ == "CreateGoogleCalendarCreateEventToolDto" || a.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(a.CreateGoogleCalendarCreateEventToolDto)
	}
	if a.typ == "CreateGoogleSheetsRowAppendToolDto" || a.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(a.CreateGoogleSheetsRowAppendToolDto)
	}
	if a.typ == "CreateMcpToolDto" || a.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(a.CreateMcpToolDto)
	}
	if a.typ == "CreateQueryToolDto" || a.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(a.CreateQueryToolDto)
	}
	if a.typ == "CreateSlackSendMessageToolDto" || a.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(a.CreateSlackSendMessageToolDto)
	}
	if a.typ == "CreateSmsToolDto" || a.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(a.CreateSmsToolDto)
	}
	if a.typ == "CreateTextEditorToolDto" || a.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(a.CreateTextEditorToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(a.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type Artifact struct {
	// These are the messages that were spoken during the call.
	Messages []*ArtifactMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the messages that were spoken during the call, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	RecordingUrl *string `json:"recordingUrl,omitempty" url:"recordingUrl,omitempty"`
	// This is the stereo recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	StereoRecordingUrl *string `json:"stereoRecordingUrl,omitempty" url:"stereoRecordingUrl,omitempty"`
	// This is video recording url for the call. To enable, set `assistant.artifactPlan.videoRecordingEnabled`.
	VideoRecordingUrl *string `json:"videoRecordingUrl,omitempty" url:"videoRecordingUrl,omitempty"`
	// This is video recording start delay in ms. To enable, set `assistant.artifactPlan.videoRecordingEnabled`. This can be used to align the playback of the recording with artifact.messages timestamps.
	VideoRecordingStartDelaySeconds *float64 `json:"videoRecordingStartDelaySeconds,omitempty" url:"videoRecordingStartDelaySeconds,omitempty"`
	// This is the recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	Recording *Recording `json:"recording,omitempty" url:"recording,omitempty"`
	// This is the transcript of the call. This is derived from `artifact.messages` but provided for convenience.
	Transcript *string `json:"transcript,omitempty" url:"transcript,omitempty"`
	// This is the packet capture url for the call. This is only available for `phone` type calls where phone number's provider is `vapi` or `byo-phone-number`.
	PcapUrl *string `json:"pcapUrl,omitempty" url:"pcapUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Artifact) GetMessages() []*ArtifactMessagesItem {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *Artifact) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if a == nil {
		return nil
	}
	return a.MessagesOpenAiFormatted
}

func (a *Artifact) GetRecordingUrl() *string {
	if a == nil {
		return nil
	}
	return a.RecordingUrl
}

func (a *Artifact) GetStereoRecordingUrl() *string {
	if a == nil {
		return nil
	}
	return a.StereoRecordingUrl
}

func (a *Artifact) GetVideoRecordingUrl() *string {
	if a == nil {
		return nil
	}
	return a.VideoRecordingUrl
}

func (a *Artifact) GetVideoRecordingStartDelaySeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.VideoRecordingStartDelaySeconds
}

func (a *Artifact) GetRecording() *Recording {
	if a == nil {
		return nil
	}
	return a.Recording
}

func (a *Artifact) GetTranscript() *string {
	if a == nil {
		return nil
	}
	return a.Transcript
}

func (a *Artifact) GetPcapUrl() *string {
	if a == nil {
		return nil
	}
	return a.PcapUrl
}

func (a *Artifact) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Artifact) UnmarshalJSON(data []byte) error {
	type unmarshaler Artifact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Artifact(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Artifact) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ArtifactMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (a *ArtifactMessagesItem) GetUserMessage() *UserMessage {
	if a == nil {
		return nil
	}
	return a.UserMessage
}

func (a *ArtifactMessagesItem) GetSystemMessage() *SystemMessage {
	if a == nil {
		return nil
	}
	return a.SystemMessage
}

func (a *ArtifactMessagesItem) GetBotMessage() *BotMessage {
	if a == nil {
		return nil
	}
	return a.BotMessage
}

func (a *ArtifactMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if a == nil {
		return nil
	}
	return a.ToolCallMessage
}

func (a *ArtifactMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if a == nil {
		return nil
	}
	return a.ToolCallResultMessage
}

func (a *ArtifactMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		a.typ = "UserMessage"
		a.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		a.typ = "SystemMessage"
		a.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		a.typ = "BotMessage"
		a.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		a.typ = "ToolCallMessage"
		a.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		a.typ = "ToolCallResultMessage"
		a.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ArtifactMessagesItem) MarshalJSON() ([]byte, error) {
	if a.typ == "UserMessage" || a.UserMessage != nil {
		return json.Marshal(a.UserMessage)
	}
	if a.typ == "SystemMessage" || a.SystemMessage != nil {
		return json.Marshal(a.SystemMessage)
	}
	if a.typ == "BotMessage" || a.BotMessage != nil {
		return json.Marshal(a.BotMessage)
	}
	if a.typ == "ToolCallMessage" || a.ToolCallMessage != nil {
		return json.Marshal(a.ToolCallMessage)
	}
	if a.typ == "ToolCallResultMessage" || a.ToolCallResultMessage != nil {
		return json.Marshal(a.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ArtifactMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (a *ArtifactMessagesItem) Accept(visitor ArtifactMessagesItemVisitor) error {
	if a.typ == "UserMessage" || a.UserMessage != nil {
		return visitor.VisitUserMessage(a.UserMessage)
	}
	if a.typ == "SystemMessage" || a.SystemMessage != nil {
		return visitor.VisitSystemMessage(a.SystemMessage)
	}
	if a.typ == "BotMessage" || a.BotMessage != nil {
		return visitor.VisitBotMessage(a.BotMessage)
	}
	if a.typ == "ToolCallMessage" || a.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(a.ToolCallMessage)
	}
	if a.typ == "ToolCallResultMessage" || a.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(a.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ArtifactPlan struct {
	// This determines whether assistant's calls are recorded. Defaults to true.
	//
	// Usage:
	// - If you don't want to record the calls, set this to false.
	// - If you want to record the calls when `assistant.hipaaEnabled` (deprecated) or `assistant.compliancePlan.hipaaEnabled` explicity set this to true and make sure to provide S3 or GCP credentials on the Provider Credentials page in the Dashboard.
	//
	// You can find the recording at `call.artifact.recordingUrl` and `call.artifact.stereoRecordingUrl` after the call is ended.
	//
	// @default true
	RecordingEnabled *bool `json:"recordingEnabled,omitempty" url:"recordingEnabled,omitempty"`
	// This determines the format of the recording. Defaults to `wav;l16`.
	//
	// @default 'wav;l16'
	RecordingFormat *ArtifactPlanRecordingFormat `json:"recordingFormat,omitempty" url:"recordingFormat,omitempty"`
	// This determines whether the video is recorded during the call. Defaults to false. Only relevant for `webCall` type.
	//
	// You can find the video recording at `call.artifact.videoRecordingUrl` after the call is ended.
	//
	// @default false
	VideoRecordingEnabled *bool `json:"videoRecordingEnabled,omitempty" url:"videoRecordingEnabled,omitempty"`
	// This determines whether the SIP packet capture is enabled. Defaults to true. Only relevant for `phone` type calls where phone number's provider is `vapi` or `byo-phone-number`.
	//
	// You can find the packet capture at `call.artifact.pcapUrl` after the call is ended.
	//
	// @default true
	PcapEnabled *bool `json:"pcapEnabled,omitempty" url:"pcapEnabled,omitempty"`
	// This is the path where the SIP packet capture will be uploaded. This is only used if you have provided S3 or GCP credentials on the Provider Credentials page in the Dashboard.
	//
	// If credential.s3PathPrefix or credential.bucketPlan.path is set, this will append to it.
	//
	// Usage:
	// - If you want to upload the packet capture to a specific path, set this to the path. Example: `/my-assistant-captures`.
	// - If you want to upload the packet capture to the root of the bucket, set this to `/`.
	//
	// @default '/'
	PcapS3PathPrefix *string `json:"pcapS3PathPrefix,omitempty" url:"pcapS3PathPrefix,omitempty"`
	// This is the plan for `call.artifact.transcript`. To disable, set `transcriptPlan.enabled` to false.
	TranscriptPlan *TranscriptPlan `json:"transcriptPlan,omitempty" url:"transcriptPlan,omitempty"`
	// This is the path where the recording will be uploaded. This is only used if you have provided S3 or GCP credentials on the Provider Credentials page in the Dashboard.
	//
	// If credential.s3PathPrefix or credential.bucketPlan.path is set, this will append to it.
	//
	// Usage:
	// - If you want to upload the recording to a specific path, set this to the path. Example: `/my-assistant-recordings`.
	// - If you want to upload the recording to the root of the bucket, set this to `/`.
	//
	// @default '/'
	RecordingPath *string `json:"recordingPath,omitempty" url:"recordingPath,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ArtifactPlan) GetRecordingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.RecordingEnabled
}

func (a *ArtifactPlan) GetRecordingFormat() *ArtifactPlanRecordingFormat {
	if a == nil {
		return nil
	}
	return a.RecordingFormat
}

func (a *ArtifactPlan) GetVideoRecordingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.VideoRecordingEnabled
}

func (a *ArtifactPlan) GetPcapEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.PcapEnabled
}

func (a *ArtifactPlan) GetPcapS3PathPrefix() *string {
	if a == nil {
		return nil
	}
	return a.PcapS3PathPrefix
}

func (a *ArtifactPlan) GetTranscriptPlan() *TranscriptPlan {
	if a == nil {
		return nil
	}
	return a.TranscriptPlan
}

func (a *ArtifactPlan) GetRecordingPath() *string {
	if a == nil {
		return nil
	}
	return a.RecordingPath
}

func (a *ArtifactPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArtifactPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler ArtifactPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArtifactPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArtifactPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This determines the format of the recording. Defaults to `wav;l16`.
//
// @default 'wav;l16'
type ArtifactPlanRecordingFormat string

const (
	ArtifactPlanRecordingFormatWavL16 ArtifactPlanRecordingFormat = "wav;l16"
	ArtifactPlanRecordingFormatMp3    ArtifactPlanRecordingFormat = "mp3"
)

func NewArtifactPlanRecordingFormatFromString(s string) (ArtifactPlanRecordingFormat, error) {
	switch s {
	case "wav;l16":
		return ArtifactPlanRecordingFormatWavL16, nil
	case "mp3":
		return ArtifactPlanRecordingFormatMp3, nil
	}
	var t ArtifactPlanRecordingFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ArtifactPlanRecordingFormat) Ptr() *ArtifactPlanRecordingFormat {
	return &a
}

type AssemblyAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssemblyAiCredential) GetApiKey() string {
	if a == nil {
		return ""
	}
	return a.ApiKey
}

func (a *AssemblyAiCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AssemblyAiCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AssemblyAiCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AssemblyAiCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AssemblyAiCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AssemblyAiCredential) Provider() string {
	return a.provider
}

func (a *AssemblyAiCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssemblyAiCredential) UnmarshalJSON(data []byte) error {
	type embed AssemblyAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssemblyAiCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "assembly-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assembly-ai", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssemblyAiCredential) MarshalJSON() ([]byte, error) {
	type embed AssemblyAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "assembly-ai",
	}
	return json.Marshal(marshaler)
}

func (a *AssemblyAiCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssemblyAiTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the language that will be set for the transcription.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// Transcripts below this confidence threshold will be discarded.
	//
	// @default 0.4
	ConfidenceThreshold *float64 `json:"confidenceThreshold,omitempty" url:"confidenceThreshold,omitempty"`
	// The WebSocket URL that the transcriber connects to.
	RealtimeUrl *string `json:"realtimeUrl,omitempty" url:"realtimeUrl,omitempty"`
	// Add up to 2500 characters of custom vocabulary.
	WordBoost []string `json:"wordBoost,omitempty" url:"wordBoost,omitempty"`
	// The duration of the end utterance silence threshold in milliseconds.
	EndUtteranceSilenceThreshold *float64 `json:"endUtteranceSilenceThreshold,omitempty" url:"endUtteranceSilenceThreshold,omitempty"`
	// Disable partial transcripts.
	// Set to `true` to not receive partial transcripts. Defaults to `false`.
	DisablePartialTranscripts *bool `json:"disablePartialTranscripts,omitempty" url:"disablePartialTranscripts,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssemblyAiTranscriber) GetConfidenceThreshold() *float64 {
	if a == nil {
		return nil
	}
	return a.ConfidenceThreshold
}

func (a *AssemblyAiTranscriber) GetRealtimeUrl() *string {
	if a == nil {
		return nil
	}
	return a.RealtimeUrl
}

func (a *AssemblyAiTranscriber) GetWordBoost() []string {
	if a == nil {
		return nil
	}
	return a.WordBoost
}

func (a *AssemblyAiTranscriber) GetEndUtteranceSilenceThreshold() *float64 {
	if a == nil {
		return nil
	}
	return a.EndUtteranceSilenceThreshold
}

func (a *AssemblyAiTranscriber) GetDisablePartialTranscripts() *bool {
	if a == nil {
		return nil
	}
	return a.DisablePartialTranscripts
}

func (a *AssemblyAiTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if a == nil {
		return nil
	}
	return a.FallbackPlan
}

func (a *AssemblyAiTranscriber) Provider() string {
	return a.provider
}

func (a *AssemblyAiTranscriber) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssemblyAiTranscriber) UnmarshalJSON(data []byte) error {
	type embed AssemblyAiTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssemblyAiTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "assembly-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assembly-ai", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssemblyAiTranscriber) MarshalJSON() ([]byte, error) {
	type embed AssemblyAiTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "assembly-ai",
	}
	return json.Marshal(marshaler)
}

func (a *AssemblyAiTranscriber) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantCustomEndpointingRule struct {
	// This endpointing rule is based on the last assistant message before customer started speaking.
	//
	// Flow:
	// - Assistant speaks
	// - Customer starts speaking
	// - Customer transcription comes in
	// - This rule is evaluated on the last assistant message
	// - If a match is found based on `regex`, the endpointing timeout is set to `timeoutSeconds`
	//
	// Usage:
	// - If you have yes/no questions in your use case like "are you interested in a loan?", you can set a shorter timeout.
	// - If you have questions where the customer may pause to look up information like "what's my account number?", you can set a longer timeout.
	// This is the regex pattern to match.
	//
	// Note:
	// - This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test("hello there")` will return `true`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	// - `RegExp.test` does substring matching, so `/cat/.test("I love cats")` will return `true`. To do full string matching, send "^cat$".
	Regex string `json:"regex" url:"regex"`
	// These are the options for the regex match. Defaults to all disabled.
	//
	// @default []
	RegexOptions []*RegexOption `json:"regexOptions,omitempty" url:"regexOptions,omitempty"`
	// This is the endpointing timeout in seconds, if the rule is matched.
	TimeoutSeconds float64 `json:"timeoutSeconds" url:"timeoutSeconds"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantCustomEndpointingRule) GetRegex() string {
	if a == nil {
		return ""
	}
	return a.Regex
}

func (a *AssistantCustomEndpointingRule) GetRegexOptions() []*RegexOption {
	if a == nil {
		return nil
	}
	return a.RegexOptions
}

func (a *AssistantCustomEndpointingRule) GetTimeoutSeconds() float64 {
	if a == nil {
		return 0
	}
	return a.TimeoutSeconds
}

func (a *AssistantCustomEndpointingRule) Type() string {
	return a.type_
}

func (a *AssistantCustomEndpointingRule) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantCustomEndpointingRule) UnmarshalJSON(data []byte) error {
	type embed AssistantCustomEndpointingRule
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantCustomEndpointingRule(unmarshaler.embed)
	if unmarshaler.Type != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assistant", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantCustomEndpointingRule) MarshalJSON() ([]byte, error) {
	type embed AssistantCustomEndpointingRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "assistant",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantCustomEndpointingRule) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantHookAssistantSpeechInterrupted struct {
	// This is the event that triggers this hook
	// This is the set of actions to perform when the hook triggers
	Do []*AssistantHookAssistantSpeechInterruptedDoItem `json:"do,omitempty" url:"do,omitempty"`
	on string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantHookAssistantSpeechInterrupted) GetDo() []*AssistantHookAssistantSpeechInterruptedDoItem {
	if a == nil {
		return nil
	}
	return a.Do
}

func (a *AssistantHookAssistantSpeechInterrupted) On() string {
	return a.on
}

func (a *AssistantHookAssistantSpeechInterrupted) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantHookAssistantSpeechInterrupted) UnmarshalJSON(data []byte) error {
	type embed AssistantHookAssistantSpeechInterrupted
	var unmarshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantHookAssistantSpeechInterrupted(unmarshaler.embed)
	if unmarshaler.On != "assistant.speech.interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assistant.speech.interrupted", unmarshaler.On)
	}
	a.on = unmarshaler.On
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "on")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantHookAssistantSpeechInterrupted) MarshalJSON() ([]byte, error) {
	type embed AssistantHookAssistantSpeechInterrupted
	var marshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*a),
		On:    "assistant.speech.interrupted",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantHookAssistantSpeechInterrupted) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantHookAssistantSpeechInterruptedDoItem struct {
	TransferAssistantHookAction     *TransferAssistantHookAction
	FunctionCallAssistantHookAction *FunctionCallAssistantHookAction
	SayAssistantHookAction          *SayAssistantHookAction

	typ string
}

func (a *AssistantHookAssistantSpeechInterruptedDoItem) GetTransferAssistantHookAction() *TransferAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.TransferAssistantHookAction
}

func (a *AssistantHookAssistantSpeechInterruptedDoItem) GetFunctionCallAssistantHookAction() *FunctionCallAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.FunctionCallAssistantHookAction
}

func (a *AssistantHookAssistantSpeechInterruptedDoItem) GetSayAssistantHookAction() *SayAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.SayAssistantHookAction
}

func (a *AssistantHookAssistantSpeechInterruptedDoItem) UnmarshalJSON(data []byte) error {
	valueTransferAssistantHookAction := new(TransferAssistantHookAction)
	if err := json.Unmarshal(data, &valueTransferAssistantHookAction); err == nil {
		a.typ = "TransferAssistantHookAction"
		a.TransferAssistantHookAction = valueTransferAssistantHookAction
		return nil
	}
	valueFunctionCallAssistantHookAction := new(FunctionCallAssistantHookAction)
	if err := json.Unmarshal(data, &valueFunctionCallAssistantHookAction); err == nil {
		a.typ = "FunctionCallAssistantHookAction"
		a.FunctionCallAssistantHookAction = valueFunctionCallAssistantHookAction
		return nil
	}
	valueSayAssistantHookAction := new(SayAssistantHookAction)
	if err := json.Unmarshal(data, &valueSayAssistantHookAction); err == nil {
		a.typ = "SayAssistantHookAction"
		a.SayAssistantHookAction = valueSayAssistantHookAction
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantHookAssistantSpeechInterruptedDoItem) MarshalJSON() ([]byte, error) {
	if a.typ == "TransferAssistantHookAction" || a.TransferAssistantHookAction != nil {
		return json.Marshal(a.TransferAssistantHookAction)
	}
	if a.typ == "FunctionCallAssistantHookAction" || a.FunctionCallAssistantHookAction != nil {
		return json.Marshal(a.FunctionCallAssistantHookAction)
	}
	if a.typ == "SayAssistantHookAction" || a.SayAssistantHookAction != nil {
		return json.Marshal(a.SayAssistantHookAction)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantHookAssistantSpeechInterruptedDoItemVisitor interface {
	VisitTransferAssistantHookAction(*TransferAssistantHookAction) error
	VisitFunctionCallAssistantHookAction(*FunctionCallAssistantHookAction) error
	VisitSayAssistantHookAction(*SayAssistantHookAction) error
}

func (a *AssistantHookAssistantSpeechInterruptedDoItem) Accept(visitor AssistantHookAssistantSpeechInterruptedDoItemVisitor) error {
	if a.typ == "TransferAssistantHookAction" || a.TransferAssistantHookAction != nil {
		return visitor.VisitTransferAssistantHookAction(a.TransferAssistantHookAction)
	}
	if a.typ == "FunctionCallAssistantHookAction" || a.FunctionCallAssistantHookAction != nil {
		return visitor.VisitFunctionCallAssistantHookAction(a.FunctionCallAssistantHookAction)
	}
	if a.typ == "SayAssistantHookAction" || a.SayAssistantHookAction != nil {
		return visitor.VisitSayAssistantHookAction(a.SayAssistantHookAction)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantHookCallEnding struct {
	// This is the event that triggers this hook
	// This is the set of actions to perform when the hook triggers
	Do []*AssistantHookCallEndingDoItem `json:"do,omitempty" url:"do,omitempty"`
	// This is the set of filters that must match for the hook to trigger
	Filters []*AssistantHookFilter `json:"filters,omitempty" url:"filters,omitempty"`
	on      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantHookCallEnding) GetDo() []*AssistantHookCallEndingDoItem {
	if a == nil {
		return nil
	}
	return a.Do
}

func (a *AssistantHookCallEnding) GetFilters() []*AssistantHookFilter {
	if a == nil {
		return nil
	}
	return a.Filters
}

func (a *AssistantHookCallEnding) On() string {
	return a.on
}

func (a *AssistantHookCallEnding) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantHookCallEnding) UnmarshalJSON(data []byte) error {
	type embed AssistantHookCallEnding
	var unmarshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantHookCallEnding(unmarshaler.embed)
	if unmarshaler.On != "call.ending" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "call.ending", unmarshaler.On)
	}
	a.on = unmarshaler.On
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "on")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantHookCallEnding) MarshalJSON() ([]byte, error) {
	type embed AssistantHookCallEnding
	var marshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*a),
		On:    "call.ending",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantHookCallEnding) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantHookCallEndingDoItem struct {
	TransferAssistantHookAction     *TransferAssistantHookAction
	FunctionCallAssistantHookAction *FunctionCallAssistantHookAction

	typ string
}

func (a *AssistantHookCallEndingDoItem) GetTransferAssistantHookAction() *TransferAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.TransferAssistantHookAction
}

func (a *AssistantHookCallEndingDoItem) GetFunctionCallAssistantHookAction() *FunctionCallAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.FunctionCallAssistantHookAction
}

func (a *AssistantHookCallEndingDoItem) UnmarshalJSON(data []byte) error {
	valueTransferAssistantHookAction := new(TransferAssistantHookAction)
	if err := json.Unmarshal(data, &valueTransferAssistantHookAction); err == nil {
		a.typ = "TransferAssistantHookAction"
		a.TransferAssistantHookAction = valueTransferAssistantHookAction
		return nil
	}
	valueFunctionCallAssistantHookAction := new(FunctionCallAssistantHookAction)
	if err := json.Unmarshal(data, &valueFunctionCallAssistantHookAction); err == nil {
		a.typ = "FunctionCallAssistantHookAction"
		a.FunctionCallAssistantHookAction = valueFunctionCallAssistantHookAction
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantHookCallEndingDoItem) MarshalJSON() ([]byte, error) {
	if a.typ == "TransferAssistantHookAction" || a.TransferAssistantHookAction != nil {
		return json.Marshal(a.TransferAssistantHookAction)
	}
	if a.typ == "FunctionCallAssistantHookAction" || a.FunctionCallAssistantHookAction != nil {
		return json.Marshal(a.FunctionCallAssistantHookAction)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantHookCallEndingDoItemVisitor interface {
	VisitTransferAssistantHookAction(*TransferAssistantHookAction) error
	VisitFunctionCallAssistantHookAction(*FunctionCallAssistantHookAction) error
}

func (a *AssistantHookCallEndingDoItem) Accept(visitor AssistantHookCallEndingDoItemVisitor) error {
	if a.typ == "TransferAssistantHookAction" || a.TransferAssistantHookAction != nil {
		return visitor.VisitTransferAssistantHookAction(a.TransferAssistantHookAction)
	}
	if a.typ == "FunctionCallAssistantHookAction" || a.FunctionCallAssistantHookAction != nil {
		return visitor.VisitFunctionCallAssistantHookAction(a.FunctionCallAssistantHookAction)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantHookCustomerSpeechInterrupted struct {
	// This is the event that triggers this hook
	// This is the set of actions to perform when the hook triggers
	Do []*AssistantHookCustomerSpeechInterruptedDoItem `json:"do,omitempty" url:"do,omitempty"`
	on string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantHookCustomerSpeechInterrupted) GetDo() []*AssistantHookCustomerSpeechInterruptedDoItem {
	if a == nil {
		return nil
	}
	return a.Do
}

func (a *AssistantHookCustomerSpeechInterrupted) On() string {
	return a.on
}

func (a *AssistantHookCustomerSpeechInterrupted) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantHookCustomerSpeechInterrupted) UnmarshalJSON(data []byte) error {
	type embed AssistantHookCustomerSpeechInterrupted
	var unmarshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantHookCustomerSpeechInterrupted(unmarshaler.embed)
	if unmarshaler.On != "customer.speech.interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "customer.speech.interrupted", unmarshaler.On)
	}
	a.on = unmarshaler.On
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "on")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantHookCustomerSpeechInterrupted) MarshalJSON() ([]byte, error) {
	type embed AssistantHookCustomerSpeechInterrupted
	var marshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*a),
		On:    "customer.speech.interrupted",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantHookCustomerSpeechInterrupted) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantHookCustomerSpeechInterruptedDoItem struct {
	TransferAssistantHookAction     *TransferAssistantHookAction
	FunctionCallAssistantHookAction *FunctionCallAssistantHookAction
	SayAssistantHookAction          *SayAssistantHookAction

	typ string
}

func (a *AssistantHookCustomerSpeechInterruptedDoItem) GetTransferAssistantHookAction() *TransferAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.TransferAssistantHookAction
}

func (a *AssistantHookCustomerSpeechInterruptedDoItem) GetFunctionCallAssistantHookAction() *FunctionCallAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.FunctionCallAssistantHookAction
}

func (a *AssistantHookCustomerSpeechInterruptedDoItem) GetSayAssistantHookAction() *SayAssistantHookAction {
	if a == nil {
		return nil
	}
	return a.SayAssistantHookAction
}

func (a *AssistantHookCustomerSpeechInterruptedDoItem) UnmarshalJSON(data []byte) error {
	valueTransferAssistantHookAction := new(TransferAssistantHookAction)
	if err := json.Unmarshal(data, &valueTransferAssistantHookAction); err == nil {
		a.typ = "TransferAssistantHookAction"
		a.TransferAssistantHookAction = valueTransferAssistantHookAction
		return nil
	}
	valueFunctionCallAssistantHookAction := new(FunctionCallAssistantHookAction)
	if err := json.Unmarshal(data, &valueFunctionCallAssistantHookAction); err == nil {
		a.typ = "FunctionCallAssistantHookAction"
		a.FunctionCallAssistantHookAction = valueFunctionCallAssistantHookAction
		return nil
	}
	valueSayAssistantHookAction := new(SayAssistantHookAction)
	if err := json.Unmarshal(data, &valueSayAssistantHookAction); err == nil {
		a.typ = "SayAssistantHookAction"
		a.SayAssistantHookAction = valueSayAssistantHookAction
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantHookCustomerSpeechInterruptedDoItem) MarshalJSON() ([]byte, error) {
	if a.typ == "TransferAssistantHookAction" || a.TransferAssistantHookAction != nil {
		return json.Marshal(a.TransferAssistantHookAction)
	}
	if a.typ == "FunctionCallAssistantHookAction" || a.FunctionCallAssistantHookAction != nil {
		return json.Marshal(a.FunctionCallAssistantHookAction)
	}
	if a.typ == "SayAssistantHookAction" || a.SayAssistantHookAction != nil {
		return json.Marshal(a.SayAssistantHookAction)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantHookCustomerSpeechInterruptedDoItemVisitor interface {
	VisitTransferAssistantHookAction(*TransferAssistantHookAction) error
	VisitFunctionCallAssistantHookAction(*FunctionCallAssistantHookAction) error
	VisitSayAssistantHookAction(*SayAssistantHookAction) error
}

func (a *AssistantHookCustomerSpeechInterruptedDoItem) Accept(visitor AssistantHookCustomerSpeechInterruptedDoItemVisitor) error {
	if a.typ == "TransferAssistantHookAction" || a.TransferAssistantHookAction != nil {
		return visitor.VisitTransferAssistantHookAction(a.TransferAssistantHookAction)
	}
	if a.typ == "FunctionCallAssistantHookAction" || a.FunctionCallAssistantHookAction != nil {
		return visitor.VisitFunctionCallAssistantHookAction(a.FunctionCallAssistantHookAction)
	}
	if a.typ == "SayAssistantHookAction" || a.SayAssistantHookAction != nil {
		return visitor.VisitSayAssistantHookAction(a.SayAssistantHookAction)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantHookFilter struct {
	// This is the type of filter - currently only "oneOf" is supported
	// This is the key to filter on (e.g. "call.endedReason")
	Key string `json:"key" url:"key"`
	// This is the array of possible values to match against
	OneOf []string `json:"oneOf,omitempty" url:"oneOf,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantHookFilter) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *AssistantHookFilter) GetOneOf() []string {
	if a == nil {
		return nil
	}
	return a.OneOf
}

func (a *AssistantHookFilter) Type() string {
	return a.type_
}

func (a *AssistantHookFilter) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantHookFilter) UnmarshalJSON(data []byte) error {
	type embed AssistantHookFilter
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantHookFilter(unmarshaler.embed)
	if unmarshaler.Type != "oneOf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "oneOf", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantHookFilter) MarshalJSON() ([]byte, error) {
	type embed AssistantHookFilter
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "oneOf",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantHookFilter) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantOverrides struct {
	// These are the options for the assistant's transcriber.
	Transcriber *AssistantOverridesTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *AssistantOverridesModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *AssistantOverridesVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage                     *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	FirstMessageInterruptionsEnabled *bool   `json:"firstMessageInterruptionsEnabled,omitempty" url:"firstMessageInterruptionsEnabled,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *AssistantOverridesFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *AssistantOverridesVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []AssistantOverridesClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []AssistantOverridesServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	// You can also provide a custom sound by providing a URL to an audio file.
	BackgroundSound *AssistantOverridesBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// This is the plan for observability configuration of assistant's calls.
	// Currently supports Langfuse for tracing and monitoring.
	ObservabilityPlan *LangfuseObservabilityPlan `json:"observabilityPlan,omitempty" url:"observabilityPlan,omitempty"`
	// These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.
	Credentials []*AssistantOverridesCredentialsItem `json:"credentials,omitempty" url:"credentials,omitempty"`
	// This is a set of actions that will be performed on certain events.
	Hooks []*AssistantOverridesHooksItem `json:"hooks,omitempty" url:"hooks,omitempty"`
	// These are values that will be used to replace the template variables in the assistant messages and other text-based fields.
	// This uses LiquidJS syntax. https://liquidjs.com/tutorials/intro-to-liquid.html
	//
	// So for example, `{{ name }}` will be replaced with the value of `name` in `variableValues`.
	// `{{"now" | date: "%b %d, %Y, %I:%M %p", "America/New_York"}}` will be replaced with the current date and time in New York.
	//
	//	Some VAPI reserved defaults:
	//	- *customer* - the customer object
	VariableValues map[string]interface{} `json:"variableValues,omitempty" url:"variableValues,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string        `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	CompliancePlan *CompliancePlan `json:"compliancePlan,omitempty" url:"compliancePlan,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server.url
	// 2. phoneNumber.serverUrl
	// 3. org.serverUrl
	Server          *Server          `json:"server,omitempty" url:"server,omitempty"`
	KeypadInputPlan *KeypadInputPlan `json:"keypadInputPlan,omitempty" url:"keypadInputPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantOverrides) GetTranscriber() *AssistantOverridesTranscriber {
	if a == nil {
		return nil
	}
	return a.Transcriber
}

func (a *AssistantOverrides) GetModel() *AssistantOverridesModel {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *AssistantOverrides) GetVoice() *AssistantOverridesVoice {
	if a == nil {
		return nil
	}
	return a.Voice
}

func (a *AssistantOverrides) GetFirstMessage() *string {
	if a == nil {
		return nil
	}
	return a.FirstMessage
}

func (a *AssistantOverrides) GetFirstMessageInterruptionsEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.FirstMessageInterruptionsEnabled
}

func (a *AssistantOverrides) GetFirstMessageMode() *AssistantOverridesFirstMessageMode {
	if a == nil {
		return nil
	}
	return a.FirstMessageMode
}

func (a *AssistantOverrides) GetVoicemailDetection() *AssistantOverridesVoicemailDetection {
	if a == nil {
		return nil
	}
	return a.VoicemailDetection
}

func (a *AssistantOverrides) GetClientMessages() []AssistantOverridesClientMessagesItem {
	if a == nil {
		return nil
	}
	return a.ClientMessages
}

func (a *AssistantOverrides) GetServerMessages() []AssistantOverridesServerMessagesItem {
	if a == nil {
		return nil
	}
	return a.ServerMessages
}

func (a *AssistantOverrides) GetSilenceTimeoutSeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.SilenceTimeoutSeconds
}

func (a *AssistantOverrides) GetMaxDurationSeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxDurationSeconds
}

func (a *AssistantOverrides) GetBackgroundSound() *AssistantOverridesBackgroundSound {
	if a == nil {
		return nil
	}
	return a.BackgroundSound
}

func (a *AssistantOverrides) GetBackgroundDenoisingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.BackgroundDenoisingEnabled
}

func (a *AssistantOverrides) GetModelOutputInMessagesEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.ModelOutputInMessagesEnabled
}

func (a *AssistantOverrides) GetTransportConfigurations() []*TransportConfigurationTwilio {
	if a == nil {
		return nil
	}
	return a.TransportConfigurations
}

func (a *AssistantOverrides) GetObservabilityPlan() *LangfuseObservabilityPlan {
	if a == nil {
		return nil
	}
	return a.ObservabilityPlan
}

func (a *AssistantOverrides) GetCredentials() []*AssistantOverridesCredentialsItem {
	if a == nil {
		return nil
	}
	return a.Credentials
}

func (a *AssistantOverrides) GetHooks() []*AssistantOverridesHooksItem {
	if a == nil {
		return nil
	}
	return a.Hooks
}

func (a *AssistantOverrides) GetVariableValues() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.VariableValues
}

func (a *AssistantOverrides) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AssistantOverrides) GetVoicemailMessage() *string {
	if a == nil {
		return nil
	}
	return a.VoicemailMessage
}

func (a *AssistantOverrides) GetEndCallMessage() *string {
	if a == nil {
		return nil
	}
	return a.EndCallMessage
}

func (a *AssistantOverrides) GetEndCallPhrases() []string {
	if a == nil {
		return nil
	}
	return a.EndCallPhrases
}

func (a *AssistantOverrides) GetCompliancePlan() *CompliancePlan {
	if a == nil {
		return nil
	}
	return a.CompliancePlan
}

func (a *AssistantOverrides) GetMetadata() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *AssistantOverrides) GetAnalysisPlan() *AnalysisPlan {
	if a == nil {
		return nil
	}
	return a.AnalysisPlan
}

func (a *AssistantOverrides) GetArtifactPlan() *ArtifactPlan {
	if a == nil {
		return nil
	}
	return a.ArtifactPlan
}

func (a *AssistantOverrides) GetMessagePlan() *MessagePlan {
	if a == nil {
		return nil
	}
	return a.MessagePlan
}

func (a *AssistantOverrides) GetStartSpeakingPlan() *StartSpeakingPlan {
	if a == nil {
		return nil
	}
	return a.StartSpeakingPlan
}

func (a *AssistantOverrides) GetStopSpeakingPlan() *StopSpeakingPlan {
	if a == nil {
		return nil
	}
	return a.StopSpeakingPlan
}

func (a *AssistantOverrides) GetMonitorPlan() *MonitorPlan {
	if a == nil {
		return nil
	}
	return a.MonitorPlan
}

func (a *AssistantOverrides) GetCredentialIds() []string {
	if a == nil {
		return nil
	}
	return a.CredentialIds
}

func (a *AssistantOverrides) GetServer() *Server {
	if a == nil {
		return nil
	}
	return a.Server
}

func (a *AssistantOverrides) GetKeypadInputPlan() *KeypadInputPlan {
	if a == nil {
		return nil
	}
	return a.KeypadInputPlan
}

func (a *AssistantOverrides) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantOverrides(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantOverrides) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
// You can also provide a custom sound by providing a URL to an audio file.
type AssistantOverridesBackgroundSound struct {
	AssistantOverridesBackgroundSoundZero AssistantOverridesBackgroundSoundZero
	String                                string

	typ string
}

func (a *AssistantOverridesBackgroundSound) GetAssistantOverridesBackgroundSoundZero() AssistantOverridesBackgroundSoundZero {
	if a == nil {
		return ""
	}
	return a.AssistantOverridesBackgroundSoundZero
}

func (a *AssistantOverridesBackgroundSound) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AssistantOverridesBackgroundSound) UnmarshalJSON(data []byte) error {
	var valueAssistantOverridesBackgroundSoundZero AssistantOverridesBackgroundSoundZero
	if err := json.Unmarshal(data, &valueAssistantOverridesBackgroundSoundZero); err == nil {
		a.typ = "AssistantOverridesBackgroundSoundZero"
		a.AssistantOverridesBackgroundSoundZero = valueAssistantOverridesBackgroundSoundZero
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesBackgroundSound) MarshalJSON() ([]byte, error) {
	if a.typ == "AssistantOverridesBackgroundSoundZero" || a.AssistantOverridesBackgroundSoundZero != "" {
		return json.Marshal(a.AssistantOverridesBackgroundSoundZero)
	}
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesBackgroundSoundVisitor interface {
	VisitAssistantOverridesBackgroundSoundZero(AssistantOverridesBackgroundSoundZero) error
	VisitString(string) error
}

func (a *AssistantOverridesBackgroundSound) Accept(visitor AssistantOverridesBackgroundSoundVisitor) error {
	if a.typ == "AssistantOverridesBackgroundSoundZero" || a.AssistantOverridesBackgroundSoundZero != "" {
		return visitor.VisitAssistantOverridesBackgroundSoundZero(a.AssistantOverridesBackgroundSoundZero)
	}
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesBackgroundSoundZero string

const (
	AssistantOverridesBackgroundSoundZeroOff    AssistantOverridesBackgroundSoundZero = "off"
	AssistantOverridesBackgroundSoundZeroOffice AssistantOverridesBackgroundSoundZero = "office"
)

func NewAssistantOverridesBackgroundSoundZeroFromString(s string) (AssistantOverridesBackgroundSoundZero, error) {
	switch s {
	case "off":
		return AssistantOverridesBackgroundSoundZeroOff, nil
	case "office":
		return AssistantOverridesBackgroundSoundZeroOffice, nil
	}
	var t AssistantOverridesBackgroundSoundZero
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesBackgroundSoundZero) Ptr() *AssistantOverridesBackgroundSoundZero {
	return &a
}

type AssistantOverridesClientMessagesItem string

const (
	AssistantOverridesClientMessagesItemConversationUpdate  AssistantOverridesClientMessagesItem = "conversation-update"
	AssistantOverridesClientMessagesItemFunctionCall        AssistantOverridesClientMessagesItem = "function-call"
	AssistantOverridesClientMessagesItemFunctionCallResult  AssistantOverridesClientMessagesItem = "function-call-result"
	AssistantOverridesClientMessagesItemHang                AssistantOverridesClientMessagesItem = "hang"
	AssistantOverridesClientMessagesItemLanguageChanged     AssistantOverridesClientMessagesItem = "language-changed"
	AssistantOverridesClientMessagesItemMetadata            AssistantOverridesClientMessagesItem = "metadata"
	AssistantOverridesClientMessagesItemModelOutput         AssistantOverridesClientMessagesItem = "model-output"
	AssistantOverridesClientMessagesItemSpeechUpdate        AssistantOverridesClientMessagesItem = "speech-update"
	AssistantOverridesClientMessagesItemStatusUpdate        AssistantOverridesClientMessagesItem = "status-update"
	AssistantOverridesClientMessagesItemTranscript          AssistantOverridesClientMessagesItem = "transcript"
	AssistantOverridesClientMessagesItemToolCalls           AssistantOverridesClientMessagesItem = "tool-calls"
	AssistantOverridesClientMessagesItemToolCallsResult     AssistantOverridesClientMessagesItem = "tool-calls-result"
	AssistantOverridesClientMessagesItemToolCompleted       AssistantOverridesClientMessagesItem = "tool.completed"
	AssistantOverridesClientMessagesItemTransferUpdate      AssistantOverridesClientMessagesItem = "transfer-update"
	AssistantOverridesClientMessagesItemUserInterrupted     AssistantOverridesClientMessagesItem = "user-interrupted"
	AssistantOverridesClientMessagesItemVoiceInput          AssistantOverridesClientMessagesItem = "voice-input"
	AssistantOverridesClientMessagesItemWorkflowNodeStarted AssistantOverridesClientMessagesItem = "workflow.node.started"
)

func NewAssistantOverridesClientMessagesItemFromString(s string) (AssistantOverridesClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantOverridesClientMessagesItemConversationUpdate, nil
	case "function-call":
		return AssistantOverridesClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return AssistantOverridesClientMessagesItemFunctionCallResult, nil
	case "hang":
		return AssistantOverridesClientMessagesItemHang, nil
	case "language-changed":
		return AssistantOverridesClientMessagesItemLanguageChanged, nil
	case "metadata":
		return AssistantOverridesClientMessagesItemMetadata, nil
	case "model-output":
		return AssistantOverridesClientMessagesItemModelOutput, nil
	case "speech-update":
		return AssistantOverridesClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantOverridesClientMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantOverridesClientMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantOverridesClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return AssistantOverridesClientMessagesItemToolCallsResult, nil
	case "tool.completed":
		return AssistantOverridesClientMessagesItemToolCompleted, nil
	case "transfer-update":
		return AssistantOverridesClientMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantOverridesClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantOverridesClientMessagesItemVoiceInput, nil
	case "workflow.node.started":
		return AssistantOverridesClientMessagesItemWorkflowNodeStarted, nil
	}
	var t AssistantOverridesClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesClientMessagesItem) Ptr() *AssistantOverridesClientMessagesItem {
	return &a
}

type AssistantOverridesCredentialsItem struct {
	CreateElevenLabsCredentialDto                        *CreateElevenLabsCredentialDto
	CreateAnthropicCredentialDto                         *CreateAnthropicCredentialDto
	CreateAnyscaleCredentialDto                          *CreateAnyscaleCredentialDto
	CreateAssemblyAiCredentialDto                        *CreateAssemblyAiCredentialDto
	CreateAzureOpenAiCredentialDto                       *CreateAzureOpenAiCredentialDto
	CreateAzureCredentialDto                             *CreateAzureCredentialDto
	CreateByoSipTrunkCredentialDto                       *CreateByoSipTrunkCredentialDto
	CreateCartesiaCredentialDto                          *CreateCartesiaCredentialDto
	CreateCerebrasCredentialDto                          *CreateCerebrasCredentialDto
	CreateCloudflareCredentialDto                        *CreateCloudflareCredentialDto
	CreateCustomLlmCredentialDto                         *CreateCustomLlmCredentialDto
	CreateDeepgramCredentialDto                          *CreateDeepgramCredentialDto
	CreateDeepInfraCredentialDto                         *CreateDeepInfraCredentialDto
	CreateDeepSeekCredentialDto                          *CreateDeepSeekCredentialDto
	CreateGcpCredentialDto                               *CreateGcpCredentialDto
	CreateGladiaCredentialDto                            *CreateGladiaCredentialDto
	CreateGoHighLevelCredentialDto                       *CreateGoHighLevelCredentialDto
	CreateGoogleCredentialDto                            *CreateGoogleCredentialDto
	CreateGroqCredentialDto                              *CreateGroqCredentialDto
	CreateInflectionAiCredentialDto                      *CreateInflectionAiCredentialDto
	CreateLangfuseCredentialDto                          *CreateLangfuseCredentialDto
	CreateLmntCredentialDto                              *CreateLmntCredentialDto
	CreateMakeCredentialDto                              *CreateMakeCredentialDto
	CreateOpenAiCredentialDto                            *CreateOpenAiCredentialDto
	CreateOpenRouterCredentialDto                        *CreateOpenRouterCredentialDto
	CreatePerplexityAiCredentialDto                      *CreatePerplexityAiCredentialDto
	CreatePlayHtCredentialDto                            *CreatePlayHtCredentialDto
	CreateRimeAiCredentialDto                            *CreateRimeAiCredentialDto
	CreateRunpodCredentialDto                            *CreateRunpodCredentialDto
	CreateS3CredentialDto                                *CreateS3CredentialDto
	CreateSupabaseCredentialDto                          *CreateSupabaseCredentialDto
	CreateSmallestAiCredentialDto                        *CreateSmallestAiCredentialDto
	CreateTavusCredentialDto                             *CreateTavusCredentialDto
	CreateTogetherAiCredentialDto                        *CreateTogetherAiCredentialDto
	CreateTwilioCredentialDto                            *CreateTwilioCredentialDto
	CreateVonageCredentialDto                            *CreateVonageCredentialDto
	CreateWebhookCredentialDto                           *CreateWebhookCredentialDto
	CreateXAiCredentialDto                               *CreateXAiCredentialDto
	CreateNeuphonicCredentialDto                         *CreateNeuphonicCredentialDto
	CreateHumeCredentialDto                              *CreateHumeCredentialDto
	CreateMistralCredentialDto                           *CreateMistralCredentialDto
	CreateSpeechmaticsCredentialDto                      *CreateSpeechmaticsCredentialDto
	CreateTrieveCredentialDto                            *CreateTrieveCredentialDto
	CreateGoogleCalendarOAuth2ClientCredentialDto        *CreateGoogleCalendarOAuth2ClientCredentialDto
	CreateGoogleCalendarOAuth2AuthorizationCredentialDto *CreateGoogleCalendarOAuth2AuthorizationCredentialDto
	CreateGoogleSheetsOAuth2AuthorizationCredentialDto   *CreateGoogleSheetsOAuth2AuthorizationCredentialDto
	CreateSlackOAuth2AuthorizationCredentialDto          *CreateSlackOAuth2AuthorizationCredentialDto
	CreateGoHighLevelMcpCredentialDto                    *CreateGoHighLevelMcpCredentialDto

	typ string
}

func (a *AssistantOverridesCredentialsItem) GetCreateElevenLabsCredentialDto() *CreateElevenLabsCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateElevenLabsCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAnthropicCredentialDto() *CreateAnthropicCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAnthropicCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAnyscaleCredentialDto() *CreateAnyscaleCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAnyscaleCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAssemblyAiCredentialDto() *CreateAssemblyAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAssemblyAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAzureOpenAiCredentialDto() *CreateAzureOpenAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAzureOpenAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAzureCredentialDto() *CreateAzureCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAzureCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateByoSipTrunkCredentialDto() *CreateByoSipTrunkCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateByoSipTrunkCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateCartesiaCredentialDto() *CreateCartesiaCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateCartesiaCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateCerebrasCredentialDto() *CreateCerebrasCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateCerebrasCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateCloudflareCredentialDto() *CreateCloudflareCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateCloudflareCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateCustomLlmCredentialDto() *CreateCustomLlmCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateCustomLlmCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateDeepgramCredentialDto() *CreateDeepgramCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateDeepgramCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateDeepInfraCredentialDto() *CreateDeepInfraCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateDeepInfraCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateDeepSeekCredentialDto() *CreateDeepSeekCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateDeepSeekCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGcpCredentialDto() *CreateGcpCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGcpCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGladiaCredentialDto() *CreateGladiaCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGladiaCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGoHighLevelCredentialDto() *CreateGoHighLevelCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGoogleCredentialDto() *CreateGoogleCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGroqCredentialDto() *CreateGroqCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGroqCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateInflectionAiCredentialDto() *CreateInflectionAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateInflectionAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateLangfuseCredentialDto() *CreateLangfuseCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateLangfuseCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateLmntCredentialDto() *CreateLmntCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateLmntCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateMakeCredentialDto() *CreateMakeCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateMakeCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateOpenAiCredentialDto() *CreateOpenAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateOpenAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateOpenRouterCredentialDto() *CreateOpenRouterCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateOpenRouterCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreatePerplexityAiCredentialDto() *CreatePerplexityAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreatePerplexityAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreatePlayHtCredentialDto() *CreatePlayHtCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreatePlayHtCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateRimeAiCredentialDto() *CreateRimeAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateRimeAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateRunpodCredentialDto() *CreateRunpodCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateRunpodCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateS3CredentialDto() *CreateS3CredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateS3CredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateSupabaseCredentialDto() *CreateSupabaseCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateSupabaseCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateSmallestAiCredentialDto() *CreateSmallestAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateSmallestAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateTavusCredentialDto() *CreateTavusCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateTavusCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateTogetherAiCredentialDto() *CreateTogetherAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateTogetherAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateTwilioCredentialDto() *CreateTwilioCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateTwilioCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateVonageCredentialDto() *CreateVonageCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateVonageCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateWebhookCredentialDto() *CreateWebhookCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateWebhookCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateXAiCredentialDto() *CreateXAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateXAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateNeuphonicCredentialDto() *CreateNeuphonicCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateNeuphonicCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateHumeCredentialDto() *CreateHumeCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateHumeCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateMistralCredentialDto() *CreateMistralCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateMistralCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateSpeechmaticsCredentialDto() *CreateSpeechmaticsCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateSpeechmaticsCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateTrieveCredentialDto() *CreateTrieveCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateTrieveCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGoogleCalendarOAuth2ClientCredentialDto() *CreateGoogleCalendarOAuth2ClientCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleCalendarOAuth2ClientCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGoogleCalendarOAuth2AuthorizationCredentialDto() *CreateGoogleCalendarOAuth2AuthorizationCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleCalendarOAuth2AuthorizationCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGoogleSheetsOAuth2AuthorizationCredentialDto() *CreateGoogleSheetsOAuth2AuthorizationCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGoogleSheetsOAuth2AuthorizationCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateSlackOAuth2AuthorizationCredentialDto() *CreateSlackOAuth2AuthorizationCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateSlackOAuth2AuthorizationCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGoHighLevelMcpCredentialDto() *CreateGoHighLevelMcpCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelMcpCredentialDto
}

func (a *AssistantOverridesCredentialsItem) UnmarshalJSON(data []byte) error {
	valueCreateElevenLabsCredentialDto := new(CreateElevenLabsCredentialDto)
	if err := json.Unmarshal(data, &valueCreateElevenLabsCredentialDto); err == nil {
		a.typ = "CreateElevenLabsCredentialDto"
		a.CreateElevenLabsCredentialDto = valueCreateElevenLabsCredentialDto
		return nil
	}
	valueCreateAnthropicCredentialDto := new(CreateAnthropicCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnthropicCredentialDto); err == nil {
		a.typ = "CreateAnthropicCredentialDto"
		a.CreateAnthropicCredentialDto = valueCreateAnthropicCredentialDto
		return nil
	}
	valueCreateAnyscaleCredentialDto := new(CreateAnyscaleCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnyscaleCredentialDto); err == nil {
		a.typ = "CreateAnyscaleCredentialDto"
		a.CreateAnyscaleCredentialDto = valueCreateAnyscaleCredentialDto
		return nil
	}
	valueCreateAssemblyAiCredentialDto := new(CreateAssemblyAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAssemblyAiCredentialDto); err == nil {
		a.typ = "CreateAssemblyAiCredentialDto"
		a.CreateAssemblyAiCredentialDto = valueCreateAssemblyAiCredentialDto
		return nil
	}
	valueCreateAzureOpenAiCredentialDto := new(CreateAzureOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureOpenAiCredentialDto); err == nil {
		a.typ = "CreateAzureOpenAiCredentialDto"
		a.CreateAzureOpenAiCredentialDto = valueCreateAzureOpenAiCredentialDto
		return nil
	}
	valueCreateAzureCredentialDto := new(CreateAzureCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureCredentialDto); err == nil {
		a.typ = "CreateAzureCredentialDto"
		a.CreateAzureCredentialDto = valueCreateAzureCredentialDto
		return nil
	}
	valueCreateByoSipTrunkCredentialDto := new(CreateByoSipTrunkCredentialDto)
	if err := json.Unmarshal(data, &valueCreateByoSipTrunkCredentialDto); err == nil {
		a.typ = "CreateByoSipTrunkCredentialDto"
		a.CreateByoSipTrunkCredentialDto = valueCreateByoSipTrunkCredentialDto
		return nil
	}
	valueCreateCartesiaCredentialDto := new(CreateCartesiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCartesiaCredentialDto); err == nil {
		a.typ = "CreateCartesiaCredentialDto"
		a.CreateCartesiaCredentialDto = valueCreateCartesiaCredentialDto
		return nil
	}
	valueCreateCerebrasCredentialDto := new(CreateCerebrasCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCerebrasCredentialDto); err == nil {
		a.typ = "CreateCerebrasCredentialDto"
		a.CreateCerebrasCredentialDto = valueCreateCerebrasCredentialDto
		return nil
	}
	valueCreateCloudflareCredentialDto := new(CreateCloudflareCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCloudflareCredentialDto); err == nil {
		a.typ = "CreateCloudflareCredentialDto"
		a.CreateCloudflareCredentialDto = valueCreateCloudflareCredentialDto
		return nil
	}
	valueCreateCustomLlmCredentialDto := new(CreateCustomLlmCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCustomLlmCredentialDto); err == nil {
		a.typ = "CreateCustomLlmCredentialDto"
		a.CreateCustomLlmCredentialDto = valueCreateCustomLlmCredentialDto
		return nil
	}
	valueCreateDeepgramCredentialDto := new(CreateDeepgramCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepgramCredentialDto); err == nil {
		a.typ = "CreateDeepgramCredentialDto"
		a.CreateDeepgramCredentialDto = valueCreateDeepgramCredentialDto
		return nil
	}
	valueCreateDeepInfraCredentialDto := new(CreateDeepInfraCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepInfraCredentialDto); err == nil {
		a.typ = "CreateDeepInfraCredentialDto"
		a.CreateDeepInfraCredentialDto = valueCreateDeepInfraCredentialDto
		return nil
	}
	valueCreateDeepSeekCredentialDto := new(CreateDeepSeekCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepSeekCredentialDto); err == nil {
		a.typ = "CreateDeepSeekCredentialDto"
		a.CreateDeepSeekCredentialDto = valueCreateDeepSeekCredentialDto
		return nil
	}
	valueCreateGcpCredentialDto := new(CreateGcpCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGcpCredentialDto); err == nil {
		a.typ = "CreateGcpCredentialDto"
		a.CreateGcpCredentialDto = valueCreateGcpCredentialDto
		return nil
	}
	valueCreateGladiaCredentialDto := new(CreateGladiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGladiaCredentialDto); err == nil {
		a.typ = "CreateGladiaCredentialDto"
		a.CreateGladiaCredentialDto = valueCreateGladiaCredentialDto
		return nil
	}
	valueCreateGoHighLevelCredentialDto := new(CreateGoHighLevelCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCredentialDto); err == nil {
		a.typ = "CreateGoHighLevelCredentialDto"
		a.CreateGoHighLevelCredentialDto = valueCreateGoHighLevelCredentialDto
		return nil
	}
	valueCreateGoogleCredentialDto := new(CreateGoogleCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCredentialDto); err == nil {
		a.typ = "CreateGoogleCredentialDto"
		a.CreateGoogleCredentialDto = valueCreateGoogleCredentialDto
		return nil
	}
	valueCreateGroqCredentialDto := new(CreateGroqCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGroqCredentialDto); err == nil {
		a.typ = "CreateGroqCredentialDto"
		a.CreateGroqCredentialDto = valueCreateGroqCredentialDto
		return nil
	}
	valueCreateInflectionAiCredentialDto := new(CreateInflectionAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateInflectionAiCredentialDto); err == nil {
		a.typ = "CreateInflectionAiCredentialDto"
		a.CreateInflectionAiCredentialDto = valueCreateInflectionAiCredentialDto
		return nil
	}
	valueCreateLangfuseCredentialDto := new(CreateLangfuseCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLangfuseCredentialDto); err == nil {
		a.typ = "CreateLangfuseCredentialDto"
		a.CreateLangfuseCredentialDto = valueCreateLangfuseCredentialDto
		return nil
	}
	valueCreateLmntCredentialDto := new(CreateLmntCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLmntCredentialDto); err == nil {
		a.typ = "CreateLmntCredentialDto"
		a.CreateLmntCredentialDto = valueCreateLmntCredentialDto
		return nil
	}
	valueCreateMakeCredentialDto := new(CreateMakeCredentialDto)
	if err := json.Unmarshal(data, &valueCreateMakeCredentialDto); err == nil {
		a.typ = "CreateMakeCredentialDto"
		a.CreateMakeCredentialDto = valueCreateMakeCredentialDto
		return nil
	}
	valueCreateOpenAiCredentialDto := new(CreateOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenAiCredentialDto); err == nil {
		a.typ = "CreateOpenAiCredentialDto"
		a.CreateOpenAiCredentialDto = valueCreateOpenAiCredentialDto
		return nil
	}
	valueCreateOpenRouterCredentialDto := new(CreateOpenRouterCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenRouterCredentialDto); err == nil {
		a.typ = "CreateOpenRouterCredentialDto"
		a.CreateOpenRouterCredentialDto = valueCreateOpenRouterCredentialDto
		return nil
	}
	valueCreatePerplexityAiCredentialDto := new(CreatePerplexityAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePerplexityAiCredentialDto); err == nil {
		a.typ = "CreatePerplexityAiCredentialDto"
		a.CreatePerplexityAiCredentialDto = valueCreatePerplexityAiCredentialDto
		return nil
	}
	valueCreatePlayHtCredentialDto := new(CreatePlayHtCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePlayHtCredentialDto); err == nil {
		a.typ = "CreatePlayHtCredentialDto"
		a.CreatePlayHtCredentialDto = valueCreatePlayHtCredentialDto
		return nil
	}
	valueCreateRimeAiCredentialDto := new(CreateRimeAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRimeAiCredentialDto); err == nil {
		a.typ = "CreateRimeAiCredentialDto"
		a.CreateRimeAiCredentialDto = valueCreateRimeAiCredentialDto
		return nil
	}
	valueCreateRunpodCredentialDto := new(CreateRunpodCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRunpodCredentialDto); err == nil {
		a.typ = "CreateRunpodCredentialDto"
		a.CreateRunpodCredentialDto = valueCreateRunpodCredentialDto
		return nil
	}
	valueCreateS3CredentialDto := new(CreateS3CredentialDto)
	if err := json.Unmarshal(data, &valueCreateS3CredentialDto); err == nil {
		a.typ = "CreateS3CredentialDto"
		a.CreateS3CredentialDto = valueCreateS3CredentialDto
		return nil
	}
	valueCreateSupabaseCredentialDto := new(CreateSupabaseCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSupabaseCredentialDto); err == nil {
		a.typ = "CreateSupabaseCredentialDto"
		a.CreateSupabaseCredentialDto = valueCreateSupabaseCredentialDto
		return nil
	}
	valueCreateSmallestAiCredentialDto := new(CreateSmallestAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSmallestAiCredentialDto); err == nil {
		a.typ = "CreateSmallestAiCredentialDto"
		a.CreateSmallestAiCredentialDto = valueCreateSmallestAiCredentialDto
		return nil
	}
	valueCreateTavusCredentialDto := new(CreateTavusCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTavusCredentialDto); err == nil {
		a.typ = "CreateTavusCredentialDto"
		a.CreateTavusCredentialDto = valueCreateTavusCredentialDto
		return nil
	}
	valueCreateTogetherAiCredentialDto := new(CreateTogetherAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTogetherAiCredentialDto); err == nil {
		a.typ = "CreateTogetherAiCredentialDto"
		a.CreateTogetherAiCredentialDto = valueCreateTogetherAiCredentialDto
		return nil
	}
	valueCreateTwilioCredentialDto := new(CreateTwilioCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTwilioCredentialDto); err == nil {
		a.typ = "CreateTwilioCredentialDto"
		a.CreateTwilioCredentialDto = valueCreateTwilioCredentialDto
		return nil
	}
	valueCreateVonageCredentialDto := new(CreateVonageCredentialDto)
	if err := json.Unmarshal(data, &valueCreateVonageCredentialDto); err == nil {
		a.typ = "CreateVonageCredentialDto"
		a.CreateVonageCredentialDto = valueCreateVonageCredentialDto
		return nil
	}
	valueCreateWebhookCredentialDto := new(CreateWebhookCredentialDto)
	if err := json.Unmarshal(data, &valueCreateWebhookCredentialDto); err == nil {
		a.typ = "CreateWebhookCredentialDto"
		a.CreateWebhookCredentialDto = valueCreateWebhookCredentialDto
		return nil
	}
	valueCreateXAiCredentialDto := new(CreateXAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateXAiCredentialDto); err == nil {
		a.typ = "CreateXAiCredentialDto"
		a.CreateXAiCredentialDto = valueCreateXAiCredentialDto
		return nil
	}
	valueCreateNeuphonicCredentialDto := new(CreateNeuphonicCredentialDto)
	if err := json.Unmarshal(data, &valueCreateNeuphonicCredentialDto); err == nil {
		a.typ = "CreateNeuphonicCredentialDto"
		a.CreateNeuphonicCredentialDto = valueCreateNeuphonicCredentialDto
		return nil
	}
	valueCreateHumeCredentialDto := new(CreateHumeCredentialDto)
	if err := json.Unmarshal(data, &valueCreateHumeCredentialDto); err == nil {
		a.typ = "CreateHumeCredentialDto"
		a.CreateHumeCredentialDto = valueCreateHumeCredentialDto
		return nil
	}
	valueCreateMistralCredentialDto := new(CreateMistralCredentialDto)
	if err := json.Unmarshal(data, &valueCreateMistralCredentialDto); err == nil {
		a.typ = "CreateMistralCredentialDto"
		a.CreateMistralCredentialDto = valueCreateMistralCredentialDto
		return nil
	}
	valueCreateSpeechmaticsCredentialDto := new(CreateSpeechmaticsCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSpeechmaticsCredentialDto); err == nil {
		a.typ = "CreateSpeechmaticsCredentialDto"
		a.CreateSpeechmaticsCredentialDto = valueCreateSpeechmaticsCredentialDto
		return nil
	}
	valueCreateTrieveCredentialDto := new(CreateTrieveCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTrieveCredentialDto); err == nil {
		a.typ = "CreateTrieveCredentialDto"
		a.CreateTrieveCredentialDto = valueCreateTrieveCredentialDto
		return nil
	}
	valueCreateGoogleCalendarOAuth2ClientCredentialDto := new(CreateGoogleCalendarOAuth2ClientCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarOAuth2ClientCredentialDto); err == nil {
		a.typ = "CreateGoogleCalendarOAuth2ClientCredentialDto"
		a.CreateGoogleCalendarOAuth2ClientCredentialDto = valueCreateGoogleCalendarOAuth2ClientCredentialDto
		return nil
	}
	valueCreateGoogleCalendarOAuth2AuthorizationCredentialDto := new(CreateGoogleCalendarOAuth2AuthorizationCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarOAuth2AuthorizationCredentialDto); err == nil {
		a.typ = "CreateGoogleCalendarOAuth2AuthorizationCredentialDto"
		a.CreateGoogleCalendarOAuth2AuthorizationCredentialDto = valueCreateGoogleCalendarOAuth2AuthorizationCredentialDto
		return nil
	}
	valueCreateGoogleSheetsOAuth2AuthorizationCredentialDto := new(CreateGoogleSheetsOAuth2AuthorizationCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsOAuth2AuthorizationCredentialDto); err == nil {
		a.typ = "CreateGoogleSheetsOAuth2AuthorizationCredentialDto"
		a.CreateGoogleSheetsOAuth2AuthorizationCredentialDto = valueCreateGoogleSheetsOAuth2AuthorizationCredentialDto
		return nil
	}
	valueCreateSlackOAuth2AuthorizationCredentialDto := new(CreateSlackOAuth2AuthorizationCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSlackOAuth2AuthorizationCredentialDto); err == nil {
		a.typ = "CreateSlackOAuth2AuthorizationCredentialDto"
		a.CreateSlackOAuth2AuthorizationCredentialDto = valueCreateSlackOAuth2AuthorizationCredentialDto
		return nil
	}
	valueCreateGoHighLevelMcpCredentialDto := new(CreateGoHighLevelMcpCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelMcpCredentialDto); err == nil {
		a.typ = "CreateGoHighLevelMcpCredentialDto"
		a.CreateGoHighLevelMcpCredentialDto = valueCreateGoHighLevelMcpCredentialDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesCredentialsItem) MarshalJSON() ([]byte, error) {
	if a.typ == "CreateElevenLabsCredentialDto" || a.CreateElevenLabsCredentialDto != nil {
		return json.Marshal(a.CreateElevenLabsCredentialDto)
	}
	if a.typ == "CreateAnthropicCredentialDto" || a.CreateAnthropicCredentialDto != nil {
		return json.Marshal(a.CreateAnthropicCredentialDto)
	}
	if a.typ == "CreateAnyscaleCredentialDto" || a.CreateAnyscaleCredentialDto != nil {
		return json.Marshal(a.CreateAnyscaleCredentialDto)
	}
	if a.typ == "CreateAssemblyAiCredentialDto" || a.CreateAssemblyAiCredentialDto != nil {
		return json.Marshal(a.CreateAssemblyAiCredentialDto)
	}
	if a.typ == "CreateAzureOpenAiCredentialDto" || a.CreateAzureOpenAiCredentialDto != nil {
		return json.Marshal(a.CreateAzureOpenAiCredentialDto)
	}
	if a.typ == "CreateAzureCredentialDto" || a.CreateAzureCredentialDto != nil {
		return json.Marshal(a.CreateAzureCredentialDto)
	}
	if a.typ == "CreateByoSipTrunkCredentialDto" || a.CreateByoSipTrunkCredentialDto != nil {
		return json.Marshal(a.CreateByoSipTrunkCredentialDto)
	}
	if a.typ == "CreateCartesiaCredentialDto" || a.CreateCartesiaCredentialDto != nil {
		return json.Marshal(a.CreateCartesiaCredentialDto)
	}
	if a.typ == "CreateCerebrasCredentialDto" || a.CreateCerebrasCredentialDto != nil {
		return json.Marshal(a.CreateCerebrasCredentialDto)
	}
	if a.typ == "CreateCloudflareCredentialDto" || a.CreateCloudflareCredentialDto != nil {
		return json.Marshal(a.CreateCloudflareCredentialDto)
	}
	if a.typ == "CreateCustomLlmCredentialDto" || a.CreateCustomLlmCredentialDto != nil {
		return json.Marshal(a.CreateCustomLlmCredentialDto)
	}
	if a.typ == "CreateDeepgramCredentialDto" || a.CreateDeepgramCredentialDto != nil {
		return json.Marshal(a.CreateDeepgramCredentialDto)
	}
	if a.typ == "CreateDeepInfraCredentialDto" || a.CreateDeepInfraCredentialDto != nil {
		return json.Marshal(a.CreateDeepInfraCredentialDto)
	}
	if a.typ == "CreateDeepSeekCredentialDto" || a.CreateDeepSeekCredentialDto != nil {
		return json.Marshal(a.CreateDeepSeekCredentialDto)
	}
	if a.typ == "CreateGcpCredentialDto" || a.CreateGcpCredentialDto != nil {
		return json.Marshal(a.CreateGcpCredentialDto)
	}
	if a.typ == "CreateGladiaCredentialDto" || a.CreateGladiaCredentialDto != nil {
		return json.Marshal(a.CreateGladiaCredentialDto)
	}
	if a.typ == "CreateGoHighLevelCredentialDto" || a.CreateGoHighLevelCredentialDto != nil {
		return json.Marshal(a.CreateGoHighLevelCredentialDto)
	}
	if a.typ == "CreateGoogleCredentialDto" || a.CreateGoogleCredentialDto != nil {
		return json.Marshal(a.CreateGoogleCredentialDto)
	}
	if a.typ == "CreateGroqCredentialDto" || a.CreateGroqCredentialDto != nil {
		return json.Marshal(a.CreateGroqCredentialDto)
	}
	if a.typ == "CreateInflectionAiCredentialDto" || a.CreateInflectionAiCredentialDto != nil {
		return json.Marshal(a.CreateInflectionAiCredentialDto)
	}
	if a.typ == "CreateLangfuseCredentialDto" || a.CreateLangfuseCredentialDto != nil {
		return json.Marshal(a.CreateLangfuseCredentialDto)
	}
	if a.typ == "CreateLmntCredentialDto" || a.CreateLmntCredentialDto != nil {
		return json.Marshal(a.CreateLmntCredentialDto)
	}
	if a.typ == "CreateMakeCredentialDto" || a.CreateMakeCredentialDto != nil {
		return json.Marshal(a.CreateMakeCredentialDto)
	}
	if a.typ == "CreateOpenAiCredentialDto" || a.CreateOpenAiCredentialDto != nil {
		return json.Marshal(a.CreateOpenAiCredentialDto)
	}
	if a.typ == "CreateOpenRouterCredentialDto" || a.CreateOpenRouterCredentialDto != nil {
		return json.Marshal(a.CreateOpenRouterCredentialDto)
	}
	if a.typ == "CreatePerplexityAiCredentialDto" || a.CreatePerplexityAiCredentialDto != nil {
		return json.Marshal(a.CreatePerplexityAiCredentialDto)
	}
	if a.typ == "CreatePlayHtCredentialDto" || a.CreatePlayHtCredentialDto != nil {
		return json.Marshal(a.CreatePlayHtCredentialDto)
	}
	if a.typ == "CreateRimeAiCredentialDto" || a.CreateRimeAiCredentialDto != nil {
		return json.Marshal(a.CreateRimeAiCredentialDto)
	}
	if a.typ == "CreateRunpodCredentialDto" || a.CreateRunpodCredentialDto != nil {
		return json.Marshal(a.CreateRunpodCredentialDto)
	}
	if a.typ == "CreateS3CredentialDto" || a.CreateS3CredentialDto != nil {
		return json.Marshal(a.CreateS3CredentialDto)
	}
	if a.typ == "CreateSupabaseCredentialDto" || a.CreateSupabaseCredentialDto != nil {
		return json.Marshal(a.CreateSupabaseCredentialDto)
	}
	if a.typ == "CreateSmallestAiCredentialDto" || a.CreateSmallestAiCredentialDto != nil {
		return json.Marshal(a.CreateSmallestAiCredentialDto)
	}
	if a.typ == "CreateTavusCredentialDto" || a.CreateTavusCredentialDto != nil {
		return json.Marshal(a.CreateTavusCredentialDto)
	}
	if a.typ == "CreateTogetherAiCredentialDto" || a.CreateTogetherAiCredentialDto != nil {
		return json.Marshal(a.CreateTogetherAiCredentialDto)
	}
	if a.typ == "CreateTwilioCredentialDto" || a.CreateTwilioCredentialDto != nil {
		return json.Marshal(a.CreateTwilioCredentialDto)
	}
	if a.typ == "CreateVonageCredentialDto" || a.CreateVonageCredentialDto != nil {
		return json.Marshal(a.CreateVonageCredentialDto)
	}
	if a.typ == "CreateWebhookCredentialDto" || a.CreateWebhookCredentialDto != nil {
		return json.Marshal(a.CreateWebhookCredentialDto)
	}
	if a.typ == "CreateXAiCredentialDto" || a.CreateXAiCredentialDto != nil {
		return json.Marshal(a.CreateXAiCredentialDto)
	}
	if a.typ == "CreateNeuphonicCredentialDto" || a.CreateNeuphonicCredentialDto != nil {
		return json.Marshal(a.CreateNeuphonicCredentialDto)
	}
	if a.typ == "CreateHumeCredentialDto" || a.CreateHumeCredentialDto != nil {
		return json.Marshal(a.CreateHumeCredentialDto)
	}
	if a.typ == "CreateMistralCredentialDto" || a.CreateMistralCredentialDto != nil {
		return json.Marshal(a.CreateMistralCredentialDto)
	}
	if a.typ == "CreateSpeechmaticsCredentialDto" || a.CreateSpeechmaticsCredentialDto != nil {
		return json.Marshal(a.CreateSpeechmaticsCredentialDto)
	}
	if a.typ == "CreateTrieveCredentialDto" || a.CreateTrieveCredentialDto != nil {
		return json.Marshal(a.CreateTrieveCredentialDto)
	}
	if a.typ == "CreateGoogleCalendarOAuth2ClientCredentialDto" || a.CreateGoogleCalendarOAuth2ClientCredentialDto != nil {
		return json.Marshal(a.CreateGoogleCalendarOAuth2ClientCredentialDto)
	}
	if a.typ == "CreateGoogleCalendarOAuth2AuthorizationCredentialDto" || a.CreateGoogleCalendarOAuth2AuthorizationCredentialDto != nil {
		return json.Marshal(a.CreateGoogleCalendarOAuth2AuthorizationCredentialDto)
	}
	if a.typ == "CreateGoogleSheetsOAuth2AuthorizationCredentialDto" || a.CreateGoogleSheetsOAuth2AuthorizationCredentialDto != nil {
		return json.Marshal(a.CreateGoogleSheetsOAuth2AuthorizationCredentialDto)
	}
	if a.typ == "CreateSlackOAuth2AuthorizationCredentialDto" || a.CreateSlackOAuth2AuthorizationCredentialDto != nil {
		return json.Marshal(a.CreateSlackOAuth2AuthorizationCredentialDto)
	}
	if a.typ == "CreateGoHighLevelMcpCredentialDto" || a.CreateGoHighLevelMcpCredentialDto != nil {
		return json.Marshal(a.CreateGoHighLevelMcpCredentialDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesCredentialsItemVisitor interface {
	VisitCreateElevenLabsCredentialDto(*CreateElevenLabsCredentialDto) error
	VisitCreateAnthropicCredentialDto(*CreateAnthropicCredentialDto) error
	VisitCreateAnyscaleCredentialDto(*CreateAnyscaleCredentialDto) error
	VisitCreateAssemblyAiCredentialDto(*CreateAssemblyAiCredentialDto) error
	VisitCreateAzureOpenAiCredentialDto(*CreateAzureOpenAiCredentialDto) error
	VisitCreateAzureCredentialDto(*CreateAzureCredentialDto) error
	VisitCreateByoSipTrunkCredentialDto(*CreateByoSipTrunkCredentialDto) error
	VisitCreateCartesiaCredentialDto(*CreateCartesiaCredentialDto) error
	VisitCreateCerebrasCredentialDto(*CreateCerebrasCredentialDto) error
	VisitCreateCloudflareCredentialDto(*CreateCloudflareCredentialDto) error
	VisitCreateCustomLlmCredentialDto(*CreateCustomLlmCredentialDto) error
	VisitCreateDeepgramCredentialDto(*CreateDeepgramCredentialDto) error
	VisitCreateDeepInfraCredentialDto(*CreateDeepInfraCredentialDto) error
	VisitCreateDeepSeekCredentialDto(*CreateDeepSeekCredentialDto) error
	VisitCreateGcpCredentialDto(*CreateGcpCredentialDto) error
	VisitCreateGladiaCredentialDto(*CreateGladiaCredentialDto) error
	VisitCreateGoHighLevelCredentialDto(*CreateGoHighLevelCredentialDto) error
	VisitCreateGoogleCredentialDto(*CreateGoogleCredentialDto) error
	VisitCreateGroqCredentialDto(*CreateGroqCredentialDto) error
	VisitCreateInflectionAiCredentialDto(*CreateInflectionAiCredentialDto) error
	VisitCreateLangfuseCredentialDto(*CreateLangfuseCredentialDto) error
	VisitCreateLmntCredentialDto(*CreateLmntCredentialDto) error
	VisitCreateMakeCredentialDto(*CreateMakeCredentialDto) error
	VisitCreateOpenAiCredentialDto(*CreateOpenAiCredentialDto) error
	VisitCreateOpenRouterCredentialDto(*CreateOpenRouterCredentialDto) error
	VisitCreatePerplexityAiCredentialDto(*CreatePerplexityAiCredentialDto) error
	VisitCreatePlayHtCredentialDto(*CreatePlayHtCredentialDto) error
	VisitCreateRimeAiCredentialDto(*CreateRimeAiCredentialDto) error
	VisitCreateRunpodCredentialDto(*CreateRunpodCredentialDto) error
	VisitCreateS3CredentialDto(*CreateS3CredentialDto) error
	VisitCreateSupabaseCredentialDto(*CreateSupabaseCredentialDto) error
	VisitCreateSmallestAiCredentialDto(*CreateSmallestAiCredentialDto) error
	VisitCreateTavusCredentialDto(*CreateTavusCredentialDto) error
	VisitCreateTogetherAiCredentialDto(*CreateTogetherAiCredentialDto) error
	VisitCreateTwilioCredentialDto(*CreateTwilioCredentialDto) error
	VisitCreateVonageCredentialDto(*CreateVonageCredentialDto) error
	VisitCreateWebhookCredentialDto(*CreateWebhookCredentialDto) error
	VisitCreateXAiCredentialDto(*CreateXAiCredentialDto) error
	VisitCreateNeuphonicCredentialDto(*CreateNeuphonicCredentialDto) error
	VisitCreateHumeCredentialDto(*CreateHumeCredentialDto) error
	VisitCreateMistralCredentialDto(*CreateMistralCredentialDto) error
	VisitCreateSpeechmaticsCredentialDto(*CreateSpeechmaticsCredentialDto) error
	VisitCreateTrieveCredentialDto(*CreateTrieveCredentialDto) error
	VisitCreateGoogleCalendarOAuth2ClientCredentialDto(*CreateGoogleCalendarOAuth2ClientCredentialDto) error
	VisitCreateGoogleCalendarOAuth2AuthorizationCredentialDto(*CreateGoogleCalendarOAuth2AuthorizationCredentialDto) error
	VisitCreateGoogleSheetsOAuth2AuthorizationCredentialDto(*CreateGoogleSheetsOAuth2AuthorizationCredentialDto) error
	VisitCreateSlackOAuth2AuthorizationCredentialDto(*CreateSlackOAuth2AuthorizationCredentialDto) error
	VisitCreateGoHighLevelMcpCredentialDto(*CreateGoHighLevelMcpCredentialDto) error
}

func (a *AssistantOverridesCredentialsItem) Accept(visitor AssistantOverridesCredentialsItemVisitor) error {
	if a.typ == "CreateElevenLabsCredentialDto" || a.CreateElevenLabsCredentialDto != nil {
		return visitor.VisitCreateElevenLabsCredentialDto(a.CreateElevenLabsCredentialDto)
	}
	if a.typ == "CreateAnthropicCredentialDto" || a.CreateAnthropicCredentialDto != nil {
		return visitor.VisitCreateAnthropicCredentialDto(a.CreateAnthropicCredentialDto)
	}
	if a.typ == "CreateAnyscaleCredentialDto" || a.CreateAnyscaleCredentialDto != nil {
		return visitor.VisitCreateAnyscaleCredentialDto(a.CreateAnyscaleCredentialDto)
	}
	if a.typ == "CreateAssemblyAiCredentialDto" || a.CreateAssemblyAiCredentialDto != nil {
		return visitor.VisitCreateAssemblyAiCredentialDto(a.CreateAssemblyAiCredentialDto)
	}
	if a.typ == "CreateAzureOpenAiCredentialDto" || a.CreateAzureOpenAiCredentialDto != nil {
		return visitor.VisitCreateAzureOpenAiCredentialDto(a.CreateAzureOpenAiCredentialDto)
	}
	if a.typ == "CreateAzureCredentialDto" || a.CreateAzureCredentialDto != nil {
		return visitor.VisitCreateAzureCredentialDto(a.CreateAzureCredentialDto)
	}
	if a.typ == "CreateByoSipTrunkCredentialDto" || a.CreateByoSipTrunkCredentialDto != nil {
		return visitor.VisitCreateByoSipTrunkCredentialDto(a.CreateByoSipTrunkCredentialDto)
	}
	if a.typ == "CreateCartesiaCredentialDto" || a.CreateCartesiaCredentialDto != nil {
		return visitor.VisitCreateCartesiaCredentialDto(a.CreateCartesiaCredentialDto)
	}
	if a.typ == "CreateCerebrasCredentialDto" || a.CreateCerebrasCredentialDto != nil {
		return visitor.VisitCreateCerebrasCredentialDto(a.CreateCerebrasCredentialDto)
	}
	if a.typ == "CreateCloudflareCredentialDto" || a.CreateCloudflareCredentialDto != nil {
		return visitor.VisitCreateCloudflareCredentialDto(a.CreateCloudflareCredentialDto)
	}
	if a.typ == "CreateCustomLlmCredentialDto" || a.CreateCustomLlmCredentialDto != nil {
		return visitor.VisitCreateCustomLlmCredentialDto(a.CreateCustomLlmCredentialDto)
	}
	if a.typ == "CreateDeepgramCredentialDto" || a.CreateDeepgramCredentialDto != nil {
		return visitor.VisitCreateDeepgramCredentialDto(a.CreateDeepgramCredentialDto)
	}
	if a.typ == "CreateDeepInfraCredentialDto" || a.CreateDeepInfraCredentialDto != nil {
		return visitor.VisitCreateDeepInfraCredentialDto(a.CreateDeepInfraCredentialDto)
	}
	if a.typ == "CreateDeepSeekCredentialDto" || a.CreateDeepSeekCredentialDto != nil {
		return visitor.VisitCreateDeepSeekCredentialDto(a.CreateDeepSeekCredentialDto)
	}
	if a.typ == "CreateGcpCredentialDto" || a.CreateGcpCredentialDto != nil {
		return visitor.VisitCreateGcpCredentialDto(a.CreateGcpCredentialDto)
	}
	if a.typ == "CreateGladiaCredentialDto" || a.CreateGladiaCredentialDto != nil {
		return visitor.VisitCreateGladiaCredentialDto(a.CreateGladiaCredentialDto)
	}
	if a.typ == "CreateGoHighLevelCredentialDto" || a.CreateGoHighLevelCredentialDto != nil {
		return visitor.VisitCreateGoHighLevelCredentialDto(a.CreateGoHighLevelCredentialDto)
	}
	if a.typ == "CreateGoogleCredentialDto" || a.CreateGoogleCredentialDto != nil {
		return visitor.VisitCreateGoogleCredentialDto(a.CreateGoogleCredentialDto)
	}
	if a.typ == "CreateGroqCredentialDto" || a.CreateGroqCredentialDto != nil {
		return visitor.VisitCreateGroqCredentialDto(a.CreateGroqCredentialDto)
	}
	if a.typ == "CreateInflectionAiCredentialDto" || a.CreateInflectionAiCredentialDto != nil {
		return visitor.VisitCreateInflectionAiCredentialDto(a.CreateInflectionAiCredentialDto)
	}
	if a.typ == "CreateLangfuseCredentialDto" || a.CreateLangfuseCredentialDto != nil {
		return visitor.VisitCreateLangfuseCredentialDto(a.CreateLangfuseCredentialDto)
	}
	if a.typ == "CreateLmntCredentialDto" || a.CreateLmntCredentialDto != nil {
		return visitor.VisitCreateLmntCredentialDto(a.CreateLmntCredentialDto)
	}
	if a.typ == "CreateMakeCredentialDto" || a.CreateMakeCredentialDto != nil {
		return visitor.VisitCreateMakeCredentialDto(a.CreateMakeCredentialDto)
	}
	if a.typ == "CreateOpenAiCredentialDto" || a.CreateOpenAiCredentialDto != nil {
		return visitor.VisitCreateOpenAiCredentialDto(a.CreateOpenAiCredentialDto)
	}
	if a.typ == "CreateOpenRouterCredentialDto" || a.CreateOpenRouterCredentialDto != nil {
		return visitor.VisitCreateOpenRouterCredentialDto(a.CreateOpenRouterCredentialDto)
	}
	if a.typ == "CreatePerplexityAiCredentialDto" || a.CreatePerplexityAiCredentialDto != nil {
		return visitor.VisitCreatePerplexityAiCredentialDto(a.CreatePerplexityAiCredentialDto)
	}
	if a.typ == "CreatePlayHtCredentialDto" || a.CreatePlayHtCredentialDto != nil {
		return visitor.VisitCreatePlayHtCredentialDto(a.CreatePlayHtCredentialDto)
	}
	if a.typ == "CreateRimeAiCredentialDto" || a.CreateRimeAiCredentialDto != nil {
		return visitor.VisitCreateRimeAiCredentialDto(a.CreateRimeAiCredentialDto)
	}
	if a.typ == "CreateRunpodCredentialDto" || a.CreateRunpodCredentialDto != nil {
		return visitor.VisitCreateRunpodCredentialDto(a.CreateRunpodCredentialDto)
	}
	if a.typ == "CreateS3CredentialDto" || a.CreateS3CredentialDto != nil {
		return visitor.VisitCreateS3CredentialDto(a.CreateS3CredentialDto)
	}
	if a.typ == "CreateSupabaseCredentialDto" || a.CreateSupabaseCredentialDto != nil {
		return visitor.VisitCreateSupabaseCredentialDto(a.CreateSupabaseCredentialDto)
	}
	if a.typ == "CreateSmallestAiCredentialDto" || a.CreateSmallestAiCredentialDto != nil {
		return visitor.VisitCreateSmallestAiCredentialDto(a.CreateSmallestAiCredentialDto)
	}
	if a.typ == "CreateTavusCredentialDto" || a.CreateTavusCredentialDto != nil {
		return visitor.VisitCreateTavusCredentialDto(a.CreateTavusCredentialDto)
	}
	if a.typ == "CreateTogetherAiCredentialDto" || a.CreateTogetherAiCredentialDto != nil {
		return visitor.VisitCreateTogetherAiCredentialDto(a.CreateTogetherAiCredentialDto)
	}
	if a.typ == "CreateTwilioCredentialDto" || a.CreateTwilioCredentialDto != nil {
		return visitor.VisitCreateTwilioCredentialDto(a.CreateTwilioCredentialDto)
	}
	if a.typ == "CreateVonageCredentialDto" || a.CreateVonageCredentialDto != nil {
		return visitor.VisitCreateVonageCredentialDto(a.CreateVonageCredentialDto)
	}
	if a.typ == "CreateWebhookCredentialDto" || a.CreateWebhookCredentialDto != nil {
		return visitor.VisitCreateWebhookCredentialDto(a.CreateWebhookCredentialDto)
	}
	if a.typ == "CreateXAiCredentialDto" || a.CreateXAiCredentialDto != nil {
		return visitor.VisitCreateXAiCredentialDto(a.CreateXAiCredentialDto)
	}
	if a.typ == "CreateNeuphonicCredentialDto" || a.CreateNeuphonicCredentialDto != nil {
		return visitor.VisitCreateNeuphonicCredentialDto(a.CreateNeuphonicCredentialDto)
	}
	if a.typ == "CreateHumeCredentialDto" || a.CreateHumeCredentialDto != nil {
		return visitor.VisitCreateHumeCredentialDto(a.CreateHumeCredentialDto)
	}
	if a.typ == "CreateMistralCredentialDto" || a.CreateMistralCredentialDto != nil {
		return visitor.VisitCreateMistralCredentialDto(a.CreateMistralCredentialDto)
	}
	if a.typ == "CreateSpeechmaticsCredentialDto" || a.CreateSpeechmaticsCredentialDto != nil {
		return visitor.VisitCreateSpeechmaticsCredentialDto(a.CreateSpeechmaticsCredentialDto)
	}
	if a.typ == "CreateTrieveCredentialDto" || a.CreateTrieveCredentialDto != nil {
		return visitor.VisitCreateTrieveCredentialDto(a.CreateTrieveCredentialDto)
	}
	if a.typ == "CreateGoogleCalendarOAuth2ClientCredentialDto" || a.CreateGoogleCalendarOAuth2ClientCredentialDto != nil {
		return visitor.VisitCreateGoogleCalendarOAuth2ClientCredentialDto(a.CreateGoogleCalendarOAuth2ClientCredentialDto)
	}
	if a.typ == "CreateGoogleCalendarOAuth2AuthorizationCredentialDto" || a.CreateGoogleCalendarOAuth2AuthorizationCredentialDto != nil {
		return visitor.VisitCreateGoogleCalendarOAuth2AuthorizationCredentialDto(a.CreateGoogleCalendarOAuth2AuthorizationCredentialDto)
	}
	if a.typ == "CreateGoogleSheetsOAuth2AuthorizationCredentialDto" || a.CreateGoogleSheetsOAuth2AuthorizationCredentialDto != nil {
		return visitor.VisitCreateGoogleSheetsOAuth2AuthorizationCredentialDto(a.CreateGoogleSheetsOAuth2AuthorizationCredentialDto)
	}
	if a.typ == "CreateSlackOAuth2AuthorizationCredentialDto" || a.CreateSlackOAuth2AuthorizationCredentialDto != nil {
		return visitor.VisitCreateSlackOAuth2AuthorizationCredentialDto(a.CreateSlackOAuth2AuthorizationCredentialDto)
	}
	if a.typ == "CreateGoHighLevelMcpCredentialDto" || a.CreateGoHighLevelMcpCredentialDto != nil {
		return visitor.VisitCreateGoHighLevelMcpCredentialDto(a.CreateGoHighLevelMcpCredentialDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type AssistantOverridesFirstMessageMode string

const (
	AssistantOverridesFirstMessageModeAssistantSpeaksFirst                          AssistantOverridesFirstMessageMode = "assistant-speaks-first"
	AssistantOverridesFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage AssistantOverridesFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	AssistantOverridesFirstMessageModeAssistantWaitsForUser                         AssistantOverridesFirstMessageMode = "assistant-waits-for-user"
)

func NewAssistantOverridesFirstMessageModeFromString(s string) (AssistantOverridesFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return AssistantOverridesFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return AssistantOverridesFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return AssistantOverridesFirstMessageModeAssistantWaitsForUser, nil
	}
	var t AssistantOverridesFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesFirstMessageMode) Ptr() *AssistantOverridesFirstMessageMode {
	return &a
}

type AssistantOverridesHooksItem struct {
	AssistantHookCallEnding                 *AssistantHookCallEnding
	AssistantHookAssistantSpeechInterrupted *AssistantHookAssistantSpeechInterrupted
	AssistantHookCustomerSpeechInterrupted  *AssistantHookCustomerSpeechInterrupted

	typ string
}

func (a *AssistantOverridesHooksItem) GetAssistantHookCallEnding() *AssistantHookCallEnding {
	if a == nil {
		return nil
	}
	return a.AssistantHookCallEnding
}

func (a *AssistantOverridesHooksItem) GetAssistantHookAssistantSpeechInterrupted() *AssistantHookAssistantSpeechInterrupted {
	if a == nil {
		return nil
	}
	return a.AssistantHookAssistantSpeechInterrupted
}

func (a *AssistantOverridesHooksItem) GetAssistantHookCustomerSpeechInterrupted() *AssistantHookCustomerSpeechInterrupted {
	if a == nil {
		return nil
	}
	return a.AssistantHookCustomerSpeechInterrupted
}

func (a *AssistantOverridesHooksItem) UnmarshalJSON(data []byte) error {
	valueAssistantHookCallEnding := new(AssistantHookCallEnding)
	if err := json.Unmarshal(data, &valueAssistantHookCallEnding); err == nil {
		a.typ = "AssistantHookCallEnding"
		a.AssistantHookCallEnding = valueAssistantHookCallEnding
		return nil
	}
	valueAssistantHookAssistantSpeechInterrupted := new(AssistantHookAssistantSpeechInterrupted)
	if err := json.Unmarshal(data, &valueAssistantHookAssistantSpeechInterrupted); err == nil {
		a.typ = "AssistantHookAssistantSpeechInterrupted"
		a.AssistantHookAssistantSpeechInterrupted = valueAssistantHookAssistantSpeechInterrupted
		return nil
	}
	valueAssistantHookCustomerSpeechInterrupted := new(AssistantHookCustomerSpeechInterrupted)
	if err := json.Unmarshal(data, &valueAssistantHookCustomerSpeechInterrupted); err == nil {
		a.typ = "AssistantHookCustomerSpeechInterrupted"
		a.AssistantHookCustomerSpeechInterrupted = valueAssistantHookCustomerSpeechInterrupted
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesHooksItem) MarshalJSON() ([]byte, error) {
	if a.typ == "AssistantHookCallEnding" || a.AssistantHookCallEnding != nil {
		return json.Marshal(a.AssistantHookCallEnding)
	}
	if a.typ == "AssistantHookAssistantSpeechInterrupted" || a.AssistantHookAssistantSpeechInterrupted != nil {
		return json.Marshal(a.AssistantHookAssistantSpeechInterrupted)
	}
	if a.typ == "AssistantHookCustomerSpeechInterrupted" || a.AssistantHookCustomerSpeechInterrupted != nil {
		return json.Marshal(a.AssistantHookCustomerSpeechInterrupted)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesHooksItemVisitor interface {
	VisitAssistantHookCallEnding(*AssistantHookCallEnding) error
	VisitAssistantHookAssistantSpeechInterrupted(*AssistantHookAssistantSpeechInterrupted) error
	VisitAssistantHookCustomerSpeechInterrupted(*AssistantHookCustomerSpeechInterrupted) error
}

func (a *AssistantOverridesHooksItem) Accept(visitor AssistantOverridesHooksItemVisitor) error {
	if a.typ == "AssistantHookCallEnding" || a.AssistantHookCallEnding != nil {
		return visitor.VisitAssistantHookCallEnding(a.AssistantHookCallEnding)
	}
	if a.typ == "AssistantHookAssistantSpeechInterrupted" || a.AssistantHookAssistantSpeechInterrupted != nil {
		return visitor.VisitAssistantHookAssistantSpeechInterrupted(a.AssistantHookAssistantSpeechInterrupted)
	}
	if a.typ == "AssistantHookCustomerSpeechInterrupted" || a.AssistantHookCustomerSpeechInterrupted != nil {
		return visitor.VisitAssistantHookCustomerSpeechInterrupted(a.AssistantHookCustomerSpeechInterrupted)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// These are the options for the assistant's LLM.
type AssistantOverridesModel struct {
	AnthropicModel    *AnthropicModel
	AnyscaleModel     *AnyscaleModel
	CerebrasModel     *CerebrasModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	DeepSeekModel     *DeepSeekModel
	GoogleModel       *GoogleModel
	GroqModel         *GroqModel
	InflectionAiModel *InflectionAiModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	XaiModel          *XaiModel

	typ string
}

func (a *AssistantOverridesModel) GetAnthropicModel() *AnthropicModel {
	if a == nil {
		return nil
	}
	return a.AnthropicModel
}

func (a *AssistantOverridesModel) GetAnyscaleModel() *AnyscaleModel {
	if a == nil {
		return nil
	}
	return a.AnyscaleModel
}

func (a *AssistantOverridesModel) GetCerebrasModel() *CerebrasModel {
	if a == nil {
		return nil
	}
	return a.CerebrasModel
}

func (a *AssistantOverridesModel) GetCustomLlmModel() *CustomLlmModel {
	if a == nil {
		return nil
	}
	return a.CustomLlmModel
}

func (a *AssistantOverridesModel) GetDeepInfraModel() *DeepInfraModel {
	if a == nil {
		return nil
	}
	return a.DeepInfraModel
}

func (a *AssistantOverridesModel) GetDeepSeekModel() *DeepSeekModel {
	if a == nil {
		return nil
	}
	return a.DeepSeekModel
}

func (a *AssistantOverridesModel) GetGoogleModel() *GoogleModel {
	if a == nil {
		return nil
	}
	return a.GoogleModel
}

func (a *AssistantOverridesModel) GetGroqModel() *GroqModel {
	if a == nil {
		return nil
	}
	return a.GroqModel
}

func (a *AssistantOverridesModel) GetInflectionAiModel() *InflectionAiModel {
	if a == nil {
		return nil
	}
	return a.InflectionAiModel
}

func (a *AssistantOverridesModel) GetOpenAiModel() *OpenAiModel {
	if a == nil {
		return nil
	}
	return a.OpenAiModel
}

func (a *AssistantOverridesModel) GetOpenRouterModel() *OpenRouterModel {
	if a == nil {
		return nil
	}
	return a.OpenRouterModel
}

func (a *AssistantOverridesModel) GetPerplexityAiModel() *PerplexityAiModel {
	if a == nil {
		return nil
	}
	return a.PerplexityAiModel
}

func (a *AssistantOverridesModel) GetTogetherAiModel() *TogetherAiModel {
	if a == nil {
		return nil
	}
	return a.TogetherAiModel
}

func (a *AssistantOverridesModel) GetXaiModel() *XaiModel {
	if a == nil {
		return nil
	}
	return a.XaiModel
}

func (a *AssistantOverridesModel) UnmarshalJSON(data []byte) error {
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		a.typ = "AnthropicModel"
		a.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		a.typ = "AnyscaleModel"
		a.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueCerebrasModel := new(CerebrasModel)
	if err := json.Unmarshal(data, &valueCerebrasModel); err == nil {
		a.typ = "CerebrasModel"
		a.CerebrasModel = valueCerebrasModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		a.typ = "CustomLlmModel"
		a.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		a.typ = "DeepInfraModel"
		a.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueDeepSeekModel := new(DeepSeekModel)
	if err := json.Unmarshal(data, &valueDeepSeekModel); err == nil {
		a.typ = "DeepSeekModel"
		a.DeepSeekModel = valueDeepSeekModel
		return nil
	}
	valueGoogleModel := new(GoogleModel)
	if err := json.Unmarshal(data, &valueGoogleModel); err == nil {
		a.typ = "GoogleModel"
		a.GoogleModel = valueGoogleModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		a.typ = "GroqModel"
		a.GroqModel = valueGroqModel
		return nil
	}
	valueInflectionAiModel := new(InflectionAiModel)
	if err := json.Unmarshal(data, &valueInflectionAiModel); err == nil {
		a.typ = "InflectionAiModel"
		a.InflectionAiModel = valueInflectionAiModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		a.typ = "OpenAiModel"
		a.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		a.typ = "OpenRouterModel"
		a.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		a.typ = "PerplexityAiModel"
		a.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		a.typ = "TogetherAiModel"
		a.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueXaiModel := new(XaiModel)
	if err := json.Unmarshal(data, &valueXaiModel); err == nil {
		a.typ = "XaiModel"
		a.XaiModel = valueXaiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesModel) MarshalJSON() ([]byte, error) {
	if a.typ == "AnthropicModel" || a.AnthropicModel != nil {
		return json.Marshal(a.AnthropicModel)
	}
	if a.typ == "AnyscaleModel" || a.AnyscaleModel != nil {
		return json.Marshal(a.AnyscaleModel)
	}
	if a.typ == "CerebrasModel" || a.CerebrasModel != nil {
		return json.Marshal(a.CerebrasModel)
	}
	if a.typ == "CustomLlmModel" || a.CustomLlmModel != nil {
		return json.Marshal(a.CustomLlmModel)
	}
	if a.typ == "DeepInfraModel" || a.DeepInfraModel != nil {
		return json.Marshal(a.DeepInfraModel)
	}
	if a.typ == "DeepSeekModel" || a.DeepSeekModel != nil {
		return json.Marshal(a.DeepSeekModel)
	}
	if a.typ == "GoogleModel" || a.GoogleModel != nil {
		return json.Marshal(a.GoogleModel)
	}
	if a.typ == "GroqModel" || a.GroqModel != nil {
		return json.Marshal(a.GroqModel)
	}
	if a.typ == "InflectionAiModel" || a.InflectionAiModel != nil {
		return json.Marshal(a.InflectionAiModel)
	}
	if a.typ == "OpenAiModel" || a.OpenAiModel != nil {
		return json.Marshal(a.OpenAiModel)
	}
	if a.typ == "OpenRouterModel" || a.OpenRouterModel != nil {
		return json.Marshal(a.OpenRouterModel)
	}
	if a.typ == "PerplexityAiModel" || a.PerplexityAiModel != nil {
		return json.Marshal(a.PerplexityAiModel)
	}
	if a.typ == "TogetherAiModel" || a.TogetherAiModel != nil {
		return json.Marshal(a.TogetherAiModel)
	}
	if a.typ == "XaiModel" || a.XaiModel != nil {
		return json.Marshal(a.XaiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesModelVisitor interface {
	VisitAnthropicModel(*AnthropicModel) error
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitCerebrasModel(*CerebrasModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitDeepSeekModel(*DeepSeekModel) error
	VisitGoogleModel(*GoogleModel) error
	VisitGroqModel(*GroqModel) error
	VisitInflectionAiModel(*InflectionAiModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitXaiModel(*XaiModel) error
}

func (a *AssistantOverridesModel) Accept(visitor AssistantOverridesModelVisitor) error {
	if a.typ == "AnthropicModel" || a.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(a.AnthropicModel)
	}
	if a.typ == "AnyscaleModel" || a.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(a.AnyscaleModel)
	}
	if a.typ == "CerebrasModel" || a.CerebrasModel != nil {
		return visitor.VisitCerebrasModel(a.CerebrasModel)
	}
	if a.typ == "CustomLlmModel" || a.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(a.CustomLlmModel)
	}
	if a.typ == "DeepInfraModel" || a.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(a.DeepInfraModel)
	}
	if a.typ == "DeepSeekModel" || a.DeepSeekModel != nil {
		return visitor.VisitDeepSeekModel(a.DeepSeekModel)
	}
	if a.typ == "GoogleModel" || a.GoogleModel != nil {
		return visitor.VisitGoogleModel(a.GoogleModel)
	}
	if a.typ == "GroqModel" || a.GroqModel != nil {
		return visitor.VisitGroqModel(a.GroqModel)
	}
	if a.typ == "InflectionAiModel" || a.InflectionAiModel != nil {
		return visitor.VisitInflectionAiModel(a.InflectionAiModel)
	}
	if a.typ == "OpenAiModel" || a.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(a.OpenAiModel)
	}
	if a.typ == "OpenRouterModel" || a.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(a.OpenRouterModel)
	}
	if a.typ == "PerplexityAiModel" || a.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(a.PerplexityAiModel)
	}
	if a.typ == "TogetherAiModel" || a.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(a.TogetherAiModel)
	}
	if a.typ == "XaiModel" || a.XaiModel != nil {
		return visitor.VisitXaiModel(a.XaiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesServerMessagesItem string

const (
	AssistantOverridesServerMessagesItemConversationUpdate            AssistantOverridesServerMessagesItem = "conversation-update"
	AssistantOverridesServerMessagesItemEndOfCallReport               AssistantOverridesServerMessagesItem = "end-of-call-report"
	AssistantOverridesServerMessagesItemFunctionCall                  AssistantOverridesServerMessagesItem = "function-call"
	AssistantOverridesServerMessagesItemHang                          AssistantOverridesServerMessagesItem = "hang"
	AssistantOverridesServerMessagesItemLanguageChanged               AssistantOverridesServerMessagesItem = "language-changed"
	AssistantOverridesServerMessagesItemLanguageChangeDetected        AssistantOverridesServerMessagesItem = "language-change-detected"
	AssistantOverridesServerMessagesItemModelOutput                   AssistantOverridesServerMessagesItem = "model-output"
	AssistantOverridesServerMessagesItemPhoneCallControl              AssistantOverridesServerMessagesItem = "phone-call-control"
	AssistantOverridesServerMessagesItemSpeechUpdate                  AssistantOverridesServerMessagesItem = "speech-update"
	AssistantOverridesServerMessagesItemStatusUpdate                  AssistantOverridesServerMessagesItem = "status-update"
	AssistantOverridesServerMessagesItemTranscript                    AssistantOverridesServerMessagesItem = "transcript"
	AssistantOverridesServerMessagesItemTranscriptTranscriptTypeFinal AssistantOverridesServerMessagesItem = "transcript[transcriptType=\\\"final\\\"]"
	AssistantOverridesServerMessagesItemToolCalls                     AssistantOverridesServerMessagesItem = "tool-calls"
	AssistantOverridesServerMessagesItemTransferDestinationRequest    AssistantOverridesServerMessagesItem = "transfer-destination-request"
	AssistantOverridesServerMessagesItemTransferUpdate                AssistantOverridesServerMessagesItem = "transfer-update"
	AssistantOverridesServerMessagesItemUserInterrupted               AssistantOverridesServerMessagesItem = "user-interrupted"
	AssistantOverridesServerMessagesItemVoiceInput                    AssistantOverridesServerMessagesItem = "voice-input"
)

func NewAssistantOverridesServerMessagesItemFromString(s string) (AssistantOverridesServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantOverridesServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return AssistantOverridesServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return AssistantOverridesServerMessagesItemFunctionCall, nil
	case "hang":
		return AssistantOverridesServerMessagesItemHang, nil
	case "language-changed":
		return AssistantOverridesServerMessagesItemLanguageChanged, nil
	case "language-change-detected":
		return AssistantOverridesServerMessagesItemLanguageChangeDetected, nil
	case "model-output":
		return AssistantOverridesServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return AssistantOverridesServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return AssistantOverridesServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantOverridesServerMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantOverridesServerMessagesItemTranscript, nil
	case "transcript[transcriptType=\"final\"]":
		return AssistantOverridesServerMessagesItemTranscriptTranscriptTypeFinal, nil
	case "tool-calls":
		return AssistantOverridesServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return AssistantOverridesServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return AssistantOverridesServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantOverridesServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantOverridesServerMessagesItemVoiceInput, nil
	}
	var t AssistantOverridesServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesServerMessagesItem) Ptr() *AssistantOverridesServerMessagesItem {
	return &a
}

// These are the options for the assistant's transcriber.
type AssistantOverridesTranscriber struct {
	AssemblyAiTranscriber   *AssemblyAiTranscriber
	AzureSpeechTranscriber  *AzureSpeechTranscriber
	CustomTranscriber       *CustomTranscriber
	DeepgramTranscriber     *DeepgramTranscriber
	ElevenLabsTranscriber   *ElevenLabsTranscriber
	GladiaTranscriber       *GladiaTranscriber
	GoogleTranscriber       *GoogleTranscriber
	SpeechmaticsTranscriber *SpeechmaticsTranscriber
	TalkscriberTranscriber  *TalkscriberTranscriber
	OpenAiTranscriber       *OpenAiTranscriber

	typ string
}

func (a *AssistantOverridesTranscriber) GetAssemblyAiTranscriber() *AssemblyAiTranscriber {
	if a == nil {
		return nil
	}
	return a.AssemblyAiTranscriber
}

func (a *AssistantOverridesTranscriber) GetAzureSpeechTranscriber() *AzureSpeechTranscriber {
	if a == nil {
		return nil
	}
	return a.AzureSpeechTranscriber
}

func (a *AssistantOverridesTranscriber) GetCustomTranscriber() *CustomTranscriber {
	if a == nil {
		return nil
	}
	return a.CustomTranscriber
}

func (a *AssistantOverridesTranscriber) GetDeepgramTranscriber() *DeepgramTranscriber {
	if a == nil {
		return nil
	}
	return a.DeepgramTranscriber
}

func (a *AssistantOverridesTranscriber) GetElevenLabsTranscriber() *ElevenLabsTranscriber {
	if a == nil {
		return nil
	}
	return a.ElevenLabsTranscriber
}

func (a *AssistantOverridesTranscriber) GetGladiaTranscriber() *GladiaTranscriber {
	if a == nil {
		return nil
	}
	return a.GladiaTranscriber
}

func (a *AssistantOverridesTranscriber) GetGoogleTranscriber() *GoogleTranscriber {
	if a == nil {
		return nil
	}
	return a.GoogleTranscriber
}

func (a *AssistantOverridesTranscriber) GetSpeechmaticsTranscriber() *SpeechmaticsTranscriber {
	if a == nil {
		return nil
	}
	return a.SpeechmaticsTranscriber
}

func (a *AssistantOverridesTranscriber) GetTalkscriberTranscriber() *TalkscriberTranscriber {
	if a == nil {
		return nil
	}
	return a.TalkscriberTranscriber
}

func (a *AssistantOverridesTranscriber) GetOpenAiTranscriber() *OpenAiTranscriber {
	if a == nil {
		return nil
	}
	return a.OpenAiTranscriber
}

func (a *AssistantOverridesTranscriber) UnmarshalJSON(data []byte) error {
	valueAssemblyAiTranscriber := new(AssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueAssemblyAiTranscriber); err == nil {
		a.typ = "AssemblyAiTranscriber"
		a.AssemblyAiTranscriber = valueAssemblyAiTranscriber
		return nil
	}
	valueAzureSpeechTranscriber := new(AzureSpeechTranscriber)
	if err := json.Unmarshal(data, &valueAzureSpeechTranscriber); err == nil {
		a.typ = "AzureSpeechTranscriber"
		a.AzureSpeechTranscriber = valueAzureSpeechTranscriber
		return nil
	}
	valueCustomTranscriber := new(CustomTranscriber)
	if err := json.Unmarshal(data, &valueCustomTranscriber); err == nil {
		a.typ = "CustomTranscriber"
		a.CustomTranscriber = valueCustomTranscriber
		return nil
	}
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		a.typ = "DeepgramTranscriber"
		a.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueElevenLabsTranscriber := new(ElevenLabsTranscriber)
	if err := json.Unmarshal(data, &valueElevenLabsTranscriber); err == nil {
		a.typ = "ElevenLabsTranscriber"
		a.ElevenLabsTranscriber = valueElevenLabsTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		a.typ = "GladiaTranscriber"
		a.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueGoogleTranscriber := new(GoogleTranscriber)
	if err := json.Unmarshal(data, &valueGoogleTranscriber); err == nil {
		a.typ = "GoogleTranscriber"
		a.GoogleTranscriber = valueGoogleTranscriber
		return nil
	}
	valueSpeechmaticsTranscriber := new(SpeechmaticsTranscriber)
	if err := json.Unmarshal(data, &valueSpeechmaticsTranscriber); err == nil {
		a.typ = "SpeechmaticsTranscriber"
		a.SpeechmaticsTranscriber = valueSpeechmaticsTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		a.typ = "TalkscriberTranscriber"
		a.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	valueOpenAiTranscriber := new(OpenAiTranscriber)
	if err := json.Unmarshal(data, &valueOpenAiTranscriber); err == nil {
		a.typ = "OpenAiTranscriber"
		a.OpenAiTranscriber = valueOpenAiTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesTranscriber) MarshalJSON() ([]byte, error) {
	if a.typ == "AssemblyAiTranscriber" || a.AssemblyAiTranscriber != nil {
		return json.Marshal(a.AssemblyAiTranscriber)
	}
	if a.typ == "AzureSpeechTranscriber" || a.AzureSpeechTranscriber != nil {
		return json.Marshal(a.AzureSpeechTranscriber)
	}
	if a.typ == "CustomTranscriber" || a.CustomTranscriber != nil {
		return json.Marshal(a.CustomTranscriber)
	}
	if a.typ == "DeepgramTranscriber" || a.DeepgramTranscriber != nil {
		return json.Marshal(a.DeepgramTranscriber)
	}
	if a.typ == "ElevenLabsTranscriber" || a.ElevenLabsTranscriber != nil {
		return json.Marshal(a.ElevenLabsTranscriber)
	}
	if a.typ == "GladiaTranscriber" || a.GladiaTranscriber != nil {
		return json.Marshal(a.GladiaTranscriber)
	}
	if a.typ == "GoogleTranscriber" || a.GoogleTranscriber != nil {
		return json.Marshal(a.GoogleTranscriber)
	}
	if a.typ == "SpeechmaticsTranscriber" || a.SpeechmaticsTranscriber != nil {
		return json.Marshal(a.SpeechmaticsTranscriber)
	}
	if a.typ == "TalkscriberTranscriber" || a.TalkscriberTranscriber != nil {
		return json.Marshal(a.TalkscriberTranscriber)
	}
	if a.typ == "OpenAiTranscriber" || a.OpenAiTranscriber != nil {
		return json.Marshal(a.OpenAiTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesTranscriberVisitor interface {
	VisitAssemblyAiTranscriber(*AssemblyAiTranscriber) error
	VisitAzureSpeechTranscriber(*AzureSpeechTranscriber) error
	VisitCustomTranscriber(*CustomTranscriber) error
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitElevenLabsTranscriber(*ElevenLabsTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitGoogleTranscriber(*GoogleTranscriber) error
	VisitSpeechmaticsTranscriber(*SpeechmaticsTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
	VisitOpenAiTranscriber(*OpenAiTranscriber) error
}

func (a *AssistantOverridesTranscriber) Accept(visitor AssistantOverridesTranscriberVisitor) error {
	if a.typ == "AssemblyAiTranscriber" || a.AssemblyAiTranscriber != nil {
		return visitor.VisitAssemblyAiTranscriber(a.AssemblyAiTranscriber)
	}
	if a.typ == "AzureSpeechTranscriber" || a.AzureSpeechTranscriber != nil {
		return visitor.VisitAzureSpeechTranscriber(a.AzureSpeechTranscriber)
	}
	if a.typ == "CustomTranscriber" || a.CustomTranscriber != nil {
		return visitor.VisitCustomTranscriber(a.CustomTranscriber)
	}
	if a.typ == "DeepgramTranscriber" || a.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(a.DeepgramTranscriber)
	}
	if a.typ == "ElevenLabsTranscriber" || a.ElevenLabsTranscriber != nil {
		return visitor.VisitElevenLabsTranscriber(a.ElevenLabsTranscriber)
	}
	if a.typ == "GladiaTranscriber" || a.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(a.GladiaTranscriber)
	}
	if a.typ == "GoogleTranscriber" || a.GoogleTranscriber != nil {
		return visitor.VisitGoogleTranscriber(a.GoogleTranscriber)
	}
	if a.typ == "SpeechmaticsTranscriber" || a.SpeechmaticsTranscriber != nil {
		return visitor.VisitSpeechmaticsTranscriber(a.SpeechmaticsTranscriber)
	}
	if a.typ == "TalkscriberTranscriber" || a.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(a.TalkscriberTranscriber)
	}
	if a.typ == "OpenAiTranscriber" || a.OpenAiTranscriber != nil {
		return visitor.VisitOpenAiTranscriber(a.OpenAiTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// These are the options for the assistant's voice.
type AssistantOverridesVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	CustomVoice     *CustomVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	HumeVoice       *HumeVoice
	LmntVoice       *LmntVoice
	NeuphonicVoice  *NeuphonicVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
	SmallestAiVoice *SmallestAiVoice
	TavusVoice      *TavusVoice
	VapiVoice       *VapiVoice
	SesameVoice     *SesameVoice

	typ string
}

func (a *AssistantOverridesVoice) GetAzureVoice() *AzureVoice {
	if a == nil {
		return nil
	}
	return a.AzureVoice
}

func (a *AssistantOverridesVoice) GetCartesiaVoice() *CartesiaVoice {
	if a == nil {
		return nil
	}
	return a.CartesiaVoice
}

func (a *AssistantOverridesVoice) GetCustomVoice() *CustomVoice {
	if a == nil {
		return nil
	}
	return a.CustomVoice
}

func (a *AssistantOverridesVoice) GetDeepgramVoice() *DeepgramVoice {
	if a == nil {
		return nil
	}
	return a.DeepgramVoice
}

func (a *AssistantOverridesVoice) GetElevenLabsVoice() *ElevenLabsVoice {
	if a == nil {
		return nil
	}
	return a.ElevenLabsVoice
}

func (a *AssistantOverridesVoice) GetHumeVoice() *HumeVoice {
	if a == nil {
		return nil
	}
	return a.HumeVoice
}

func (a *AssistantOverridesVoice) GetLmntVoice() *LmntVoice {
	if a == nil {
		return nil
	}
	return a.LmntVoice
}

func (a *AssistantOverridesVoice) GetNeuphonicVoice() *NeuphonicVoice {
	if a == nil {
		return nil
	}
	return a.NeuphonicVoice
}

func (a *AssistantOverridesVoice) GetOpenAiVoice() *OpenAiVoice {
	if a == nil {
		return nil
	}
	return a.OpenAiVoice
}

func (a *AssistantOverridesVoice) GetPlayHtVoice() *PlayHtVoice {
	if a == nil {
		return nil
	}
	return a.PlayHtVoice
}

func (a *AssistantOverridesVoice) GetRimeAiVoice() *RimeAiVoice {
	if a == nil {
		return nil
	}
	return a.RimeAiVoice
}

func (a *AssistantOverridesVoice) GetSmallestAiVoice() *SmallestAiVoice {
	if a == nil {
		return nil
	}
	return a.SmallestAiVoice
}

func (a *AssistantOverridesVoice) GetTavusVoice() *TavusVoice {
	if a == nil {
		return nil
	}
	return a.TavusVoice
}

func (a *AssistantOverridesVoice) GetVapiVoice() *VapiVoice {
	if a == nil {
		return nil
	}
	return a.VapiVoice
}

func (a *AssistantOverridesVoice) GetSesameVoice() *SesameVoice {
	if a == nil {
		return nil
	}
	return a.SesameVoice
}

func (a *AssistantOverridesVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		a.typ = "AzureVoice"
		a.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		a.typ = "CartesiaVoice"
		a.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueCustomVoice := new(CustomVoice)
	if err := json.Unmarshal(data, &valueCustomVoice); err == nil {
		a.typ = "CustomVoice"
		a.CustomVoice = valueCustomVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		a.typ = "DeepgramVoice"
		a.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		a.typ = "ElevenLabsVoice"
		a.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueHumeVoice := new(HumeVoice)
	if err := json.Unmarshal(data, &valueHumeVoice); err == nil {
		a.typ = "HumeVoice"
		a.HumeVoice = valueHumeVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		a.typ = "LmntVoice"
		a.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeuphonicVoice := new(NeuphonicVoice)
	if err := json.Unmarshal(data, &valueNeuphonicVoice); err == nil {
		a.typ = "NeuphonicVoice"
		a.NeuphonicVoice = valueNeuphonicVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		a.typ = "OpenAiVoice"
		a.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		a.typ = "PlayHtVoice"
		a.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		a.typ = "RimeAiVoice"
		a.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	valueSmallestAiVoice := new(SmallestAiVoice)
	if err := json.Unmarshal(data, &valueSmallestAiVoice); err == nil {
		a.typ = "SmallestAiVoice"
		a.SmallestAiVoice = valueSmallestAiVoice
		return nil
	}
	valueTavusVoice := new(TavusVoice)
	if err := json.Unmarshal(data, &valueTavusVoice); err == nil {
		a.typ = "TavusVoice"
		a.TavusVoice = valueTavusVoice
		return nil
	}
	valueVapiVoice := new(VapiVoice)
	if err := json.Unmarshal(data, &valueVapiVoice); err == nil {
		a.typ = "VapiVoice"
		a.VapiVoice = valueVapiVoice
		return nil
	}
	valueSesameVoice := new(SesameVoice)
	if err := json.Unmarshal(data, &valueSesameVoice); err == nil {
		a.typ = "SesameVoice"
		a.SesameVoice = valueSesameVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesVoice) MarshalJSON() ([]byte, error) {
	if a.typ == "AzureVoice" || a.AzureVoice != nil {
		return json.Marshal(a.AzureVoice)
	}
	if a.typ == "CartesiaVoice" || a.CartesiaVoice != nil {
		return json.Marshal(a.CartesiaVoice)
	}
	if a.typ == "CustomVoice" || a.CustomVoice != nil {
		return json.Marshal(a.CustomVoice)
	}
	if a.typ == "DeepgramVoice" || a.DeepgramVoice != nil {
		return json.Marshal(a.DeepgramVoice)
	}
	if a.typ == "ElevenLabsVoice" || a.ElevenLabsVoice != nil {
		return json.Marshal(a.ElevenLabsVoice)
	}
	if a.typ == "HumeVoice" || a.HumeVoice != nil {
		return json.Marshal(a.HumeVoice)
	}
	if a.typ == "LmntVoice" || a.LmntVoice != nil {
		return json.Marshal(a.LmntVoice)
	}
	if a.typ == "NeuphonicVoice" || a.NeuphonicVoice != nil {
		return json.Marshal(a.NeuphonicVoice)
	}
	if a.typ == "OpenAiVoice" || a.OpenAiVoice != nil {
		return json.Marshal(a.OpenAiVoice)
	}
	if a.typ == "PlayHtVoice" || a.PlayHtVoice != nil {
		return json.Marshal(a.PlayHtVoice)
	}
	if a.typ == "RimeAiVoice" || a.RimeAiVoice != nil {
		return json.Marshal(a.RimeAiVoice)
	}
	if a.typ == "SmallestAiVoice" || a.SmallestAiVoice != nil {
		return json.Marshal(a.SmallestAiVoice)
	}
	if a.typ == "TavusVoice" || a.TavusVoice != nil {
		return json.Marshal(a.TavusVoice)
	}
	if a.typ == "VapiVoice" || a.VapiVoice != nil {
		return json.Marshal(a.VapiVoice)
	}
	if a.typ == "SesameVoice" || a.SesameVoice != nil {
		return json.Marshal(a.SesameVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitCustomVoice(*CustomVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitHumeVoice(*HumeVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeuphonicVoice(*NeuphonicVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
	VisitSmallestAiVoice(*SmallestAiVoice) error
	VisitTavusVoice(*TavusVoice) error
	VisitVapiVoice(*VapiVoice) error
	VisitSesameVoice(*SesameVoice) error
}

func (a *AssistantOverridesVoice) Accept(visitor AssistantOverridesVoiceVisitor) error {
	if a.typ == "AzureVoice" || a.AzureVoice != nil {
		return visitor.VisitAzureVoice(a.AzureVoice)
	}
	if a.typ == "CartesiaVoice" || a.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(a.CartesiaVoice)
	}
	if a.typ == "CustomVoice" || a.CustomVoice != nil {
		return visitor.VisitCustomVoice(a.CustomVoice)
	}
	if a.typ == "DeepgramVoice" || a.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(a.DeepgramVoice)
	}
	if a.typ == "ElevenLabsVoice" || a.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(a.ElevenLabsVoice)
	}
	if a.typ == "HumeVoice" || a.HumeVoice != nil {
		return visitor.VisitHumeVoice(a.HumeVoice)
	}
	if a.typ == "LmntVoice" || a.LmntVoice != nil {
		return visitor.VisitLmntVoice(a.LmntVoice)
	}
	if a.typ == "NeuphonicVoice" || a.NeuphonicVoice != nil {
		return visitor.VisitNeuphonicVoice(a.NeuphonicVoice)
	}
	if a.typ == "OpenAiVoice" || a.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(a.OpenAiVoice)
	}
	if a.typ == "PlayHtVoice" || a.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(a.PlayHtVoice)
	}
	if a.typ == "RimeAiVoice" || a.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(a.RimeAiVoice)
	}
	if a.typ == "SmallestAiVoice" || a.SmallestAiVoice != nil {
		return visitor.VisitSmallestAiVoice(a.SmallestAiVoice)
	}
	if a.typ == "TavusVoice" || a.TavusVoice != nil {
		return visitor.VisitTavusVoice(a.TavusVoice)
	}
	if a.typ == "VapiVoice" || a.VapiVoice != nil {
		return visitor.VisitVapiVoice(a.VapiVoice)
	}
	if a.typ == "SesameVoice" || a.SesameVoice != nil {
		return visitor.VisitSesameVoice(a.SesameVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
type AssistantOverridesVoicemailDetection struct {
	GoogleVoicemailDetectionPlan *GoogleVoicemailDetectionPlan
	OpenAiVoicemailDetectionPlan *OpenAiVoicemailDetectionPlan
	TwilioVoicemailDetectionPlan *TwilioVoicemailDetectionPlan
	VapiVoicemailDetectionPlan   *VapiVoicemailDetectionPlan

	typ string
}

func (a *AssistantOverridesVoicemailDetection) GetGoogleVoicemailDetectionPlan() *GoogleVoicemailDetectionPlan {
	if a == nil {
		return nil
	}
	return a.GoogleVoicemailDetectionPlan
}

func (a *AssistantOverridesVoicemailDetection) GetOpenAiVoicemailDetectionPlan() *OpenAiVoicemailDetectionPlan {
	if a == nil {
		return nil
	}
	return a.OpenAiVoicemailDetectionPlan
}

func (a *AssistantOverridesVoicemailDetection) GetTwilioVoicemailDetectionPlan() *TwilioVoicemailDetectionPlan {
	if a == nil {
		return nil
	}
	return a.TwilioVoicemailDetectionPlan
}

func (a *AssistantOverridesVoicemailDetection) GetVapiVoicemailDetectionPlan() *VapiVoicemailDetectionPlan {
	if a == nil {
		return nil
	}
	return a.VapiVoicemailDetectionPlan
}

func (a *AssistantOverridesVoicemailDetection) UnmarshalJSON(data []byte) error {
	valueGoogleVoicemailDetectionPlan := new(GoogleVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueGoogleVoicemailDetectionPlan); err == nil {
		a.typ = "GoogleVoicemailDetectionPlan"
		a.GoogleVoicemailDetectionPlan = valueGoogleVoicemailDetectionPlan
		return nil
	}
	valueOpenAiVoicemailDetectionPlan := new(OpenAiVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueOpenAiVoicemailDetectionPlan); err == nil {
		a.typ = "OpenAiVoicemailDetectionPlan"
		a.OpenAiVoicemailDetectionPlan = valueOpenAiVoicemailDetectionPlan
		return nil
	}
	valueTwilioVoicemailDetectionPlan := new(TwilioVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueTwilioVoicemailDetectionPlan); err == nil {
		a.typ = "TwilioVoicemailDetectionPlan"
		a.TwilioVoicemailDetectionPlan = valueTwilioVoicemailDetectionPlan
		return nil
	}
	valueVapiVoicemailDetectionPlan := new(VapiVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueVapiVoicemailDetectionPlan); err == nil {
		a.typ = "VapiVoicemailDetectionPlan"
		a.VapiVoicemailDetectionPlan = valueVapiVoicemailDetectionPlan
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesVoicemailDetection) MarshalJSON() ([]byte, error) {
	if a.typ == "GoogleVoicemailDetectionPlan" || a.GoogleVoicemailDetectionPlan != nil {
		return json.Marshal(a.GoogleVoicemailDetectionPlan)
	}
	if a.typ == "OpenAiVoicemailDetectionPlan" || a.OpenAiVoicemailDetectionPlan != nil {
		return json.Marshal(a.OpenAiVoicemailDetectionPlan)
	}
	if a.typ == "TwilioVoicemailDetectionPlan" || a.TwilioVoicemailDetectionPlan != nil {
		return json.Marshal(a.TwilioVoicemailDetectionPlan)
	}
	if a.typ == "VapiVoicemailDetectionPlan" || a.VapiVoicemailDetectionPlan != nil {
		return json.Marshal(a.VapiVoicemailDetectionPlan)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesVoicemailDetectionVisitor interface {
	VisitGoogleVoicemailDetectionPlan(*GoogleVoicemailDetectionPlan) error
	VisitOpenAiVoicemailDetectionPlan(*OpenAiVoicemailDetectionPlan) error
	VisitTwilioVoicemailDetectionPlan(*TwilioVoicemailDetectionPlan) error
	VisitVapiVoicemailDetectionPlan(*VapiVoicemailDetectionPlan) error
}

func (a *AssistantOverridesVoicemailDetection) Accept(visitor AssistantOverridesVoicemailDetectionVisitor) error {
	if a.typ == "GoogleVoicemailDetectionPlan" || a.GoogleVoicemailDetectionPlan != nil {
		return visitor.VisitGoogleVoicemailDetectionPlan(a.GoogleVoicemailDetectionPlan)
	}
	if a.typ == "OpenAiVoicemailDetectionPlan" || a.OpenAiVoicemailDetectionPlan != nil {
		return visitor.VisitOpenAiVoicemailDetectionPlan(a.OpenAiVoicemailDetectionPlan)
	}
	if a.typ == "TwilioVoicemailDetectionPlan" || a.TwilioVoicemailDetectionPlan != nil {
		return visitor.VisitTwilioVoicemailDetectionPlan(a.TwilioVoicemailDetectionPlan)
	}
	if a.typ == "VapiVoicemailDetectionPlan" || a.VapiVoicemailDetectionPlan != nil {
		return visitor.VisitVapiVoicemailDetectionPlan(a.VapiVoicemailDetectionPlan)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantPaginatedResponse struct {
	Results  []*Assistant    `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantPaginatedResponse) GetResults() []*Assistant {
	if a == nil {
		return nil
	}
	return a.Results
}

func (a *AssistantPaginatedResponse) GetMetadata() *PaginationMeta {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *AssistantPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantPaginatedResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantUserEditable struct {
	ServerMessages interface{} `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantUserEditable) GetServerMessages() interface{} {
	if a == nil {
		return nil
	}
	return a.ServerMessages
}

func (a *AssistantUserEditable) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantUserEditable) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantUserEditable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantUserEditable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantUserEditable) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantVersionPaginatedResponse struct {
	Results       []interface{}   `json:"results,omitempty" url:"results,omitempty"`
	Metadata      *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`
	NextPageState *string         `json:"nextPageState,omitempty" url:"nextPageState,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantVersionPaginatedResponse) GetResults() []interface{} {
	if a == nil {
		return nil
	}
	return a.Results
}

func (a *AssistantVersionPaginatedResponse) GetMetadata() *PaginationMeta {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *AssistantVersionPaginatedResponse) GetNextPageState() *string {
	if a == nil {
		return nil
	}
	return a.NextPageState
}

func (a *AssistantVersionPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantVersionPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantVersionPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantVersionPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantVersionPaginatedResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutoReloadPlan struct {
	// This the amount of credits to reload.
	Credits float64 `json:"credits" url:"credits"`
	// This is the limit at which the reload is triggered.
	Threshold float64 `json:"threshold" url:"threshold"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AutoReloadPlan) GetCredits() float64 {
	if a == nil {
		return 0
	}
	return a.Credits
}

func (a *AutoReloadPlan) GetThreshold() float64 {
	if a == nil {
		return 0
	}
	return a.Threshold
}

func (a *AutoReloadPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutoReloadPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AutoReloadPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutoReloadPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutoReloadPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AzureBlobStorageBucketPlan struct {
	// This is the blob storage connection string for the Azure resource.
	ConnectionString string `json:"connectionString" url:"connectionString"`
	// This is the container name for the Azure blob storage.
	ContainerName string `json:"containerName" url:"containerName"`
	// This is the path where call artifacts will be stored.
	//
	// Usage:
	// - To store call artifacts in a specific folder, set this to the full path. Eg. "/folder-name1/folder-name2".
	// - To store call artifacts in the root of the bucket, leave this blank.
	//
	// @default "/"
	Path *string `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureBlobStorageBucketPlan) GetConnectionString() string {
	if a == nil {
		return ""
	}
	return a.ConnectionString
}

func (a *AzureBlobStorageBucketPlan) GetContainerName() string {
	if a == nil {
		return ""
	}
	return a.ContainerName
}

func (a *AzureBlobStorageBucketPlan) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *AzureBlobStorageBucketPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureBlobStorageBucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AzureBlobStorageBucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AzureBlobStorageBucketPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureBlobStorageBucketPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AzureCredential struct {
	// This is the service being used in Azure.
	Service AzureCredentialService `json:"service" url:"service"`
	// This is the region of the Azure resource.
	Region *AzureCredentialRegion `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.
	BucketPlan *AzureBlobStorageBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureCredential) GetService() AzureCredentialService {
	if a == nil {
		return ""
	}
	return a.Service
}

func (a *AzureCredential) GetRegion() *AzureCredentialRegion {
	if a == nil {
		return nil
	}
	return a.Region
}

func (a *AzureCredential) GetApiKey() *string {
	if a == nil {
		return nil
	}
	return a.ApiKey
}

func (a *AzureCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AzureCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AzureCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AzureCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AzureCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AzureCredential) GetBucketPlan() *AzureBlobStorageBucketPlan {
	if a == nil {
		return nil
	}
	return a.BucketPlan
}

func (a *AzureCredential) Provider() string {
	return a.provider
}

func (a *AzureCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureCredential) UnmarshalJSON(data []byte) error {
	type embed AzureCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureCredential) MarshalJSON() ([]byte, error) {
	type embed AzureCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "azure",
	}
	return json.Marshal(marshaler)
}

func (a *AzureCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the region of the Azure resource.
type AzureCredentialRegion string

const (
	AzureCredentialRegionAustralia      AzureCredentialRegion = "australia"
	AzureCredentialRegionCanadaeast     AzureCredentialRegion = "canadaeast"
	AzureCredentialRegionCanadacentral  AzureCredentialRegion = "canadacentral"
	AzureCredentialRegionEastus2        AzureCredentialRegion = "eastus2"
	AzureCredentialRegionEastus         AzureCredentialRegion = "eastus"
	AzureCredentialRegionFrance         AzureCredentialRegion = "france"
	AzureCredentialRegionIndia          AzureCredentialRegion = "india"
	AzureCredentialRegionJapaneast      AzureCredentialRegion = "japaneast"
	AzureCredentialRegionJapanwest      AzureCredentialRegion = "japanwest"
	AzureCredentialRegionUaenorth       AzureCredentialRegion = "uaenorth"
	AzureCredentialRegionNorthcentralus AzureCredentialRegion = "northcentralus"
	AzureCredentialRegionNorway         AzureCredentialRegion = "norway"
	AzureCredentialRegionSouthcentralus AzureCredentialRegion = "southcentralus"
	AzureCredentialRegionSwedencentral  AzureCredentialRegion = "swedencentral"
	AzureCredentialRegionSwitzerland    AzureCredentialRegion = "switzerland"
	AzureCredentialRegionUk             AzureCredentialRegion = "uk"
	AzureCredentialRegionWestus         AzureCredentialRegion = "westus"
	AzureCredentialRegionWestus3        AzureCredentialRegion = "westus3"
)

func NewAzureCredentialRegionFromString(s string) (AzureCredentialRegion, error) {
	switch s {
	case "australia":
		return AzureCredentialRegionAustralia, nil
	case "canadaeast":
		return AzureCredentialRegionCanadaeast, nil
	case "canadacentral":
		return AzureCredentialRegionCanadacentral, nil
	case "eastus2":
		return AzureCredentialRegionEastus2, nil
	case "eastus":
		return AzureCredentialRegionEastus, nil
	case "france":
		return AzureCredentialRegionFrance, nil
	case "india":
		return AzureCredentialRegionIndia, nil
	case "japaneast":
		return AzureCredentialRegionJapaneast, nil
	case "japanwest":
		return AzureCredentialRegionJapanwest, nil
	case "uaenorth":
		return AzureCredentialRegionUaenorth, nil
	case "northcentralus":
		return AzureCredentialRegionNorthcentralus, nil
	case "norway":
		return AzureCredentialRegionNorway, nil
	case "southcentralus":
		return AzureCredentialRegionSouthcentralus, nil
	case "swedencentral":
		return AzureCredentialRegionSwedencentral, nil
	case "switzerland":
		return AzureCredentialRegionSwitzerland, nil
	case "uk":
		return AzureCredentialRegionUk, nil
	case "westus":
		return AzureCredentialRegionWestus, nil
	case "westus3":
		return AzureCredentialRegionWestus3, nil
	}
	var t AzureCredentialRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureCredentialRegion) Ptr() *AzureCredentialRegion {
	return &a
}

// This is the service being used in Azure.
type AzureCredentialService string

const (
	AzureCredentialServiceSpeech      AzureCredentialService = "speech"
	AzureCredentialServiceBlobStorage AzureCredentialService = "blob_storage"
)

func NewAzureCredentialServiceFromString(s string) (AzureCredentialService, error) {
	switch s {
	case "speech":
		return AzureCredentialServiceSpeech, nil
	case "blob_storage":
		return AzureCredentialServiceBlobStorage, nil
	}
	var t AzureCredentialService
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureCredentialService) Ptr() *AzureCredentialService {
	return &a
}

type AzureOpenAiCredential struct {
	Region AzureOpenAiCredentialRegion       `json:"region" url:"region"`
	Models []AzureOpenAiCredentialModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey string `json:"openAIKey" url:"openAIKey"`
	// This is not returned in the API.
	OcpApimSubscriptionKey *string `json:"ocpApimSubscriptionKey,omitempty" url:"ocpApimSubscriptionKey,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name           *string `json:"name,omitempty" url:"name,omitempty"`
	OpenAiEndpoint string  `json:"openAIEndpoint" url:"openAIEndpoint"`
	provider       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureOpenAiCredential) GetRegion() AzureOpenAiCredentialRegion {
	if a == nil {
		return ""
	}
	return a.Region
}

func (a *AzureOpenAiCredential) GetModels() []AzureOpenAiCredentialModelsItem {
	if a == nil {
		return nil
	}
	return a.Models
}

func (a *AzureOpenAiCredential) GetOpenAiKey() string {
	if a == nil {
		return ""
	}
	return a.OpenAiKey
}

func (a *AzureOpenAiCredential) GetOcpApimSubscriptionKey() *string {
	if a == nil {
		return nil
	}
	return a.OcpApimSubscriptionKey
}

func (a *AzureOpenAiCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AzureOpenAiCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AzureOpenAiCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AzureOpenAiCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AzureOpenAiCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AzureOpenAiCredential) GetOpenAiEndpoint() string {
	if a == nil {
		return ""
	}
	return a.OpenAiEndpoint
}

func (a *AzureOpenAiCredential) Provider() string {
	return a.provider
}

func (a *AzureOpenAiCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureOpenAiCredential) UnmarshalJSON(data []byte) error {
	type embed AzureOpenAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureOpenAiCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "azure-openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure-openai", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureOpenAiCredential) MarshalJSON() ([]byte, error) {
	type embed AzureOpenAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "azure-openai",
	}
	return json.Marshal(marshaler)
}

func (a *AzureOpenAiCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AzureOpenAiCredentialModelsItem string

const (
	AzureOpenAiCredentialModelsItemGpt4120250414     AzureOpenAiCredentialModelsItem = "gpt-4.1-2025-04-14"
	AzureOpenAiCredentialModelsItemGpt41Mini20250414 AzureOpenAiCredentialModelsItem = "gpt-4.1-mini-2025-04-14"
	AzureOpenAiCredentialModelsItemGpt41Nano20250414 AzureOpenAiCredentialModelsItem = "gpt-4.1-nano-2025-04-14"
	AzureOpenAiCredentialModelsItemGpt4O20241120     AzureOpenAiCredentialModelsItem = "gpt-4o-2024-11-20"
	AzureOpenAiCredentialModelsItemGpt4O20240806     AzureOpenAiCredentialModelsItem = "gpt-4o-2024-08-06"
	AzureOpenAiCredentialModelsItemGpt4O20240513     AzureOpenAiCredentialModelsItem = "gpt-4o-2024-05-13"
	AzureOpenAiCredentialModelsItemGpt4OMini20240718 AzureOpenAiCredentialModelsItem = "gpt-4o-mini-2024-07-18"
	AzureOpenAiCredentialModelsItemGpt4Turbo20240409 AzureOpenAiCredentialModelsItem = "gpt-4-turbo-2024-04-09"
	AzureOpenAiCredentialModelsItemGpt40125Preview   AzureOpenAiCredentialModelsItem = "gpt-4-0125-preview"
	AzureOpenAiCredentialModelsItemGpt41106Preview   AzureOpenAiCredentialModelsItem = "gpt-4-1106-preview"
	AzureOpenAiCredentialModelsItemGpt40613          AzureOpenAiCredentialModelsItem = "gpt-4-0613"
	AzureOpenAiCredentialModelsItemGpt35Turbo0125    AzureOpenAiCredentialModelsItem = "gpt-35-turbo-0125"
	AzureOpenAiCredentialModelsItemGpt35Turbo1106    AzureOpenAiCredentialModelsItem = "gpt-35-turbo-1106"
)

func NewAzureOpenAiCredentialModelsItemFromString(s string) (AzureOpenAiCredentialModelsItem, error) {
	switch s {
	case "gpt-4.1-2025-04-14":
		return AzureOpenAiCredentialModelsItemGpt4120250414, nil
	case "gpt-4.1-mini-2025-04-14":
		return AzureOpenAiCredentialModelsItemGpt41Mini20250414, nil
	case "gpt-4.1-nano-2025-04-14":
		return AzureOpenAiCredentialModelsItemGpt41Nano20250414, nil
	case "gpt-4o-2024-11-20":
		return AzureOpenAiCredentialModelsItemGpt4O20241120, nil
	case "gpt-4o-2024-08-06":
		return AzureOpenAiCredentialModelsItemGpt4O20240806, nil
	case "gpt-4o-2024-05-13":
		return AzureOpenAiCredentialModelsItemGpt4O20240513, nil
	case "gpt-4o-mini-2024-07-18":
		return AzureOpenAiCredentialModelsItemGpt4OMini20240718, nil
	case "gpt-4-turbo-2024-04-09":
		return AzureOpenAiCredentialModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return AzureOpenAiCredentialModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return AzureOpenAiCredentialModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return AzureOpenAiCredentialModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return AzureOpenAiCredentialModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return AzureOpenAiCredentialModelsItemGpt35Turbo1106, nil
	}
	var t AzureOpenAiCredentialModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureOpenAiCredentialModelsItem) Ptr() *AzureOpenAiCredentialModelsItem {
	return &a
}

type AzureOpenAiCredentialRegion string

const (
	AzureOpenAiCredentialRegionAustralia      AzureOpenAiCredentialRegion = "australia"
	AzureOpenAiCredentialRegionCanadaeast     AzureOpenAiCredentialRegion = "canadaeast"
	AzureOpenAiCredentialRegionCanadacentral  AzureOpenAiCredentialRegion = "canadacentral"
	AzureOpenAiCredentialRegionEastus2        AzureOpenAiCredentialRegion = "eastus2"
	AzureOpenAiCredentialRegionEastus         AzureOpenAiCredentialRegion = "eastus"
	AzureOpenAiCredentialRegionFrance         AzureOpenAiCredentialRegion = "france"
	AzureOpenAiCredentialRegionIndia          AzureOpenAiCredentialRegion = "india"
	AzureOpenAiCredentialRegionJapaneast      AzureOpenAiCredentialRegion = "japaneast"
	AzureOpenAiCredentialRegionJapanwest      AzureOpenAiCredentialRegion = "japanwest"
	AzureOpenAiCredentialRegionUaenorth       AzureOpenAiCredentialRegion = "uaenorth"
	AzureOpenAiCredentialRegionNorthcentralus AzureOpenAiCredentialRegion = "northcentralus"
	AzureOpenAiCredentialRegionNorway         AzureOpenAiCredentialRegion = "norway"
	AzureOpenAiCredentialRegionSouthcentralus AzureOpenAiCredentialRegion = "southcentralus"
	AzureOpenAiCredentialRegionSwedencentral  AzureOpenAiCredentialRegion = "swedencentral"
	AzureOpenAiCredentialRegionSwitzerland    AzureOpenAiCredentialRegion = "switzerland"
	AzureOpenAiCredentialRegionUk             AzureOpenAiCredentialRegion = "uk"
	AzureOpenAiCredentialRegionWestus         AzureOpenAiCredentialRegion = "westus"
	AzureOpenAiCredentialRegionWestus3        AzureOpenAiCredentialRegion = "westus3"
)

func NewAzureOpenAiCredentialRegionFromString(s string) (AzureOpenAiCredentialRegion, error) {
	switch s {
	case "australia":
		return AzureOpenAiCredentialRegionAustralia, nil
	case "canadaeast":
		return AzureOpenAiCredentialRegionCanadaeast, nil
	case "canadacentral":
		return AzureOpenAiCredentialRegionCanadacentral, nil
	case "eastus2":
		return AzureOpenAiCredentialRegionEastus2, nil
	case "eastus":
		return AzureOpenAiCredentialRegionEastus, nil
	case "france":
		return AzureOpenAiCredentialRegionFrance, nil
	case "india":
		return AzureOpenAiCredentialRegionIndia, nil
	case "japaneast":
		return AzureOpenAiCredentialRegionJapaneast, nil
	case "japanwest":
		return AzureOpenAiCredentialRegionJapanwest, nil
	case "uaenorth":
		return AzureOpenAiCredentialRegionUaenorth, nil
	case "northcentralus":
		return AzureOpenAiCredentialRegionNorthcentralus, nil
	case "norway":
		return AzureOpenAiCredentialRegionNorway, nil
	case "southcentralus":
		return AzureOpenAiCredentialRegionSouthcentralus, nil
	case "swedencentral":
		return AzureOpenAiCredentialRegionSwedencentral, nil
	case "switzerland":
		return AzureOpenAiCredentialRegionSwitzerland, nil
	case "uk":
		return AzureOpenAiCredentialRegionUk, nil
	case "westus":
		return AzureOpenAiCredentialRegionWestus, nil
	case "westus3":
		return AzureOpenAiCredentialRegionWestus3, nil
	}
	var t AzureOpenAiCredentialRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureOpenAiCredentialRegion) Ptr() *AzureOpenAiCredentialRegion {
	return &a
}

type AzureSpeechTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt
	Language *AzureSpeechTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureSpeechTranscriber) GetLanguage() *AzureSpeechTranscriberLanguage {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *AzureSpeechTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if a == nil {
		return nil
	}
	return a.FallbackPlan
}

func (a *AzureSpeechTranscriber) Provider() string {
	return a.provider
}

func (a *AzureSpeechTranscriber) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureSpeechTranscriber) UnmarshalJSON(data []byte) error {
	type embed AzureSpeechTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureSpeechTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureSpeechTranscriber) MarshalJSON() ([]byte, error) {
	type embed AzureSpeechTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (a *AzureSpeechTranscriber) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt
type AzureSpeechTranscriberLanguage string

const (
	AzureSpeechTranscriberLanguageAfZa         AzureSpeechTranscriberLanguage = "af-ZA"
	AzureSpeechTranscriberLanguageAmEt         AzureSpeechTranscriberLanguage = "am-ET"
	AzureSpeechTranscriberLanguageArAe         AzureSpeechTranscriberLanguage = "ar-AE"
	AzureSpeechTranscriberLanguageArBh         AzureSpeechTranscriberLanguage = "ar-BH"
	AzureSpeechTranscriberLanguageArDz         AzureSpeechTranscriberLanguage = "ar-DZ"
	AzureSpeechTranscriberLanguageArEg         AzureSpeechTranscriberLanguage = "ar-EG"
	AzureSpeechTranscriberLanguageArIl         AzureSpeechTranscriberLanguage = "ar-IL"
	AzureSpeechTranscriberLanguageArIq         AzureSpeechTranscriberLanguage = "ar-IQ"
	AzureSpeechTranscriberLanguageArJo         AzureSpeechTranscriberLanguage = "ar-JO"
	AzureSpeechTranscriberLanguageArKw         AzureSpeechTranscriberLanguage = "ar-KW"
	AzureSpeechTranscriberLanguageArLb         AzureSpeechTranscriberLanguage = "ar-LB"
	AzureSpeechTranscriberLanguageArLy         AzureSpeechTranscriberLanguage = "ar-LY"
	AzureSpeechTranscriberLanguageArMa         AzureSpeechTranscriberLanguage = "ar-MA"
	AzureSpeechTranscriberLanguageArOm         AzureSpeechTranscriberLanguage = "ar-OM"
	AzureSpeechTranscriberLanguageArPs         AzureSpeechTranscriberLanguage = "ar-PS"
	AzureSpeechTranscriberLanguageArQa         AzureSpeechTranscriberLanguage = "ar-QA"
	AzureSpeechTranscriberLanguageArSa         AzureSpeechTranscriberLanguage = "ar-SA"
	AzureSpeechTranscriberLanguageArSy         AzureSpeechTranscriberLanguage = "ar-SY"
	AzureSpeechTranscriberLanguageArTn         AzureSpeechTranscriberLanguage = "ar-TN"
	AzureSpeechTranscriberLanguageArYe         AzureSpeechTranscriberLanguage = "ar-YE"
	AzureSpeechTranscriberLanguageAzAz         AzureSpeechTranscriberLanguage = "az-AZ"
	AzureSpeechTranscriberLanguageBgBg         AzureSpeechTranscriberLanguage = "bg-BG"
	AzureSpeechTranscriberLanguageBnIn         AzureSpeechTranscriberLanguage = "bn-IN"
	AzureSpeechTranscriberLanguageBsBa         AzureSpeechTranscriberLanguage = "bs-BA"
	AzureSpeechTranscriberLanguageCaEs         AzureSpeechTranscriberLanguage = "ca-ES"
	AzureSpeechTranscriberLanguageCsCz         AzureSpeechTranscriberLanguage = "cs-CZ"
	AzureSpeechTranscriberLanguageCyGb         AzureSpeechTranscriberLanguage = "cy-GB"
	AzureSpeechTranscriberLanguageDaDk         AzureSpeechTranscriberLanguage = "da-DK"
	AzureSpeechTranscriberLanguageDeAt         AzureSpeechTranscriberLanguage = "de-AT"
	AzureSpeechTranscriberLanguageDeCh         AzureSpeechTranscriberLanguage = "de-CH"
	AzureSpeechTranscriberLanguageDeDe         AzureSpeechTranscriberLanguage = "de-DE"
	AzureSpeechTranscriberLanguageElGr         AzureSpeechTranscriberLanguage = "el-GR"
	AzureSpeechTranscriberLanguageEnAu         AzureSpeechTranscriberLanguage = "en-AU"
	AzureSpeechTranscriberLanguageEnCa         AzureSpeechTranscriberLanguage = "en-CA"
	AzureSpeechTranscriberLanguageEnGb         AzureSpeechTranscriberLanguage = "en-GB"
	AzureSpeechTranscriberLanguageEnGh         AzureSpeechTranscriberLanguage = "en-GH"
	AzureSpeechTranscriberLanguageEnHk         AzureSpeechTranscriberLanguage = "en-HK"
	AzureSpeechTranscriberLanguageEnIe         AzureSpeechTranscriberLanguage = "en-IE"
	AzureSpeechTranscriberLanguageEnIn         AzureSpeechTranscriberLanguage = "en-IN"
	AzureSpeechTranscriberLanguageEnKe         AzureSpeechTranscriberLanguage = "en-KE"
	AzureSpeechTranscriberLanguageEnNg         AzureSpeechTranscriberLanguage = "en-NG"
	AzureSpeechTranscriberLanguageEnNz         AzureSpeechTranscriberLanguage = "en-NZ"
	AzureSpeechTranscriberLanguageEnPh         AzureSpeechTranscriberLanguage = "en-PH"
	AzureSpeechTranscriberLanguageEnSg         AzureSpeechTranscriberLanguage = "en-SG"
	AzureSpeechTranscriberLanguageEnTz         AzureSpeechTranscriberLanguage = "en-TZ"
	AzureSpeechTranscriberLanguageEnUs         AzureSpeechTranscriberLanguage = "en-US"
	AzureSpeechTranscriberLanguageEnZa         AzureSpeechTranscriberLanguage = "en-ZA"
	AzureSpeechTranscriberLanguageEsAr         AzureSpeechTranscriberLanguage = "es-AR"
	AzureSpeechTranscriberLanguageEsBo         AzureSpeechTranscriberLanguage = "es-BO"
	AzureSpeechTranscriberLanguageEsCl         AzureSpeechTranscriberLanguage = "es-CL"
	AzureSpeechTranscriberLanguageEsCo         AzureSpeechTranscriberLanguage = "es-CO"
	AzureSpeechTranscriberLanguageEsCr         AzureSpeechTranscriberLanguage = "es-CR"
	AzureSpeechTranscriberLanguageEsCu         AzureSpeechTranscriberLanguage = "es-CU"
	AzureSpeechTranscriberLanguageEsDo         AzureSpeechTranscriberLanguage = "es-DO"
	AzureSpeechTranscriberLanguageEsEc         AzureSpeechTranscriberLanguage = "es-EC"
	AzureSpeechTranscriberLanguageEsEs         AzureSpeechTranscriberLanguage = "es-ES"
	AzureSpeechTranscriberLanguageEsGq         AzureSpeechTranscriberLanguage = "es-GQ"
	AzureSpeechTranscriberLanguageEsGt         AzureSpeechTranscriberLanguage = "es-GT"
	AzureSpeechTranscriberLanguageEsHn         AzureSpeechTranscriberLanguage = "es-HN"
	AzureSpeechTranscriberLanguageEsMx         AzureSpeechTranscriberLanguage = "es-MX"
	AzureSpeechTranscriberLanguageEsNi         AzureSpeechTranscriberLanguage = "es-NI"
	AzureSpeechTranscriberLanguageEsPa         AzureSpeechTranscriberLanguage = "es-PA"
	AzureSpeechTranscriberLanguageEsPe         AzureSpeechTranscriberLanguage = "es-PE"
	AzureSpeechTranscriberLanguageEsPr         AzureSpeechTranscriberLanguage = "es-PR"
	AzureSpeechTranscriberLanguageEsPy         AzureSpeechTranscriberLanguage = "es-PY"
	AzureSpeechTranscriberLanguageEsSv         AzureSpeechTranscriberLanguage = "es-SV"
	AzureSpeechTranscriberLanguageEsUs         AzureSpeechTranscriberLanguage = "es-US"
	AzureSpeechTranscriberLanguageEsUy         AzureSpeechTranscriberLanguage = "es-UY"
	AzureSpeechTranscriberLanguageEsVe         AzureSpeechTranscriberLanguage = "es-VE"
	AzureSpeechTranscriberLanguageEtEe         AzureSpeechTranscriberLanguage = "et-EE"
	AzureSpeechTranscriberLanguageEuEs         AzureSpeechTranscriberLanguage = "eu-ES"
	AzureSpeechTranscriberLanguageFaIr         AzureSpeechTranscriberLanguage = "fa-IR"
	AzureSpeechTranscriberLanguageFiFi         AzureSpeechTranscriberLanguage = "fi-FI"
	AzureSpeechTranscriberLanguageFilPh        AzureSpeechTranscriberLanguage = "fil-PH"
	AzureSpeechTranscriberLanguageFrBe         AzureSpeechTranscriberLanguage = "fr-BE"
	AzureSpeechTranscriberLanguageFrCa         AzureSpeechTranscriberLanguage = "fr-CA"
	AzureSpeechTranscriberLanguageFrCh         AzureSpeechTranscriberLanguage = "fr-CH"
	AzureSpeechTranscriberLanguageFrFr         AzureSpeechTranscriberLanguage = "fr-FR"
	AzureSpeechTranscriberLanguageGaIe         AzureSpeechTranscriberLanguage = "ga-IE"
	AzureSpeechTranscriberLanguageGlEs         AzureSpeechTranscriberLanguage = "gl-ES"
	AzureSpeechTranscriberLanguageGuIn         AzureSpeechTranscriberLanguage = "gu-IN"
	AzureSpeechTranscriberLanguageHeIl         AzureSpeechTranscriberLanguage = "he-IL"
	AzureSpeechTranscriberLanguageHiIn         AzureSpeechTranscriberLanguage = "hi-IN"
	AzureSpeechTranscriberLanguageHrHr         AzureSpeechTranscriberLanguage = "hr-HR"
	AzureSpeechTranscriberLanguageHuHu         AzureSpeechTranscriberLanguage = "hu-HU"
	AzureSpeechTranscriberLanguageHyAm         AzureSpeechTranscriberLanguage = "hy-AM"
	AzureSpeechTranscriberLanguageIdId         AzureSpeechTranscriberLanguage = "id-ID"
	AzureSpeechTranscriberLanguageIsIs         AzureSpeechTranscriberLanguage = "is-IS"
	AzureSpeechTranscriberLanguageItCh         AzureSpeechTranscriberLanguage = "it-CH"
	AzureSpeechTranscriberLanguageItIt         AzureSpeechTranscriberLanguage = "it-IT"
	AzureSpeechTranscriberLanguageJaJp         AzureSpeechTranscriberLanguage = "ja-JP"
	AzureSpeechTranscriberLanguageJvId         AzureSpeechTranscriberLanguage = "jv-ID"
	AzureSpeechTranscriberLanguageKaGe         AzureSpeechTranscriberLanguage = "ka-GE"
	AzureSpeechTranscriberLanguageKkKz         AzureSpeechTranscriberLanguage = "kk-KZ"
	AzureSpeechTranscriberLanguageKmKh         AzureSpeechTranscriberLanguage = "km-KH"
	AzureSpeechTranscriberLanguageKnIn         AzureSpeechTranscriberLanguage = "kn-IN"
	AzureSpeechTranscriberLanguageKoKr         AzureSpeechTranscriberLanguage = "ko-KR"
	AzureSpeechTranscriberLanguageLoLa         AzureSpeechTranscriberLanguage = "lo-LA"
	AzureSpeechTranscriberLanguageLtLt         AzureSpeechTranscriberLanguage = "lt-LT"
	AzureSpeechTranscriberLanguageLvLv         AzureSpeechTranscriberLanguage = "lv-LV"
	AzureSpeechTranscriberLanguageMkMk         AzureSpeechTranscriberLanguage = "mk-MK"
	AzureSpeechTranscriberLanguageMlIn         AzureSpeechTranscriberLanguage = "ml-IN"
	AzureSpeechTranscriberLanguageMnMn         AzureSpeechTranscriberLanguage = "mn-MN"
	AzureSpeechTranscriberLanguageMrIn         AzureSpeechTranscriberLanguage = "mr-IN"
	AzureSpeechTranscriberLanguageMsMy         AzureSpeechTranscriberLanguage = "ms-MY"
	AzureSpeechTranscriberLanguageMtMt         AzureSpeechTranscriberLanguage = "mt-MT"
	AzureSpeechTranscriberLanguageMyMm         AzureSpeechTranscriberLanguage = "my-MM"
	AzureSpeechTranscriberLanguageNbNo         AzureSpeechTranscriberLanguage = "nb-NO"
	AzureSpeechTranscriberLanguageNeNp         AzureSpeechTranscriberLanguage = "ne-NP"
	AzureSpeechTranscriberLanguageNlBe         AzureSpeechTranscriberLanguage = "nl-BE"
	AzureSpeechTranscriberLanguageNlNl         AzureSpeechTranscriberLanguage = "nl-NL"
	AzureSpeechTranscriberLanguagePaIn         AzureSpeechTranscriberLanguage = "pa-IN"
	AzureSpeechTranscriberLanguagePlPl         AzureSpeechTranscriberLanguage = "pl-PL"
	AzureSpeechTranscriberLanguagePsAf         AzureSpeechTranscriberLanguage = "ps-AF"
	AzureSpeechTranscriberLanguagePtBr         AzureSpeechTranscriberLanguage = "pt-BR"
	AzureSpeechTranscriberLanguagePtPt         AzureSpeechTranscriberLanguage = "pt-PT"
	AzureSpeechTranscriberLanguageRoRo         AzureSpeechTranscriberLanguage = "ro-RO"
	AzureSpeechTranscriberLanguageRuRu         AzureSpeechTranscriberLanguage = "ru-RU"
	AzureSpeechTranscriberLanguageSiLk         AzureSpeechTranscriberLanguage = "si-LK"
	AzureSpeechTranscriberLanguageSkSk         AzureSpeechTranscriberLanguage = "sk-SK"
	AzureSpeechTranscriberLanguageSlSi         AzureSpeechTranscriberLanguage = "sl-SI"
	AzureSpeechTranscriberLanguageSoSo         AzureSpeechTranscriberLanguage = "so-SO"
	AzureSpeechTranscriberLanguageSqAl         AzureSpeechTranscriberLanguage = "sq-AL"
	AzureSpeechTranscriberLanguageSrRs         AzureSpeechTranscriberLanguage = "sr-RS"
	AzureSpeechTranscriberLanguageSvSe         AzureSpeechTranscriberLanguage = "sv-SE"
	AzureSpeechTranscriberLanguageSwKe         AzureSpeechTranscriberLanguage = "sw-KE"
	AzureSpeechTranscriberLanguageSwTz         AzureSpeechTranscriberLanguage = "sw-TZ"
	AzureSpeechTranscriberLanguageTaIn         AzureSpeechTranscriberLanguage = "ta-IN"
	AzureSpeechTranscriberLanguageTeIn         AzureSpeechTranscriberLanguage = "te-IN"
	AzureSpeechTranscriberLanguageThTh         AzureSpeechTranscriberLanguage = "th-TH"
	AzureSpeechTranscriberLanguageTrTr         AzureSpeechTranscriberLanguage = "tr-TR"
	AzureSpeechTranscriberLanguageUkUa         AzureSpeechTranscriberLanguage = "uk-UA"
	AzureSpeechTranscriberLanguageUrIn         AzureSpeechTranscriberLanguage = "ur-IN"
	AzureSpeechTranscriberLanguageUzUz         AzureSpeechTranscriberLanguage = "uz-UZ"
	AzureSpeechTranscriberLanguageViVn         AzureSpeechTranscriberLanguage = "vi-VN"
	AzureSpeechTranscriberLanguageWuuCn        AzureSpeechTranscriberLanguage = "wuu-CN"
	AzureSpeechTranscriberLanguageYueCn        AzureSpeechTranscriberLanguage = "yue-CN"
	AzureSpeechTranscriberLanguageZhCn         AzureSpeechTranscriberLanguage = "zh-CN"
	AzureSpeechTranscriberLanguageZhCnShandong AzureSpeechTranscriberLanguage = "zh-CN-shandong"
	AzureSpeechTranscriberLanguageZhCnSichuan  AzureSpeechTranscriberLanguage = "zh-CN-sichuan"
	AzureSpeechTranscriberLanguageZhHk         AzureSpeechTranscriberLanguage = "zh-HK"
	AzureSpeechTranscriberLanguageZhTw         AzureSpeechTranscriberLanguage = "zh-TW"
	AzureSpeechTranscriberLanguageZuZa         AzureSpeechTranscriberLanguage = "zu-ZA"
)

func NewAzureSpeechTranscriberLanguageFromString(s string) (AzureSpeechTranscriberLanguage, error) {
	switch s {
	case "af-ZA":
		return AzureSpeechTranscriberLanguageAfZa, nil
	case "am-ET":
		return AzureSpeechTranscriberLanguageAmEt, nil
	case "ar-AE":
		return AzureSpeechTranscriberLanguageArAe, nil
	case "ar-BH":
		return AzureSpeechTranscriberLanguageArBh, nil
	case "ar-DZ":
		return AzureSpeechTranscriberLanguageArDz, nil
	case "ar-EG":
		return AzureSpeechTranscriberLanguageArEg, nil
	case "ar-IL":
		return AzureSpeechTranscriberLanguageArIl, nil
	case "ar-IQ":
		return AzureSpeechTranscriberLanguageArIq, nil
	case "ar-JO":
		return AzureSpeechTranscriberLanguageArJo, nil
	case "ar-KW":
		return AzureSpeechTranscriberLanguageArKw, nil
	case "ar-LB":
		return AzureSpeechTranscriberLanguageArLb, nil
	case "ar-LY":
		return AzureSpeechTranscriberLanguageArLy, nil
	case "ar-MA":
		return AzureSpeechTranscriberLanguageArMa, nil
	case "ar-OM":
		return AzureSpeechTranscriberLanguageArOm, nil
	case "ar-PS":
		return AzureSpeechTranscriberLanguageArPs, nil
	case "ar-QA":
		return AzureSpeechTranscriberLanguageArQa, nil
	case "ar-SA":
		return AzureSpeechTranscriberLanguageArSa, nil
	case "ar-SY":
		return AzureSpeechTranscriberLanguageArSy, nil
	case "ar-TN":
		return AzureSpeechTranscriberLanguageArTn, nil
	case "ar-YE":
		return AzureSpeechTranscriberLanguageArYe, nil
	case "az-AZ":
		return AzureSpeechTranscriberLanguageAzAz, nil
	case "bg-BG":
		return AzureSpeechTranscriberLanguageBgBg, nil
	case "bn-IN":
		return AzureSpeechTranscriberLanguageBnIn, nil
	case "bs-BA":
		return AzureSpeechTranscriberLanguageBsBa, nil
	case "ca-ES":
		return AzureSpeechTranscriberLanguageCaEs, nil
	case "cs-CZ":
		return AzureSpeechTranscriberLanguageCsCz, nil
	case "cy-GB":
		return AzureSpeechTranscriberLanguageCyGb, nil
	case "da-DK":
		return AzureSpeechTranscriberLanguageDaDk, nil
	case "de-AT":
		return AzureSpeechTranscriberLanguageDeAt, nil
	case "de-CH":
		return AzureSpeechTranscriberLanguageDeCh, nil
	case "de-DE":
		return AzureSpeechTranscriberLanguageDeDe, nil
	case "el-GR":
		return AzureSpeechTranscriberLanguageElGr, nil
	case "en-AU":
		return AzureSpeechTranscriberLanguageEnAu, nil
	case "en-CA":
		return AzureSpeechTranscriberLanguageEnCa, nil
	case "en-GB":
		return AzureSpeechTranscriberLanguageEnGb, nil
	case "en-GH":
		return AzureSpeechTranscriberLanguageEnGh, nil
	case "en-HK":
		return AzureSpeechTranscriberLanguageEnHk, nil
	case "en-IE":
		return AzureSpeechTranscriberLanguageEnIe, nil
	case "en-IN":
		return AzureSpeechTranscriberLanguageEnIn, nil
	case "en-KE":
		return AzureSpeechTranscriberLanguageEnKe, nil
	case "en-NG":
		return AzureSpeechTranscriberLanguageEnNg, nil
	case "en-NZ":
		return AzureSpeechTranscriberLanguageEnNz, nil
	case "en-PH":
		return AzureSpeechTranscriberLanguageEnPh, nil
	case "en-SG":
		return AzureSpeechTranscriberLanguageEnSg, nil
	case "en-TZ":
		return AzureSpeechTranscriberLanguageEnTz, nil
	case "en-US":
		return AzureSpeechTranscriberLanguageEnUs, nil
	case "en-ZA":
		return AzureSpeechTranscriberLanguageEnZa, nil
	case "es-AR":
		return AzureSpeechTranscriberLanguageEsAr, nil
	case "es-BO":
		return AzureSpeechTranscriberLanguageEsBo, nil
	case "es-CL":
		return AzureSpeechTranscriberLanguageEsCl, nil
	case "es-CO":
		return AzureSpeechTranscriberLanguageEsCo, nil
	case "es-CR":
		return AzureSpeechTranscriberLanguageEsCr, nil
	case "es-CU":
		return AzureSpeechTranscriberLanguageEsCu, nil
	case "es-DO":
		return AzureSpeechTranscriberLanguageEsDo, nil
	case "es-EC":
		return AzureSpeechTranscriberLanguageEsEc, nil
	case "es-ES":
		return AzureSpeechTranscriberLanguageEsEs, nil
	case "es-GQ":
		return AzureSpeechTranscriberLanguageEsGq, nil
	case "es-GT":
		return AzureSpeechTranscriberLanguageEsGt, nil
	case "es-HN":
		return AzureSpeechTranscriberLanguageEsHn, nil
	case "es-MX":
		return AzureSpeechTranscriberLanguageEsMx, nil
	case "es-NI":
		return AzureSpeechTranscriberLanguageEsNi, nil
	case "es-PA":
		return AzureSpeechTranscriberLanguageEsPa, nil
	case "es-PE":
		return AzureSpeechTranscriberLanguageEsPe, nil
	case "es-PR":
		return AzureSpeechTranscriberLanguageEsPr, nil
	case "es-PY":
		return AzureSpeechTranscriberLanguageEsPy, nil
	case "es-SV":
		return AzureSpeechTranscriberLanguageEsSv, nil
	case "es-US":
		return AzureSpeechTranscriberLanguageEsUs, nil
	case "es-UY":
		return AzureSpeechTranscriberLanguageEsUy, nil
	case "es-VE":
		return AzureSpeechTranscriberLanguageEsVe, nil
	case "et-EE":
		return AzureSpeechTranscriberLanguageEtEe, nil
	case "eu-ES":
		return AzureSpeechTranscriberLanguageEuEs, nil
	case "fa-IR":
		return AzureSpeechTranscriberLanguageFaIr, nil
	case "fi-FI":
		return AzureSpeechTranscriberLanguageFiFi, nil
	case "fil-PH":
		return AzureSpeechTranscriberLanguageFilPh, nil
	case "fr-BE":
		return AzureSpeechTranscriberLanguageFrBe, nil
	case "fr-CA":
		return AzureSpeechTranscriberLanguageFrCa, nil
	case "fr-CH":
		return AzureSpeechTranscriberLanguageFrCh, nil
	case "fr-FR":
		return AzureSpeechTranscriberLanguageFrFr, nil
	case "ga-IE":
		return AzureSpeechTranscriberLanguageGaIe, nil
	case "gl-ES":
		return AzureSpeechTranscriberLanguageGlEs, nil
	case "gu-IN":
		return AzureSpeechTranscriberLanguageGuIn, nil
	case "he-IL":
		return AzureSpeechTranscriberLanguageHeIl, nil
	case "hi-IN":
		return AzureSpeechTranscriberLanguageHiIn, nil
	case "hr-HR":
		return AzureSpeechTranscriberLanguageHrHr, nil
	case "hu-HU":
		return AzureSpeechTranscriberLanguageHuHu, nil
	case "hy-AM":
		return AzureSpeechTranscriberLanguageHyAm, nil
	case "id-ID":
		return AzureSpeechTranscriberLanguageIdId, nil
	case "is-IS":
		return AzureSpeechTranscriberLanguageIsIs, nil
	case "it-CH":
		return AzureSpeechTranscriberLanguageItCh, nil
	case "it-IT":
		return AzureSpeechTranscriberLanguageItIt, nil
	case "ja-JP":
		return AzureSpeechTranscriberLanguageJaJp, nil
	case "jv-ID":
		return AzureSpeechTranscriberLanguageJvId, nil
	case "ka-GE":
		return AzureSpeechTranscriberLanguageKaGe, nil
	case "kk-KZ":
		return AzureSpeechTranscriberLanguageKkKz, nil
	case "km-KH":
		return AzureSpeechTranscriberLanguageKmKh, nil
	case "kn-IN":
		return AzureSpeechTranscriberLanguageKnIn, nil
	case "ko-KR":
		return AzureSpeechTranscriberLanguageKoKr, nil
	case "lo-LA":
		return AzureSpeechTranscriberLanguageLoLa, nil
	case "lt-LT":
		return AzureSpeechTranscriberLanguageLtLt, nil
	case "lv-LV":
		return AzureSpeechTranscriberLanguageLvLv, nil
	case "mk-MK":
		return AzureSpeechTranscriberLanguageMkMk, nil
	case "ml-IN":
		return AzureSpeechTranscriberLanguageMlIn, nil
	case "mn-MN":
		return AzureSpeechTranscriberLanguageMnMn, nil
	case "mr-IN":
		return AzureSpeechTranscriberLanguageMrIn, nil
	case "ms-MY":
		return AzureSpeechTranscriberLanguageMsMy, nil
	case "mt-MT":
		return AzureSpeechTranscriberLanguageMtMt, nil
	case "my-MM":
		return AzureSpeechTranscriberLanguageMyMm, nil
	case "nb-NO":
		return AzureSpeechTranscriberLanguageNbNo, nil
	case "ne-NP":
		return AzureSpeechTranscriberLanguageNeNp, nil
	case "nl-BE":
		return AzureSpeechTranscriberLanguageNlBe, nil
	case "nl-NL":
		return AzureSpeechTranscriberLanguageNlNl, nil
	case "pa-IN":
		return AzureSpeechTranscriberLanguagePaIn, nil
	case "pl-PL":
		return AzureSpeechTranscriberLanguagePlPl, nil
	case "ps-AF":
		return AzureSpeechTranscriberLanguagePsAf, nil
	case "pt-BR":
		return AzureSpeechTranscriberLanguagePtBr, nil
	case "pt-PT":
		return AzureSpeechTranscriberLanguagePtPt, nil
	case "ro-RO":
		return AzureSpeechTranscriberLanguageRoRo, nil
	case "ru-RU":
		return AzureSpeechTranscriberLanguageRuRu, nil
	case "si-LK":
		return AzureSpeechTranscriberLanguageSiLk, nil
	case "sk-SK":
		return AzureSpeechTranscriberLanguageSkSk, nil
	case "sl-SI":
		return AzureSpeechTranscriberLanguageSlSi, nil
	case "so-SO":
		return AzureSpeechTranscriberLanguageSoSo, nil
	case "sq-AL":
		return AzureSpeechTranscriberLanguageSqAl, nil
	case "sr-RS":
		return AzureSpeechTranscriberLanguageSrRs, nil
	case "sv-SE":
		return AzureSpeechTranscriberLanguageSvSe, nil
	case "sw-KE":
		return AzureSpeechTranscriberLanguageSwKe, nil
	case "sw-TZ":
		return AzureSpeechTranscriberLanguageSwTz, nil
	case "ta-IN":
		return AzureSpeechTranscriberLanguageTaIn, nil
	case "te-IN":
		return AzureSpeechTranscriberLanguageTeIn, nil
	case "th-TH":
		return AzureSpeechTranscriberLanguageThTh, nil
	case "tr-TR":
		return AzureSpeechTranscriberLanguageTrTr, nil
	case "uk-UA":
		return AzureSpeechTranscriberLanguageUkUa, nil
	case "ur-IN":
		return AzureSpeechTranscriberLanguageUrIn, nil
	case "uz-UZ":
		return AzureSpeechTranscriberLanguageUzUz, nil
	case "vi-VN":
		return AzureSpeechTranscriberLanguageViVn, nil
	case "wuu-CN":
		return AzureSpeechTranscriberLanguageWuuCn, nil
	case "yue-CN":
		return AzureSpeechTranscriberLanguageYueCn, nil
	case "zh-CN":
		return AzureSpeechTranscriberLanguageZhCn, nil
	case "zh-CN-shandong":
		return AzureSpeechTranscriberLanguageZhCnShandong, nil
	case "zh-CN-sichuan":
		return AzureSpeechTranscriberLanguageZhCnSichuan, nil
	case "zh-HK":
		return AzureSpeechTranscriberLanguageZhHk, nil
	case "zh-TW":
		return AzureSpeechTranscriberLanguageZhTw, nil
	case "zu-ZA":
		return AzureSpeechTranscriberLanguageZuZa, nil
	}
	var t AzureSpeechTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureSpeechTranscriberLanguage) Ptr() *AzureSpeechTranscriberLanguage {
	return &a
}

type AzureVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *AzureVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureVoice) GetCachingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.CachingEnabled
}

func (a *AzureVoice) GetVoiceId() *AzureVoiceId {
	if a == nil {
		return nil
	}
	return a.VoiceId
}

func (a *AzureVoice) GetChunkPlan() *ChunkPlan {
	if a == nil {
		return nil
	}
	return a.ChunkPlan
}

func (a *AzureVoice) GetSpeed() *float64 {
	if a == nil {
		return nil
	}
	return a.Speed
}

func (a *AzureVoice) GetFallbackPlan() *FallbackPlan {
	if a == nil {
		return nil
	}
	return a.FallbackPlan
}

func (a *AzureVoice) Provider() string {
	return a.provider
}

func (a *AzureVoice) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureVoice) UnmarshalJSON(data []byte) error {
	type embed AzureVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureVoice(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureVoice) MarshalJSON() ([]byte, error) {
	type embed AzureVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (a *AzureVoice) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the provider-specific ID that will be used.
type AzureVoiceId struct {
	AzureVoiceIdEnum AzureVoiceIdEnum
	String           string

	typ string
}

func (a *AzureVoiceId) GetAzureVoiceIdEnum() AzureVoiceIdEnum {
	if a == nil {
		return ""
	}
	return a.AzureVoiceIdEnum
}

func (a *AzureVoiceId) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AzureVoiceId) UnmarshalJSON(data []byte) error {
	var valueAzureVoiceIdEnum AzureVoiceIdEnum
	if err := json.Unmarshal(data, &valueAzureVoiceIdEnum); err == nil {
		a.typ = "AzureVoiceIdEnum"
		a.AzureVoiceIdEnum = valueAzureVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AzureVoiceId) MarshalJSON() ([]byte, error) {
	if a.typ == "AzureVoiceIdEnum" || a.AzureVoiceIdEnum != "" {
		return json.Marshal(a.AzureVoiceIdEnum)
	}
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AzureVoiceIdVisitor interface {
	VisitAzureVoiceIdEnum(AzureVoiceIdEnum) error
	VisitString(string) error
}

func (a *AzureVoiceId) Accept(visitor AzureVoiceIdVisitor) error {
	if a.typ == "AzureVoiceIdEnum" || a.AzureVoiceIdEnum != "" {
		return visitor.VisitAzureVoiceIdEnum(a.AzureVoiceIdEnum)
	}
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AzureVoiceIdEnum string

const (
	AzureVoiceIdEnumAndrew AzureVoiceIdEnum = "andrew"
	AzureVoiceIdEnumBrian  AzureVoiceIdEnum = "brian"
	AzureVoiceIdEnumEmma   AzureVoiceIdEnum = "emma"
)

func NewAzureVoiceIdEnumFromString(s string) (AzureVoiceIdEnum, error) {
	switch s {
	case "andrew":
		return AzureVoiceIdEnumAndrew, nil
	case "brian":
		return AzureVoiceIdEnumBrian, nil
	case "emma":
		return AzureVoiceIdEnumEmma, nil
	}
	var t AzureVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureVoiceIdEnum) Ptr() *AzureVoiceIdEnum {
	return &a
}

type BackoffPlan struct {
	// This is the type of backoff plan to use. Defaults to fixed.
	//
	// @default fixed
	Type map[string]interface{} `json:"type,omitempty" url:"type,omitempty"`
	// This is the maximum number of retries to attempt if the request fails. Defaults to 0 (no retries).
	//
	// @default 0
	MaxRetries float64 `json:"maxRetries" url:"maxRetries"`
	// This is the base delay in seconds. For linear backoff, this is the delay between each retry. For exponential backoff, this is the initial delay.
	BaseDelaySeconds float64 `json:"baseDelaySeconds" url:"baseDelaySeconds"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BackoffPlan) GetType() map[string]interface{} {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BackoffPlan) GetMaxRetries() float64 {
	if b == nil {
		return 0
	}
	return b.MaxRetries
}

func (b *BackoffPlan) GetBaseDelaySeconds() float64 {
	if b == nil {
		return 0
	}
	return b.BaseDelaySeconds
}

func (b *BackoffPlan) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BackoffPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler BackoffPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BackoffPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BackoffPlan) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BashToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*BashToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "bash" for Bash tool.
	// The sub type of tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// The name of the tool, fixed to 'bash'
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server  *Server `json:"server,omitempty" url:"server,omitempty"`
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BashToolWithToolCall) GetAsync() *bool {
	if b == nil {
		return nil
	}
	return b.Async
}

func (b *BashToolWithToolCall) GetMessages() []*BashToolWithToolCallMessagesItem {
	if b == nil {
		return nil
	}
	return b.Messages
}

func (b *BashToolWithToolCall) GetToolCall() *ToolCall {
	if b == nil {
		return nil
	}
	return b.ToolCall
}

func (b *BashToolWithToolCall) GetFunction() *OpenAiFunction {
	if b == nil {
		return nil
	}
	return b.Function
}

func (b *BashToolWithToolCall) GetServer() *Server {
	if b == nil {
		return nil
	}
	return b.Server
}

func (b *BashToolWithToolCall) Type() string {
	return b.type_
}

func (b *BashToolWithToolCall) SubType() string {
	return b.subType
}

func (b *BashToolWithToolCall) Name() string {
	return b.name
}

func (b *BashToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BashToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed BashToolWithToolCall
	var unmarshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BashToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "bash" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bash", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	if unmarshaler.SubType != "bash_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bash_20241022", unmarshaler.SubType)
	}
	b.subType = unmarshaler.SubType
	if unmarshaler.Name != "bash" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bash", unmarshaler.Name)
	}
	b.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type", "subType", "name")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BashToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed BashToolWithToolCall
	var marshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed:   embed(*b),
		Type:    "bash",
		SubType: "bash_20241022",
		Name:    "bash",
	}
	return json.Marshal(marshaler)
}

func (b *BashToolWithToolCall) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BashToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (b *BashToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if b == nil {
		return nil
	}
	return b.ToolMessageStart
}

func (b *BashToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if b == nil {
		return nil
	}
	return b.ToolMessageComplete
}

func (b *BashToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if b == nil {
		return nil
	}
	return b.ToolMessageFailed
}

func (b *BashToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if b == nil {
		return nil
	}
	return b.ToolMessageDelayed
}

func (b *BashToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		b.typ = "ToolMessageStart"
		b.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		b.typ = "ToolMessageComplete"
		b.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		b.typ = "ToolMessageFailed"
		b.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		b.typ = "ToolMessageDelayed"
		b.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BashToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if b.typ == "ToolMessageStart" || b.ToolMessageStart != nil {
		return json.Marshal(b.ToolMessageStart)
	}
	if b.typ == "ToolMessageComplete" || b.ToolMessageComplete != nil {
		return json.Marshal(b.ToolMessageComplete)
	}
	if b.typ == "ToolMessageFailed" || b.ToolMessageFailed != nil {
		return json.Marshal(b.ToolMessageFailed)
	}
	if b.typ == "ToolMessageDelayed" || b.ToolMessageDelayed != nil {
		return json.Marshal(b.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BashToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (b *BashToolWithToolCallMessagesItem) Accept(visitor BashToolWithToolCallMessagesItemVisitor) error {
	if b.typ == "ToolMessageStart" || b.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(b.ToolMessageStart)
	}
	if b.typ == "ToolMessageComplete" || b.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(b.ToolMessageComplete)
	}
	if b.typ == "ToolMessageFailed" || b.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(b.ToolMessageFailed)
	}
	if b.typ == "ToolMessageDelayed" || b.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(b.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BotMessage struct {
	// The role of the bot in the conversation.
	Role string `json:"role" url:"role"`
	// The message content from the bot.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The timestamp when the message ended.
	EndTime float64 `json:"endTime" url:"endTime"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`
	// The source of the message.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// The duration of the message in seconds.
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotMessage) GetRole() string {
	if b == nil {
		return ""
	}
	return b.Role
}

func (b *BotMessage) GetMessage() string {
	if b == nil {
		return ""
	}
	return b.Message
}

func (b *BotMessage) GetTime() float64 {
	if b == nil {
		return 0
	}
	return b.Time
}

func (b *BotMessage) GetEndTime() float64 {
	if b == nil {
		return 0
	}
	return b.EndTime
}

func (b *BotMessage) GetSecondsFromStart() float64 {
	if b == nil {
		return 0
	}
	return b.SecondsFromStart
}

func (b *BotMessage) GetSource() *string {
	if b == nil {
		return nil
	}
	return b.Source
}

func (b *BotMessage) GetDuration() *float64 {
	if b == nil {
		return nil
	}
	return b.Duration
}

func (b *BotMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler BotMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotMessage) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BothCustomEndpointingRule struct {
	// This endpointing rule is based on both the last assistant message and the current customer message as they are speaking.
	//
	// Flow:
	// - Assistant speaks
	// - Customer starts speaking
	// - Customer transcription comes in
	// - This rule is evaluated on the last assistant message and the current customer transcription
	// - If assistant message matches `assistantRegex` AND customer message matches `customerRegex`, the endpointing timeout is set to `timeoutSeconds`
	//
	// Usage:
	// - If you want to wait longer while customer is speaking numbers, you can set a longer timeout.
	// This is the regex pattern to match the assistant's message.
	//
	// Note:
	// - This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test("hello there")` will return `true`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	// - `RegExp.test` does substring matching, so `/cat/.test("I love cats")` will return `true`. To do full string matching, send "^cat$".
	AssistantRegex string `json:"assistantRegex" url:"assistantRegex"`
	// These are the options for the assistant's message regex match. Defaults to all disabled.
	//
	// @default []
	AssistantRegexOptions []*RegexOption `json:"assistantRegexOptions,omitempty" url:"assistantRegexOptions,omitempty"`
	CustomerRegex         string         `json:"customerRegex" url:"customerRegex"`
	// These are the options for the customer's message regex match. Defaults to all disabled.
	//
	// @default []
	CustomerRegexOptions []*RegexOption `json:"customerRegexOptions,omitempty" url:"customerRegexOptions,omitempty"`
	// This is the endpointing timeout in seconds, if the rule is matched.
	TimeoutSeconds float64 `json:"timeoutSeconds" url:"timeoutSeconds"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BothCustomEndpointingRule) GetAssistantRegex() string {
	if b == nil {
		return ""
	}
	return b.AssistantRegex
}

func (b *BothCustomEndpointingRule) GetAssistantRegexOptions() []*RegexOption {
	if b == nil {
		return nil
	}
	return b.AssistantRegexOptions
}

func (b *BothCustomEndpointingRule) GetCustomerRegex() string {
	if b == nil {
		return ""
	}
	return b.CustomerRegex
}

func (b *BothCustomEndpointingRule) GetCustomerRegexOptions() []*RegexOption {
	if b == nil {
		return nil
	}
	return b.CustomerRegexOptions
}

func (b *BothCustomEndpointingRule) GetTimeoutSeconds() float64 {
	if b == nil {
		return 0
	}
	return b.TimeoutSeconds
}

func (b *BothCustomEndpointingRule) Type() string {
	return b.type_
}

func (b *BothCustomEndpointingRule) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BothCustomEndpointingRule) UnmarshalJSON(data []byte) error {
	type embed BothCustomEndpointingRule
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BothCustomEndpointingRule(unmarshaler.embed)
	if unmarshaler.Type != "both" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "both", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BothCustomEndpointingRule) MarshalJSON() ([]byte, error) {
	type embed BothCustomEndpointingRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "both",
	}
	return json.Marshal(marshaler)
}

func (b *BothCustomEndpointingRule) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BucketPlan struct {
	// This is the name of the bucket.
	Name string `json:"name" url:"name"`
	// This is the region of the bucket.
	//
	// Usage:
	// - If `credential.type` is `aws`, then this is required.
	// - If `credential.type` is `gcp`, then this is optional since GCP allows buckets to be accessed without a region but region is required for data residency requirements. Read here: https://cloud.google.com/storage/docs/request-endpoints
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// This is the path where call artifacts will be stored.
	//
	// Usage:
	// - To store call artifacts in a specific folder, set this to the full path. Eg. "/folder-name1/folder-name2".
	// - To store call artifacts in the root of the bucket, leave this blank.
	//
	// @default "/"
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// This is the HMAC access key offered by GCP for interoperability with S3 clients. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console
	//
	// Usage:
	// - If `credential.type` is `gcp`, then this is required.
	// - If `credential.type` is `aws`, then this is not required since credential.awsAccessKeyId is used instead.
	HmacAccessKey *string `json:"hmacAccessKey,omitempty" url:"hmacAccessKey,omitempty"`
	// This is the secret for the HMAC access key. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console
	//
	// Usage:
	// - If `credential.type` is `gcp`, then this is required.
	// - If `credential.type` is `aws`, then this is not required since credential.awsSecretAccessKey is used instead.
	//
	// Note: This is not returned in the API.
	HmacSecret *string `json:"hmacSecret,omitempty" url:"hmacSecret,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BucketPlan) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BucketPlan) GetRegion() *string {
	if b == nil {
		return nil
	}
	return b.Region
}

func (b *BucketPlan) GetPath() *string {
	if b == nil {
		return nil
	}
	return b.Path
}

func (b *BucketPlan) GetHmacAccessKey() *string {
	if b == nil {
		return nil
	}
	return b.HmacAccessKey
}

func (b *BucketPlan) GetHmacSecret() *string {
	if b == nil {
		return nil
	}
	return b.HmacSecret
}

func (b *BucketPlan) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler BucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BucketPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BucketPlan) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ByoSipTrunkCredential struct {
	// This can be used to bring your own SIP trunks or to connect to a Carrier.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This can be used to configure the tech prefix on outbound calls. This is an advanced property.
	TechPrefix *string `json:"techPrefix,omitempty" url:"techPrefix,omitempty"`
	// This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.
	SipDiversionHeader *string `json:"sipDiversionHeader,omitempty" url:"sipDiversionHeader,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *ByoSipTrunkCredential) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *ByoSipTrunkCredential) GetOrgId() string {
	if b == nil {
		return ""
	}
	return b.OrgId
}

func (b *ByoSipTrunkCredential) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *ByoSipTrunkCredential) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *ByoSipTrunkCredential) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *ByoSipTrunkCredential) GetGateways() []*SipTrunkGateway {
	if b == nil {
		return nil
	}
	return b.Gateways
}

func (b *ByoSipTrunkCredential) GetOutboundAuthenticationPlan() *SipTrunkOutboundAuthenticationPlan {
	if b == nil {
		return nil
	}
	return b.OutboundAuthenticationPlan
}

func (b *ByoSipTrunkCredential) GetOutboundLeadingPlusEnabled() *bool {
	if b == nil {
		return nil
	}
	return b.OutboundLeadingPlusEnabled
}

func (b *ByoSipTrunkCredential) GetTechPrefix() *string {
	if b == nil {
		return nil
	}
	return b.TechPrefix
}

func (b *ByoSipTrunkCredential) GetSipDiversionHeader() *string {
	if b == nil {
		return nil
	}
	return b.SipDiversionHeader
}

func (b *ByoSipTrunkCredential) GetSbcConfiguration() *SbcConfiguration {
	if b == nil {
		return nil
	}
	return b.SbcConfiguration
}

func (b *ByoSipTrunkCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *ByoSipTrunkCredential) UnmarshalJSON(data []byte) error {
	type embed ByoSipTrunkCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = ByoSipTrunkCredential(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *ByoSipTrunkCredential) MarshalJSON() ([]byte, error) {
	type embed ByoSipTrunkCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *ByoSipTrunkCredential) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CallLogPrivileged struct {
	// This is the unique identifier for the call.
	CallId string `json:"callId" url:"callId"`
	// This is the unique identifier for the org that this call log belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the log message associated with the call.
	Log string `json:"log" url:"log"`
	// This is the level of the log message.
	Level CallLogPrivilegedLevel `json:"level" url:"level"`
	// This is the ISO 8601 date-time string of when the log was created.
	Time time.Time `json:"time" url:"time"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CallLogPrivileged) GetCallId() string {
	if c == nil {
		return ""
	}
	return c.CallId
}

func (c *CallLogPrivileged) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CallLogPrivileged) GetLog() string {
	if c == nil {
		return ""
	}
	return c.Log
}

func (c *CallLogPrivileged) GetLevel() CallLogPrivilegedLevel {
	if c == nil {
		return ""
	}
	return c.Level
}

func (c *CallLogPrivileged) GetTime() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Time
}

func (c *CallLogPrivileged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallLogPrivileged) UnmarshalJSON(data []byte) error {
	type embed CallLogPrivileged
	var unmarshaler = struct {
		embed
		Time *internal.DateTime `json:"time"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CallLogPrivileged(unmarshaler.embed)
	c.Time = unmarshaler.Time.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallLogPrivileged) MarshalJSON() ([]byte, error) {
	type embed CallLogPrivileged
	var marshaler = struct {
		embed
		Time *internal.DateTime `json:"time"`
	}{
		embed: embed(*c),
		Time:  internal.NewDateTime(c.Time),
	}
	return json.Marshal(marshaler)
}

func (c *CallLogPrivileged) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the level of the log message.
type CallLogPrivilegedLevel string

const (
	CallLogPrivilegedLevelInfo       CallLogPrivilegedLevel = "INFO"
	CallLogPrivilegedLevelLog        CallLogPrivilegedLevel = "LOG"
	CallLogPrivilegedLevelWarn       CallLogPrivilegedLevel = "WARN"
	CallLogPrivilegedLevelError      CallLogPrivilegedLevel = "ERROR"
	CallLogPrivilegedLevelCheckpoint CallLogPrivilegedLevel = "CHECKPOINT"
)

func NewCallLogPrivilegedLevelFromString(s string) (CallLogPrivilegedLevel, error) {
	switch s {
	case "INFO":
		return CallLogPrivilegedLevelInfo, nil
	case "LOG":
		return CallLogPrivilegedLevelLog, nil
	case "WARN":
		return CallLogPrivilegedLevelWarn, nil
	case "ERROR":
		return CallLogPrivilegedLevelError, nil
	case "CHECKPOINT":
		return CallLogPrivilegedLevelCheckpoint, nil
	}
	var t CallLogPrivilegedLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CallLogPrivilegedLevel) Ptr() *CallLogPrivilegedLevel {
	return &c
}

type CallLogsPaginatedResponse struct {
	Results  []*CallLogPrivileged `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta      `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CallLogsPaginatedResponse) GetResults() []*CallLogPrivileged {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *CallLogsPaginatedResponse) GetMetadata() *PaginationMeta {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CallLogsPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallLogsPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CallLogsPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CallLogsPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallLogsPaginatedResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CallPaginatedResponse struct {
	Results  []*Call         `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CallPaginatedResponse) GetResults() []*Call {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *CallPaginatedResponse) GetMetadata() *PaginationMeta {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CallPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CallPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CallPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallPaginatedResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CartesiaCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CartesiaCredential) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CartesiaCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CartesiaCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CartesiaCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CartesiaCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CartesiaCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CartesiaCredential) Provider() string {
	return c.provider
}

func (c *CartesiaCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CartesiaCredential) UnmarshalJSON(data []byte) error {
	type embed CartesiaCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CartesiaCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CartesiaCredential) MarshalJSON() ([]byte, error) {
	type embed CartesiaCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CartesiaCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CartesiaExperimentalControls struct {
	Speed   *CartesiaSpeedControl                `json:"speed,omitempty" url:"speed,omitempty"`
	Emotion *CartesiaExperimentalControlsEmotion `json:"emotion,omitempty" url:"emotion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CartesiaExperimentalControls) GetSpeed() *CartesiaSpeedControl {
	if c == nil {
		return nil
	}
	return c.Speed
}

func (c *CartesiaExperimentalControls) GetEmotion() *CartesiaExperimentalControlsEmotion {
	if c == nil {
		return nil
	}
	return c.Emotion
}

func (c *CartesiaExperimentalControls) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CartesiaExperimentalControls) UnmarshalJSON(data []byte) error {
	type unmarshaler CartesiaExperimentalControls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CartesiaExperimentalControls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CartesiaExperimentalControls) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CartesiaExperimentalControlsEmotion string

const (
	CartesiaExperimentalControlsEmotionAngerLowest       CartesiaExperimentalControlsEmotion = "anger:lowest"
	CartesiaExperimentalControlsEmotionAngerLow          CartesiaExperimentalControlsEmotion = "anger:low"
	CartesiaExperimentalControlsEmotionAngerHigh         CartesiaExperimentalControlsEmotion = "anger:high"
	CartesiaExperimentalControlsEmotionAngerHighest      CartesiaExperimentalControlsEmotion = "anger:highest"
	CartesiaExperimentalControlsEmotionPositivityLowest  CartesiaExperimentalControlsEmotion = "positivity:lowest"
	CartesiaExperimentalControlsEmotionPositivityLow     CartesiaExperimentalControlsEmotion = "positivity:low"
	CartesiaExperimentalControlsEmotionPositivityHigh    CartesiaExperimentalControlsEmotion = "positivity:high"
	CartesiaExperimentalControlsEmotionPositivityHighest CartesiaExperimentalControlsEmotion = "positivity:highest"
	CartesiaExperimentalControlsEmotionSurpriseLowest    CartesiaExperimentalControlsEmotion = "surprise:lowest"
	CartesiaExperimentalControlsEmotionSurpriseLow       CartesiaExperimentalControlsEmotion = "surprise:low"
	CartesiaExperimentalControlsEmotionSurpriseHigh      CartesiaExperimentalControlsEmotion = "surprise:high"
	CartesiaExperimentalControlsEmotionSurpriseHighest   CartesiaExperimentalControlsEmotion = "surprise:highest"
	CartesiaExperimentalControlsEmotionSadnessLowest     CartesiaExperimentalControlsEmotion = "sadness:lowest"
	CartesiaExperimentalControlsEmotionSadnessLow        CartesiaExperimentalControlsEmotion = "sadness:low"
	CartesiaExperimentalControlsEmotionSadnessHigh       CartesiaExperimentalControlsEmotion = "sadness:high"
	CartesiaExperimentalControlsEmotionSadnessHighest    CartesiaExperimentalControlsEmotion = "sadness:highest"
	CartesiaExperimentalControlsEmotionCuriosityLowest   CartesiaExperimentalControlsEmotion = "curiosity:lowest"
	CartesiaExperimentalControlsEmotionCuriosityLow      CartesiaExperimentalControlsEmotion = "curiosity:low"
	CartesiaExperimentalControlsEmotionCuriosityHigh     CartesiaExperimentalControlsEmotion = "curiosity:high"
	CartesiaExperimentalControlsEmotionCuriosityHighest  CartesiaExperimentalControlsEmotion = "curiosity:highest"
)

func NewCartesiaExperimentalControlsEmotionFromString(s string) (CartesiaExperimentalControlsEmotion, error) {
	switch s {
	case "anger:lowest":
		return CartesiaExperimentalControlsEmotionAngerLowest, nil
	case "anger:low":
		return CartesiaExperimentalControlsEmotionAngerLow, nil
	case "anger:high":
		return CartesiaExperimentalControlsEmotionAngerHigh, nil
	case "anger:highest":
		return CartesiaExperimentalControlsEmotionAngerHighest, nil
	case "positivity:lowest":
		return CartesiaExperimentalControlsEmotionPositivityLowest, nil
	case "positivity:low":
		return CartesiaExperimentalControlsEmotionPositivityLow, nil
	case "positivity:high":
		return CartesiaExperimentalControlsEmotionPositivityHigh, nil
	case "positivity:highest":
		return CartesiaExperimentalControlsEmotionPositivityHighest, nil
	case "surprise:lowest":
		return CartesiaExperimentalControlsEmotionSurpriseLowest, nil
	case "surprise:low":
		return CartesiaExperimentalControlsEmotionSurpriseLow, nil
	case "surprise:high":
		return CartesiaExperimentalControlsEmotionSurpriseHigh, nil
	case "surprise:highest":
		return CartesiaExperimentalControlsEmotionSurpriseHighest, nil
	case "sadness:lowest":
		return CartesiaExperimentalControlsEmotionSadnessLowest, nil
	case "sadness:low":
		return CartesiaExperimentalControlsEmotionSadnessLow, nil
	case "sadness:high":
		return CartesiaExperimentalControlsEmotionSadnessHigh, nil
	case "sadness:highest":
		return CartesiaExperimentalControlsEmotionSadnessHighest, nil
	case "curiosity:lowest":
		return CartesiaExperimentalControlsEmotionCuriosityLowest, nil
	case "curiosity:low":
		return CartesiaExperimentalControlsEmotionCuriosityLow, nil
	case "curiosity:high":
		return CartesiaExperimentalControlsEmotionCuriosityHigh, nil
	case "curiosity:highest":
		return CartesiaExperimentalControlsEmotionCuriosityHighest, nil
	}
	var t CartesiaExperimentalControlsEmotion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaExperimentalControlsEmotion) Ptr() *CartesiaExperimentalControlsEmotion {
	return &c
}

type CartesiaExperimentalControlsSpeed string

const (
	CartesiaExperimentalControlsSpeedSlowest CartesiaExperimentalControlsSpeed = "slowest"
	CartesiaExperimentalControlsSpeedSlow    CartesiaExperimentalControlsSpeed = "slow"
	CartesiaExperimentalControlsSpeedNormal  CartesiaExperimentalControlsSpeed = "normal"
	CartesiaExperimentalControlsSpeedFast    CartesiaExperimentalControlsSpeed = "fast"
	CartesiaExperimentalControlsSpeedFastest CartesiaExperimentalControlsSpeed = "fastest"
)

func NewCartesiaExperimentalControlsSpeedFromString(s string) (CartesiaExperimentalControlsSpeed, error) {
	switch s {
	case "slowest":
		return CartesiaExperimentalControlsSpeedSlowest, nil
	case "slow":
		return CartesiaExperimentalControlsSpeedSlow, nil
	case "normal":
		return CartesiaExperimentalControlsSpeedNormal, nil
	case "fast":
		return CartesiaExperimentalControlsSpeedFast, nil
	case "fastest":
		return CartesiaExperimentalControlsSpeedFastest, nil
	}
	var t CartesiaExperimentalControlsSpeed
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaExperimentalControlsSpeed) Ptr() *CartesiaExperimentalControlsSpeed {
	return &c
}

type CartesiaSpeedControl struct {
	CartesiaExperimentalControlsSpeed CartesiaExperimentalControlsSpeed
	Double                            float64

	typ string
}

func (c *CartesiaSpeedControl) GetCartesiaExperimentalControlsSpeed() CartesiaExperimentalControlsSpeed {
	if c == nil {
		return ""
	}
	return c.CartesiaExperimentalControlsSpeed
}

func (c *CartesiaSpeedControl) GetDouble() float64 {
	if c == nil {
		return 0
	}
	return c.Double
}

func (c *CartesiaSpeedControl) UnmarshalJSON(data []byte) error {
	var valueCartesiaExperimentalControlsSpeed CartesiaExperimentalControlsSpeed
	if err := json.Unmarshal(data, &valueCartesiaExperimentalControlsSpeed); err == nil {
		c.typ = "CartesiaExperimentalControlsSpeed"
		c.CartesiaExperimentalControlsSpeed = valueCartesiaExperimentalControlsSpeed
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		c.typ = "Double"
		c.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CartesiaSpeedControl) MarshalJSON() ([]byte, error) {
	if c.typ == "CartesiaExperimentalControlsSpeed" || c.CartesiaExperimentalControlsSpeed != "" {
		return json.Marshal(c.CartesiaExperimentalControlsSpeed)
	}
	if c.typ == "Double" || c.Double != 0 {
		return json.Marshal(c.Double)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CartesiaSpeedControlVisitor interface {
	VisitCartesiaExperimentalControlsSpeed(CartesiaExperimentalControlsSpeed) error
	VisitDouble(float64) error
}

func (c *CartesiaSpeedControl) Accept(visitor CartesiaSpeedControlVisitor) error {
	if c.typ == "CartesiaExperimentalControlsSpeed" || c.CartesiaExperimentalControlsSpeed != "" {
		return visitor.VisitCartesiaExperimentalControlsSpeed(c.CartesiaExperimentalControlsSpeed)
	}
	if c.typ == "Double" || c.Double != 0 {
		return visitor.VisitDouble(c.Double)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CartesiaVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// The ID of the particular voice you want to use.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
	Model *CartesiaVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
	Language *CartesiaVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// Experimental controls for Cartesia voice generation
	ExperimentalControls *CartesiaExperimentalControls `json:"experimentalControls,omitempty" url:"experimentalControls,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CartesiaVoice) GetCachingEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.CachingEnabled
}

func (c *CartesiaVoice) GetVoiceId() string {
	if c == nil {
		return ""
	}
	return c.VoiceId
}

func (c *CartesiaVoice) GetModel() *CartesiaVoiceModel {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *CartesiaVoice) GetLanguage() *CartesiaVoiceLanguage {
	if c == nil {
		return nil
	}
	return c.Language
}

func (c *CartesiaVoice) GetExperimentalControls() *CartesiaExperimentalControls {
	if c == nil {
		return nil
	}
	return c.ExperimentalControls
}

func (c *CartesiaVoice) GetChunkPlan() *ChunkPlan {
	if c == nil {
		return nil
	}
	return c.ChunkPlan
}

func (c *CartesiaVoice) GetFallbackPlan() *FallbackPlan {
	if c == nil {
		return nil
	}
	return c.FallbackPlan
}

func (c *CartesiaVoice) Provider() string {
	return c.provider
}

func (c *CartesiaVoice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CartesiaVoice) UnmarshalJSON(data []byte) error {
	type embed CartesiaVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CartesiaVoice(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CartesiaVoice) MarshalJSON() ([]byte, error) {
	type embed CartesiaVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CartesiaVoice) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
type CartesiaVoiceLanguage string

const (
	CartesiaVoiceLanguageEn CartesiaVoiceLanguage = "en"
	CartesiaVoiceLanguageDe CartesiaVoiceLanguage = "de"
	CartesiaVoiceLanguageEs CartesiaVoiceLanguage = "es"
	CartesiaVoiceLanguageFr CartesiaVoiceLanguage = "fr"
	CartesiaVoiceLanguageJa CartesiaVoiceLanguage = "ja"
	CartesiaVoiceLanguagePt CartesiaVoiceLanguage = "pt"
	CartesiaVoiceLanguageZh CartesiaVoiceLanguage = "zh"
	CartesiaVoiceLanguageHi CartesiaVoiceLanguage = "hi"
	CartesiaVoiceLanguageIt CartesiaVoiceLanguage = "it"
	CartesiaVoiceLanguageKo CartesiaVoiceLanguage = "ko"
	CartesiaVoiceLanguageNl CartesiaVoiceLanguage = "nl"
	CartesiaVoiceLanguagePl CartesiaVoiceLanguage = "pl"
	CartesiaVoiceLanguageRu CartesiaVoiceLanguage = "ru"
	CartesiaVoiceLanguageSv CartesiaVoiceLanguage = "sv"
	CartesiaVoiceLanguageTr CartesiaVoiceLanguage = "tr"
)

func NewCartesiaVoiceLanguageFromString(s string) (CartesiaVoiceLanguage, error) {
	switch s {
	case "en":
		return CartesiaVoiceLanguageEn, nil
	case "de":
		return CartesiaVoiceLanguageDe, nil
	case "es":
		return CartesiaVoiceLanguageEs, nil
	case "fr":
		return CartesiaVoiceLanguageFr, nil
	case "ja":
		return CartesiaVoiceLanguageJa, nil
	case "pt":
		return CartesiaVoiceLanguagePt, nil
	case "zh":
		return CartesiaVoiceLanguageZh, nil
	case "hi":
		return CartesiaVoiceLanguageHi, nil
	case "it":
		return CartesiaVoiceLanguageIt, nil
	case "ko":
		return CartesiaVoiceLanguageKo, nil
	case "nl":
		return CartesiaVoiceLanguageNl, nil
	case "pl":
		return CartesiaVoiceLanguagePl, nil
	case "ru":
		return CartesiaVoiceLanguageRu, nil
	case "sv":
		return CartesiaVoiceLanguageSv, nil
	case "tr":
		return CartesiaVoiceLanguageTr, nil
	}
	var t CartesiaVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaVoiceLanguage) Ptr() *CartesiaVoiceLanguage {
	return &c
}

// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
type CartesiaVoiceModel string

const (
	CartesiaVoiceModelSonic2            CartesiaVoiceModel = "sonic-2"
	CartesiaVoiceModelSonicEnglish      CartesiaVoiceModel = "sonic-english"
	CartesiaVoiceModelSonicMultilingual CartesiaVoiceModel = "sonic-multilingual"
	CartesiaVoiceModelSonicPreview      CartesiaVoiceModel = "sonic-preview"
	CartesiaVoiceModelSonic             CartesiaVoiceModel = "sonic"
)

func NewCartesiaVoiceModelFromString(s string) (CartesiaVoiceModel, error) {
	switch s {
	case "sonic-2":
		return CartesiaVoiceModelSonic2, nil
	case "sonic-english":
		return CartesiaVoiceModelSonicEnglish, nil
	case "sonic-multilingual":
		return CartesiaVoiceModelSonicMultilingual, nil
	case "sonic-preview":
		return CartesiaVoiceModelSonicPreview, nil
	case "sonic":
		return CartesiaVoiceModelSonic, nil
	}
	var t CartesiaVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaVoiceModel) Ptr() *CartesiaVoiceModel {
	return &c
}

type CerebrasCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CerebrasCredential) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CerebrasCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CerebrasCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CerebrasCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CerebrasCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CerebrasCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CerebrasCredential) Provider() string {
	return c.provider
}

func (c *CerebrasCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CerebrasCredential) UnmarshalJSON(data []byte) error {
	type embed CerebrasCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CerebrasCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "cerebras" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cerebras", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CerebrasCredential) MarshalJSON() ([]byte, error) {
	type embed CerebrasCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "cerebras",
	}
	return json.Marshal(marshaler)
}

func (c *CerebrasCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CerebrasModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*CerebrasModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model CerebrasModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CerebrasModel) GetMessages() []*OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CerebrasModel) GetTools() []*CerebrasModelToolsItem {
	if c == nil {
		return nil
	}
	return c.Tools
}

func (c *CerebrasModel) GetToolIds() []string {
	if c == nil {
		return nil
	}
	return c.ToolIds
}

func (c *CerebrasModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if c == nil {
		return nil
	}
	return c.KnowledgeBase
}

func (c *CerebrasModel) GetKnowledgeBaseId() *string {
	if c == nil {
		return nil
	}
	return c.KnowledgeBaseId
}

func (c *CerebrasModel) GetModel() CerebrasModelModel {
	if c == nil {
		return ""
	}
	return c.Model
}

func (c *CerebrasModel) GetTemperature() *float64 {
	if c == nil {
		return nil
	}
	return c.Temperature
}

func (c *CerebrasModel) GetMaxTokens() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxTokens
}

func (c *CerebrasModel) GetEmotionRecognitionEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.EmotionRecognitionEnabled
}

func (c *CerebrasModel) GetNumFastTurns() *float64 {
	if c == nil {
		return nil
	}
	return c.NumFastTurns
}

func (c *CerebrasModel) Provider() string {
	return c.provider
}

func (c *CerebrasModel) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CerebrasModel) UnmarshalJSON(data []byte) error {
	type embed CerebrasModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CerebrasModel(unmarshaler.embed)
	if unmarshaler.Provider != "cerebras" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cerebras", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CerebrasModel) MarshalJSON() ([]byte, error) {
	type embed CerebrasModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cerebras",
	}
	return json.Marshal(marshaler)
}

func (c *CerebrasModel) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
type CerebrasModelModel string

const (
	CerebrasModelModelLlama318B  CerebrasModelModel = "llama3.1-8b"
	CerebrasModelModelLlama3370B CerebrasModelModel = "llama-3.3-70b"
)

func NewCerebrasModelModelFromString(s string) (CerebrasModelModel, error) {
	switch s {
	case "llama3.1-8b":
		return CerebrasModelModelLlama318B, nil
	case "llama-3.3-70b":
		return CerebrasModelModelLlama3370B, nil
	}
	var t CerebrasModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CerebrasModelModel) Ptr() *CerebrasModelModel {
	return &c
}

type CerebrasModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (c *CerebrasModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if c == nil {
		return nil
	}
	return c.CreateApiRequestToolDto
}

func (c *CerebrasModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if c == nil {
		return nil
	}
	return c.CreateBashToolDto
}

func (c *CerebrasModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if c == nil {
		return nil
	}
	return c.CreateComputerToolDto
}

func (c *CerebrasModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if c == nil {
		return nil
	}
	return c.CreateDtmfToolDto
}

func (c *CerebrasModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateEndCallToolDto
}

func (c *CerebrasModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if c == nil {
		return nil
	}
	return c.CreateFunctionToolDto
}

func (c *CerebrasModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (c *CerebrasModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarEventCreateToolDto
}

func (c *CerebrasModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactCreateToolDto
}

func (c *CerebrasModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactGetToolDto
}

func (c *CerebrasModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (c *CerebrasModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCreateEventToolDto
}

func (c *CerebrasModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleSheetsRowAppendToolDto
}

func (c *CerebrasModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if c == nil {
		return nil
	}
	return c.CreateMcpToolDto
}

func (c *CerebrasModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if c == nil {
		return nil
	}
	return c.CreateQueryToolDto
}

func (c *CerebrasModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSlackSendMessageToolDto
}

func (c *CerebrasModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSmsToolDto
}

func (c *CerebrasModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTextEditorToolDto
}

func (c *CerebrasModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTransferCallToolDto
}

func (c *CerebrasModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		c.typ = "CreateApiRequestToolDto"
		c.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		c.typ = "CreateBashToolDto"
		c.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		c.typ = "CreateComputerToolDto"
		c.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.typ = "CreateDtmfToolDto"
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.typ = "CreateEndCallToolDto"
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.typ = "CreateFunctionToolDto"
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		c.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		c.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactCreateToolDto"
		c.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactGetToolDto"
		c.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		c.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCreateEventToolDto"
		c.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		c.typ = "CreateGoogleSheetsRowAppendToolDto"
		c.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		c.typ = "CreateMcpToolDto"
		c.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		c.typ = "CreateQueryToolDto"
		c.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		c.typ = "CreateSlackSendMessageToolDto"
		c.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		c.typ = "CreateSmsToolDto"
		c.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		c.typ = "CreateTextEditorToolDto"
		c.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.typ = "CreateTransferCallToolDto"
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CerebrasModelToolsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return json.Marshal(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return json.Marshal(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return json.Marshal(c.CreateComputerToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactGetToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return json.Marshal(c.CreateMcpToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return json.Marshal(c.CreateQueryToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return json.Marshal(c.CreateSmsToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return json.Marshal(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CerebrasModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CerebrasModelToolsItem) Accept(visitor CerebrasModelToolsItemVisitor) error {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(c.CreateComputerToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(c.CreateGoHighLevelContactGetToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(c.CreateMcpToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(c.CreateQueryToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(c.CreateSmsToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ChatCompletionMessageMetadata struct {
	TaskName   string                 `json:"taskName" url:"taskName"`
	TaskType   string                 `json:"taskType" url:"taskType"`
	TaskOutput string                 `json:"taskOutput" url:"taskOutput"`
	TaskState  map[string]interface{} `json:"taskState,omitempty" url:"taskState,omitempty"`
	NodeTrace  []string               `json:"nodeTrace,omitempty" url:"nodeTrace,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatCompletionMessageMetadata) GetTaskName() string {
	if c == nil {
		return ""
	}
	return c.TaskName
}

func (c *ChatCompletionMessageMetadata) GetTaskType() string {
	if c == nil {
		return ""
	}
	return c.TaskType
}

func (c *ChatCompletionMessageMetadata) GetTaskOutput() string {
	if c == nil {
		return ""
	}
	return c.TaskOutput
}

func (c *ChatCompletionMessageMetadata) GetTaskState() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.TaskState
}

func (c *ChatCompletionMessageMetadata) GetNodeTrace() []string {
	if c == nil {
		return nil
	}
	return c.NodeTrace
}

func (c *ChatCompletionMessageMetadata) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatCompletionMessageMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCompletionMessageMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCompletionMessageMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCompletionMessageMetadata) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatCompletionMessageWorkflows struct {
	Role     map[string]interface{}         `json:"role,omitempty" url:"role,omitempty"`
	Content  *string                        `json:"content,omitempty" url:"content,omitempty"`
	Metadata *ChatCompletionMessageMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatCompletionMessageWorkflows) GetRole() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Role
}

func (c *ChatCompletionMessageWorkflows) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ChatCompletionMessageWorkflows) GetMetadata() *ChatCompletionMessageMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ChatCompletionMessageWorkflows) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatCompletionMessageWorkflows) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCompletionMessageWorkflows
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCompletionMessageWorkflows(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCompletionMessageWorkflows) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatCompletionsDto struct {
	Messages   []*ChatCompletionMessageWorkflows `json:"messages,omitempty" url:"messages,omitempty"`
	WorkflowId *string                           `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	Workflow   *CreateWorkflowDto                `json:"workflow,omitempty" url:"workflow,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatCompletionsDto) GetMessages() []*ChatCompletionMessageWorkflows {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ChatCompletionsDto) GetWorkflowId() *string {
	if c == nil {
		return nil
	}
	return c.WorkflowId
}

func (c *ChatCompletionsDto) GetWorkflow() *CreateWorkflowDto {
	if c == nil {
		return nil
	}
	return c.Workflow
}

func (c *ChatCompletionsDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatCompletionsDto) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCompletionsDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCompletionsDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCompletionsDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatServiceResponse struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatServiceResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatServiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatServiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatServiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatServiceResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChunkPlan struct {
	// This determines whether the model output is chunked before being sent to the voice provider. Default `true`.
	//
	// Usage:
	// - To rely on the voice provider's audio generation logic, set this to `false`.
	// - If seeing issues with quality, set this to `true`.
	//
	// If disabled, Vapi-provided audio control tokens like <flush /> will not work.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the minimum number of characters in a chunk.
	//
	// Usage:
	// - To increase quality, set this to a higher value.
	// - To decrease latency, set this to a lower value.
	//
	// @default 30
	MinCharacters *float64 `json:"minCharacters,omitempty" url:"minCharacters,omitempty"`
	// These are the punctuations that are considered valid boundaries for a chunk to be created.
	//
	// Usage:
	// - To increase quality, constrain to fewer boundaries.
	// - To decrease latency, enable all.
	//
	// Default is automatically set to balance the trade-off between quality and latency based on the provider.
	PunctuationBoundaries []PunctuationBoundary `json:"punctuationBoundaries,omitempty" url:"punctuationBoundaries,omitempty"`
	// This is the plan for formatting the chunk before it is sent to the voice provider.
	FormatPlan *FormatPlan `json:"formatPlan,omitempty" url:"formatPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChunkPlan) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ChunkPlan) GetMinCharacters() *float64 {
	if c == nil {
		return nil
	}
	return c.MinCharacters
}

func (c *ChunkPlan) GetPunctuationBoundaries() []PunctuationBoundary {
	if c == nil {
		return nil
	}
	return c.PunctuationBoundaries
}

func (c *ChunkPlan) GetFormatPlan() *FormatPlan {
	if c == nil {
		return nil
	}
	return c.FormatPlan
}

func (c *ChunkPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChunkPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler ChunkPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChunkPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChunkPlan) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessage struct {
	// These are the messages that can be sent from client-side SDKs to control the call.
	Message *ClientInboundMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessage) GetMessage() *ClientInboundMessageMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ClientInboundMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientInboundMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientInboundMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageAddMessage struct {
	// This is the type of the message. Send "add-message" message to add a message to the conversation history.
	// This is the message to add to the conversation.
	Message *OpenAiMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the flag to trigger a response, or to insert the message into the conversation history silently. Defaults to `true`.
	//
	// Usage:
	// - Use `true` to trigger a response.
	// - Use `false` to insert the message into the conversation history silently.
	//
	// @default true
	TriggerResponseEnabled *bool `json:"triggerResponseEnabled,omitempty" url:"triggerResponseEnabled,omitempty"`
	type_                  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageAddMessage) GetMessage() *OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ClientInboundMessageAddMessage) GetTriggerResponseEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.TriggerResponseEnabled
}

func (c *ClientInboundMessageAddMessage) Type() string {
	return c.type_
}

func (c *ClientInboundMessageAddMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageAddMessage) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageAddMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageAddMessage(unmarshaler.embed)
	if unmarshaler.Type != "add-message" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "add-message", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageAddMessage) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageAddMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "add-message",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageAddMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageControl struct {
	// This is the type of the message. Send "control" message to control the assistant. `control` options are:
	// - "mute-assistant" - mute the assistant
	// - "unmute-assistant" - unmute the assistant
	// - "say-first-message" - say the first message (this is used when video recording is enabled and the conversation is only started once the client side kicks off the recording)
	// This is the control action
	Control ClientInboundMessageControlControl `json:"control" url:"control"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageControl) GetControl() ClientInboundMessageControlControl {
	if c == nil {
		return ""
	}
	return c.Control
}

func (c *ClientInboundMessageControl) Type() string {
	return c.type_
}

func (c *ClientInboundMessageControl) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageControl) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageControl
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageControl(unmarshaler.embed)
	if unmarshaler.Type != "control" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "control", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageControl) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageControl
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "control",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageControl) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the control action
type ClientInboundMessageControlControl string

const (
	ClientInboundMessageControlControlMuteAssistant   ClientInboundMessageControlControl = "mute-assistant"
	ClientInboundMessageControlControlUnmuteAssistant ClientInboundMessageControlControl = "unmute-assistant"
	ClientInboundMessageControlControlSayFirstMessage ClientInboundMessageControlControl = "say-first-message"
)

func NewClientInboundMessageControlControlFromString(s string) (ClientInboundMessageControlControl, error) {
	switch s {
	case "mute-assistant":
		return ClientInboundMessageControlControlMuteAssistant, nil
	case "unmute-assistant":
		return ClientInboundMessageControlControlUnmuteAssistant, nil
	case "say-first-message":
		return ClientInboundMessageControlControlSayFirstMessage, nil
	}
	var t ClientInboundMessageControlControl
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientInboundMessageControlControl) Ptr() *ClientInboundMessageControlControl {
	return &c
}

type ClientInboundMessageEndCall struct {
	// This is the type of the message. Send "end-call" message to end the call.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageEndCall) Type() string {
	return c.type_
}

func (c *ClientInboundMessageEndCall) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageEndCall) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageEndCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageEndCall(unmarshaler.embed)
	if unmarshaler.Type != "end-call" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "end-call", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageEndCall) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageEndCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "end-call",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageEndCall) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// These are the messages that can be sent from client-side SDKs to control the call.
type ClientInboundMessageMessage struct {
	ClientInboundMessageAddMessage *ClientInboundMessageAddMessage
	ClientInboundMessageControl    *ClientInboundMessageControl
	ClientInboundMessageSay        *ClientInboundMessageSay
	ClientInboundMessageEndCall    *ClientInboundMessageEndCall
	ClientInboundMessageTransfer   *ClientInboundMessageTransfer

	typ string
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageAddMessage() *ClientInboundMessageAddMessage {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageAddMessage
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageControl() *ClientInboundMessageControl {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageControl
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageSay() *ClientInboundMessageSay {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageSay
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageEndCall() *ClientInboundMessageEndCall {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageEndCall
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageTransfer() *ClientInboundMessageTransfer {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageTransfer
}

func (c *ClientInboundMessageMessage) UnmarshalJSON(data []byte) error {
	valueClientInboundMessageAddMessage := new(ClientInboundMessageAddMessage)
	if err := json.Unmarshal(data, &valueClientInboundMessageAddMessage); err == nil {
		c.typ = "ClientInboundMessageAddMessage"
		c.ClientInboundMessageAddMessage = valueClientInboundMessageAddMessage
		return nil
	}
	valueClientInboundMessageControl := new(ClientInboundMessageControl)
	if err := json.Unmarshal(data, &valueClientInboundMessageControl); err == nil {
		c.typ = "ClientInboundMessageControl"
		c.ClientInboundMessageControl = valueClientInboundMessageControl
		return nil
	}
	valueClientInboundMessageSay := new(ClientInboundMessageSay)
	if err := json.Unmarshal(data, &valueClientInboundMessageSay); err == nil {
		c.typ = "ClientInboundMessageSay"
		c.ClientInboundMessageSay = valueClientInboundMessageSay
		return nil
	}
	valueClientInboundMessageEndCall := new(ClientInboundMessageEndCall)
	if err := json.Unmarshal(data, &valueClientInboundMessageEndCall); err == nil {
		c.typ = "ClientInboundMessageEndCall"
		c.ClientInboundMessageEndCall = valueClientInboundMessageEndCall
		return nil
	}
	valueClientInboundMessageTransfer := new(ClientInboundMessageTransfer)
	if err := json.Unmarshal(data, &valueClientInboundMessageTransfer); err == nil {
		c.typ = "ClientInboundMessageTransfer"
		c.ClientInboundMessageTransfer = valueClientInboundMessageTransfer
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientInboundMessageMessage) MarshalJSON() ([]byte, error) {
	if c.typ == "ClientInboundMessageAddMessage" || c.ClientInboundMessageAddMessage != nil {
		return json.Marshal(c.ClientInboundMessageAddMessage)
	}
	if c.typ == "ClientInboundMessageControl" || c.ClientInboundMessageControl != nil {
		return json.Marshal(c.ClientInboundMessageControl)
	}
	if c.typ == "ClientInboundMessageSay" || c.ClientInboundMessageSay != nil {
		return json.Marshal(c.ClientInboundMessageSay)
	}
	if c.typ == "ClientInboundMessageEndCall" || c.ClientInboundMessageEndCall != nil {
		return json.Marshal(c.ClientInboundMessageEndCall)
	}
	if c.typ == "ClientInboundMessageTransfer" || c.ClientInboundMessageTransfer != nil {
		return json.Marshal(c.ClientInboundMessageTransfer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageMessageVisitor interface {
	VisitClientInboundMessageAddMessage(*ClientInboundMessageAddMessage) error
	VisitClientInboundMessageControl(*ClientInboundMessageControl) error
	VisitClientInboundMessageSay(*ClientInboundMessageSay) error
	VisitClientInboundMessageEndCall(*ClientInboundMessageEndCall) error
	VisitClientInboundMessageTransfer(*ClientInboundMessageTransfer) error
}

func (c *ClientInboundMessageMessage) Accept(visitor ClientInboundMessageMessageVisitor) error {
	if c.typ == "ClientInboundMessageAddMessage" || c.ClientInboundMessageAddMessage != nil {
		return visitor.VisitClientInboundMessageAddMessage(c.ClientInboundMessageAddMessage)
	}
	if c.typ == "ClientInboundMessageControl" || c.ClientInboundMessageControl != nil {
		return visitor.VisitClientInboundMessageControl(c.ClientInboundMessageControl)
	}
	if c.typ == "ClientInboundMessageSay" || c.ClientInboundMessageSay != nil {
		return visitor.VisitClientInboundMessageSay(c.ClientInboundMessageSay)
	}
	if c.typ == "ClientInboundMessageEndCall" || c.ClientInboundMessageEndCall != nil {
		return visitor.VisitClientInboundMessageEndCall(c.ClientInboundMessageEndCall)
	}
	if c.typ == "ClientInboundMessageTransfer" || c.ClientInboundMessageTransfer != nil {
		return visitor.VisitClientInboundMessageTransfer(c.ClientInboundMessageTransfer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageSay struct {
	// This is the type of the message. Send "say" message to make the assistant say something.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the content to say.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is the flag to end call after content is spoken.
	EndCallAfterSpoken *bool `json:"endCallAfterSpoken,omitempty" url:"endCallAfterSpoken,omitempty"`
	// This is the flag for whether the message is interruptible.
	InterruptionsEnabled *bool `json:"interruptionsEnabled,omitempty" url:"interruptionsEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageSay) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ClientInboundMessageSay) GetEndCallAfterSpoken() *bool {
	if c == nil {
		return nil
	}
	return c.EndCallAfterSpoken
}

func (c *ClientInboundMessageSay) GetInterruptionsEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.InterruptionsEnabled
}

func (c *ClientInboundMessageSay) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageSay) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientInboundMessageSay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientInboundMessageSay(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageSay) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageTransfer struct {
	// This is the type of the message. Send "transfer" message to transfer the call to a destination.
	// This is the destination to transfer the call to.
	Destination *ClientInboundMessageTransferDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the content to say.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageTransfer) GetDestination() *ClientInboundMessageTransferDestination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *ClientInboundMessageTransfer) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ClientInboundMessageTransfer) Type() string {
	return c.type_
}

func (c *ClientInboundMessageTransfer) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageTransfer) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageTransfer
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageTransfer(unmarshaler.embed)
	if unmarshaler.Type != "transfer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transfer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageTransfer) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageTransfer
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transfer",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageTransfer) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the destination to transfer the call to.
type ClientInboundMessageTransferDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (c *ClientInboundMessageTransferDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if c == nil {
		return nil
	}
	return c.TransferDestinationNumber
}

func (c *ClientInboundMessageTransferDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if c == nil {
		return nil
	}
	return c.TransferDestinationSip
}

func (c *ClientInboundMessageTransferDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.typ = "TransferDestinationNumber"
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.typ = "TransferDestinationSip"
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientInboundMessageTransferDestination) MarshalJSON() ([]byte, error) {
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageTransferDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *ClientInboundMessageTransferDestination) Accept(visitor ClientInboundMessageTransferDestinationVisitor) error {
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessage struct {
	// These are all the messages that can be sent to the client-side SDKs during the call. Configure the messages you'd like to receive in `assistant.clientMessages`.
	Message *ClientMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessage) GetMessage() *ClientMessageMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ClientMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageConversationUpdate struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageConversationUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "conversation-update" is sent when an update is committed to the conversation history.
	// This is the most up-to-date conversation history at the time the message is sent.
	Messages []*ClientMessageConversationUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	type_     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageConversationUpdate) GetPhoneNumber() *ClientMessageConversationUpdatePhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageConversationUpdate) GetMessages() []*ClientMessageConversationUpdateMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ClientMessageConversationUpdate) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.MessagesOpenAiFormatted
}

func (c *ClientMessageConversationUpdate) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageConversationUpdate) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageConversationUpdate) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageConversationUpdate) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageConversationUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageConversationUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageConversationUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageConversationUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageConversationUpdate(unmarshaler.embed)
	if unmarshaler.Type != "conversation-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageConversationUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageConversationUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageConversationUpdate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageConversationUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (c *ClientMessageConversationUpdateMessagesItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetBotMessage() *BotMessage {
	if c == nil {
		return nil
	}
	return c.BotMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if c == nil {
		return nil
	}
	return c.ToolCallMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if c == nil {
		return nil
	}
	return c.ToolCallResultMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		c.typ = "BotMessage"
		c.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		c.typ = "ToolCallMessage"
		c.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		c.typ = "ToolCallResultMessage"
		c.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageConversationUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "BotMessage" || c.BotMessage != nil {
		return json.Marshal(c.BotMessage)
	}
	if c.typ == "ToolCallMessage" || c.ToolCallMessage != nil {
		return json.Marshal(c.ToolCallMessage)
	}
	if c.typ == "ToolCallResultMessage" || c.ToolCallResultMessage != nil {
		return json.Marshal(c.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageConversationUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (c *ClientMessageConversationUpdateMessagesItem) Accept(visitor ClientMessageConversationUpdateMessagesItemVisitor) error {
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "BotMessage" || c.BotMessage != nil {
		return visitor.VisitBotMessage(c.BotMessage)
	}
	if c.typ == "ToolCallMessage" || c.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(c.ToolCallMessage)
	}
	if c.typ == "ToolCallResultMessage" || c.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(c.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the phone number that the message is associated with.
type ClientMessageConversationUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageConversationUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageConversationUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageConversationUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageConversationUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageConversationUpdatePhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageConversationUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageConversationUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageConversationUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageConversationUpdatePhoneNumber) Accept(visitor ClientMessageConversationUpdatePhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageHang struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageHangPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "hang" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:
	// - the model is too slow to respond
	// - the voice is too slow to respond
	// - the tool call is still waiting for a response from your server
	// - etc.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	type_     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageHang) GetPhoneNumber() *ClientMessageHangPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageHang) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageHang) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageHang) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageHang) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageHang) Type() string {
	return c.type_
}

func (c *ClientMessageHang) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageHang) UnmarshalJSON(data []byte) error {
	type embed ClientMessageHang
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageHang(unmarshaler.embed)
	if unmarshaler.Type != "hang" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "hang", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageHang) MarshalJSON() ([]byte, error) {
	type embed ClientMessageHang
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "hang",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageHang) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageHangPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageHangPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageHangPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageHangPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageHangPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageHangPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageHangPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageHangPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageHangPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageHangPhoneNumber) Accept(visitor ClientMessageHangPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageLanguageChangeDetected struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageLanguageChangeDetectedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "language-change-detected" is sent when the transcriber is automatically switched based on the detected language.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the language the transcriber is switched to.
	Language string `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageLanguageChangeDetected) GetPhoneNumber() *ClientMessageLanguageChangeDetectedPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageLanguageChangeDetected) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageLanguageChangeDetected) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageLanguageChangeDetected) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageLanguageChangeDetected) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageLanguageChangeDetected) GetLanguage() string {
	if c == nil {
		return ""
	}
	return c.Language
}

func (c *ClientMessageLanguageChangeDetected) Type() string {
	return c.type_
}

func (c *ClientMessageLanguageChangeDetected) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageLanguageChangeDetected) UnmarshalJSON(data []byte) error {
	type embed ClientMessageLanguageChangeDetected
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageLanguageChangeDetected(unmarshaler.embed)
	if unmarshaler.Type != "language-change-detected" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "language-change-detected", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageLanguageChangeDetected) MarshalJSON() ([]byte, error) {
	type embed ClientMessageLanguageChangeDetected
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "language-change-detected",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageLanguageChangeDetected) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageLanguageChangeDetectedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageLanguageChangeDetectedPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageLanguageChangeDetectedPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageLanguageChangeDetectedPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageLanguageChangeDetectedPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageLanguageChangeDetectedPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageLanguageChangeDetectedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageLanguageChangeDetectedPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageLanguageChangeDetectedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageLanguageChangeDetectedPhoneNumber) Accept(visitor ClientMessageLanguageChangeDetectedPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are all the messages that can be sent to the client-side SDKs during the call. Configure the messages you'd like to receive in `assistant.clientMessages`.
type ClientMessageMessage struct {
	ClientMessageWorkflowNodeStarted    *ClientMessageWorkflowNodeStarted
	ClientMessageConversationUpdate     *ClientMessageConversationUpdate
	ClientMessageHang                   *ClientMessageHang
	ClientMessageMetadata               *ClientMessageMetadata
	ClientMessageModelOutput            *ClientMessageModelOutput
	ClientMessageSpeechUpdate           *ClientMessageSpeechUpdate
	ClientMessageTranscript             *ClientMessageTranscript
	ClientMessageToolCalls              *ClientMessageToolCalls
	ClientMessageToolCallsResult        *ClientMessageToolCallsResult
	ClientMessageTransferUpdate         *ClientMessageTransferUpdate
	ClientMessageUserInterrupted        *ClientMessageUserInterrupted
	ClientMessageLanguageChangeDetected *ClientMessageLanguageChangeDetected
	ClientMessageVoiceInput             *ClientMessageVoiceInput

	typ string
}

func (c *ClientMessageMessage) GetClientMessageWorkflowNodeStarted() *ClientMessageWorkflowNodeStarted {
	if c == nil {
		return nil
	}
	return c.ClientMessageWorkflowNodeStarted
}

func (c *ClientMessageMessage) GetClientMessageConversationUpdate() *ClientMessageConversationUpdate {
	if c == nil {
		return nil
	}
	return c.ClientMessageConversationUpdate
}

func (c *ClientMessageMessage) GetClientMessageHang() *ClientMessageHang {
	if c == nil {
		return nil
	}
	return c.ClientMessageHang
}

func (c *ClientMessageMessage) GetClientMessageMetadata() *ClientMessageMetadata {
	if c == nil {
		return nil
	}
	return c.ClientMessageMetadata
}

func (c *ClientMessageMessage) GetClientMessageModelOutput() *ClientMessageModelOutput {
	if c == nil {
		return nil
	}
	return c.ClientMessageModelOutput
}

func (c *ClientMessageMessage) GetClientMessageSpeechUpdate() *ClientMessageSpeechUpdate {
	if c == nil {
		return nil
	}
	return c.ClientMessageSpeechUpdate
}

func (c *ClientMessageMessage) GetClientMessageTranscript() *ClientMessageTranscript {
	if c == nil {
		return nil
	}
	return c.ClientMessageTranscript
}

func (c *ClientMessageMessage) GetClientMessageToolCalls() *ClientMessageToolCalls {
	if c == nil {
		return nil
	}
	return c.ClientMessageToolCalls
}

func (c *ClientMessageMessage) GetClientMessageToolCallsResult() *ClientMessageToolCallsResult {
	if c == nil {
		return nil
	}
	return c.ClientMessageToolCallsResult
}

func (c *ClientMessageMessage) GetClientMessageTransferUpdate() *ClientMessageTransferUpdate {
	if c == nil {
		return nil
	}
	return c.ClientMessageTransferUpdate
}

func (c *ClientMessageMessage) GetClientMessageUserInterrupted() *ClientMessageUserInterrupted {
	if c == nil {
		return nil
	}
	return c.ClientMessageUserInterrupted
}

func (c *ClientMessageMessage) GetClientMessageLanguageChangeDetected() *ClientMessageLanguageChangeDetected {
	if c == nil {
		return nil
	}
	return c.ClientMessageLanguageChangeDetected
}

func (c *ClientMessageMessage) GetClientMessageVoiceInput() *ClientMessageVoiceInput {
	if c == nil {
		return nil
	}
	return c.ClientMessageVoiceInput
}

func (c *ClientMessageMessage) UnmarshalJSON(data []byte) error {
	valueClientMessageWorkflowNodeStarted := new(ClientMessageWorkflowNodeStarted)
	if err := json.Unmarshal(data, &valueClientMessageWorkflowNodeStarted); err == nil {
		c.typ = "ClientMessageWorkflowNodeStarted"
		c.ClientMessageWorkflowNodeStarted = valueClientMessageWorkflowNodeStarted
		return nil
	}
	valueClientMessageConversationUpdate := new(ClientMessageConversationUpdate)
	if err := json.Unmarshal(data, &valueClientMessageConversationUpdate); err == nil {
		c.typ = "ClientMessageConversationUpdate"
		c.ClientMessageConversationUpdate = valueClientMessageConversationUpdate
		return nil
	}
	valueClientMessageHang := new(ClientMessageHang)
	if err := json.Unmarshal(data, &valueClientMessageHang); err == nil {
		c.typ = "ClientMessageHang"
		c.ClientMessageHang = valueClientMessageHang
		return nil
	}
	valueClientMessageMetadata := new(ClientMessageMetadata)
	if err := json.Unmarshal(data, &valueClientMessageMetadata); err == nil {
		c.typ = "ClientMessageMetadata"
		c.ClientMessageMetadata = valueClientMessageMetadata
		return nil
	}
	valueClientMessageModelOutput := new(ClientMessageModelOutput)
	if err := json.Unmarshal(data, &valueClientMessageModelOutput); err == nil {
		c.typ = "ClientMessageModelOutput"
		c.ClientMessageModelOutput = valueClientMessageModelOutput
		return nil
	}
	valueClientMessageSpeechUpdate := new(ClientMessageSpeechUpdate)
	if err := json.Unmarshal(data, &valueClientMessageSpeechUpdate); err == nil {
		c.typ = "ClientMessageSpeechUpdate"
		c.ClientMessageSpeechUpdate = valueClientMessageSpeechUpdate
		return nil
	}
	valueClientMessageTranscript := new(ClientMessageTranscript)
	if err := json.Unmarshal(data, &valueClientMessageTranscript); err == nil {
		c.typ = "ClientMessageTranscript"
		c.ClientMessageTranscript = valueClientMessageTranscript
		return nil
	}
	valueClientMessageToolCalls := new(ClientMessageToolCalls)
	if err := json.Unmarshal(data, &valueClientMessageToolCalls); err == nil {
		c.typ = "ClientMessageToolCalls"
		c.ClientMessageToolCalls = valueClientMessageToolCalls
		return nil
	}
	valueClientMessageToolCallsResult := new(ClientMessageToolCallsResult)
	if err := json.Unmarshal(data, &valueClientMessageToolCallsResult); err == nil {
		c.typ = "ClientMessageToolCallsResult"
		c.ClientMessageToolCallsResult = valueClientMessageToolCallsResult
		return nil
	}
	valueClientMessageTransferUpdate := new(ClientMessageTransferUpdate)
	if err := json.Unmarshal(data, &valueClientMessageTransferUpdate); err == nil {
		c.typ = "ClientMessageTransferUpdate"
		c.ClientMessageTransferUpdate = valueClientMessageTransferUpdate
		return nil
	}
	valueClientMessageUserInterrupted := new(ClientMessageUserInterrupted)
	if err := json.Unmarshal(data, &valueClientMessageUserInterrupted); err == nil {
		c.typ = "ClientMessageUserInterrupted"
		c.ClientMessageUserInterrupted = valueClientMessageUserInterrupted
		return nil
	}
	valueClientMessageLanguageChangeDetected := new(ClientMessageLanguageChangeDetected)
	if err := json.Unmarshal(data, &valueClientMessageLanguageChangeDetected); err == nil {
		c.typ = "ClientMessageLanguageChangeDetected"
		c.ClientMessageLanguageChangeDetected = valueClientMessageLanguageChangeDetected
		return nil
	}
	valueClientMessageVoiceInput := new(ClientMessageVoiceInput)
	if err := json.Unmarshal(data, &valueClientMessageVoiceInput); err == nil {
		c.typ = "ClientMessageVoiceInput"
		c.ClientMessageVoiceInput = valueClientMessageVoiceInput
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageMessage) MarshalJSON() ([]byte, error) {
	if c.typ == "ClientMessageWorkflowNodeStarted" || c.ClientMessageWorkflowNodeStarted != nil {
		return json.Marshal(c.ClientMessageWorkflowNodeStarted)
	}
	if c.typ == "ClientMessageConversationUpdate" || c.ClientMessageConversationUpdate != nil {
		return json.Marshal(c.ClientMessageConversationUpdate)
	}
	if c.typ == "ClientMessageHang" || c.ClientMessageHang != nil {
		return json.Marshal(c.ClientMessageHang)
	}
	if c.typ == "ClientMessageMetadata" || c.ClientMessageMetadata != nil {
		return json.Marshal(c.ClientMessageMetadata)
	}
	if c.typ == "ClientMessageModelOutput" || c.ClientMessageModelOutput != nil {
		return json.Marshal(c.ClientMessageModelOutput)
	}
	if c.typ == "ClientMessageSpeechUpdate" || c.ClientMessageSpeechUpdate != nil {
		return json.Marshal(c.ClientMessageSpeechUpdate)
	}
	if c.typ == "ClientMessageTranscript" || c.ClientMessageTranscript != nil {
		return json.Marshal(c.ClientMessageTranscript)
	}
	if c.typ == "ClientMessageToolCalls" || c.ClientMessageToolCalls != nil {
		return json.Marshal(c.ClientMessageToolCalls)
	}
	if c.typ == "ClientMessageToolCallsResult" || c.ClientMessageToolCallsResult != nil {
		return json.Marshal(c.ClientMessageToolCallsResult)
	}
	if c.typ == "ClientMessageTransferUpdate" || c.ClientMessageTransferUpdate != nil {
		return json.Marshal(c.ClientMessageTransferUpdate)
	}
	if c.typ == "ClientMessageUserInterrupted" || c.ClientMessageUserInterrupted != nil {
		return json.Marshal(c.ClientMessageUserInterrupted)
	}
	if c.typ == "ClientMessageLanguageChangeDetected" || c.ClientMessageLanguageChangeDetected != nil {
		return json.Marshal(c.ClientMessageLanguageChangeDetected)
	}
	if c.typ == "ClientMessageVoiceInput" || c.ClientMessageVoiceInput != nil {
		return json.Marshal(c.ClientMessageVoiceInput)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageMessageVisitor interface {
	VisitClientMessageWorkflowNodeStarted(*ClientMessageWorkflowNodeStarted) error
	VisitClientMessageConversationUpdate(*ClientMessageConversationUpdate) error
	VisitClientMessageHang(*ClientMessageHang) error
	VisitClientMessageMetadata(*ClientMessageMetadata) error
	VisitClientMessageModelOutput(*ClientMessageModelOutput) error
	VisitClientMessageSpeechUpdate(*ClientMessageSpeechUpdate) error
	VisitClientMessageTranscript(*ClientMessageTranscript) error
	VisitClientMessageToolCalls(*ClientMessageToolCalls) error
	VisitClientMessageToolCallsResult(*ClientMessageToolCallsResult) error
	VisitClientMessageTransferUpdate(*ClientMessageTransferUpdate) error
	VisitClientMessageUserInterrupted(*ClientMessageUserInterrupted) error
	VisitClientMessageLanguageChangeDetected(*ClientMessageLanguageChangeDetected) error
	VisitClientMessageVoiceInput(*ClientMessageVoiceInput) error
}

func (c *ClientMessageMessage) Accept(visitor ClientMessageMessageVisitor) error {
	if c.typ == "ClientMessageWorkflowNodeStarted" || c.ClientMessageWorkflowNodeStarted != nil {
		return visitor.VisitClientMessageWorkflowNodeStarted(c.ClientMessageWorkflowNodeStarted)
	}
	if c.typ == "ClientMessageConversationUpdate" || c.ClientMessageConversationUpdate != nil {
		return visitor.VisitClientMessageConversationUpdate(c.ClientMessageConversationUpdate)
	}
	if c.typ == "ClientMessageHang" || c.ClientMessageHang != nil {
		return visitor.VisitClientMessageHang(c.ClientMessageHang)
	}
	if c.typ == "ClientMessageMetadata" || c.ClientMessageMetadata != nil {
		return visitor.VisitClientMessageMetadata(c.ClientMessageMetadata)
	}
	if c.typ == "ClientMessageModelOutput" || c.ClientMessageModelOutput != nil {
		return visitor.VisitClientMessageModelOutput(c.ClientMessageModelOutput)
	}
	if c.typ == "ClientMessageSpeechUpdate" || c.ClientMessageSpeechUpdate != nil {
		return visitor.VisitClientMessageSpeechUpdate(c.ClientMessageSpeechUpdate)
	}
	if c.typ == "ClientMessageTranscript" || c.ClientMessageTranscript != nil {
		return visitor.VisitClientMessageTranscript(c.ClientMessageTranscript)
	}
	if c.typ == "ClientMessageToolCalls" || c.ClientMessageToolCalls != nil {
		return visitor.VisitClientMessageToolCalls(c.ClientMessageToolCalls)
	}
	if c.typ == "ClientMessageToolCallsResult" || c.ClientMessageToolCallsResult != nil {
		return visitor.VisitClientMessageToolCallsResult(c.ClientMessageToolCallsResult)
	}
	if c.typ == "ClientMessageTransferUpdate" || c.ClientMessageTransferUpdate != nil {
		return visitor.VisitClientMessageTransferUpdate(c.ClientMessageTransferUpdate)
	}
	if c.typ == "ClientMessageUserInterrupted" || c.ClientMessageUserInterrupted != nil {
		return visitor.VisitClientMessageUserInterrupted(c.ClientMessageUserInterrupted)
	}
	if c.typ == "ClientMessageLanguageChangeDetected" || c.ClientMessageLanguageChangeDetected != nil {
		return visitor.VisitClientMessageLanguageChangeDetected(c.ClientMessageLanguageChangeDetected)
	}
	if c.typ == "ClientMessageVoiceInput" || c.ClientMessageVoiceInput != nil {
		return visitor.VisitClientMessageVoiceInput(c.ClientMessageVoiceInput)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageMetadata struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageMetadataPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "metadata" is sent to forward metadata to the client.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the metadata content
	Metadata string `json:"metadata" url:"metadata"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageMetadata) GetPhoneNumber() *ClientMessageMetadataPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageMetadata) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageMetadata) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageMetadata) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageMetadata) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageMetadata) GetMetadata() string {
	if c == nil {
		return ""
	}
	return c.Metadata
}

func (c *ClientMessageMetadata) Type() string {
	return c.type_
}

func (c *ClientMessageMetadata) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageMetadata) UnmarshalJSON(data []byte) error {
	type embed ClientMessageMetadata
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageMetadata(unmarshaler.embed)
	if unmarshaler.Type != "metadata" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "metadata", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageMetadata) MarshalJSON() ([]byte, error) {
	type embed ClientMessageMetadata
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "metadata",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageMetadata) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageMetadataPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageMetadataPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageMetadataPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageMetadataPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageMetadataPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageMetadataPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageMetadataPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageMetadataPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageMetadataPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageMetadataPhoneNumber) Accept(visitor ClientMessageMetadataPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageModelOutput struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageModelOutputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "model-output" is sent as the model outputs tokens.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the output of the model. It can be a token or tool call.
	Output map[string]interface{} `json:"output,omitempty" url:"output,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageModelOutput) GetPhoneNumber() *ClientMessageModelOutputPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageModelOutput) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageModelOutput) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageModelOutput) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageModelOutput) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageModelOutput) GetOutput() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Output
}

func (c *ClientMessageModelOutput) Type() string {
	return c.type_
}

func (c *ClientMessageModelOutput) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageModelOutput) UnmarshalJSON(data []byte) error {
	type embed ClientMessageModelOutput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageModelOutput(unmarshaler.embed)
	if unmarshaler.Type != "model-output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "model-output", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageModelOutput) MarshalJSON() ([]byte, error) {
	type embed ClientMessageModelOutput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "model-output",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageModelOutput) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageModelOutputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageModelOutputPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageModelOutputPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageModelOutputPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageModelOutputPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageModelOutputPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageModelOutputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageModelOutputPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageModelOutputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageModelOutputPhoneNumber) Accept(visitor ClientMessageModelOutputPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageSpeechUpdate struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageSpeechUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "speech-update" is sent whenever assistant or user start or stop speaking.
	// This is the status of the speech update.
	Status ClientMessageSpeechUpdateStatus `json:"status" url:"status"`
	// This is the role which the speech update is for.
	Role ClientMessageSpeechUpdateRole `json:"role" url:"role"`
	// This is the turn number of the speech update (0-indexed).
	Turn *float64 `json:"turn,omitempty" url:"turn,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	type_     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageSpeechUpdate) GetPhoneNumber() *ClientMessageSpeechUpdatePhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageSpeechUpdate) GetStatus() ClientMessageSpeechUpdateStatus {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *ClientMessageSpeechUpdate) GetRole() ClientMessageSpeechUpdateRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ClientMessageSpeechUpdate) GetTurn() *float64 {
	if c == nil {
		return nil
	}
	return c.Turn
}

func (c *ClientMessageSpeechUpdate) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageSpeechUpdate) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageSpeechUpdate) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageSpeechUpdate) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageSpeechUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageSpeechUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageSpeechUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageSpeechUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageSpeechUpdate(unmarshaler.embed)
	if unmarshaler.Type != "speech-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "speech-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageSpeechUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageSpeechUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "speech-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageSpeechUpdate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageSpeechUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageSpeechUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageSpeechUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageSpeechUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageSpeechUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageSpeechUpdatePhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageSpeechUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageSpeechUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageSpeechUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageSpeechUpdatePhoneNumber) Accept(visitor ClientMessageSpeechUpdatePhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the role which the speech update is for.
type ClientMessageSpeechUpdateRole string

const (
	ClientMessageSpeechUpdateRoleAssistant ClientMessageSpeechUpdateRole = "assistant"
	ClientMessageSpeechUpdateRoleUser      ClientMessageSpeechUpdateRole = "user"
)

func NewClientMessageSpeechUpdateRoleFromString(s string) (ClientMessageSpeechUpdateRole, error) {
	switch s {
	case "assistant":
		return ClientMessageSpeechUpdateRoleAssistant, nil
	case "user":
		return ClientMessageSpeechUpdateRoleUser, nil
	}
	var t ClientMessageSpeechUpdateRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageSpeechUpdateRole) Ptr() *ClientMessageSpeechUpdateRole {
	return &c
}

// This is the status of the speech update.
type ClientMessageSpeechUpdateStatus string

const (
	ClientMessageSpeechUpdateStatusStarted ClientMessageSpeechUpdateStatus = "started"
	ClientMessageSpeechUpdateStatusStopped ClientMessageSpeechUpdateStatus = "stopped"
)

func NewClientMessageSpeechUpdateStatusFromString(s string) (ClientMessageSpeechUpdateStatus, error) {
	switch s {
	case "started":
		return ClientMessageSpeechUpdateStatusStarted, nil
	case "stopped":
		return ClientMessageSpeechUpdateStatusStopped, nil
	}
	var t ClientMessageSpeechUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageSpeechUpdateStatus) Ptr() *ClientMessageSpeechUpdateStatus {
	return &c
}

type ClientMessageToolCalls struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageToolCallsPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "tool-calls" is sent to call a tool.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the list of tools calls that the model is requesting along with the original tool configuration.
	ToolWithToolCallList []*ClientMessageToolCallsToolWithToolCallListItem `json:"toolWithToolCallList,omitempty" url:"toolWithToolCallList,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the list of tool calls that the model is requesting.
	ToolCallList []*ToolCall `json:"toolCallList,omitempty" url:"toolCallList,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageToolCalls) GetPhoneNumber() *ClientMessageToolCallsPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageToolCalls) GetToolWithToolCallList() []*ClientMessageToolCallsToolWithToolCallListItem {
	if c == nil {
		return nil
	}
	return c.ToolWithToolCallList
}

func (c *ClientMessageToolCalls) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageToolCalls) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageToolCalls) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageToolCalls) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageToolCalls) GetToolCallList() []*ToolCall {
	if c == nil {
		return nil
	}
	return c.ToolCallList
}

func (c *ClientMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientMessageToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageToolCalls) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageToolCallsPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageToolCallsPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageToolCallsPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageToolCallsPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageToolCallsPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageToolCallsPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageToolCallsPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageToolCallsPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageToolCallsPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageToolCallsPhoneNumber) Accept(visitor ClientMessageToolCallsPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageToolCallsResult struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageToolCallsResultPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "tool-calls-result" is sent to forward the result of a tool call to the client.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the result of the tool call.
	ToolCallResult map[string]interface{} `json:"toolCallResult,omitempty" url:"toolCallResult,omitempty"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageToolCallsResult) GetPhoneNumber() *ClientMessageToolCallsResultPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageToolCallsResult) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageToolCallsResult) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageToolCallsResult) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageToolCallsResult) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageToolCallsResult) GetToolCallResult() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.ToolCallResult
}

func (c *ClientMessageToolCallsResult) Type() string {
	return c.type_
}

func (c *ClientMessageToolCallsResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageToolCallsResult) UnmarshalJSON(data []byte) error {
	type embed ClientMessageToolCallsResult
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageToolCallsResult(unmarshaler.embed)
	if unmarshaler.Type != "tool-calls-result" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool-calls-result", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageToolCallsResult) MarshalJSON() ([]byte, error) {
	type embed ClientMessageToolCallsResult
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool-calls-result",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageToolCallsResult) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageToolCallsResultPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageToolCallsResultPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageToolCallsResultPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageToolCallsResultPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageToolCallsResultPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageToolCallsResultPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageToolCallsResultPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageToolCallsResultPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageToolCallsResultPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageToolCallsResultPhoneNumber) Accept(visitor ClientMessageToolCallsResultPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageToolCallsToolWithToolCallListItem struct {
	FunctionToolWithToolCall                  *FunctionToolWithToolCall
	GhlToolWithToolCall                       *GhlToolWithToolCall
	MakeToolWithToolCall                      *MakeToolWithToolCall
	BashToolWithToolCall                      *BashToolWithToolCall
	ComputerToolWithToolCall                  *ComputerToolWithToolCall
	TextEditorToolWithToolCall                *TextEditorToolWithToolCall
	GoogleCalendarCreateEventToolWithToolCall *GoogleCalendarCreateEventToolWithToolCall

	typ string
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetFunctionToolWithToolCall() *FunctionToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.FunctionToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetGhlToolWithToolCall() *GhlToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.GhlToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetMakeToolWithToolCall() *MakeToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.MakeToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetBashToolWithToolCall() *BashToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.BashToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetComputerToolWithToolCall() *ComputerToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.ComputerToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetTextEditorToolWithToolCall() *TextEditorToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.TextEditorToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetGoogleCalendarCreateEventToolWithToolCall() *GoogleCalendarCreateEventToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.GoogleCalendarCreateEventToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) UnmarshalJSON(data []byte) error {
	valueFunctionToolWithToolCall := new(FunctionToolWithToolCall)
	if err := json.Unmarshal(data, &valueFunctionToolWithToolCall); err == nil {
		c.typ = "FunctionToolWithToolCall"
		c.FunctionToolWithToolCall = valueFunctionToolWithToolCall
		return nil
	}
	valueGhlToolWithToolCall := new(GhlToolWithToolCall)
	if err := json.Unmarshal(data, &valueGhlToolWithToolCall); err == nil {
		c.typ = "GhlToolWithToolCall"
		c.GhlToolWithToolCall = valueGhlToolWithToolCall
		return nil
	}
	valueMakeToolWithToolCall := new(MakeToolWithToolCall)
	if err := json.Unmarshal(data, &valueMakeToolWithToolCall); err == nil {
		c.typ = "MakeToolWithToolCall"
		c.MakeToolWithToolCall = valueMakeToolWithToolCall
		return nil
	}
	valueBashToolWithToolCall := new(BashToolWithToolCall)
	if err := json.Unmarshal(data, &valueBashToolWithToolCall); err == nil {
		c.typ = "BashToolWithToolCall"
		c.BashToolWithToolCall = valueBashToolWithToolCall
		return nil
	}
	valueComputerToolWithToolCall := new(ComputerToolWithToolCall)
	if err := json.Unmarshal(data, &valueComputerToolWithToolCall); err == nil {
		c.typ = "ComputerToolWithToolCall"
		c.ComputerToolWithToolCall = valueComputerToolWithToolCall
		return nil
	}
	valueTextEditorToolWithToolCall := new(TextEditorToolWithToolCall)
	if err := json.Unmarshal(data, &valueTextEditorToolWithToolCall); err == nil {
		c.typ = "TextEditorToolWithToolCall"
		c.TextEditorToolWithToolCall = valueTextEditorToolWithToolCall
		return nil
	}
	valueGoogleCalendarCreateEventToolWithToolCall := new(GoogleCalendarCreateEventToolWithToolCall)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventToolWithToolCall); err == nil {
		c.typ = "GoogleCalendarCreateEventToolWithToolCall"
		c.GoogleCalendarCreateEventToolWithToolCall = valueGoogleCalendarCreateEventToolWithToolCall
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageToolCallsToolWithToolCallListItem) MarshalJSON() ([]byte, error) {
	if c.typ == "FunctionToolWithToolCall" || c.FunctionToolWithToolCall != nil {
		return json.Marshal(c.FunctionToolWithToolCall)
	}
	if c.typ == "GhlToolWithToolCall" || c.GhlToolWithToolCall != nil {
		return json.Marshal(c.GhlToolWithToolCall)
	}
	if c.typ == "MakeToolWithToolCall" || c.MakeToolWithToolCall != nil {
		return json.Marshal(c.MakeToolWithToolCall)
	}
	if c.typ == "BashToolWithToolCall" || c.BashToolWithToolCall != nil {
		return json.Marshal(c.BashToolWithToolCall)
	}
	if c.typ == "ComputerToolWithToolCall" || c.ComputerToolWithToolCall != nil {
		return json.Marshal(c.ComputerToolWithToolCall)
	}
	if c.typ == "TextEditorToolWithToolCall" || c.TextEditorToolWithToolCall != nil {
		return json.Marshal(c.TextEditorToolWithToolCall)
	}
	if c.typ == "GoogleCalendarCreateEventToolWithToolCall" || c.GoogleCalendarCreateEventToolWithToolCall != nil {
		return json.Marshal(c.GoogleCalendarCreateEventToolWithToolCall)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageToolCallsToolWithToolCallListItemVisitor interface {
	VisitFunctionToolWithToolCall(*FunctionToolWithToolCall) error
	VisitGhlToolWithToolCall(*GhlToolWithToolCall) error
	VisitMakeToolWithToolCall(*MakeToolWithToolCall) error
	VisitBashToolWithToolCall(*BashToolWithToolCall) error
	VisitComputerToolWithToolCall(*ComputerToolWithToolCall) error
	VisitTextEditorToolWithToolCall(*TextEditorToolWithToolCall) error
	VisitGoogleCalendarCreateEventToolWithToolCall(*GoogleCalendarCreateEventToolWithToolCall) error
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) Accept(visitor ClientMessageToolCallsToolWithToolCallListItemVisitor) error {
	if c.typ == "FunctionToolWithToolCall" || c.FunctionToolWithToolCall != nil {
		return visitor.VisitFunctionToolWithToolCall(c.FunctionToolWithToolCall)
	}
	if c.typ == "GhlToolWithToolCall" || c.GhlToolWithToolCall != nil {
		return visitor.VisitGhlToolWithToolCall(c.GhlToolWithToolCall)
	}
	if c.typ == "MakeToolWithToolCall" || c.MakeToolWithToolCall != nil {
		return visitor.VisitMakeToolWithToolCall(c.MakeToolWithToolCall)
	}
	if c.typ == "BashToolWithToolCall" || c.BashToolWithToolCall != nil {
		return visitor.VisitBashToolWithToolCall(c.BashToolWithToolCall)
	}
	if c.typ == "ComputerToolWithToolCall" || c.ComputerToolWithToolCall != nil {
		return visitor.VisitComputerToolWithToolCall(c.ComputerToolWithToolCall)
	}
	if c.typ == "TextEditorToolWithToolCall" || c.TextEditorToolWithToolCall != nil {
		return visitor.VisitTextEditorToolWithToolCall(c.TextEditorToolWithToolCall)
	}
	if c.typ == "GoogleCalendarCreateEventToolWithToolCall" || c.GoogleCalendarCreateEventToolWithToolCall != nil {
		return visitor.VisitGoogleCalendarCreateEventToolWithToolCall(c.GoogleCalendarCreateEventToolWithToolCall)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageTranscript struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageTranscriptPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
	Type ClientMessageTranscriptType `json:"type" url:"type"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the role for which the transcript is for.
	Role ClientMessageTranscriptRole `json:"role" url:"role"`
	// This is the type of the transcript.
	TranscriptType ClientMessageTranscriptTranscriptType `json:"transcriptType" url:"transcriptType"`
	// This is the transcript content.
	Transcript string `json:"transcript" url:"transcript"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageTranscript) GetPhoneNumber() *ClientMessageTranscriptPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageTranscript) GetType() ClientMessageTranscriptType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientMessageTranscript) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageTranscript) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageTranscript) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageTranscript) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageTranscript) GetRole() ClientMessageTranscriptRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ClientMessageTranscript) GetTranscriptType() ClientMessageTranscriptTranscriptType {
	if c == nil {
		return ""
	}
	return c.TranscriptType
}

func (c *ClientMessageTranscript) GetTranscript() string {
	if c == nil {
		return ""
	}
	return c.Transcript
}

func (c *ClientMessageTranscript) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageTranscript) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientMessageTranscript
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientMessageTranscript(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageTranscript) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageTranscriptPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageTranscriptPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageTranscriptPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageTranscriptPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageTranscriptPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageTranscriptPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageTranscriptPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageTranscriptPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageTranscriptPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageTranscriptPhoneNumber) Accept(visitor ClientMessageTranscriptPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the role for which the transcript is for.
type ClientMessageTranscriptRole string

const (
	ClientMessageTranscriptRoleAssistant ClientMessageTranscriptRole = "assistant"
	ClientMessageTranscriptRoleUser      ClientMessageTranscriptRole = "user"
)

func NewClientMessageTranscriptRoleFromString(s string) (ClientMessageTranscriptRole, error) {
	switch s {
	case "assistant":
		return ClientMessageTranscriptRoleAssistant, nil
	case "user":
		return ClientMessageTranscriptRoleUser, nil
	}
	var t ClientMessageTranscriptRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageTranscriptRole) Ptr() *ClientMessageTranscriptRole {
	return &c
}

// This is the type of the transcript.
type ClientMessageTranscriptTranscriptType string

const (
	ClientMessageTranscriptTranscriptTypePartial ClientMessageTranscriptTranscriptType = "partial"
	ClientMessageTranscriptTranscriptTypeFinal   ClientMessageTranscriptTranscriptType = "final"
)

func NewClientMessageTranscriptTranscriptTypeFromString(s string) (ClientMessageTranscriptTranscriptType, error) {
	switch s {
	case "partial":
		return ClientMessageTranscriptTranscriptTypePartial, nil
	case "final":
		return ClientMessageTranscriptTranscriptTypeFinal, nil
	}
	var t ClientMessageTranscriptTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageTranscriptTranscriptType) Ptr() *ClientMessageTranscriptTranscriptType {
	return &c
}

// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
type ClientMessageTranscriptType string

const (
	ClientMessageTranscriptTypeTranscript                    ClientMessageTranscriptType = "transcript"
	ClientMessageTranscriptTypeTranscriptTranscriptTypeFinal ClientMessageTranscriptType = "transcript[transcriptType=\\\"final\\\"]"
)

func NewClientMessageTranscriptTypeFromString(s string) (ClientMessageTranscriptType, error) {
	switch s {
	case "transcript":
		return ClientMessageTranscriptTypeTranscript, nil
	case "transcript[transcriptType=\"final\"]":
		return ClientMessageTranscriptTypeTranscriptTranscriptTypeFinal, nil
	}
	var t ClientMessageTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageTranscriptType) Ptr() *ClientMessageTranscriptType {
	return &c
}

type ClientMessageTransferUpdate struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageTransferUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transfer-update" is sent whenever a transfer happens.
	// This is the destination of the transfer.
	Destination *ClientMessageTransferUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the assistant that the call is being transferred to. This is only sent if `destination.type` is "assistant".
	ToAssistant *CreateAssistantDto `json:"toAssistant,omitempty" url:"toAssistant,omitempty"`
	// This is the assistant that the call is being transferred from. This is only sent if `destination.type` is "assistant".
	FromAssistant *CreateAssistantDto `json:"fromAssistant,omitempty" url:"fromAssistant,omitempty"`
	// This is the step that the conversation moved to.
	ToStepRecord map[string]interface{} `json:"toStepRecord,omitempty" url:"toStepRecord,omitempty"`
	// This is the step that the conversation moved from. =
	FromStepRecord map[string]interface{} `json:"fromStepRecord,omitempty" url:"fromStepRecord,omitempty"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageTransferUpdate) GetPhoneNumber() *ClientMessageTransferUpdatePhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageTransferUpdate) GetDestination() *ClientMessageTransferUpdateDestination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *ClientMessageTransferUpdate) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageTransferUpdate) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageTransferUpdate) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageTransferUpdate) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageTransferUpdate) GetToAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.ToAssistant
}

func (c *ClientMessageTransferUpdate) GetFromAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.FromAssistant
}

func (c *ClientMessageTransferUpdate) GetToStepRecord() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.ToStepRecord
}

func (c *ClientMessageTransferUpdate) GetFromStepRecord() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FromStepRecord
}

func (c *ClientMessageTransferUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageTransferUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageTransferUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageTransferUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageTransferUpdate(unmarshaler.embed)
	if unmarshaler.Type != "transfer-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transfer-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageTransferUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageTransferUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transfer-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageTransferUpdate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the destination of the transfer.
type ClientMessageTransferUpdateDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (c *ClientMessageTransferUpdateDestination) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if c == nil {
		return nil
	}
	return c.TransferDestinationAssistant
}

func (c *ClientMessageTransferUpdateDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if c == nil {
		return nil
	}
	return c.TransferDestinationNumber
}

func (c *ClientMessageTransferUpdateDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if c == nil {
		return nil
	}
	return c.TransferDestinationSip
}

func (c *ClientMessageTransferUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		c.typ = "TransferDestinationAssistant"
		c.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.typ = "TransferDestinationNumber"
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.typ = "TransferDestinationSip"
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageTransferUpdateDestination) MarshalJSON() ([]byte, error) {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return json.Marshal(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageTransferUpdateDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *ClientMessageTransferUpdateDestination) Accept(visitor ClientMessageTransferUpdateDestinationVisitor) error {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the phone number that the message is associated with.
type ClientMessageTransferUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageTransferUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageTransferUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageTransferUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageTransferUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageTransferUpdatePhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageTransferUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageTransferUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageTransferUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageTransferUpdatePhoneNumber) Accept(visitor ClientMessageTransferUpdatePhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageUserInterrupted struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageUserInterruptedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "user-interrupted" is sent when the user interrupts the assistant.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	type_     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageUserInterrupted) GetPhoneNumber() *ClientMessageUserInterruptedPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageUserInterrupted) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageUserInterrupted) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageUserInterrupted) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageUserInterrupted) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageUserInterrupted) Type() string {
	return c.type_
}

func (c *ClientMessageUserInterrupted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageUserInterrupted) UnmarshalJSON(data []byte) error {
	type embed ClientMessageUserInterrupted
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageUserInterrupted(unmarshaler.embed)
	if unmarshaler.Type != "user-interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "user-interrupted", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageUserInterrupted) MarshalJSON() ([]byte, error) {
	type embed ClientMessageUserInterrupted
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "user-interrupted",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageUserInterrupted) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageUserInterruptedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageUserInterruptedPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageUserInterruptedPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageUserInterruptedPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageUserInterruptedPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageUserInterruptedPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageUserInterruptedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageUserInterruptedPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageUserInterruptedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageUserInterruptedPhoneNumber) Accept(visitor ClientMessageUserInterruptedPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageVoiceInput struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageVoiceInputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "voice-input" is sent when a generation is requested from voice provider.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the voice input content
	Input string `json:"input" url:"input"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageVoiceInput) GetPhoneNumber() *ClientMessageVoiceInputPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageVoiceInput) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageVoiceInput) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageVoiceInput) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageVoiceInput) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageVoiceInput) GetInput() string {
	if c == nil {
		return ""
	}
	return c.Input
}

func (c *ClientMessageVoiceInput) Type() string {
	return c.type_
}

func (c *ClientMessageVoiceInput) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageVoiceInput) UnmarshalJSON(data []byte) error {
	type embed ClientMessageVoiceInput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageVoiceInput(unmarshaler.embed)
	if unmarshaler.Type != "voice-input" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "voice-input", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageVoiceInput) MarshalJSON() ([]byte, error) {
	type embed ClientMessageVoiceInput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "voice-input",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageVoiceInput) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageVoiceInputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageVoiceInputPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageVoiceInputPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageVoiceInputPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageVoiceInputPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageVoiceInputPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageVoiceInputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageVoiceInputPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageVoiceInputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageVoiceInputPhoneNumber) Accept(visitor ClientMessageVoiceInputPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageWorkflowNodeStarted struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ClientMessageWorkflowNodeStartedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "workflow.node.started" is sent when the active node changes.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the active node.
	Node  map[string]interface{} `json:"node,omitempty" url:"node,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageWorkflowNodeStarted) GetPhoneNumber() *ClientMessageWorkflowNodeStartedPhoneNumber {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *ClientMessageWorkflowNodeStarted) GetTimestamp() *float64 {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ClientMessageWorkflowNodeStarted) GetCall() *Call {
	if c == nil {
		return nil
	}
	return c.Call
}

func (c *ClientMessageWorkflowNodeStarted) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *ClientMessageWorkflowNodeStarted) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ClientMessageWorkflowNodeStarted) GetNode() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Node
}

func (c *ClientMessageWorkflowNodeStarted) Type() string {
	return c.type_
}

func (c *ClientMessageWorkflowNodeStarted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageWorkflowNodeStarted) UnmarshalJSON(data []byte) error {
	type embed ClientMessageWorkflowNodeStarted
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageWorkflowNodeStarted(unmarshaler.embed)
	if unmarshaler.Type != "workflow.node.started" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "workflow.node.started", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageWorkflowNodeStarted) MarshalJSON() ([]byte, error) {
	type embed ClientMessageWorkflowNodeStarted
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "workflow.node.started",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageWorkflowNodeStarted) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the phone number that the message is associated with.
type ClientMessageWorkflowNodeStartedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (c *ClientMessageWorkflowNodeStartedPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateByoPhoneNumberDto
}

func (c *ClientMessageWorkflowNodeStartedPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioPhoneNumberDto
}

func (c *ClientMessageWorkflowNodeStartedPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVonagePhoneNumberDto
}

func (c *ClientMessageWorkflowNodeStartedPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateVapiPhoneNumberDto
}

func (c *ClientMessageWorkflowNodeStartedPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.CreateTelnyxPhoneNumberDto
}

func (c *ClientMessageWorkflowNodeStartedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		c.typ = "CreateByoPhoneNumberDto"
		c.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		c.typ = "CreateTwilioPhoneNumberDto"
		c.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		c.typ = "CreateVonagePhoneNumberDto"
		c.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		c.typ = "CreateVapiPhoneNumberDto"
		c.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		c.typ = "CreateTelnyxPhoneNumberDto"
		c.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageWorkflowNodeStartedPhoneNumber) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return json.Marshal(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(c.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageWorkflowNodeStartedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (c *ClientMessageWorkflowNodeStartedPhoneNumber) Accept(visitor ClientMessageWorkflowNodeStartedPhoneNumberVisitor) error {
	if c.typ == "CreateByoPhoneNumberDto" || c.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(c.CreateByoPhoneNumberDto)
	}
	if c.typ == "CreateTwilioPhoneNumberDto" || c.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(c.CreateTwilioPhoneNumberDto)
	}
	if c.typ == "CreateVonagePhoneNumberDto" || c.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(c.CreateVonagePhoneNumberDto)
	}
	if c.typ == "CreateVapiPhoneNumberDto" || c.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(c.CreateVapiPhoneNumberDto)
	}
	if c.typ == "CreateTelnyxPhoneNumberDto" || c.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(c.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CloneVoiceDto struct {
	// This is the name of the cloned voice in the provider account.
	Name string `json:"name" url:"name"`
	// This is the description of your cloned voice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Serialized labels dictionary for the voice.
	Labels *string `json:"labels,omitempty" url:"labels,omitempty"`
	// These are the files you want to use to clone your voice. Only Audio files are supported.
	Files []string `json:"files,omitempty" url:"files,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CloneVoiceDto) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CloneVoiceDto) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CloneVoiceDto) GetLabels() *string {
	if c == nil {
		return nil
	}
	return c.Labels
}

func (c *CloneVoiceDto) GetFiles() []string {
	if c == nil {
		return nil
	}
	return c.Files
}

func (c *CloneVoiceDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloneVoiceDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CloneVoiceDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloneVoiceDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloneVoiceDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CloudflareCredential struct {
	// Credential provider. Only allowed value is cloudflare
	// Cloudflare Account Id.
	AccountId *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Cloudflare API Key / Token.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// Cloudflare Account Email.
	AccountEmail *string `json:"accountEmail,omitempty" url:"accountEmail,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in R2
	BucketPlan *CloudflareR2BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CloudflareCredential) GetAccountId() *string {
	if c == nil {
		return nil
	}
	return c.AccountId
}

func (c *CloudflareCredential) GetApiKey() *string {
	if c == nil {
		return nil
	}
	return c.ApiKey
}

func (c *CloudflareCredential) GetAccountEmail() *string {
	if c == nil {
		return nil
	}
	return c.AccountEmail
}

func (c *CloudflareCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CloudflareCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CloudflareCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CloudflareCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CloudflareCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CloudflareCredential) GetBucketPlan() *CloudflareR2BucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CloudflareCredential) Provider() string {
	return c.provider
}

func (c *CloudflareCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloudflareCredential) UnmarshalJSON(data []byte) error {
	type embed CloudflareCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CloudflareCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "cloudflare" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cloudflare", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloudflareCredential) MarshalJSON() ([]byte, error) {
	type embed CloudflareCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "cloudflare",
	}
	return json.Marshal(marshaler)
}

func (c *CloudflareCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CloudflareR2BucketPlan struct {
	// Cloudflare R2 Access key ID.
	AccessKeyId *string `json:"accessKeyId,omitempty" url:"accessKeyId,omitempty"`
	// Cloudflare R2 access key secret. This is not returned in the API.
	SecretAccessKey *string `json:"secretAccessKey,omitempty" url:"secretAccessKey,omitempty"`
	// Cloudflare R2 base url.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// This is the name of the bucket.
	Name string `json:"name" url:"name"`
	// This is the path where call artifacts will be stored.
	//
	// Usage:
	// - To store call artifacts in a specific folder, set this to the full path. Eg. "/folder-name1/folder-name2".
	// - To store call artifacts in the root of the bucket, leave this blank.
	//
	// @default "/"
	Path *string `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CloudflareR2BucketPlan) GetAccessKeyId() *string {
	if c == nil {
		return nil
	}
	return c.AccessKeyId
}

func (c *CloudflareR2BucketPlan) GetSecretAccessKey() *string {
	if c == nil {
		return nil
	}
	return c.SecretAccessKey
}

func (c *CloudflareR2BucketPlan) GetUrl() *string {
	if c == nil {
		return nil
	}
	return c.Url
}

func (c *CloudflareR2BucketPlan) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CloudflareR2BucketPlan) GetPath() *string {
	if c == nil {
		return nil
	}
	return c.Path
}

func (c *CloudflareR2BucketPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloudflareR2BucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CloudflareR2BucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloudflareR2BucketPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloudflareR2BucketPlan) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompliancePlan struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored.
	// At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// When this is enabled, the user will be restricted to use PCI-compliant providers, and no logs or transcripts are stored.
	// At the end of the call, you will receive an end-of-call-report message to store on your server. Defaults to false.
	PciEnabled *bool `json:"pciEnabled,omitempty" url:"pciEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CompliancePlan) GetHipaaEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.HipaaEnabled
}

func (c *CompliancePlan) GetPciEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PciEnabled
}

func (c *CompliancePlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompliancePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CompliancePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompliancePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompliancePlan) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ComputerToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*ComputerToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "computer" for Computer tool.
	// The sub type of tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// The name of the tool, fixed to 'computer'
	// The display width in pixels
	DisplayWidthPx float64 `json:"displayWidthPx" url:"displayWidthPx"`
	// The display height in pixels
	DisplayHeightPx float64 `json:"displayHeightPx" url:"displayHeightPx"`
	// Optional display number
	DisplayNumber *float64 `json:"displayNumber,omitempty" url:"displayNumber,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server  *Server `json:"server,omitempty" url:"server,omitempty"`
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ComputerToolWithToolCall) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *ComputerToolWithToolCall) GetMessages() []*ComputerToolWithToolCallMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ComputerToolWithToolCall) GetToolCall() *ToolCall {
	if c == nil {
		return nil
	}
	return c.ToolCall
}

func (c *ComputerToolWithToolCall) GetDisplayWidthPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayWidthPx
}

func (c *ComputerToolWithToolCall) GetDisplayHeightPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayHeightPx
}

func (c *ComputerToolWithToolCall) GetDisplayNumber() *float64 {
	if c == nil {
		return nil
	}
	return c.DisplayNumber
}

func (c *ComputerToolWithToolCall) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *ComputerToolWithToolCall) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *ComputerToolWithToolCall) Type() string {
	return c.type_
}

func (c *ComputerToolWithToolCall) SubType() string {
	return c.subType
}

func (c *ComputerToolWithToolCall) Name() string {
	return c.name
}

func (c *ComputerToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComputerToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed ComputerToolWithToolCall
	var unmarshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ComputerToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "computer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	if unmarshaler.SubType != "computer_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer_20241022", unmarshaler.SubType)
	}
	c.subType = unmarshaler.SubType
	if unmarshaler.Name != "computer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer", unmarshaler.Name)
	}
	c.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type", "subType", "name")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComputerToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed ComputerToolWithToolCall
	var marshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed:   embed(*c),
		Type:    "computer",
		SubType: "computer_20241022",
		Name:    "computer",
	}
	return json.Marshal(marshaler)
}

func (c *ComputerToolWithToolCall) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ComputerToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *ComputerToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *ComputerToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *ComputerToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *ComputerToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *ComputerToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ComputerToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ComputerToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *ComputerToolWithToolCallMessagesItem) Accept(visitor ComputerToolWithToolCallMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type Condition struct {
	// This is the operator you want to use to compare the parameter and value.
	Operator ConditionOperator `json:"operator" url:"operator"`
	// This is the name of the parameter that you want to check.
	Param string `json:"param" url:"param"`
	// This is the value you want to compare against the parameter.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Condition) GetOperator() ConditionOperator {
	if c == nil {
		return ""
	}
	return c.Operator
}

func (c *Condition) GetParam() string {
	if c == nil {
		return ""
	}
	return c.Param
}

func (c *Condition) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *Condition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Condition) UnmarshalJSON(data []byte) error {
	type unmarshaler Condition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Condition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Condition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the operator you want to use to compare the parameter and value.
type ConditionOperator string

const (
	ConditionOperatorEq  ConditionOperator = "eq"
	ConditionOperatorNeq ConditionOperator = "neq"
	ConditionOperatorGt  ConditionOperator = "gt"
	ConditionOperatorGte ConditionOperator = "gte"
	ConditionOperatorLt  ConditionOperator = "lt"
	ConditionOperatorLte ConditionOperator = "lte"
)

func NewConditionOperatorFromString(s string) (ConditionOperator, error) {
	switch s {
	case "eq":
		return ConditionOperatorEq, nil
	case "neq":
		return ConditionOperatorNeq, nil
	case "gt":
		return ConditionOperatorGt, nil
	case "gte":
		return ConditionOperatorGte, nil
	case "lt":
		return ConditionOperatorLt, nil
	case "lte":
		return ConditionOperatorLte, nil
	}
	var t ConditionOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConditionOperator) Ptr() *ConditionOperator {
	return &c
}

type ConversationNode struct {
	// This is the Conversation node. This can be used to start a conversation with the customer.
	//
	// The flow is:
	// - Workflow starts the conversation node
	// - Model is active with the `prompt` and global context.
	// - Model will call a tool to exit this node.
	// - Workflow will extract variables from the conversation.
	// - Workflow continues.
	// This is the model for the Conversation Task.
	Model *ConversationNodeModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's transcriber.
	Transcriber *ConversationNodeTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's voice.
	Voice  *ConversationNodeVoice `json:"voice,omitempty" url:"voice,omitempty"`
	Prompt *string                `json:"prompt,omitempty" url:"prompt,omitempty"`
	// This is the plan for the global node.
	GlobalNodePlan *GlobalNodePlan `json:"globalNodePlan,omitempty" url:"globalNodePlan,omitempty"`
	// This is the plan that controls the variable extraction from the user's response.
	VariableExtractionPlan *VariableExtractionPlan `json:"variableExtractionPlan,omitempty" url:"variableExtractionPlan,omitempty"`
	Name                   string                  `json:"name" url:"name"`
	// This is whether or not the node is the start of the workflow.
	IsStart *bool `json:"isStart,omitempty" url:"isStart,omitempty"`
	// This is for metadata you want to store on the task.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationNode) GetModel() *ConversationNodeModel {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *ConversationNode) GetTranscriber() *ConversationNodeTranscriber {
	if c == nil {
		return nil
	}
	return c.Transcriber
}

func (c *ConversationNode) GetVoice() *ConversationNodeVoice {
	if c == nil {
		return nil
	}
	return c.Voice
}

func (c *ConversationNode) GetPrompt() *string {
	if c == nil {
		return nil
	}
	return c.Prompt
}

func (c *ConversationNode) GetGlobalNodePlan() *GlobalNodePlan {
	if c == nil {
		return nil
	}
	return c.GlobalNodePlan
}

func (c *ConversationNode) GetVariableExtractionPlan() *VariableExtractionPlan {
	if c == nil {
		return nil
	}
	return c.VariableExtractionPlan
}

func (c *ConversationNode) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ConversationNode) GetIsStart() *bool {
	if c == nil {
		return nil
	}
	return c.IsStart
}

func (c *ConversationNode) GetMetadata() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationNode) Type() string {
	return c.type_
}

func (c *ConversationNode) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationNode) UnmarshalJSON(data []byte) error {
	type embed ConversationNode
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationNode(unmarshaler.embed)
	if unmarshaler.Type != "conversation" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationNode) MarshalJSON() ([]byte, error) {
	type embed ConversationNode
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation",
	}
	return json.Marshal(marshaler)
}

func (c *ConversationNode) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the model for the Conversation Task.
type ConversationNodeModel struct {
	WorkflowOpenAiModel    *WorkflowOpenAiModel
	WorkflowAnthropicModel *WorkflowAnthropicModel

	typ string
}

func (c *ConversationNodeModel) GetWorkflowOpenAiModel() *WorkflowOpenAiModel {
	if c == nil {
		return nil
	}
	return c.WorkflowOpenAiModel
}

func (c *ConversationNodeModel) GetWorkflowAnthropicModel() *WorkflowAnthropicModel {
	if c == nil {
		return nil
	}
	return c.WorkflowAnthropicModel
}

func (c *ConversationNodeModel) UnmarshalJSON(data []byte) error {
	valueWorkflowOpenAiModel := new(WorkflowOpenAiModel)
	if err := json.Unmarshal(data, &valueWorkflowOpenAiModel); err == nil {
		c.typ = "WorkflowOpenAiModel"
		c.WorkflowOpenAiModel = valueWorkflowOpenAiModel
		return nil
	}
	valueWorkflowAnthropicModel := new(WorkflowAnthropicModel)
	if err := json.Unmarshal(data, &valueWorkflowAnthropicModel); err == nil {
		c.typ = "WorkflowAnthropicModel"
		c.WorkflowAnthropicModel = valueWorkflowAnthropicModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConversationNodeModel) MarshalJSON() ([]byte, error) {
	if c.typ == "WorkflowOpenAiModel" || c.WorkflowOpenAiModel != nil {
		return json.Marshal(c.WorkflowOpenAiModel)
	}
	if c.typ == "WorkflowAnthropicModel" || c.WorkflowAnthropicModel != nil {
		return json.Marshal(c.WorkflowAnthropicModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ConversationNodeModelVisitor interface {
	VisitWorkflowOpenAiModel(*WorkflowOpenAiModel) error
	VisitWorkflowAnthropicModel(*WorkflowAnthropicModel) error
}

func (c *ConversationNodeModel) Accept(visitor ConversationNodeModelVisitor) error {
	if c.typ == "WorkflowOpenAiModel" || c.WorkflowOpenAiModel != nil {
		return visitor.VisitWorkflowOpenAiModel(c.WorkflowOpenAiModel)
	}
	if c.typ == "WorkflowAnthropicModel" || c.WorkflowAnthropicModel != nil {
		return visitor.VisitWorkflowAnthropicModel(c.WorkflowAnthropicModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are the options for the assistant's transcriber.
type ConversationNodeTranscriber struct {
	AssemblyAiTranscriber   *AssemblyAiTranscriber
	AzureSpeechTranscriber  *AzureSpeechTranscriber
	CustomTranscriber       *CustomTranscriber
	DeepgramTranscriber     *DeepgramTranscriber
	ElevenLabsTranscriber   *ElevenLabsTranscriber
	GladiaTranscriber       *GladiaTranscriber
	GoogleTranscriber       *GoogleTranscriber
	SpeechmaticsTranscriber *SpeechmaticsTranscriber
	TalkscriberTranscriber  *TalkscriberTranscriber
	OpenAiTranscriber       *OpenAiTranscriber

	typ string
}

func (c *ConversationNodeTranscriber) GetAssemblyAiTranscriber() *AssemblyAiTranscriber {
	if c == nil {
		return nil
	}
	return c.AssemblyAiTranscriber
}

func (c *ConversationNodeTranscriber) GetAzureSpeechTranscriber() *AzureSpeechTranscriber {
	if c == nil {
		return nil
	}
	return c.AzureSpeechTranscriber
}

func (c *ConversationNodeTranscriber) GetCustomTranscriber() *CustomTranscriber {
	if c == nil {
		return nil
	}
	return c.CustomTranscriber
}

func (c *ConversationNodeTranscriber) GetDeepgramTranscriber() *DeepgramTranscriber {
	if c == nil {
		return nil
	}
	return c.DeepgramTranscriber
}

func (c *ConversationNodeTranscriber) GetElevenLabsTranscriber() *ElevenLabsTranscriber {
	if c == nil {
		return nil
	}
	return c.ElevenLabsTranscriber
}

func (c *ConversationNodeTranscriber) GetGladiaTranscriber() *GladiaTranscriber {
	if c == nil {
		return nil
	}
	return c.GladiaTranscriber
}

func (c *ConversationNodeTranscriber) GetGoogleTranscriber() *GoogleTranscriber {
	if c == nil {
		return nil
	}
	return c.GoogleTranscriber
}

func (c *ConversationNodeTranscriber) GetSpeechmaticsTranscriber() *SpeechmaticsTranscriber {
	if c == nil {
		return nil
	}
	return c.SpeechmaticsTranscriber
}

func (c *ConversationNodeTranscriber) GetTalkscriberTranscriber() *TalkscriberTranscriber {
	if c == nil {
		return nil
	}
	return c.TalkscriberTranscriber
}

func (c *ConversationNodeTranscriber) GetOpenAiTranscriber() *OpenAiTranscriber {
	if c == nil {
		return nil
	}
	return c.OpenAiTranscriber
}

func (c *ConversationNodeTranscriber) UnmarshalJSON(data []byte) error {
	valueAssemblyAiTranscriber := new(AssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueAssemblyAiTranscriber); err == nil {
		c.typ = "AssemblyAiTranscriber"
		c.AssemblyAiTranscriber = valueAssemblyAiTranscriber
		return nil
	}
	valueAzureSpeechTranscriber := new(AzureSpeechTranscriber)
	if err := json.Unmarshal(data, &valueAzureSpeechTranscriber); err == nil {
		c.typ = "AzureSpeechTranscriber"
		c.AzureSpeechTranscriber = valueAzureSpeechTranscriber
		return nil
	}
	valueCustomTranscriber := new(CustomTranscriber)
	if err := json.Unmarshal(data, &valueCustomTranscriber); err == nil {
		c.typ = "CustomTranscriber"
		c.CustomTranscriber = valueCustomTranscriber
		return nil
	}
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		c.typ = "DeepgramTranscriber"
		c.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueElevenLabsTranscriber := new(ElevenLabsTranscriber)
	if err := json.Unmarshal(data, &valueElevenLabsTranscriber); err == nil {
		c.typ = "ElevenLabsTranscriber"
		c.ElevenLabsTranscriber = valueElevenLabsTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		c.typ = "GladiaTranscriber"
		c.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueGoogleTranscriber := new(GoogleTranscriber)
	if err := json.Unmarshal(data, &valueGoogleTranscriber); err == nil {
		c.typ = "GoogleTranscriber"
		c.GoogleTranscriber = valueGoogleTranscriber
		return nil
	}
	valueSpeechmaticsTranscriber := new(SpeechmaticsTranscriber)
	if err := json.Unmarshal(data, &valueSpeechmaticsTranscriber); err == nil {
		c.typ = "SpeechmaticsTranscriber"
		c.SpeechmaticsTranscriber = valueSpeechmaticsTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		c.typ = "TalkscriberTranscriber"
		c.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	valueOpenAiTranscriber := new(OpenAiTranscriber)
	if err := json.Unmarshal(data, &valueOpenAiTranscriber); err == nil {
		c.typ = "OpenAiTranscriber"
		c.OpenAiTranscriber = valueOpenAiTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConversationNodeTranscriber) MarshalJSON() ([]byte, error) {
	if c.typ == "AssemblyAiTranscriber" || c.AssemblyAiTranscriber != nil {
		return json.Marshal(c.AssemblyAiTranscriber)
	}
	if c.typ == "AzureSpeechTranscriber" || c.AzureSpeechTranscriber != nil {
		return json.Marshal(c.AzureSpeechTranscriber)
	}
	if c.typ == "CustomTranscriber" || c.CustomTranscriber != nil {
		return json.Marshal(c.CustomTranscriber)
	}
	if c.typ == "DeepgramTranscriber" || c.DeepgramTranscriber != nil {
		return json.Marshal(c.DeepgramTranscriber)
	}
	if c.typ == "ElevenLabsTranscriber" || c.ElevenLabsTranscriber != nil {
		return json.Marshal(c.ElevenLabsTranscriber)
	}
	if c.typ == "GladiaTranscriber" || c.GladiaTranscriber != nil {
		return json.Marshal(c.GladiaTranscriber)
	}
	if c.typ == "GoogleTranscriber" || c.GoogleTranscriber != nil {
		return json.Marshal(c.GoogleTranscriber)
	}
	if c.typ == "SpeechmaticsTranscriber" || c.SpeechmaticsTranscriber != nil {
		return json.Marshal(c.SpeechmaticsTranscriber)
	}
	if c.typ == "TalkscriberTranscriber" || c.TalkscriberTranscriber != nil {
		return json.Marshal(c.TalkscriberTranscriber)
	}
	if c.typ == "OpenAiTranscriber" || c.OpenAiTranscriber != nil {
		return json.Marshal(c.OpenAiTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ConversationNodeTranscriberVisitor interface {
	VisitAssemblyAiTranscriber(*AssemblyAiTranscriber) error
	VisitAzureSpeechTranscriber(*AzureSpeechTranscriber) error
	VisitCustomTranscriber(*CustomTranscriber) error
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitElevenLabsTranscriber(*ElevenLabsTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitGoogleTranscriber(*GoogleTranscriber) error
	VisitSpeechmaticsTranscriber(*SpeechmaticsTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
	VisitOpenAiTranscriber(*OpenAiTranscriber) error
}

func (c *ConversationNodeTranscriber) Accept(visitor ConversationNodeTranscriberVisitor) error {
	if c.typ == "AssemblyAiTranscriber" || c.AssemblyAiTranscriber != nil {
		return visitor.VisitAssemblyAiTranscriber(c.AssemblyAiTranscriber)
	}
	if c.typ == "AzureSpeechTranscriber" || c.AzureSpeechTranscriber != nil {
		return visitor.VisitAzureSpeechTranscriber(c.AzureSpeechTranscriber)
	}
	if c.typ == "CustomTranscriber" || c.CustomTranscriber != nil {
		return visitor.VisitCustomTranscriber(c.CustomTranscriber)
	}
	if c.typ == "DeepgramTranscriber" || c.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(c.DeepgramTranscriber)
	}
	if c.typ == "ElevenLabsTranscriber" || c.ElevenLabsTranscriber != nil {
		return visitor.VisitElevenLabsTranscriber(c.ElevenLabsTranscriber)
	}
	if c.typ == "GladiaTranscriber" || c.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(c.GladiaTranscriber)
	}
	if c.typ == "GoogleTranscriber" || c.GoogleTranscriber != nil {
		return visitor.VisitGoogleTranscriber(c.GoogleTranscriber)
	}
	if c.typ == "SpeechmaticsTranscriber" || c.SpeechmaticsTranscriber != nil {
		return visitor.VisitSpeechmaticsTranscriber(c.SpeechmaticsTranscriber)
	}
	if c.typ == "TalkscriberTranscriber" || c.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(c.TalkscriberTranscriber)
	}
	if c.typ == "OpenAiTranscriber" || c.OpenAiTranscriber != nil {
		return visitor.VisitOpenAiTranscriber(c.OpenAiTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are the options for the assistant's voice.
type ConversationNodeVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	CustomVoice     *CustomVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	HumeVoice       *HumeVoice
	LmntVoice       *LmntVoice
	NeuphonicVoice  *NeuphonicVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
	SmallestAiVoice *SmallestAiVoice
	TavusVoice      *TavusVoice
	VapiVoice       *VapiVoice
	SesameVoice     *SesameVoice

	typ string
}

func (c *ConversationNodeVoice) GetAzureVoice() *AzureVoice {
	if c == nil {
		return nil
	}
	return c.AzureVoice
}

func (c *ConversationNodeVoice) GetCartesiaVoice() *CartesiaVoice {
	if c == nil {
		return nil
	}
	return c.CartesiaVoice
}

func (c *ConversationNodeVoice) GetCustomVoice() *CustomVoice {
	if c == nil {
		return nil
	}
	return c.CustomVoice
}

func (c *ConversationNodeVoice) GetDeepgramVoice() *DeepgramVoice {
	if c == nil {
		return nil
	}
	return c.DeepgramVoice
}

func (c *ConversationNodeVoice) GetElevenLabsVoice() *ElevenLabsVoice {
	if c == nil {
		return nil
	}
	return c.ElevenLabsVoice
}

func (c *ConversationNodeVoice) GetHumeVoice() *HumeVoice {
	if c == nil {
		return nil
	}
	return c.HumeVoice
}

func (c *ConversationNodeVoice) GetLmntVoice() *LmntVoice {
	if c == nil {
		return nil
	}
	return c.LmntVoice
}

func (c *ConversationNodeVoice) GetNeuphonicVoice() *NeuphonicVoice {
	if c == nil {
		return nil
	}
	return c.NeuphonicVoice
}

func (c *ConversationNodeVoice) GetOpenAiVoice() *OpenAiVoice {
	if c == nil {
		return nil
	}
	return c.OpenAiVoice
}

func (c *ConversationNodeVoice) GetPlayHtVoice() *PlayHtVoice {
	if c == nil {
		return nil
	}
	return c.PlayHtVoice
}

func (c *ConversationNodeVoice) GetRimeAiVoice() *RimeAiVoice {
	if c == nil {
		return nil
	}
	return c.RimeAiVoice
}

func (c *ConversationNodeVoice) GetSmallestAiVoice() *SmallestAiVoice {
	if c == nil {
		return nil
	}
	return c.SmallestAiVoice
}

func (c *ConversationNodeVoice) GetTavusVoice() *TavusVoice {
	if c == nil {
		return nil
	}
	return c.TavusVoice
}

func (c *ConversationNodeVoice) GetVapiVoice() *VapiVoice {
	if c == nil {
		return nil
	}
	return c.VapiVoice
}

func (c *ConversationNodeVoice) GetSesameVoice() *SesameVoice {
	if c == nil {
		return nil
	}
	return c.SesameVoice
}

func (c *ConversationNodeVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		c.typ = "AzureVoice"
		c.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		c.typ = "CartesiaVoice"
		c.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueCustomVoice := new(CustomVoice)
	if err := json.Unmarshal(data, &valueCustomVoice); err == nil {
		c.typ = "CustomVoice"
		c.CustomVoice = valueCustomVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		c.typ = "DeepgramVoice"
		c.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		c.typ = "ElevenLabsVoice"
		c.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueHumeVoice := new(HumeVoice)
	if err := json.Unmarshal(data, &valueHumeVoice); err == nil {
		c.typ = "HumeVoice"
		c.HumeVoice = valueHumeVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		c.typ = "LmntVoice"
		c.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeuphonicVoice := new(NeuphonicVoice)
	if err := json.Unmarshal(data, &valueNeuphonicVoice); err == nil {
		c.typ = "NeuphonicVoice"
		c.NeuphonicVoice = valueNeuphonicVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		c.typ = "OpenAiVoice"
		c.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		c.typ = "PlayHtVoice"
		c.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		c.typ = "RimeAiVoice"
		c.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	valueSmallestAiVoice := new(SmallestAiVoice)
	if err := json.Unmarshal(data, &valueSmallestAiVoice); err == nil {
		c.typ = "SmallestAiVoice"
		c.SmallestAiVoice = valueSmallestAiVoice
		return nil
	}
	valueTavusVoice := new(TavusVoice)
	if err := json.Unmarshal(data, &valueTavusVoice); err == nil {
		c.typ = "TavusVoice"
		c.TavusVoice = valueTavusVoice
		return nil
	}
	valueVapiVoice := new(VapiVoice)
	if err := json.Unmarshal(data, &valueVapiVoice); err == nil {
		c.typ = "VapiVoice"
		c.VapiVoice = valueVapiVoice
		return nil
	}
	valueSesameVoice := new(SesameVoice)
	if err := json.Unmarshal(data, &valueSesameVoice); err == nil {
		c.typ = "SesameVoice"
		c.SesameVoice = valueSesameVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConversationNodeVoice) MarshalJSON() ([]byte, error) {
	if c.typ == "AzureVoice" || c.AzureVoice != nil {
		return json.Marshal(c.AzureVoice)
	}
	if c.typ == "CartesiaVoice" || c.CartesiaVoice != nil {
		return json.Marshal(c.CartesiaVoice)
	}
	if c.typ == "CustomVoice" || c.CustomVoice != nil {
		return json.Marshal(c.CustomVoice)
	}
	if c.typ == "DeepgramVoice" || c.DeepgramVoice != nil {
		return json.Marshal(c.DeepgramVoice)
	}
	if c.typ == "ElevenLabsVoice" || c.ElevenLabsVoice != nil {
		return json.Marshal(c.ElevenLabsVoice)
	}
	if c.typ == "HumeVoice" || c.HumeVoice != nil {
		return json.Marshal(c.HumeVoice)
	}
	if c.typ == "LmntVoice" || c.LmntVoice != nil {
		return json.Marshal(c.LmntVoice)
	}
	if c.typ == "NeuphonicVoice" || c.NeuphonicVoice != nil {
		return json.Marshal(c.NeuphonicVoice)
	}
	if c.typ == "OpenAiVoice" || c.OpenAiVoice != nil {
		return json.Marshal(c.OpenAiVoice)
	}
	if c.typ == "PlayHtVoice" || c.PlayHtVoice != nil {
		return json.Marshal(c.PlayHtVoice)
	}
	if c.typ == "RimeAiVoice" || c.RimeAiVoice != nil {
		return json.Marshal(c.RimeAiVoice)
	}
	if c.typ == "SmallestAiVoice" || c.SmallestAiVoice != nil {
		return json.Marshal(c.SmallestAiVoice)
	}
	if c.typ == "TavusVoice" || c.TavusVoice != nil {
		return json.Marshal(c.TavusVoice)
	}
	if c.typ == "VapiVoice" || c.VapiVoice != nil {
		return json.Marshal(c.VapiVoice)
	}
	if c.typ == "SesameVoice" || c.SesameVoice != nil {
		return json.Marshal(c.SesameVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ConversationNodeVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitCustomVoice(*CustomVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitHumeVoice(*HumeVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeuphonicVoice(*NeuphonicVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
	VisitSmallestAiVoice(*SmallestAiVoice) error
	VisitTavusVoice(*TavusVoice) error
	VisitVapiVoice(*VapiVoice) error
	VisitSesameVoice(*SesameVoice) error
}

func (c *ConversationNodeVoice) Accept(visitor ConversationNodeVoiceVisitor) error {
	if c.typ == "AzureVoice" || c.AzureVoice != nil {
		return visitor.VisitAzureVoice(c.AzureVoice)
	}
	if c.typ == "CartesiaVoice" || c.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(c.CartesiaVoice)
	}
	if c.typ == "CustomVoice" || c.CustomVoice != nil {
		return visitor.VisitCustomVoice(c.CustomVoice)
	}
	if c.typ == "DeepgramVoice" || c.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(c.DeepgramVoice)
	}
	if c.typ == "ElevenLabsVoice" || c.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(c.ElevenLabsVoice)
	}
	if c.typ == "HumeVoice" || c.HumeVoice != nil {
		return visitor.VisitHumeVoice(c.HumeVoice)
	}
	if c.typ == "LmntVoice" || c.LmntVoice != nil {
		return visitor.VisitLmntVoice(c.LmntVoice)
	}
	if c.typ == "NeuphonicVoice" || c.NeuphonicVoice != nil {
		return visitor.VisitNeuphonicVoice(c.NeuphonicVoice)
	}
	if c.typ == "OpenAiVoice" || c.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(c.OpenAiVoice)
	}
	if c.typ == "PlayHtVoice" || c.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(c.PlayHtVoice)
	}
	if c.typ == "RimeAiVoice" || c.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(c.RimeAiVoice)
	}
	if c.typ == "SmallestAiVoice" || c.SmallestAiVoice != nil {
		return visitor.VisitSmallestAiVoice(c.SmallestAiVoice)
	}
	if c.typ == "TavusVoice" || c.TavusVoice != nil {
		return visitor.VisitTavusVoice(c.TavusVoice)
	}
	if c.typ == "VapiVoice" || c.VapiVoice != nil {
		return visitor.VisitVapiVoice(c.VapiVoice)
	}
	if c.typ == "SesameVoice" || c.SesameVoice != nil {
		return visitor.VisitSesameVoice(c.SesameVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAnthropicCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAnthropicCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateAnthropicCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAnthropicCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAnthropicCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAnthropicCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAnthropicCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAnthropicCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "anthropic", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAnthropicCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAnthropicCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAnthropicCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAnyscaleCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAnyscaleCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateAnyscaleCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAnyscaleCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAnyscaleCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAnyscaleCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAnyscaleCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAnyscaleCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "anyscale", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAnyscaleCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAnyscaleCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "anyscale",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAnyscaleCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateApiRequestToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateApiRequestToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "apiRequest" for API request tool.
	Method CreateApiRequestToolDtoMethod `json:"method" url:"method"`
	// This is the timeout in seconds for the request. Defaults to 20 seconds.
	//
	// @default 20
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// This is the name of the tool. This will be passed to the model.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the description of the tool. This will be passed to the model.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is where the request will be sent.
	Url string `json:"url" url:"url"`
	// This is the body of the request.
	Body *JsonSchema `json:"body,omitempty" url:"body,omitempty"`
	// These are the headers to send in the request.
	Headers *JsonSchema `json:"headers,omitempty" url:"headers,omitempty"`
	// This is the backoff plan if the request fails. Defaults to undefined (the request will not be retried).
	//
	// @default undefined (the request will not be retried)
	BackoffPlan *BackoffPlan `json:"backoffPlan,omitempty" url:"backoffPlan,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateApiRequestToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateApiRequestToolDto) GetMessages() []*CreateApiRequestToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateApiRequestToolDto) GetMethod() CreateApiRequestToolDtoMethod {
	if c == nil {
		return ""
	}
	return c.Method
}

func (c *CreateApiRequestToolDto) GetTimeoutSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.TimeoutSeconds
}

func (c *CreateApiRequestToolDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateApiRequestToolDto) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateApiRequestToolDto) GetUrl() string {
	if c == nil {
		return ""
	}
	return c.Url
}

func (c *CreateApiRequestToolDto) GetBody() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.Body
}

func (c *CreateApiRequestToolDto) GetHeaders() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.Headers
}

func (c *CreateApiRequestToolDto) GetBackoffPlan() *BackoffPlan {
	if c == nil {
		return nil
	}
	return c.BackoffPlan
}

func (c *CreateApiRequestToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateApiRequestToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateApiRequestToolDto) Type() string {
	return c.type_
}

func (c *CreateApiRequestToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateApiRequestToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateApiRequestToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateApiRequestToolDto(unmarshaler.embed)
	if unmarshaler.Type != "apiRequest" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "apiRequest", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateApiRequestToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateApiRequestToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "apiRequest",
	}
	return json.Marshal(marshaler)
}

func (c *CreateApiRequestToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateApiRequestToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateApiRequestToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateApiRequestToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateApiRequestToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateApiRequestToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateApiRequestToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateApiRequestToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateApiRequestToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateApiRequestToolDtoMessagesItem) Accept(visitor CreateApiRequestToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateApiRequestToolDtoMethod string

const (
	CreateApiRequestToolDtoMethodPost CreateApiRequestToolDtoMethod = "POST"
	CreateApiRequestToolDtoMethodGet  CreateApiRequestToolDtoMethod = "GET"
)

func NewCreateApiRequestToolDtoMethodFromString(s string) (CreateApiRequestToolDtoMethod, error) {
	switch s {
	case "POST":
		return CreateApiRequestToolDtoMethodPost, nil
	case "GET":
		return CreateApiRequestToolDtoMethodGet, nil
	}
	var t CreateApiRequestToolDtoMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateApiRequestToolDtoMethod) Ptr() *CreateApiRequestToolDtoMethod {
	return &c
}

type CreateAssemblyAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAssemblyAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateAssemblyAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAssemblyAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAssemblyAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssemblyAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAssemblyAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAssemblyAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "assembly-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "assembly-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAssemblyAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAssemblyAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "assembly-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAssemblyAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAssistantDto struct {
	// These are the options for the assistant's transcriber.
	Transcriber *CreateAssistantDtoTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *CreateAssistantDtoModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *CreateAssistantDtoVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage                     *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	FirstMessageInterruptionsEnabled *bool   `json:"firstMessageInterruptionsEnabled,omitempty" url:"firstMessageInterruptionsEnabled,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *CreateAssistantDtoFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *CreateAssistantDtoVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []CreateAssistantDtoClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []CreateAssistantDtoServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	// You can also provide a custom sound by providing a URL to an audio file.
	BackgroundSound *CreateAssistantDtoBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// This is the plan for observability configuration of assistant's calls.
	// Currently supports Langfuse for tracing and monitoring.
	ObservabilityPlan *LangfuseObservabilityPlan `json:"observabilityPlan,omitempty" url:"observabilityPlan,omitempty"`
	// These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.
	Credentials []*CreateAssistantDtoCredentialsItem `json:"credentials,omitempty" url:"credentials,omitempty"`
	// This is a set of actions that will be performed on certain events.
	Hooks []*CreateAssistantDtoHooksItem `json:"hooks,omitempty" url:"hooks,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string        `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	CompliancePlan *CompliancePlan `json:"compliancePlan,omitempty" url:"compliancePlan,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server.url
	// 2. phoneNumber.serverUrl
	// 3. org.serverUrl
	Server          *Server          `json:"server,omitempty" url:"server,omitempty"`
	KeypadInputPlan *KeypadInputPlan `json:"keypadInputPlan,omitempty" url:"keypadInputPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAssistantDto) GetTranscriber() *CreateAssistantDtoTranscriber {
	if c == nil {
		return nil
	}
	return c.Transcriber
}

func (c *CreateAssistantDto) GetModel() *CreateAssistantDtoModel {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *CreateAssistantDto) GetVoice() *CreateAssistantDtoVoice {
	if c == nil {
		return nil
	}
	return c.Voice
}

func (c *CreateAssistantDto) GetFirstMessage() *string {
	if c == nil {
		return nil
	}
	return c.FirstMessage
}

func (c *CreateAssistantDto) GetFirstMessageInterruptionsEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.FirstMessageInterruptionsEnabled
}

func (c *CreateAssistantDto) GetFirstMessageMode() *CreateAssistantDtoFirstMessageMode {
	if c == nil {
		return nil
	}
	return c.FirstMessageMode
}

func (c *CreateAssistantDto) GetVoicemailDetection() *CreateAssistantDtoVoicemailDetection {
	if c == nil {
		return nil
	}
	return c.VoicemailDetection
}

func (c *CreateAssistantDto) GetClientMessages() []CreateAssistantDtoClientMessagesItem {
	if c == nil {
		return nil
	}
	return c.ClientMessages
}

func (c *CreateAssistantDto) GetServerMessages() []CreateAssistantDtoServerMessagesItem {
	if c == nil {
		return nil
	}
	return c.ServerMessages
}

func (c *CreateAssistantDto) GetSilenceTimeoutSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.SilenceTimeoutSeconds
}

func (c *CreateAssistantDto) GetMaxDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxDurationSeconds
}

func (c *CreateAssistantDto) GetBackgroundSound() *CreateAssistantDtoBackgroundSound {
	if c == nil {
		return nil
	}
	return c.BackgroundSound
}

func (c *CreateAssistantDto) GetBackgroundDenoisingEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.BackgroundDenoisingEnabled
}

func (c *CreateAssistantDto) GetModelOutputInMessagesEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.ModelOutputInMessagesEnabled
}

func (c *CreateAssistantDto) GetTransportConfigurations() []*TransportConfigurationTwilio {
	if c == nil {
		return nil
	}
	return c.TransportConfigurations
}

func (c *CreateAssistantDto) GetObservabilityPlan() *LangfuseObservabilityPlan {
	if c == nil {
		return nil
	}
	return c.ObservabilityPlan
}

func (c *CreateAssistantDto) GetCredentials() []*CreateAssistantDtoCredentialsItem {
	if c == nil {
		return nil
	}
	return c.Credentials
}

func (c *CreateAssistantDto) GetHooks() []*CreateAssistantDtoHooksItem {
	if c == nil {
		return nil
	}
	return c.Hooks
}

func (c *CreateAssistantDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAssistantDto) GetVoicemailMessage() *string {
	if c == nil {
		return nil
	}
	return c.VoicemailMessage
}

func (c *CreateAssistantDto) GetEndCallMessage() *string {
	if c == nil {
		return nil
	}
	return c.EndCallMessage
}

func (c *CreateAssistantDto) GetEndCallPhrases() []string {
	if c == nil {
		return nil
	}
	return c.EndCallPhrases
}

func (c *CreateAssistantDto) GetCompliancePlan() *CompliancePlan {
	if c == nil {
		return nil
	}
	return c.CompliancePlan
}

func (c *CreateAssistantDto) GetMetadata() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateAssistantDto) GetAnalysisPlan() *AnalysisPlan {
	if c == nil {
		return nil
	}
	return c.AnalysisPlan
}

func (c *CreateAssistantDto) GetArtifactPlan() *ArtifactPlan {
	if c == nil {
		return nil
	}
	return c.ArtifactPlan
}

func (c *CreateAssistantDto) GetMessagePlan() *MessagePlan {
	if c == nil {
		return nil
	}
	return c.MessagePlan
}

func (c *CreateAssistantDto) GetStartSpeakingPlan() *StartSpeakingPlan {
	if c == nil {
		return nil
	}
	return c.StartSpeakingPlan
}

func (c *CreateAssistantDto) GetStopSpeakingPlan() *StopSpeakingPlan {
	if c == nil {
		return nil
	}
	return c.StopSpeakingPlan
}

func (c *CreateAssistantDto) GetMonitorPlan() *MonitorPlan {
	if c == nil {
		return nil
	}
	return c.MonitorPlan
}

func (c *CreateAssistantDto) GetCredentialIds() []string {
	if c == nil {
		return nil
	}
	return c.CredentialIds
}

func (c *CreateAssistantDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateAssistantDto) GetKeypadInputPlan() *KeypadInputPlan {
	if c == nil {
		return nil
	}
	return c.KeypadInputPlan
}

func (c *CreateAssistantDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssistantDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAssistantDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAssistantDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAssistantDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
// You can also provide a custom sound by providing a URL to an audio file.
type CreateAssistantDtoBackgroundSound struct {
	CreateAssistantDtoBackgroundSoundZero CreateAssistantDtoBackgroundSoundZero
	String                                string

	typ string
}

func (c *CreateAssistantDtoBackgroundSound) GetCreateAssistantDtoBackgroundSoundZero() CreateAssistantDtoBackgroundSoundZero {
	if c == nil {
		return ""
	}
	return c.CreateAssistantDtoBackgroundSoundZero
}

func (c *CreateAssistantDtoBackgroundSound) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CreateAssistantDtoBackgroundSound) UnmarshalJSON(data []byte) error {
	var valueCreateAssistantDtoBackgroundSoundZero CreateAssistantDtoBackgroundSoundZero
	if err := json.Unmarshal(data, &valueCreateAssistantDtoBackgroundSoundZero); err == nil {
		c.typ = "CreateAssistantDtoBackgroundSoundZero"
		c.CreateAssistantDtoBackgroundSoundZero = valueCreateAssistantDtoBackgroundSoundZero
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typ = "String"
		c.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoBackgroundSound) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateAssistantDtoBackgroundSoundZero" || c.CreateAssistantDtoBackgroundSoundZero != "" {
		return json.Marshal(c.CreateAssistantDtoBackgroundSoundZero)
	}
	if c.typ == "String" || c.String != "" {
		return json.Marshal(c.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoBackgroundSoundVisitor interface {
	VisitCreateAssistantDtoBackgroundSoundZero(CreateAssistantDtoBackgroundSoundZero) error
	VisitString(string) error
}

func (c *CreateAssistantDtoBackgroundSound) Accept(visitor CreateAssistantDtoBackgroundSoundVisitor) error {
	if c.typ == "CreateAssistantDtoBackgroundSoundZero" || c.CreateAssistantDtoBackgroundSoundZero != "" {
		return visitor.VisitCreateAssistantDtoBackgroundSoundZero(c.CreateAssistantDtoBackgroundSoundZero)
	}
	if c.typ == "String" || c.String != "" {
		return visitor.VisitString(c.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoBackgroundSoundZero string

const (
	CreateAssistantDtoBackgroundSoundZeroOff    CreateAssistantDtoBackgroundSoundZero = "off"
	CreateAssistantDtoBackgroundSoundZeroOffice CreateAssistantDtoBackgroundSoundZero = "office"
)

func NewCreateAssistantDtoBackgroundSoundZeroFromString(s string) (CreateAssistantDtoBackgroundSoundZero, error) {
	switch s {
	case "off":
		return CreateAssistantDtoBackgroundSoundZeroOff, nil
	case "office":
		return CreateAssistantDtoBackgroundSoundZeroOffice, nil
	}
	var t CreateAssistantDtoBackgroundSoundZero
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoBackgroundSoundZero) Ptr() *CreateAssistantDtoBackgroundSoundZero {
	return &c
}

type CreateAssistantDtoClientMessagesItem string

const (
	CreateAssistantDtoClientMessagesItemConversationUpdate  CreateAssistantDtoClientMessagesItem = "conversation-update"
	CreateAssistantDtoClientMessagesItemFunctionCall        CreateAssistantDtoClientMessagesItem = "function-call"
	CreateAssistantDtoClientMessagesItemFunctionCallResult  CreateAssistantDtoClientMessagesItem = "function-call-result"
	CreateAssistantDtoClientMessagesItemHang                CreateAssistantDtoClientMessagesItem = "hang"
	CreateAssistantDtoClientMessagesItemLanguageChanged     CreateAssistantDtoClientMessagesItem = "language-changed"
	CreateAssistantDtoClientMessagesItemMetadata            CreateAssistantDtoClientMessagesItem = "metadata"
	CreateAssistantDtoClientMessagesItemModelOutput         CreateAssistantDtoClientMessagesItem = "model-output"
	CreateAssistantDtoClientMessagesItemSpeechUpdate        CreateAssistantDtoClientMessagesItem = "speech-update"
	CreateAssistantDtoClientMessagesItemStatusUpdate        CreateAssistantDtoClientMessagesItem = "status-update"
	CreateAssistantDtoClientMessagesItemTranscript          CreateAssistantDtoClientMessagesItem = "transcript"
	CreateAssistantDtoClientMessagesItemToolCalls           CreateAssistantDtoClientMessagesItem = "tool-calls"
	CreateAssistantDtoClientMessagesItemToolCallsResult     CreateAssistantDtoClientMessagesItem = "tool-calls-result"
	CreateAssistantDtoClientMessagesItemToolCompleted       CreateAssistantDtoClientMessagesItem = "tool.completed"
	CreateAssistantDtoClientMessagesItemTransferUpdate      CreateAssistantDtoClientMessagesItem = "transfer-update"
	CreateAssistantDtoClientMessagesItemUserInterrupted     CreateAssistantDtoClientMessagesItem = "user-interrupted"
	CreateAssistantDtoClientMessagesItemVoiceInput          CreateAssistantDtoClientMessagesItem = "voice-input"
	CreateAssistantDtoClientMessagesItemWorkflowNodeStarted CreateAssistantDtoClientMessagesItem = "workflow.node.started"
)

func NewCreateAssistantDtoClientMessagesItemFromString(s string) (CreateAssistantDtoClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return CreateAssistantDtoClientMessagesItemConversationUpdate, nil
	case "function-call":
		return CreateAssistantDtoClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return CreateAssistantDtoClientMessagesItemFunctionCallResult, nil
	case "hang":
		return CreateAssistantDtoClientMessagesItemHang, nil
	case "language-changed":
		return CreateAssistantDtoClientMessagesItemLanguageChanged, nil
	case "metadata":
		return CreateAssistantDtoClientMessagesItemMetadata, nil
	case "model-output":
		return CreateAssistantDtoClientMessagesItemModelOutput, nil
	case "speech-update":
		return CreateAssistantDtoClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return CreateAssistantDtoClientMessagesItemStatusUpdate, nil
	case "transcript":
		return CreateAssistantDtoClientMessagesItemTranscript, nil
	case "tool-calls":
		return CreateAssistantDtoClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return CreateAssistantDtoClientMessagesItemToolCallsResult, nil
	case "tool.completed":
		return CreateAssistantDtoClientMessagesItemToolCompleted, nil
	case "transfer-update":
		return CreateAssistantDtoClientMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return CreateAssistantDtoClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return CreateAssistantDtoClientMessagesItemVoiceInput, nil
	case "workflow.node.started":
		return CreateAssistantDtoClientMessagesItemWorkflowNodeStarted, nil
	}
	var t CreateAssistantDtoClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoClientMessagesItem) Ptr() *CreateAssistantDtoClientMessagesItem {
	return &c
}

type CreateAssistantDtoCredentialsItem struct {
	CreateElevenLabsCredentialDto                        *CreateElevenLabsCredentialDto
	CreateAnthropicCredentialDto                         *CreateAnthropicCredentialDto
	CreateAnyscaleCredentialDto                          *CreateAnyscaleCredentialDto
	CreateAssemblyAiCredentialDto                        *CreateAssemblyAiCredentialDto
	CreateAzureOpenAiCredentialDto                       *CreateAzureOpenAiCredentialDto
	CreateAzureCredentialDto                             *CreateAzureCredentialDto
	CreateByoSipTrunkCredentialDto                       *CreateByoSipTrunkCredentialDto
	CreateCartesiaCredentialDto                          *CreateCartesiaCredentialDto
	CreateCerebrasCredentialDto                          *CreateCerebrasCredentialDto
	CreateCloudflareCredentialDto                        *CreateCloudflareCredentialDto
	CreateCustomLlmCredentialDto                         *CreateCustomLlmCredentialDto
	CreateDeepgramCredentialDto                          *CreateDeepgramCredentialDto
	CreateDeepInfraCredentialDto                         *CreateDeepInfraCredentialDto
	CreateDeepSeekCredentialDto                          *CreateDeepSeekCredentialDto
	CreateGcpCredentialDto                               *CreateGcpCredentialDto
	CreateGladiaCredentialDto                            *CreateGladiaCredentialDto
	CreateGoHighLevelCredentialDto                       *CreateGoHighLevelCredentialDto
	CreateGoogleCredentialDto                            *CreateGoogleCredentialDto
	CreateGroqCredentialDto                              *CreateGroqCredentialDto
	CreateInflectionAiCredentialDto                      *CreateInflectionAiCredentialDto
	CreateLangfuseCredentialDto                          *CreateLangfuseCredentialDto
	CreateLmntCredentialDto                              *CreateLmntCredentialDto
	CreateMakeCredentialDto                              *CreateMakeCredentialDto
	CreateOpenAiCredentialDto                            *CreateOpenAiCredentialDto
	CreateOpenRouterCredentialDto                        *CreateOpenRouterCredentialDto
	CreatePerplexityAiCredentialDto                      *CreatePerplexityAiCredentialDto
	CreatePlayHtCredentialDto                            *CreatePlayHtCredentialDto
	CreateRimeAiCredentialDto                            *CreateRimeAiCredentialDto
	CreateRunpodCredentialDto                            *CreateRunpodCredentialDto
	CreateS3CredentialDto                                *CreateS3CredentialDto
	CreateSupabaseCredentialDto                          *CreateSupabaseCredentialDto
	CreateSmallestAiCredentialDto                        *CreateSmallestAiCredentialDto
	CreateTavusCredentialDto                             *CreateTavusCredentialDto
	CreateTogetherAiCredentialDto                        *CreateTogetherAiCredentialDto
	CreateTwilioCredentialDto                            *CreateTwilioCredentialDto
	CreateVonageCredentialDto                            *CreateVonageCredentialDto
	CreateWebhookCredentialDto                           *CreateWebhookCredentialDto
	CreateXAiCredentialDto                               *CreateXAiCredentialDto
	CreateNeuphonicCredentialDto                         *CreateNeuphonicCredentialDto
	CreateHumeCredentialDto                              *CreateHumeCredentialDto
	CreateMistralCredentialDto                           *CreateMistralCredentialDto
	CreateSpeechmaticsCredentialDto                      *CreateSpeechmaticsCredentialDto
	CreateTrieveCredentialDto                            *CreateTrieveCredentialDto
	CreateGoogleCalendarOAuth2ClientCredentialDto        *CreateGoogleCalendarOAuth2ClientCredentialDto
	CreateGoogleCalendarOAuth2AuthorizationCredentialDto *CreateGoogleCalendarOAuth2AuthorizationCredentialDto
	CreateGoogleSheetsOAuth2AuthorizationCredentialDto   *CreateGoogleSheetsOAuth2AuthorizationCredentialDto
	CreateSlackOAuth2AuthorizationCredentialDto          *CreateSlackOAuth2AuthorizationCredentialDto
	CreateGoHighLevelMcpCredentialDto                    *CreateGoHighLevelMcpCredentialDto

	typ string
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateElevenLabsCredentialDto() *CreateElevenLabsCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateElevenLabsCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAnthropicCredentialDto() *CreateAnthropicCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAnthropicCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAnyscaleCredentialDto() *CreateAnyscaleCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAnyscaleCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAssemblyAiCredentialDto() *CreateAssemblyAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAssemblyAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAzureOpenAiCredentialDto() *CreateAzureOpenAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAzureOpenAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAzureCredentialDto() *CreateAzureCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAzureCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateByoSipTrunkCredentialDto() *CreateByoSipTrunkCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateByoSipTrunkCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateCartesiaCredentialDto() *CreateCartesiaCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateCartesiaCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateCerebrasCredentialDto() *CreateCerebrasCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateCerebrasCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateCloudflareCredentialDto() *CreateCloudflareCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateCloudflareCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateCustomLlmCredentialDto() *CreateCustomLlmCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateCustomLlmCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateDeepgramCredentialDto() *CreateDeepgramCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateDeepgramCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateDeepInfraCredentialDto() *CreateDeepInfraCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateDeepInfraCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateDeepSeekCredentialDto() *CreateDeepSeekCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateDeepSeekCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGcpCredentialDto() *CreateGcpCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGcpCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGladiaCredentialDto() *CreateGladiaCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGladiaCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGoHighLevelCredentialDto() *CreateGoHighLevelCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGoogleCredentialDto() *CreateGoogleCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGroqCredentialDto() *CreateGroqCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGroqCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateInflectionAiCredentialDto() *CreateInflectionAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateInflectionAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateLangfuseCredentialDto() *CreateLangfuseCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateLangfuseCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateLmntCredentialDto() *CreateLmntCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateLmntCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateMakeCredentialDto() *CreateMakeCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateMakeCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateOpenAiCredentialDto() *CreateOpenAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateOpenAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateOpenRouterCredentialDto() *CreateOpenRouterCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateOpenRouterCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreatePerplexityAiCredentialDto() *CreatePerplexityAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreatePerplexityAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreatePlayHtCredentialDto() *CreatePlayHtCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreatePlayHtCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateRimeAiCredentialDto() *CreateRimeAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateRimeAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateRunpodCredentialDto() *CreateRunpodCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateRunpodCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateS3CredentialDto() *CreateS3CredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateS3CredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateSupabaseCredentialDto() *CreateSupabaseCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateSupabaseCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateSmallestAiCredentialDto() *CreateSmallestAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateSmallestAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateTavusCredentialDto() *CreateTavusCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateTavusCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateTogetherAiCredentialDto() *CreateTogetherAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateTogetherAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateTwilioCredentialDto() *CreateTwilioCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateVonageCredentialDto() *CreateVonageCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateVonageCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateWebhookCredentialDto() *CreateWebhookCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateWebhookCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateXAiCredentialDto() *CreateXAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateXAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateNeuphonicCredentialDto() *CreateNeuphonicCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateNeuphonicCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateHumeCredentialDto() *CreateHumeCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateHumeCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateMistralCredentialDto() *CreateMistralCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateMistralCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateSpeechmaticsCredentialDto() *CreateSpeechmaticsCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateSpeechmaticsCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateTrieveCredentialDto() *CreateTrieveCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateTrieveCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGoogleCalendarOAuth2ClientCredentialDto() *CreateGoogleCalendarOAuth2ClientCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarOAuth2ClientCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGoogleCalendarOAuth2AuthorizationCredentialDto() *CreateGoogleCalendarOAuth2AuthorizationCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarOAuth2AuthorizationCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGoogleSheetsOAuth2AuthorizationCredentialDto() *CreateGoogleSheetsOAuth2AuthorizationCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleSheetsOAuth2AuthorizationCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateSlackOAuth2AuthorizationCredentialDto() *CreateSlackOAuth2AuthorizationCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateSlackOAuth2AuthorizationCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGoHighLevelMcpCredentialDto() *CreateGoHighLevelMcpCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelMcpCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) UnmarshalJSON(data []byte) error {
	valueCreateElevenLabsCredentialDto := new(CreateElevenLabsCredentialDto)
	if err := json.Unmarshal(data, &valueCreateElevenLabsCredentialDto); err == nil {
		c.typ = "CreateElevenLabsCredentialDto"
		c.CreateElevenLabsCredentialDto = valueCreateElevenLabsCredentialDto
		return nil
	}
	valueCreateAnthropicCredentialDto := new(CreateAnthropicCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnthropicCredentialDto); err == nil {
		c.typ = "CreateAnthropicCredentialDto"
		c.CreateAnthropicCredentialDto = valueCreateAnthropicCredentialDto
		return nil
	}
	valueCreateAnyscaleCredentialDto := new(CreateAnyscaleCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnyscaleCredentialDto); err == nil {
		c.typ = "CreateAnyscaleCredentialDto"
		c.CreateAnyscaleCredentialDto = valueCreateAnyscaleCredentialDto
		return nil
	}
	valueCreateAssemblyAiCredentialDto := new(CreateAssemblyAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAssemblyAiCredentialDto); err == nil {
		c.typ = "CreateAssemblyAiCredentialDto"
		c.CreateAssemblyAiCredentialDto = valueCreateAssemblyAiCredentialDto
		return nil
	}
	valueCreateAzureOpenAiCredentialDto := new(CreateAzureOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureOpenAiCredentialDto); err == nil {
		c.typ = "CreateAzureOpenAiCredentialDto"
		c.CreateAzureOpenAiCredentialDto = valueCreateAzureOpenAiCredentialDto
		return nil
	}
	valueCreateAzureCredentialDto := new(CreateAzureCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureCredentialDto); err == nil {
		c.typ = "CreateAzureCredentialDto"
		c.CreateAzureCredentialDto = valueCreateAzureCredentialDto
		return nil
	}
	valueCreateByoSipTrunkCredentialDto := new(CreateByoSipTrunkCredentialDto)
	if err := json.Unmarshal(data, &valueCreateByoSipTrunkCredentialDto); err == nil {
		c.typ = "CreateByoSipTrunkCredentialDto"
		c.CreateByoSipTrunkCredentialDto = valueCreateByoSipTrunkCredentialDto
		return nil
	}
	valueCreateCartesiaCredentialDto := new(CreateCartesiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCartesiaCredentialDto); err == nil {
		c.typ = "CreateCartesiaCredentialDto"
		c.CreateCartesiaCredentialDto = valueCreateCartesiaCredentialDto
		return nil
	}
	valueCreateCerebrasCredentialDto := new(CreateCerebrasCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCerebrasCredentialDto); err == nil {
		c.typ = "CreateCerebrasCredentialDto"
		c.CreateCerebrasCredentialDto = valueCreateCerebrasCredentialDto
		return nil
	}
	valueCreateCloudflareCredentialDto := new(CreateCloudflareCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCloudflareCredentialDto); err == nil {
		c.typ = "CreateCloudflareCredentialDto"
		c.CreateCloudflareCredentialDto = valueCreateCloudflareCredentialDto
		return nil
	}
	valueCreateCustomLlmCredentialDto := new(CreateCustomLlmCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCustomLlmCredentialDto); err == nil {
		c.typ = "CreateCustomLlmCredentialDto"
		c.CreateCustomLlmCredentialDto = valueCreateCustomLlmCredentialDto
		return nil
	}
	valueCreateDeepgramCredentialDto := new(CreateDeepgramCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepgramCredentialDto); err == nil {
		c.typ = "CreateDeepgramCredentialDto"
		c.CreateDeepgramCredentialDto = valueCreateDeepgramCredentialDto
		return nil
	}
	valueCreateDeepInfraCredentialDto := new(CreateDeepInfraCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepInfraCredentialDto); err == nil {
		c.typ = "CreateDeepInfraCredentialDto"
		c.CreateDeepInfraCredentialDto = valueCreateDeepInfraCredentialDto
		return nil
	}
	valueCreateDeepSeekCredentialDto := new(CreateDeepSeekCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepSeekCredentialDto); err == nil {
		c.typ = "CreateDeepSeekCredentialDto"
		c.CreateDeepSeekCredentialDto = valueCreateDeepSeekCredentialDto
		return nil
	}
	valueCreateGcpCredentialDto := new(CreateGcpCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGcpCredentialDto); err == nil {
		c.typ = "CreateGcpCredentialDto"
		c.CreateGcpCredentialDto = valueCreateGcpCredentialDto
		return nil
	}
	valueCreateGladiaCredentialDto := new(CreateGladiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGladiaCredentialDto); err == nil {
		c.typ = "CreateGladiaCredentialDto"
		c.CreateGladiaCredentialDto = valueCreateGladiaCredentialDto
		return nil
	}
	valueCreateGoHighLevelCredentialDto := new(CreateGoHighLevelCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCredentialDto); err == nil {
		c.typ = "CreateGoHighLevelCredentialDto"
		c.CreateGoHighLevelCredentialDto = valueCreateGoHighLevelCredentialDto
		return nil
	}
	valueCreateGoogleCredentialDto := new(CreateGoogleCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCredentialDto); err == nil {
		c.typ = "CreateGoogleCredentialDto"
		c.CreateGoogleCredentialDto = valueCreateGoogleCredentialDto
		return nil
	}
	valueCreateGroqCredentialDto := new(CreateGroqCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGroqCredentialDto); err == nil {
		c.typ = "CreateGroqCredentialDto"
		c.CreateGroqCredentialDto = valueCreateGroqCredentialDto
		return nil
	}
	valueCreateInflectionAiCredentialDto := new(CreateInflectionAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateInflectionAiCredentialDto); err == nil {
		c.typ = "CreateInflectionAiCredentialDto"
		c.CreateInflectionAiCredentialDto = valueCreateInflectionAiCredentialDto
		return nil
	}
	valueCreateLangfuseCredentialDto := new(CreateLangfuseCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLangfuseCredentialDto); err == nil {
		c.typ = "CreateLangfuseCredentialDto"
		c.CreateLangfuseCredentialDto = valueCreateLangfuseCredentialDto
		return nil
	}
	valueCreateLmntCredentialDto := new(CreateLmntCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLmntCredentialDto); err == nil {
		c.typ = "CreateLmntCredentialDto"
		c.CreateLmntCredentialDto = valueCreateLmntCredentialDto
		return nil
	}
	valueCreateMakeCredentialDto := new(CreateMakeCredentialDto)
	if err := json.Unmarshal(data, &valueCreateMakeCredentialDto); err == nil {
		c.typ = "CreateMakeCredentialDto"
		c.CreateMakeCredentialDto = valueCreateMakeCredentialDto
		return nil
	}
	valueCreateOpenAiCredentialDto := new(CreateOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenAiCredentialDto); err == nil {
		c.typ = "CreateOpenAiCredentialDto"
		c.CreateOpenAiCredentialDto = valueCreateOpenAiCredentialDto
		return nil
	}
	valueCreateOpenRouterCredentialDto := new(CreateOpenRouterCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenRouterCredentialDto); err == nil {
		c.typ = "CreateOpenRouterCredentialDto"
		c.CreateOpenRouterCredentialDto = valueCreateOpenRouterCredentialDto
		return nil
	}
	valueCreatePerplexityAiCredentialDto := new(CreatePerplexityAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePerplexityAiCredentialDto); err == nil {
		c.typ = "CreatePerplexityAiCredentialDto"
		c.CreatePerplexityAiCredentialDto = valueCreatePerplexityAiCredentialDto
		return nil
	}
	valueCreatePlayHtCredentialDto := new(CreatePlayHtCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePlayHtCredentialDto); err == nil {
		c.typ = "CreatePlayHtCredentialDto"
		c.CreatePlayHtCredentialDto = valueCreatePlayHtCredentialDto
		return nil
	}
	valueCreateRimeAiCredentialDto := new(CreateRimeAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRimeAiCredentialDto); err == nil {
		c.typ = "CreateRimeAiCredentialDto"
		c.CreateRimeAiCredentialDto = valueCreateRimeAiCredentialDto
		return nil
	}
	valueCreateRunpodCredentialDto := new(CreateRunpodCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRunpodCredentialDto); err == nil {
		c.typ = "CreateRunpodCredentialDto"
		c.CreateRunpodCredentialDto = valueCreateRunpodCredentialDto
		return nil
	}
	valueCreateS3CredentialDto := new(CreateS3CredentialDto)
	if err := json.Unmarshal(data, &valueCreateS3CredentialDto); err == nil {
		c.typ = "CreateS3CredentialDto"
		c.CreateS3CredentialDto = valueCreateS3CredentialDto
		return nil
	}
	valueCreateSupabaseCredentialDto := new(CreateSupabaseCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSupabaseCredentialDto); err == nil {
		c.typ = "CreateSupabaseCredentialDto"
		c.CreateSupabaseCredentialDto = valueCreateSupabaseCredentialDto
		return nil
	}
	valueCreateSmallestAiCredentialDto := new(CreateSmallestAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSmallestAiCredentialDto); err == nil {
		c.typ = "CreateSmallestAiCredentialDto"
		c.CreateSmallestAiCredentialDto = valueCreateSmallestAiCredentialDto
		return nil
	}
	valueCreateTavusCredentialDto := new(CreateTavusCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTavusCredentialDto); err == nil {
		c.typ = "CreateTavusCredentialDto"
		c.CreateTavusCredentialDto = valueCreateTavusCredentialDto
		return nil
	}
	valueCreateTogetherAiCredentialDto := new(CreateTogetherAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTogetherAiCredentialDto); err == nil {
		c.typ = "CreateTogetherAiCredentialDto"
		c.CreateTogetherAiCredentialDto = valueCreateTogetherAiCredentialDto
		return nil
	}
	valueCreateTwilioCredentialDto := new(CreateTwilioCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTwilioCredentialDto); err == nil {
		c.typ = "CreateTwilioCredentialDto"
		c.CreateTwilioCredentialDto = valueCreateTwilioCredentialDto
		return nil
	}
	valueCreateVonageCredentialDto := new(CreateVonageCredentialDto)
	if err := json.Unmarshal(data, &valueCreateVonageCredentialDto); err == nil {
		c.typ = "CreateVonageCredentialDto"
		c.CreateVonageCredentialDto = valueCreateVonageCredentialDto
		return nil
	}
	valueCreateWebhookCredentialDto := new(CreateWebhookCredentialDto)
	if err := json.Unmarshal(data, &valueCreateWebhookCredentialDto); err == nil {
		c.typ = "CreateWebhookCredentialDto"
		c.CreateWebhookCredentialDto = valueCreateWebhookCredentialDto
		return nil
	}
	valueCreateXAiCredentialDto := new(CreateXAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateXAiCredentialDto); err == nil {
		c.typ = "CreateXAiCredentialDto"
		c.CreateXAiCredentialDto = valueCreateXAiCredentialDto
		return nil
	}
	valueCreateNeuphonicCredentialDto := new(CreateNeuphonicCredentialDto)
	if err := json.Unmarshal(data, &valueCreateNeuphonicCredentialDto); err == nil {
		c.typ = "CreateNeuphonicCredentialDto"
		c.CreateNeuphonicCredentialDto = valueCreateNeuphonicCredentialDto
		return nil
	}
	valueCreateHumeCredentialDto := new(CreateHumeCredentialDto)
	if err := json.Unmarshal(data, &valueCreateHumeCredentialDto); err == nil {
		c.typ = "CreateHumeCredentialDto"
		c.CreateHumeCredentialDto = valueCreateHumeCredentialDto
		return nil
	}
	valueCreateMistralCredentialDto := new(CreateMistralCredentialDto)
	if err := json.Unmarshal(data, &valueCreateMistralCredentialDto); err == nil {
		c.typ = "CreateMistralCredentialDto"
		c.CreateMistralCredentialDto = valueCreateMistralCredentialDto
		return nil
	}
	valueCreateSpeechmaticsCredentialDto := new(CreateSpeechmaticsCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSpeechmaticsCredentialDto); err == nil {
		c.typ = "CreateSpeechmaticsCredentialDto"
		c.CreateSpeechmaticsCredentialDto = valueCreateSpeechmaticsCredentialDto
		return nil
	}
	valueCreateTrieveCredentialDto := new(CreateTrieveCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTrieveCredentialDto); err == nil {
		c.typ = "CreateTrieveCredentialDto"
		c.CreateTrieveCredentialDto = valueCreateTrieveCredentialDto
		return nil
	}
	valueCreateGoogleCalendarOAuth2ClientCredentialDto := new(CreateGoogleCalendarOAuth2ClientCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarOAuth2ClientCredentialDto); err == nil {
		c.typ = "CreateGoogleCalendarOAuth2ClientCredentialDto"
		c.CreateGoogleCalendarOAuth2ClientCredentialDto = valueCreateGoogleCalendarOAuth2ClientCredentialDto
		return nil
	}
	valueCreateGoogleCalendarOAuth2AuthorizationCredentialDto := new(CreateGoogleCalendarOAuth2AuthorizationCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarOAuth2AuthorizationCredentialDto); err == nil {
		c.typ = "CreateGoogleCalendarOAuth2AuthorizationCredentialDto"
		c.CreateGoogleCalendarOAuth2AuthorizationCredentialDto = valueCreateGoogleCalendarOAuth2AuthorizationCredentialDto
		return nil
	}
	valueCreateGoogleSheetsOAuth2AuthorizationCredentialDto := new(CreateGoogleSheetsOAuth2AuthorizationCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsOAuth2AuthorizationCredentialDto); err == nil {
		c.typ = "CreateGoogleSheetsOAuth2AuthorizationCredentialDto"
		c.CreateGoogleSheetsOAuth2AuthorizationCredentialDto = valueCreateGoogleSheetsOAuth2AuthorizationCredentialDto
		return nil
	}
	valueCreateSlackOAuth2AuthorizationCredentialDto := new(CreateSlackOAuth2AuthorizationCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSlackOAuth2AuthorizationCredentialDto); err == nil {
		c.typ = "CreateSlackOAuth2AuthorizationCredentialDto"
		c.CreateSlackOAuth2AuthorizationCredentialDto = valueCreateSlackOAuth2AuthorizationCredentialDto
		return nil
	}
	valueCreateGoHighLevelMcpCredentialDto := new(CreateGoHighLevelMcpCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelMcpCredentialDto); err == nil {
		c.typ = "CreateGoHighLevelMcpCredentialDto"
		c.CreateGoHighLevelMcpCredentialDto = valueCreateGoHighLevelMcpCredentialDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoCredentialsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateElevenLabsCredentialDto" || c.CreateElevenLabsCredentialDto != nil {
		return json.Marshal(c.CreateElevenLabsCredentialDto)
	}
	if c.typ == "CreateAnthropicCredentialDto" || c.CreateAnthropicCredentialDto != nil {
		return json.Marshal(c.CreateAnthropicCredentialDto)
	}
	if c.typ == "CreateAnyscaleCredentialDto" || c.CreateAnyscaleCredentialDto != nil {
		return json.Marshal(c.CreateAnyscaleCredentialDto)
	}
	if c.typ == "CreateAssemblyAiCredentialDto" || c.CreateAssemblyAiCredentialDto != nil {
		return json.Marshal(c.CreateAssemblyAiCredentialDto)
	}
	if c.typ == "CreateAzureOpenAiCredentialDto" || c.CreateAzureOpenAiCredentialDto != nil {
		return json.Marshal(c.CreateAzureOpenAiCredentialDto)
	}
	if c.typ == "CreateAzureCredentialDto" || c.CreateAzureCredentialDto != nil {
		return json.Marshal(c.CreateAzureCredentialDto)
	}
	if c.typ == "CreateByoSipTrunkCredentialDto" || c.CreateByoSipTrunkCredentialDto != nil {
		return json.Marshal(c.CreateByoSipTrunkCredentialDto)
	}
	if c.typ == "CreateCartesiaCredentialDto" || c.CreateCartesiaCredentialDto != nil {
		return json.Marshal(c.CreateCartesiaCredentialDto)
	}
	if c.typ == "CreateCerebrasCredentialDto" || c.CreateCerebrasCredentialDto != nil {
		return json.Marshal(c.CreateCerebrasCredentialDto)
	}
	if c.typ == "CreateCloudflareCredentialDto" || c.CreateCloudflareCredentialDto != nil {
		return json.Marshal(c.CreateCloudflareCredentialDto)
	}
	if c.typ == "CreateCustomLlmCredentialDto" || c.CreateCustomLlmCredentialDto != nil {
		return json.Marshal(c.CreateCustomLlmCredentialDto)
	}
	if c.typ == "CreateDeepgramCredentialDto" || c.CreateDeepgramCredentialDto != nil {
		return json.Marshal(c.CreateDeepgramCredentialDto)
	}
	if c.typ == "CreateDeepInfraCredentialDto" || c.CreateDeepInfraCredentialDto != nil {
		return json.Marshal(c.CreateDeepInfraCredentialDto)
	}
	if c.typ == "CreateDeepSeekCredentialDto" || c.CreateDeepSeekCredentialDto != nil {
		return json.Marshal(c.CreateDeepSeekCredentialDto)
	}
	if c.typ == "CreateGcpCredentialDto" || c.CreateGcpCredentialDto != nil {
		return json.Marshal(c.CreateGcpCredentialDto)
	}
	if c.typ == "CreateGladiaCredentialDto" || c.CreateGladiaCredentialDto != nil {
		return json.Marshal(c.CreateGladiaCredentialDto)
	}
	if c.typ == "CreateGoHighLevelCredentialDto" || c.CreateGoHighLevelCredentialDto != nil {
		return json.Marshal(c.CreateGoHighLevelCredentialDto)
	}
	if c.typ == "CreateGoogleCredentialDto" || c.CreateGoogleCredentialDto != nil {
		return json.Marshal(c.CreateGoogleCredentialDto)
	}
	if c.typ == "CreateGroqCredentialDto" || c.CreateGroqCredentialDto != nil {
		return json.Marshal(c.CreateGroqCredentialDto)
	}
	if c.typ == "CreateInflectionAiCredentialDto" || c.CreateInflectionAiCredentialDto != nil {
		return json.Marshal(c.CreateInflectionAiCredentialDto)
	}
	if c.typ == "CreateLangfuseCredentialDto" || c.CreateLangfuseCredentialDto != nil {
		return json.Marshal(c.CreateLangfuseCredentialDto)
	}
	if c.typ == "CreateLmntCredentialDto" || c.CreateLmntCredentialDto != nil {
		return json.Marshal(c.CreateLmntCredentialDto)
	}
	if c.typ == "CreateMakeCredentialDto" || c.CreateMakeCredentialDto != nil {
		return json.Marshal(c.CreateMakeCredentialDto)
	}
	if c.typ == "CreateOpenAiCredentialDto" || c.CreateOpenAiCredentialDto != nil {
		return json.Marshal(c.CreateOpenAiCredentialDto)
	}
	if c.typ == "CreateOpenRouterCredentialDto" || c.CreateOpenRouterCredentialDto != nil {
		return json.Marshal(c.CreateOpenRouterCredentialDto)
	}
	if c.typ == "CreatePerplexityAiCredentialDto" || c.CreatePerplexityAiCredentialDto != nil {
		return json.Marshal(c.CreatePerplexityAiCredentialDto)
	}
	if c.typ == "CreatePlayHtCredentialDto" || c.CreatePlayHtCredentialDto != nil {
		return json.Marshal(c.CreatePlayHtCredentialDto)
	}
	if c.typ == "CreateRimeAiCredentialDto" || c.CreateRimeAiCredentialDto != nil {
		return json.Marshal(c.CreateRimeAiCredentialDto)
	}
	if c.typ == "CreateRunpodCredentialDto" || c.CreateRunpodCredentialDto != nil {
		return json.Marshal(c.CreateRunpodCredentialDto)
	}
	if c.typ == "CreateS3CredentialDto" || c.CreateS3CredentialDto != nil {
		return json.Marshal(c.CreateS3CredentialDto)
	}
	if c.typ == "CreateSupabaseCredentialDto" || c.CreateSupabaseCredentialDto != nil {
		return json.Marshal(c.CreateSupabaseCredentialDto)
	}
	if c.typ == "CreateSmallestAiCredentialDto" || c.CreateSmallestAiCredentialDto != nil {
		return json.Marshal(c.CreateSmallestAiCredentialDto)
	}
	if c.typ == "CreateTavusCredentialDto" || c.CreateTavusCredentialDto != nil {
		return json.Marshal(c.CreateTavusCredentialDto)
	}
	if c.typ == "CreateTogetherAiCredentialDto" || c.CreateTogetherAiCredentialDto != nil {
		return json.Marshal(c.CreateTogetherAiCredentialDto)
	}
	if c.typ == "CreateTwilioCredentialDto" || c.CreateTwilioCredentialDto != nil {
		return json.Marshal(c.CreateTwilioCredentialDto)
	}
	if c.typ == "CreateVonageCredentialDto" || c.CreateVonageCredentialDto != nil {
		return json.Marshal(c.CreateVonageCredentialDto)
	}
	if c.typ == "CreateWebhookCredentialDto" || c.CreateWebhookCredentialDto != nil {
		return json.Marshal(c.CreateWebhookCredentialDto)
	}
	if c.typ == "CreateXAiCredentialDto" || c.CreateXAiCredentialDto != nil {
		return json.Marshal(c.CreateXAiCredentialDto)
	}
	if c.typ == "CreateNeuphonicCredentialDto" || c.CreateNeuphonicCredentialDto != nil {
		return json.Marshal(c.CreateNeuphonicCredentialDto)
	}
	if c.typ == "CreateHumeCredentialDto" || c.CreateHumeCredentialDto != nil {
		return json.Marshal(c.CreateHumeCredentialDto)
	}
	if c.typ == "CreateMistralCredentialDto" || c.CreateMistralCredentialDto != nil {
		return json.Marshal(c.CreateMistralCredentialDto)
	}
	if c.typ == "CreateSpeechmaticsCredentialDto" || c.CreateSpeechmaticsCredentialDto != nil {
		return json.Marshal(c.CreateSpeechmaticsCredentialDto)
	}
	if c.typ == "CreateTrieveCredentialDto" || c.CreateTrieveCredentialDto != nil {
		return json.Marshal(c.CreateTrieveCredentialDto)
	}
	if c.typ == "CreateGoogleCalendarOAuth2ClientCredentialDto" || c.CreateGoogleCalendarOAuth2ClientCredentialDto != nil {
		return json.Marshal(c.CreateGoogleCalendarOAuth2ClientCredentialDto)
	}
	if c.typ == "CreateGoogleCalendarOAuth2AuthorizationCredentialDto" || c.CreateGoogleCalendarOAuth2AuthorizationCredentialDto != nil {
		return json.Marshal(c.CreateGoogleCalendarOAuth2AuthorizationCredentialDto)
	}
	if c.typ == "CreateGoogleSheetsOAuth2AuthorizationCredentialDto" || c.CreateGoogleSheetsOAuth2AuthorizationCredentialDto != nil {
		return json.Marshal(c.CreateGoogleSheetsOAuth2AuthorizationCredentialDto)
	}
	if c.typ == "CreateSlackOAuth2AuthorizationCredentialDto" || c.CreateSlackOAuth2AuthorizationCredentialDto != nil {
		return json.Marshal(c.CreateSlackOAuth2AuthorizationCredentialDto)
	}
	if c.typ == "CreateGoHighLevelMcpCredentialDto" || c.CreateGoHighLevelMcpCredentialDto != nil {
		return json.Marshal(c.CreateGoHighLevelMcpCredentialDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoCredentialsItemVisitor interface {
	VisitCreateElevenLabsCredentialDto(*CreateElevenLabsCredentialDto) error
	VisitCreateAnthropicCredentialDto(*CreateAnthropicCredentialDto) error
	VisitCreateAnyscaleCredentialDto(*CreateAnyscaleCredentialDto) error
	VisitCreateAssemblyAiCredentialDto(*CreateAssemblyAiCredentialDto) error
	VisitCreateAzureOpenAiCredentialDto(*CreateAzureOpenAiCredentialDto) error
	VisitCreateAzureCredentialDto(*CreateAzureCredentialDto) error
	VisitCreateByoSipTrunkCredentialDto(*CreateByoSipTrunkCredentialDto) error
	VisitCreateCartesiaCredentialDto(*CreateCartesiaCredentialDto) error
	VisitCreateCerebrasCredentialDto(*CreateCerebrasCredentialDto) error
	VisitCreateCloudflareCredentialDto(*CreateCloudflareCredentialDto) error
	VisitCreateCustomLlmCredentialDto(*CreateCustomLlmCredentialDto) error
	VisitCreateDeepgramCredentialDto(*CreateDeepgramCredentialDto) error
	VisitCreateDeepInfraCredentialDto(*CreateDeepInfraCredentialDto) error
	VisitCreateDeepSeekCredentialDto(*CreateDeepSeekCredentialDto) error
	VisitCreateGcpCredentialDto(*CreateGcpCredentialDto) error
	VisitCreateGladiaCredentialDto(*CreateGladiaCredentialDto) error
	VisitCreateGoHighLevelCredentialDto(*CreateGoHighLevelCredentialDto) error
	VisitCreateGoogleCredentialDto(*CreateGoogleCredentialDto) error
	VisitCreateGroqCredentialDto(*CreateGroqCredentialDto) error
	VisitCreateInflectionAiCredentialDto(*CreateInflectionAiCredentialDto) error
	VisitCreateLangfuseCredentialDto(*CreateLangfuseCredentialDto) error
	VisitCreateLmntCredentialDto(*CreateLmntCredentialDto) error
	VisitCreateMakeCredentialDto(*CreateMakeCredentialDto) error
	VisitCreateOpenAiCredentialDto(*CreateOpenAiCredentialDto) error
	VisitCreateOpenRouterCredentialDto(*CreateOpenRouterCredentialDto) error
	VisitCreatePerplexityAiCredentialDto(*CreatePerplexityAiCredentialDto) error
	VisitCreatePlayHtCredentialDto(*CreatePlayHtCredentialDto) error
	VisitCreateRimeAiCredentialDto(*CreateRimeAiCredentialDto) error
	VisitCreateRunpodCredentialDto(*CreateRunpodCredentialDto) error
	VisitCreateS3CredentialDto(*CreateS3CredentialDto) error
	VisitCreateSupabaseCredentialDto(*CreateSupabaseCredentialDto) error
	VisitCreateSmallestAiCredentialDto(*CreateSmallestAiCredentialDto) error
	VisitCreateTavusCredentialDto(*CreateTavusCredentialDto) error
	VisitCreateTogetherAiCredentialDto(*CreateTogetherAiCredentialDto) error
	VisitCreateTwilioCredentialDto(*CreateTwilioCredentialDto) error
	VisitCreateVonageCredentialDto(*CreateVonageCredentialDto) error
	VisitCreateWebhookCredentialDto(*CreateWebhookCredentialDto) error
	VisitCreateXAiCredentialDto(*CreateXAiCredentialDto) error
	VisitCreateNeuphonicCredentialDto(*CreateNeuphonicCredentialDto) error
	VisitCreateHumeCredentialDto(*CreateHumeCredentialDto) error
	VisitCreateMistralCredentialDto(*CreateMistralCredentialDto) error
	VisitCreateSpeechmaticsCredentialDto(*CreateSpeechmaticsCredentialDto) error
	VisitCreateTrieveCredentialDto(*CreateTrieveCredentialDto) error
	VisitCreateGoogleCalendarOAuth2ClientCredentialDto(*CreateGoogleCalendarOAuth2ClientCredentialDto) error
	VisitCreateGoogleCalendarOAuth2AuthorizationCredentialDto(*CreateGoogleCalendarOAuth2AuthorizationCredentialDto) error
	VisitCreateGoogleSheetsOAuth2AuthorizationCredentialDto(*CreateGoogleSheetsOAuth2AuthorizationCredentialDto) error
	VisitCreateSlackOAuth2AuthorizationCredentialDto(*CreateSlackOAuth2AuthorizationCredentialDto) error
	VisitCreateGoHighLevelMcpCredentialDto(*CreateGoHighLevelMcpCredentialDto) error
}

func (c *CreateAssistantDtoCredentialsItem) Accept(visitor CreateAssistantDtoCredentialsItemVisitor) error {
	if c.typ == "CreateElevenLabsCredentialDto" || c.CreateElevenLabsCredentialDto != nil {
		return visitor.VisitCreateElevenLabsCredentialDto(c.CreateElevenLabsCredentialDto)
	}
	if c.typ == "CreateAnthropicCredentialDto" || c.CreateAnthropicCredentialDto != nil {
		return visitor.VisitCreateAnthropicCredentialDto(c.CreateAnthropicCredentialDto)
	}
	if c.typ == "CreateAnyscaleCredentialDto" || c.CreateAnyscaleCredentialDto != nil {
		return visitor.VisitCreateAnyscaleCredentialDto(c.CreateAnyscaleCredentialDto)
	}
	if c.typ == "CreateAssemblyAiCredentialDto" || c.CreateAssemblyAiCredentialDto != nil {
		return visitor.VisitCreateAssemblyAiCredentialDto(c.CreateAssemblyAiCredentialDto)
	}
	if c.typ == "CreateAzureOpenAiCredentialDto" || c.CreateAzureOpenAiCredentialDto != nil {
		return visitor.VisitCreateAzureOpenAiCredentialDto(c.CreateAzureOpenAiCredentialDto)
	}
	if c.typ == "CreateAzureCredentialDto" || c.CreateAzureCredentialDto != nil {
		return visitor.VisitCreateAzureCredentialDto(c.CreateAzureCredentialDto)
	}
	if c.typ == "CreateByoSipTrunkCredentialDto" || c.CreateByoSipTrunkCredentialDto != nil {
		return visitor.VisitCreateByoSipTrunkCredentialDto(c.CreateByoSipTrunkCredentialDto)
	}
	if c.typ == "CreateCartesiaCredentialDto" || c.CreateCartesiaCredentialDto != nil {
		return visitor.VisitCreateCartesiaCredentialDto(c.CreateCartesiaCredentialDto)
	}
	if c.typ == "CreateCerebrasCredentialDto" || c.CreateCerebrasCredentialDto != nil {
		return visitor.VisitCreateCerebrasCredentialDto(c.CreateCerebrasCredentialDto)
	}
	if c.typ == "CreateCloudflareCredentialDto" || c.CreateCloudflareCredentialDto != nil {
		return visitor.VisitCreateCloudflareCredentialDto(c.CreateCloudflareCredentialDto)
	}
	if c.typ == "CreateCustomLlmCredentialDto" || c.CreateCustomLlmCredentialDto != nil {
		return visitor.VisitCreateCustomLlmCredentialDto(c.CreateCustomLlmCredentialDto)
	}
	if c.typ == "CreateDeepgramCredentialDto" || c.CreateDeepgramCredentialDto != nil {
		return visitor.VisitCreateDeepgramCredentialDto(c.CreateDeepgramCredentialDto)
	}
	if c.typ == "CreateDeepInfraCredentialDto" || c.CreateDeepInfraCredentialDto != nil {
		return visitor.VisitCreateDeepInfraCredentialDto(c.CreateDeepInfraCredentialDto)
	}
	if c.typ == "CreateDeepSeekCredentialDto" || c.CreateDeepSeekCredentialDto != nil {
		return visitor.VisitCreateDeepSeekCredentialDto(c.CreateDeepSeekCredentialDto)
	}
	if c.typ == "CreateGcpCredentialDto" || c.CreateGcpCredentialDto != nil {
		return visitor.VisitCreateGcpCredentialDto(c.CreateGcpCredentialDto)
	}
	if c.typ == "CreateGladiaCredentialDto" || c.CreateGladiaCredentialDto != nil {
		return visitor.VisitCreateGladiaCredentialDto(c.CreateGladiaCredentialDto)
	}
	if c.typ == "CreateGoHighLevelCredentialDto" || c.CreateGoHighLevelCredentialDto != nil {
		return visitor.VisitCreateGoHighLevelCredentialDto(c.CreateGoHighLevelCredentialDto)
	}
	if c.typ == "CreateGoogleCredentialDto" || c.CreateGoogleCredentialDto != nil {
		return visitor.VisitCreateGoogleCredentialDto(c.CreateGoogleCredentialDto)
	}
	if c.typ == "CreateGroqCredentialDto" || c.CreateGroqCredentialDto != nil {
		return visitor.VisitCreateGroqCredentialDto(c.CreateGroqCredentialDto)
	}
	if c.typ == "CreateInflectionAiCredentialDto" || c.CreateInflectionAiCredentialDto != nil {
		return visitor.VisitCreateInflectionAiCredentialDto(c.CreateInflectionAiCredentialDto)
	}
	if c.typ == "CreateLangfuseCredentialDto" || c.CreateLangfuseCredentialDto != nil {
		return visitor.VisitCreateLangfuseCredentialDto(c.CreateLangfuseCredentialDto)
	}
	if c.typ == "CreateLmntCredentialDto" || c.CreateLmntCredentialDto != nil {
		return visitor.VisitCreateLmntCredentialDto(c.CreateLmntCredentialDto)
	}
	if c.typ == "CreateMakeCredentialDto" || c.CreateMakeCredentialDto != nil {
		return visitor.VisitCreateMakeCredentialDto(c.CreateMakeCredentialDto)
	}
	if c.typ == "CreateOpenAiCredentialDto" || c.CreateOpenAiCredentialDto != nil {
		return visitor.VisitCreateOpenAiCredentialDto(c.CreateOpenAiCredentialDto)
	}
	if c.typ == "CreateOpenRouterCredentialDto" || c.CreateOpenRouterCredentialDto != nil {
		return visitor.VisitCreateOpenRouterCredentialDto(c.CreateOpenRouterCredentialDto)
	}
	if c.typ == "CreatePerplexityAiCredentialDto" || c.CreatePerplexityAiCredentialDto != nil {
		return visitor.VisitCreatePerplexityAiCredentialDto(c.CreatePerplexityAiCredentialDto)
	}
	if c.typ == "CreatePlayHtCredentialDto" || c.CreatePlayHtCredentialDto != nil {
		return visitor.VisitCreatePlayHtCredentialDto(c.CreatePlayHtCredentialDto)
	}
	if c.typ == "CreateRimeAiCredentialDto" || c.CreateRimeAiCredentialDto != nil {
		return visitor.VisitCreateRimeAiCredentialDto(c.CreateRimeAiCredentialDto)
	}
	if c.typ == "CreateRunpodCredentialDto" || c.CreateRunpodCredentialDto != nil {
		return visitor.VisitCreateRunpodCredentialDto(c.CreateRunpodCredentialDto)
	}
	if c.typ == "CreateS3CredentialDto" || c.CreateS3CredentialDto != nil {
		return visitor.VisitCreateS3CredentialDto(c.CreateS3CredentialDto)
	}
	if c.typ == "CreateSupabaseCredentialDto" || c.CreateSupabaseCredentialDto != nil {
		return visitor.VisitCreateSupabaseCredentialDto(c.CreateSupabaseCredentialDto)
	}
	if c.typ == "CreateSmallestAiCredentialDto" || c.CreateSmallestAiCredentialDto != nil {
		return visitor.VisitCreateSmallestAiCredentialDto(c.CreateSmallestAiCredentialDto)
	}
	if c.typ == "CreateTavusCredentialDto" || c.CreateTavusCredentialDto != nil {
		return visitor.VisitCreateTavusCredentialDto(c.CreateTavusCredentialDto)
	}
	if c.typ == "CreateTogetherAiCredentialDto" || c.CreateTogetherAiCredentialDto != nil {
		return visitor.VisitCreateTogetherAiCredentialDto(c.CreateTogetherAiCredentialDto)
	}
	if c.typ == "CreateTwilioCredentialDto" || c.CreateTwilioCredentialDto != nil {
		return visitor.VisitCreateTwilioCredentialDto(c.CreateTwilioCredentialDto)
	}
	if c.typ == "CreateVonageCredentialDto" || c.CreateVonageCredentialDto != nil {
		return visitor.VisitCreateVonageCredentialDto(c.CreateVonageCredentialDto)
	}
	if c.typ == "CreateWebhookCredentialDto" || c.CreateWebhookCredentialDto != nil {
		return visitor.VisitCreateWebhookCredentialDto(c.CreateWebhookCredentialDto)
	}
	if c.typ == "CreateXAiCredentialDto" || c.CreateXAiCredentialDto != nil {
		return visitor.VisitCreateXAiCredentialDto(c.CreateXAiCredentialDto)
	}
	if c.typ == "CreateNeuphonicCredentialDto" || c.CreateNeuphonicCredentialDto != nil {
		return visitor.VisitCreateNeuphonicCredentialDto(c.CreateNeuphonicCredentialDto)
	}
	if c.typ == "CreateHumeCredentialDto" || c.CreateHumeCredentialDto != nil {
		return visitor.VisitCreateHumeCredentialDto(c.CreateHumeCredentialDto)
	}
	if c.typ == "CreateMistralCredentialDto" || c.CreateMistralCredentialDto != nil {
		return visitor.VisitCreateMistralCredentialDto(c.CreateMistralCredentialDto)
	}
	if c.typ == "CreateSpeechmaticsCredentialDto" || c.CreateSpeechmaticsCredentialDto != nil {
		return visitor.VisitCreateSpeechmaticsCredentialDto(c.CreateSpeechmaticsCredentialDto)
	}
	if c.typ == "CreateTrieveCredentialDto" || c.CreateTrieveCredentialDto != nil {
		return visitor.VisitCreateTrieveCredentialDto(c.CreateTrieveCredentialDto)
	}
	if c.typ == "CreateGoogleCalendarOAuth2ClientCredentialDto" || c.CreateGoogleCalendarOAuth2ClientCredentialDto != nil {
		return visitor.VisitCreateGoogleCalendarOAuth2ClientCredentialDto(c.CreateGoogleCalendarOAuth2ClientCredentialDto)
	}
	if c.typ == "CreateGoogleCalendarOAuth2AuthorizationCredentialDto" || c.CreateGoogleCalendarOAuth2AuthorizationCredentialDto != nil {
		return visitor.VisitCreateGoogleCalendarOAuth2AuthorizationCredentialDto(c.CreateGoogleCalendarOAuth2AuthorizationCredentialDto)
	}
	if c.typ == "CreateGoogleSheetsOAuth2AuthorizationCredentialDto" || c.CreateGoogleSheetsOAuth2AuthorizationCredentialDto != nil {
		return visitor.VisitCreateGoogleSheetsOAuth2AuthorizationCredentialDto(c.CreateGoogleSheetsOAuth2AuthorizationCredentialDto)
	}
	if c.typ == "CreateSlackOAuth2AuthorizationCredentialDto" || c.CreateSlackOAuth2AuthorizationCredentialDto != nil {
		return visitor.VisitCreateSlackOAuth2AuthorizationCredentialDto(c.CreateSlackOAuth2AuthorizationCredentialDto)
	}
	if c.typ == "CreateGoHighLevelMcpCredentialDto" || c.CreateGoHighLevelMcpCredentialDto != nil {
		return visitor.VisitCreateGoHighLevelMcpCredentialDto(c.CreateGoHighLevelMcpCredentialDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type CreateAssistantDtoFirstMessageMode string

const (
	CreateAssistantDtoFirstMessageModeAssistantSpeaksFirst                          CreateAssistantDtoFirstMessageMode = "assistant-speaks-first"
	CreateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage CreateAssistantDtoFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	CreateAssistantDtoFirstMessageModeAssistantWaitsForUser                         CreateAssistantDtoFirstMessageMode = "assistant-waits-for-user"
)

func NewCreateAssistantDtoFirstMessageModeFromString(s string) (CreateAssistantDtoFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return CreateAssistantDtoFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return CreateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return CreateAssistantDtoFirstMessageModeAssistantWaitsForUser, nil
	}
	var t CreateAssistantDtoFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoFirstMessageMode) Ptr() *CreateAssistantDtoFirstMessageMode {
	return &c
}

type CreateAssistantDtoHooksItem struct {
	AssistantHookCallEnding                 *AssistantHookCallEnding
	AssistantHookAssistantSpeechInterrupted *AssistantHookAssistantSpeechInterrupted
	AssistantHookCustomerSpeechInterrupted  *AssistantHookCustomerSpeechInterrupted

	typ string
}

func (c *CreateAssistantDtoHooksItem) GetAssistantHookCallEnding() *AssistantHookCallEnding {
	if c == nil {
		return nil
	}
	return c.AssistantHookCallEnding
}

func (c *CreateAssistantDtoHooksItem) GetAssistantHookAssistantSpeechInterrupted() *AssistantHookAssistantSpeechInterrupted {
	if c == nil {
		return nil
	}
	return c.AssistantHookAssistantSpeechInterrupted
}

func (c *CreateAssistantDtoHooksItem) GetAssistantHookCustomerSpeechInterrupted() *AssistantHookCustomerSpeechInterrupted {
	if c == nil {
		return nil
	}
	return c.AssistantHookCustomerSpeechInterrupted
}

func (c *CreateAssistantDtoHooksItem) UnmarshalJSON(data []byte) error {
	valueAssistantHookCallEnding := new(AssistantHookCallEnding)
	if err := json.Unmarshal(data, &valueAssistantHookCallEnding); err == nil {
		c.typ = "AssistantHookCallEnding"
		c.AssistantHookCallEnding = valueAssistantHookCallEnding
		return nil
	}
	valueAssistantHookAssistantSpeechInterrupted := new(AssistantHookAssistantSpeechInterrupted)
	if err := json.Unmarshal(data, &valueAssistantHookAssistantSpeechInterrupted); err == nil {
		c.typ = "AssistantHookAssistantSpeechInterrupted"
		c.AssistantHookAssistantSpeechInterrupted = valueAssistantHookAssistantSpeechInterrupted
		return nil
	}
	valueAssistantHookCustomerSpeechInterrupted := new(AssistantHookCustomerSpeechInterrupted)
	if err := json.Unmarshal(data, &valueAssistantHookCustomerSpeechInterrupted); err == nil {
		c.typ = "AssistantHookCustomerSpeechInterrupted"
		c.AssistantHookCustomerSpeechInterrupted = valueAssistantHookCustomerSpeechInterrupted
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoHooksItem) MarshalJSON() ([]byte, error) {
	if c.typ == "AssistantHookCallEnding" || c.AssistantHookCallEnding != nil {
		return json.Marshal(c.AssistantHookCallEnding)
	}
	if c.typ == "AssistantHookAssistantSpeechInterrupted" || c.AssistantHookAssistantSpeechInterrupted != nil {
		return json.Marshal(c.AssistantHookAssistantSpeechInterrupted)
	}
	if c.typ == "AssistantHookCustomerSpeechInterrupted" || c.AssistantHookCustomerSpeechInterrupted != nil {
		return json.Marshal(c.AssistantHookCustomerSpeechInterrupted)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoHooksItemVisitor interface {
	VisitAssistantHookCallEnding(*AssistantHookCallEnding) error
	VisitAssistantHookAssistantSpeechInterrupted(*AssistantHookAssistantSpeechInterrupted) error
	VisitAssistantHookCustomerSpeechInterrupted(*AssistantHookCustomerSpeechInterrupted) error
}

func (c *CreateAssistantDtoHooksItem) Accept(visitor CreateAssistantDtoHooksItemVisitor) error {
	if c.typ == "AssistantHookCallEnding" || c.AssistantHookCallEnding != nil {
		return visitor.VisitAssistantHookCallEnding(c.AssistantHookCallEnding)
	}
	if c.typ == "AssistantHookAssistantSpeechInterrupted" || c.AssistantHookAssistantSpeechInterrupted != nil {
		return visitor.VisitAssistantHookAssistantSpeechInterrupted(c.AssistantHookAssistantSpeechInterrupted)
	}
	if c.typ == "AssistantHookCustomerSpeechInterrupted" || c.AssistantHookCustomerSpeechInterrupted != nil {
		return visitor.VisitAssistantHookCustomerSpeechInterrupted(c.AssistantHookCustomerSpeechInterrupted)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are the options for the assistant's LLM.
type CreateAssistantDtoModel struct {
	AnthropicModel    *AnthropicModel
	AnyscaleModel     *AnyscaleModel
	CerebrasModel     *CerebrasModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	DeepSeekModel     *DeepSeekModel
	GoogleModel       *GoogleModel
	GroqModel         *GroqModel
	InflectionAiModel *InflectionAiModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	XaiModel          *XaiModel

	typ string
}

func (c *CreateAssistantDtoModel) GetAnthropicModel() *AnthropicModel {
	if c == nil {
		return nil
	}
	return c.AnthropicModel
}

func (c *CreateAssistantDtoModel) GetAnyscaleModel() *AnyscaleModel {
	if c == nil {
		return nil
	}
	return c.AnyscaleModel
}

func (c *CreateAssistantDtoModel) GetCerebrasModel() *CerebrasModel {
	if c == nil {
		return nil
	}
	return c.CerebrasModel
}

func (c *CreateAssistantDtoModel) GetCustomLlmModel() *CustomLlmModel {
	if c == nil {
		return nil
	}
	return c.CustomLlmModel
}

func (c *CreateAssistantDtoModel) GetDeepInfraModel() *DeepInfraModel {
	if c == nil {
		return nil
	}
	return c.DeepInfraModel
}

func (c *CreateAssistantDtoModel) GetDeepSeekModel() *DeepSeekModel {
	if c == nil {
		return nil
	}
	return c.DeepSeekModel
}

func (c *CreateAssistantDtoModel) GetGoogleModel() *GoogleModel {
	if c == nil {
		return nil
	}
	return c.GoogleModel
}

func (c *CreateAssistantDtoModel) GetGroqModel() *GroqModel {
	if c == nil {
		return nil
	}
	return c.GroqModel
}

func (c *CreateAssistantDtoModel) GetInflectionAiModel() *InflectionAiModel {
	if c == nil {
		return nil
	}
	return c.InflectionAiModel
}

func (c *CreateAssistantDtoModel) GetOpenAiModel() *OpenAiModel {
	if c == nil {
		return nil
	}
	return c.OpenAiModel
}

func (c *CreateAssistantDtoModel) GetOpenRouterModel() *OpenRouterModel {
	if c == nil {
		return nil
	}
	return c.OpenRouterModel
}

func (c *CreateAssistantDtoModel) GetPerplexityAiModel() *PerplexityAiModel {
	if c == nil {
		return nil
	}
	return c.PerplexityAiModel
}

func (c *CreateAssistantDtoModel) GetTogetherAiModel() *TogetherAiModel {
	if c == nil {
		return nil
	}
	return c.TogetherAiModel
}

func (c *CreateAssistantDtoModel) GetXaiModel() *XaiModel {
	if c == nil {
		return nil
	}
	return c.XaiModel
}

func (c *CreateAssistantDtoModel) UnmarshalJSON(data []byte) error {
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		c.typ = "AnthropicModel"
		c.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		c.typ = "AnyscaleModel"
		c.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueCerebrasModel := new(CerebrasModel)
	if err := json.Unmarshal(data, &valueCerebrasModel); err == nil {
		c.typ = "CerebrasModel"
		c.CerebrasModel = valueCerebrasModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		c.typ = "CustomLlmModel"
		c.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		c.typ = "DeepInfraModel"
		c.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueDeepSeekModel := new(DeepSeekModel)
	if err := json.Unmarshal(data, &valueDeepSeekModel); err == nil {
		c.typ = "DeepSeekModel"
		c.DeepSeekModel = valueDeepSeekModel
		return nil
	}
	valueGoogleModel := new(GoogleModel)
	if err := json.Unmarshal(data, &valueGoogleModel); err == nil {
		c.typ = "GoogleModel"
		c.GoogleModel = valueGoogleModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		c.typ = "GroqModel"
		c.GroqModel = valueGroqModel
		return nil
	}
	valueInflectionAiModel := new(InflectionAiModel)
	if err := json.Unmarshal(data, &valueInflectionAiModel); err == nil {
		c.typ = "InflectionAiModel"
		c.InflectionAiModel = valueInflectionAiModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		c.typ = "OpenAiModel"
		c.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		c.typ = "OpenRouterModel"
		c.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		c.typ = "PerplexityAiModel"
		c.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		c.typ = "TogetherAiModel"
		c.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueXaiModel := new(XaiModel)
	if err := json.Unmarshal(data, &valueXaiModel); err == nil {
		c.typ = "XaiModel"
		c.XaiModel = valueXaiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoModel) MarshalJSON() ([]byte, error) {
	if c.typ == "AnthropicModel" || c.AnthropicModel != nil {
		return json.Marshal(c.AnthropicModel)
	}
	if c.typ == "AnyscaleModel" || c.AnyscaleModel != nil {
		return json.Marshal(c.AnyscaleModel)
	}
	if c.typ == "CerebrasModel" || c.CerebrasModel != nil {
		return json.Marshal(c.CerebrasModel)
	}
	if c.typ == "CustomLlmModel" || c.CustomLlmModel != nil {
		return json.Marshal(c.CustomLlmModel)
	}
	if c.typ == "DeepInfraModel" || c.DeepInfraModel != nil {
		return json.Marshal(c.DeepInfraModel)
	}
	if c.typ == "DeepSeekModel" || c.DeepSeekModel != nil {
		return json.Marshal(c.DeepSeekModel)
	}
	if c.typ == "GoogleModel" || c.GoogleModel != nil {
		return json.Marshal(c.GoogleModel)
	}
	if c.typ == "GroqModel" || c.GroqModel != nil {
		return json.Marshal(c.GroqModel)
	}
	if c.typ == "InflectionAiModel" || c.InflectionAiModel != nil {
		return json.Marshal(c.InflectionAiModel)
	}
	if c.typ == "OpenAiModel" || c.OpenAiModel != nil {
		return json.Marshal(c.OpenAiModel)
	}
	if c.typ == "OpenRouterModel" || c.OpenRouterModel != nil {
		return json.Marshal(c.OpenRouterModel)
	}
	if c.typ == "PerplexityAiModel" || c.PerplexityAiModel != nil {
		return json.Marshal(c.PerplexityAiModel)
	}
	if c.typ == "TogetherAiModel" || c.TogetherAiModel != nil {
		return json.Marshal(c.TogetherAiModel)
	}
	if c.typ == "XaiModel" || c.XaiModel != nil {
		return json.Marshal(c.XaiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoModelVisitor interface {
	VisitAnthropicModel(*AnthropicModel) error
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitCerebrasModel(*CerebrasModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitDeepSeekModel(*DeepSeekModel) error
	VisitGoogleModel(*GoogleModel) error
	VisitGroqModel(*GroqModel) error
	VisitInflectionAiModel(*InflectionAiModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitXaiModel(*XaiModel) error
}

func (c *CreateAssistantDtoModel) Accept(visitor CreateAssistantDtoModelVisitor) error {
	if c.typ == "AnthropicModel" || c.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(c.AnthropicModel)
	}
	if c.typ == "AnyscaleModel" || c.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(c.AnyscaleModel)
	}
	if c.typ == "CerebrasModel" || c.CerebrasModel != nil {
		return visitor.VisitCerebrasModel(c.CerebrasModel)
	}
	if c.typ == "CustomLlmModel" || c.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(c.CustomLlmModel)
	}
	if c.typ == "DeepInfraModel" || c.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(c.DeepInfraModel)
	}
	if c.typ == "DeepSeekModel" || c.DeepSeekModel != nil {
		return visitor.VisitDeepSeekModel(c.DeepSeekModel)
	}
	if c.typ == "GoogleModel" || c.GoogleModel != nil {
		return visitor.VisitGoogleModel(c.GoogleModel)
	}
	if c.typ == "GroqModel" || c.GroqModel != nil {
		return visitor.VisitGroqModel(c.GroqModel)
	}
	if c.typ == "InflectionAiModel" || c.InflectionAiModel != nil {
		return visitor.VisitInflectionAiModel(c.InflectionAiModel)
	}
	if c.typ == "OpenAiModel" || c.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(c.OpenAiModel)
	}
	if c.typ == "OpenRouterModel" || c.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(c.OpenRouterModel)
	}
	if c.typ == "PerplexityAiModel" || c.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(c.PerplexityAiModel)
	}
	if c.typ == "TogetherAiModel" || c.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(c.TogetherAiModel)
	}
	if c.typ == "XaiModel" || c.XaiModel != nil {
		return visitor.VisitXaiModel(c.XaiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoServerMessagesItem string

const (
	CreateAssistantDtoServerMessagesItemConversationUpdate            CreateAssistantDtoServerMessagesItem = "conversation-update"
	CreateAssistantDtoServerMessagesItemEndOfCallReport               CreateAssistantDtoServerMessagesItem = "end-of-call-report"
	CreateAssistantDtoServerMessagesItemFunctionCall                  CreateAssistantDtoServerMessagesItem = "function-call"
	CreateAssistantDtoServerMessagesItemHang                          CreateAssistantDtoServerMessagesItem = "hang"
	CreateAssistantDtoServerMessagesItemLanguageChanged               CreateAssistantDtoServerMessagesItem = "language-changed"
	CreateAssistantDtoServerMessagesItemLanguageChangeDetected        CreateAssistantDtoServerMessagesItem = "language-change-detected"
	CreateAssistantDtoServerMessagesItemModelOutput                   CreateAssistantDtoServerMessagesItem = "model-output"
	CreateAssistantDtoServerMessagesItemPhoneCallControl              CreateAssistantDtoServerMessagesItem = "phone-call-control"
	CreateAssistantDtoServerMessagesItemSpeechUpdate                  CreateAssistantDtoServerMessagesItem = "speech-update"
	CreateAssistantDtoServerMessagesItemStatusUpdate                  CreateAssistantDtoServerMessagesItem = "status-update"
	CreateAssistantDtoServerMessagesItemTranscript                    CreateAssistantDtoServerMessagesItem = "transcript"
	CreateAssistantDtoServerMessagesItemTranscriptTranscriptTypeFinal CreateAssistantDtoServerMessagesItem = "transcript[transcriptType=\\\"final\\\"]"
	CreateAssistantDtoServerMessagesItemToolCalls                     CreateAssistantDtoServerMessagesItem = "tool-calls"
	CreateAssistantDtoServerMessagesItemTransferDestinationRequest    CreateAssistantDtoServerMessagesItem = "transfer-destination-request"
	CreateAssistantDtoServerMessagesItemTransferUpdate                CreateAssistantDtoServerMessagesItem = "transfer-update"
	CreateAssistantDtoServerMessagesItemUserInterrupted               CreateAssistantDtoServerMessagesItem = "user-interrupted"
	CreateAssistantDtoServerMessagesItemVoiceInput                    CreateAssistantDtoServerMessagesItem = "voice-input"
)

func NewCreateAssistantDtoServerMessagesItemFromString(s string) (CreateAssistantDtoServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return CreateAssistantDtoServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return CreateAssistantDtoServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return CreateAssistantDtoServerMessagesItemFunctionCall, nil
	case "hang":
		return CreateAssistantDtoServerMessagesItemHang, nil
	case "language-changed":
		return CreateAssistantDtoServerMessagesItemLanguageChanged, nil
	case "language-change-detected":
		return CreateAssistantDtoServerMessagesItemLanguageChangeDetected, nil
	case "model-output":
		return CreateAssistantDtoServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return CreateAssistantDtoServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return CreateAssistantDtoServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return CreateAssistantDtoServerMessagesItemStatusUpdate, nil
	case "transcript":
		return CreateAssistantDtoServerMessagesItemTranscript, nil
	case "transcript[transcriptType=\"final\"]":
		return CreateAssistantDtoServerMessagesItemTranscriptTranscriptTypeFinal, nil
	case "tool-calls":
		return CreateAssistantDtoServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return CreateAssistantDtoServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return CreateAssistantDtoServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return CreateAssistantDtoServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return CreateAssistantDtoServerMessagesItemVoiceInput, nil
	}
	var t CreateAssistantDtoServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoServerMessagesItem) Ptr() *CreateAssistantDtoServerMessagesItem {
	return &c
}

// These are the options for the assistant's transcriber.
type CreateAssistantDtoTranscriber struct {
	AssemblyAiTranscriber   *AssemblyAiTranscriber
	AzureSpeechTranscriber  *AzureSpeechTranscriber
	CustomTranscriber       *CustomTranscriber
	DeepgramTranscriber     *DeepgramTranscriber
	ElevenLabsTranscriber   *ElevenLabsTranscriber
	GladiaTranscriber       *GladiaTranscriber
	GoogleTranscriber       *GoogleTranscriber
	SpeechmaticsTranscriber *SpeechmaticsTranscriber
	TalkscriberTranscriber  *TalkscriberTranscriber
	OpenAiTranscriber       *OpenAiTranscriber

	typ string
}

func (c *CreateAssistantDtoTranscriber) GetAssemblyAiTranscriber() *AssemblyAiTranscriber {
	if c == nil {
		return nil
	}
	return c.AssemblyAiTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetAzureSpeechTranscriber() *AzureSpeechTranscriber {
	if c == nil {
		return nil
	}
	return c.AzureSpeechTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetCustomTranscriber() *CustomTranscriber {
	if c == nil {
		return nil
	}
	return c.CustomTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetDeepgramTranscriber() *DeepgramTranscriber {
	if c == nil {
		return nil
	}
	return c.DeepgramTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetElevenLabsTranscriber() *ElevenLabsTranscriber {
	if c == nil {
		return nil
	}
	return c.ElevenLabsTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetGladiaTranscriber() *GladiaTranscriber {
	if c == nil {
		return nil
	}
	return c.GladiaTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetGoogleTranscriber() *GoogleTranscriber {
	if c == nil {
		return nil
	}
	return c.GoogleTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetSpeechmaticsTranscriber() *SpeechmaticsTranscriber {
	if c == nil {
		return nil
	}
	return c.SpeechmaticsTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetTalkscriberTranscriber() *TalkscriberTranscriber {
	if c == nil {
		return nil
	}
	return c.TalkscriberTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetOpenAiTranscriber() *OpenAiTranscriber {
	if c == nil {
		return nil
	}
	return c.OpenAiTranscriber
}

func (c *CreateAssistantDtoTranscriber) UnmarshalJSON(data []byte) error {
	valueAssemblyAiTranscriber := new(AssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueAssemblyAiTranscriber); err == nil {
		c.typ = "AssemblyAiTranscriber"
		c.AssemblyAiTranscriber = valueAssemblyAiTranscriber
		return nil
	}
	valueAzureSpeechTranscriber := new(AzureSpeechTranscriber)
	if err := json.Unmarshal(data, &valueAzureSpeechTranscriber); err == nil {
		c.typ = "AzureSpeechTranscriber"
		c.AzureSpeechTranscriber = valueAzureSpeechTranscriber
		return nil
	}
	valueCustomTranscriber := new(CustomTranscriber)
	if err := json.Unmarshal(data, &valueCustomTranscriber); err == nil {
		c.typ = "CustomTranscriber"
		c.CustomTranscriber = valueCustomTranscriber
		return nil
	}
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		c.typ = "DeepgramTranscriber"
		c.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueElevenLabsTranscriber := new(ElevenLabsTranscriber)
	if err := json.Unmarshal(data, &valueElevenLabsTranscriber); err == nil {
		c.typ = "ElevenLabsTranscriber"
		c.ElevenLabsTranscriber = valueElevenLabsTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		c.typ = "GladiaTranscriber"
		c.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueGoogleTranscriber := new(GoogleTranscriber)
	if err := json.Unmarshal(data, &valueGoogleTranscriber); err == nil {
		c.typ = "GoogleTranscriber"
		c.GoogleTranscriber = valueGoogleTranscriber
		return nil
	}
	valueSpeechmaticsTranscriber := new(SpeechmaticsTranscriber)
	if err := json.Unmarshal(data, &valueSpeechmaticsTranscriber); err == nil {
		c.typ = "SpeechmaticsTranscriber"
		c.SpeechmaticsTranscriber = valueSpeechmaticsTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		c.typ = "TalkscriberTranscriber"
		c.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	valueOpenAiTranscriber := new(OpenAiTranscriber)
	if err := json.Unmarshal(data, &valueOpenAiTranscriber); err == nil {
		c.typ = "OpenAiTranscriber"
		c.OpenAiTranscriber = valueOpenAiTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoTranscriber) MarshalJSON() ([]byte, error) {
	if c.typ == "AssemblyAiTranscriber" || c.AssemblyAiTranscriber != nil {
		return json.Marshal(c.AssemblyAiTranscriber)
	}
	if c.typ == "AzureSpeechTranscriber" || c.AzureSpeechTranscriber != nil {
		return json.Marshal(c.AzureSpeechTranscriber)
	}
	if c.typ == "CustomTranscriber" || c.CustomTranscriber != nil {
		return json.Marshal(c.CustomTranscriber)
	}
	if c.typ == "DeepgramTranscriber" || c.DeepgramTranscriber != nil {
		return json.Marshal(c.DeepgramTranscriber)
	}
	if c.typ == "ElevenLabsTranscriber" || c.ElevenLabsTranscriber != nil {
		return json.Marshal(c.ElevenLabsTranscriber)
	}
	if c.typ == "GladiaTranscriber" || c.GladiaTranscriber != nil {
		return json.Marshal(c.GladiaTranscriber)
	}
	if c.typ == "GoogleTranscriber" || c.GoogleTranscriber != nil {
		return json.Marshal(c.GoogleTranscriber)
	}
	if c.typ == "SpeechmaticsTranscriber" || c.SpeechmaticsTranscriber != nil {
		return json.Marshal(c.SpeechmaticsTranscriber)
	}
	if c.typ == "TalkscriberTranscriber" || c.TalkscriberTranscriber != nil {
		return json.Marshal(c.TalkscriberTranscriber)
	}
	if c.typ == "OpenAiTranscriber" || c.OpenAiTranscriber != nil {
		return json.Marshal(c.OpenAiTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoTranscriberVisitor interface {
	VisitAssemblyAiTranscriber(*AssemblyAiTranscriber) error
	VisitAzureSpeechTranscriber(*AzureSpeechTranscriber) error
	VisitCustomTranscriber(*CustomTranscriber) error
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitElevenLabsTranscriber(*ElevenLabsTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitGoogleTranscriber(*GoogleTranscriber) error
	VisitSpeechmaticsTranscriber(*SpeechmaticsTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
	VisitOpenAiTranscriber(*OpenAiTranscriber) error
}

func (c *CreateAssistantDtoTranscriber) Accept(visitor CreateAssistantDtoTranscriberVisitor) error {
	if c.typ == "AssemblyAiTranscriber" || c.AssemblyAiTranscriber != nil {
		return visitor.VisitAssemblyAiTranscriber(c.AssemblyAiTranscriber)
	}
	if c.typ == "AzureSpeechTranscriber" || c.AzureSpeechTranscriber != nil {
		return visitor.VisitAzureSpeechTranscriber(c.AzureSpeechTranscriber)
	}
	if c.typ == "CustomTranscriber" || c.CustomTranscriber != nil {
		return visitor.VisitCustomTranscriber(c.CustomTranscriber)
	}
	if c.typ == "DeepgramTranscriber" || c.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(c.DeepgramTranscriber)
	}
	if c.typ == "ElevenLabsTranscriber" || c.ElevenLabsTranscriber != nil {
		return visitor.VisitElevenLabsTranscriber(c.ElevenLabsTranscriber)
	}
	if c.typ == "GladiaTranscriber" || c.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(c.GladiaTranscriber)
	}
	if c.typ == "GoogleTranscriber" || c.GoogleTranscriber != nil {
		return visitor.VisitGoogleTranscriber(c.GoogleTranscriber)
	}
	if c.typ == "SpeechmaticsTranscriber" || c.SpeechmaticsTranscriber != nil {
		return visitor.VisitSpeechmaticsTranscriber(c.SpeechmaticsTranscriber)
	}
	if c.typ == "TalkscriberTranscriber" || c.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(c.TalkscriberTranscriber)
	}
	if c.typ == "OpenAiTranscriber" || c.OpenAiTranscriber != nil {
		return visitor.VisitOpenAiTranscriber(c.OpenAiTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are the options for the assistant's voice.
type CreateAssistantDtoVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	CustomVoice     *CustomVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	HumeVoice       *HumeVoice
	LmntVoice       *LmntVoice
	NeuphonicVoice  *NeuphonicVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
	SmallestAiVoice *SmallestAiVoice
	TavusVoice      *TavusVoice
	VapiVoice       *VapiVoice
	SesameVoice     *SesameVoice

	typ string
}

func (c *CreateAssistantDtoVoice) GetAzureVoice() *AzureVoice {
	if c == nil {
		return nil
	}
	return c.AzureVoice
}

func (c *CreateAssistantDtoVoice) GetCartesiaVoice() *CartesiaVoice {
	if c == nil {
		return nil
	}
	return c.CartesiaVoice
}

func (c *CreateAssistantDtoVoice) GetCustomVoice() *CustomVoice {
	if c == nil {
		return nil
	}
	return c.CustomVoice
}

func (c *CreateAssistantDtoVoice) GetDeepgramVoice() *DeepgramVoice {
	if c == nil {
		return nil
	}
	return c.DeepgramVoice
}

func (c *CreateAssistantDtoVoice) GetElevenLabsVoice() *ElevenLabsVoice {
	if c == nil {
		return nil
	}
	return c.ElevenLabsVoice
}

func (c *CreateAssistantDtoVoice) GetHumeVoice() *HumeVoice {
	if c == nil {
		return nil
	}
	return c.HumeVoice
}

func (c *CreateAssistantDtoVoice) GetLmntVoice() *LmntVoice {
	if c == nil {
		return nil
	}
	return c.LmntVoice
}

func (c *CreateAssistantDtoVoice) GetNeuphonicVoice() *NeuphonicVoice {
	if c == nil {
		return nil
	}
	return c.NeuphonicVoice
}

func (c *CreateAssistantDtoVoice) GetOpenAiVoice() *OpenAiVoice {
	if c == nil {
		return nil
	}
	return c.OpenAiVoice
}

func (c *CreateAssistantDtoVoice) GetPlayHtVoice() *PlayHtVoice {
	if c == nil {
		return nil
	}
	return c.PlayHtVoice
}

func (c *CreateAssistantDtoVoice) GetRimeAiVoice() *RimeAiVoice {
	if c == nil {
		return nil
	}
	return c.RimeAiVoice
}

func (c *CreateAssistantDtoVoice) GetSmallestAiVoice() *SmallestAiVoice {
	if c == nil {
		return nil
	}
	return c.SmallestAiVoice
}

func (c *CreateAssistantDtoVoice) GetTavusVoice() *TavusVoice {
	if c == nil {
		return nil
	}
	return c.TavusVoice
}

func (c *CreateAssistantDtoVoice) GetVapiVoice() *VapiVoice {
	if c == nil {
		return nil
	}
	return c.VapiVoice
}

func (c *CreateAssistantDtoVoice) GetSesameVoice() *SesameVoice {
	if c == nil {
		return nil
	}
	return c.SesameVoice
}

func (c *CreateAssistantDtoVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		c.typ = "AzureVoice"
		c.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		c.typ = "CartesiaVoice"
		c.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueCustomVoice := new(CustomVoice)
	if err := json.Unmarshal(data, &valueCustomVoice); err == nil {
		c.typ = "CustomVoice"
		c.CustomVoice = valueCustomVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		c.typ = "DeepgramVoice"
		c.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		c.typ = "ElevenLabsVoice"
		c.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueHumeVoice := new(HumeVoice)
	if err := json.Unmarshal(data, &valueHumeVoice); err == nil {
		c.typ = "HumeVoice"
		c.HumeVoice = valueHumeVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		c.typ = "LmntVoice"
		c.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeuphonicVoice := new(NeuphonicVoice)
	if err := json.Unmarshal(data, &valueNeuphonicVoice); err == nil {
		c.typ = "NeuphonicVoice"
		c.NeuphonicVoice = valueNeuphonicVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		c.typ = "OpenAiVoice"
		c.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		c.typ = "PlayHtVoice"
		c.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		c.typ = "RimeAiVoice"
		c.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	valueSmallestAiVoice := new(SmallestAiVoice)
	if err := json.Unmarshal(data, &valueSmallestAiVoice); err == nil {
		c.typ = "SmallestAiVoice"
		c.SmallestAiVoice = valueSmallestAiVoice
		return nil
	}
	valueTavusVoice := new(TavusVoice)
	if err := json.Unmarshal(data, &valueTavusVoice); err == nil {
		c.typ = "TavusVoice"
		c.TavusVoice = valueTavusVoice
		return nil
	}
	valueVapiVoice := new(VapiVoice)
	if err := json.Unmarshal(data, &valueVapiVoice); err == nil {
		c.typ = "VapiVoice"
		c.VapiVoice = valueVapiVoice
		return nil
	}
	valueSesameVoice := new(SesameVoice)
	if err := json.Unmarshal(data, &valueSesameVoice); err == nil {
		c.typ = "SesameVoice"
		c.SesameVoice = valueSesameVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoVoice) MarshalJSON() ([]byte, error) {
	if c.typ == "AzureVoice" || c.AzureVoice != nil {
		return json.Marshal(c.AzureVoice)
	}
	if c.typ == "CartesiaVoice" || c.CartesiaVoice != nil {
		return json.Marshal(c.CartesiaVoice)
	}
	if c.typ == "CustomVoice" || c.CustomVoice != nil {
		return json.Marshal(c.CustomVoice)
	}
	if c.typ == "DeepgramVoice" || c.DeepgramVoice != nil {
		return json.Marshal(c.DeepgramVoice)
	}
	if c.typ == "ElevenLabsVoice" || c.ElevenLabsVoice != nil {
		return json.Marshal(c.ElevenLabsVoice)
	}
	if c.typ == "HumeVoice" || c.HumeVoice != nil {
		return json.Marshal(c.HumeVoice)
	}
	if c.typ == "LmntVoice" || c.LmntVoice != nil {
		return json.Marshal(c.LmntVoice)
	}
	if c.typ == "NeuphonicVoice" || c.NeuphonicVoice != nil {
		return json.Marshal(c.NeuphonicVoice)
	}
	if c.typ == "OpenAiVoice" || c.OpenAiVoice != nil {
		return json.Marshal(c.OpenAiVoice)
	}
	if c.typ == "PlayHtVoice" || c.PlayHtVoice != nil {
		return json.Marshal(c.PlayHtVoice)
	}
	if c.typ == "RimeAiVoice" || c.RimeAiVoice != nil {
		return json.Marshal(c.RimeAiVoice)
	}
	if c.typ == "SmallestAiVoice" || c.SmallestAiVoice != nil {
		return json.Marshal(c.SmallestAiVoice)
	}
	if c.typ == "TavusVoice" || c.TavusVoice != nil {
		return json.Marshal(c.TavusVoice)
	}
	if c.typ == "VapiVoice" || c.VapiVoice != nil {
		return json.Marshal(c.VapiVoice)
	}
	if c.typ == "SesameVoice" || c.SesameVoice != nil {
		return json.Marshal(c.SesameVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitCustomVoice(*CustomVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitHumeVoice(*HumeVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeuphonicVoice(*NeuphonicVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
	VisitSmallestAiVoice(*SmallestAiVoice) error
	VisitTavusVoice(*TavusVoice) error
	VisitVapiVoice(*VapiVoice) error
	VisitSesameVoice(*SesameVoice) error
}

func (c *CreateAssistantDtoVoice) Accept(visitor CreateAssistantDtoVoiceVisitor) error {
	if c.typ == "AzureVoice" || c.AzureVoice != nil {
		return visitor.VisitAzureVoice(c.AzureVoice)
	}
	if c.typ == "CartesiaVoice" || c.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(c.CartesiaVoice)
	}
	if c.typ == "CustomVoice" || c.CustomVoice != nil {
		return visitor.VisitCustomVoice(c.CustomVoice)
	}
	if c.typ == "DeepgramVoice" || c.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(c.DeepgramVoice)
	}
	if c.typ == "ElevenLabsVoice" || c.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(c.ElevenLabsVoice)
	}
	if c.typ == "HumeVoice" || c.HumeVoice != nil {
		return visitor.VisitHumeVoice(c.HumeVoice)
	}
	if c.typ == "LmntVoice" || c.LmntVoice != nil {
		return visitor.VisitLmntVoice(c.LmntVoice)
	}
	if c.typ == "NeuphonicVoice" || c.NeuphonicVoice != nil {
		return visitor.VisitNeuphonicVoice(c.NeuphonicVoice)
	}
	if c.typ == "OpenAiVoice" || c.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(c.OpenAiVoice)
	}
	if c.typ == "PlayHtVoice" || c.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(c.PlayHtVoice)
	}
	if c.typ == "RimeAiVoice" || c.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(c.RimeAiVoice)
	}
	if c.typ == "SmallestAiVoice" || c.SmallestAiVoice != nil {
		return visitor.VisitSmallestAiVoice(c.SmallestAiVoice)
	}
	if c.typ == "TavusVoice" || c.TavusVoice != nil {
		return visitor.VisitTavusVoice(c.TavusVoice)
	}
	if c.typ == "VapiVoice" || c.VapiVoice != nil {
		return visitor.VisitVapiVoice(c.VapiVoice)
	}
	if c.typ == "SesameVoice" || c.SesameVoice != nil {
		return visitor.VisitSesameVoice(c.SesameVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
type CreateAssistantDtoVoicemailDetection struct {
	GoogleVoicemailDetectionPlan *GoogleVoicemailDetectionPlan
	OpenAiVoicemailDetectionPlan *OpenAiVoicemailDetectionPlan
	TwilioVoicemailDetectionPlan *TwilioVoicemailDetectionPlan
	VapiVoicemailDetectionPlan   *VapiVoicemailDetectionPlan

	typ string
}

func (c *CreateAssistantDtoVoicemailDetection) GetGoogleVoicemailDetectionPlan() *GoogleVoicemailDetectionPlan {
	if c == nil {
		return nil
	}
	return c.GoogleVoicemailDetectionPlan
}

func (c *CreateAssistantDtoVoicemailDetection) GetOpenAiVoicemailDetectionPlan() *OpenAiVoicemailDetectionPlan {
	if c == nil {
		return nil
	}
	return c.OpenAiVoicemailDetectionPlan
}

func (c *CreateAssistantDtoVoicemailDetection) GetTwilioVoicemailDetectionPlan() *TwilioVoicemailDetectionPlan {
	if c == nil {
		return nil
	}
	return c.TwilioVoicemailDetectionPlan
}

func (c *CreateAssistantDtoVoicemailDetection) GetVapiVoicemailDetectionPlan() *VapiVoicemailDetectionPlan {
	if c == nil {
		return nil
	}
	return c.VapiVoicemailDetectionPlan
}

func (c *CreateAssistantDtoVoicemailDetection) UnmarshalJSON(data []byte) error {
	valueGoogleVoicemailDetectionPlan := new(GoogleVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueGoogleVoicemailDetectionPlan); err == nil {
		c.typ = "GoogleVoicemailDetectionPlan"
		c.GoogleVoicemailDetectionPlan = valueGoogleVoicemailDetectionPlan
		return nil
	}
	valueOpenAiVoicemailDetectionPlan := new(OpenAiVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueOpenAiVoicemailDetectionPlan); err == nil {
		c.typ = "OpenAiVoicemailDetectionPlan"
		c.OpenAiVoicemailDetectionPlan = valueOpenAiVoicemailDetectionPlan
		return nil
	}
	valueTwilioVoicemailDetectionPlan := new(TwilioVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueTwilioVoicemailDetectionPlan); err == nil {
		c.typ = "TwilioVoicemailDetectionPlan"
		c.TwilioVoicemailDetectionPlan = valueTwilioVoicemailDetectionPlan
		return nil
	}
	valueVapiVoicemailDetectionPlan := new(VapiVoicemailDetectionPlan)
	if err := json.Unmarshal(data, &valueVapiVoicemailDetectionPlan); err == nil {
		c.typ = "VapiVoicemailDetectionPlan"
		c.VapiVoicemailDetectionPlan = valueVapiVoicemailDetectionPlan
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoVoicemailDetection) MarshalJSON() ([]byte, error) {
	if c.typ == "GoogleVoicemailDetectionPlan" || c.GoogleVoicemailDetectionPlan != nil {
		return json.Marshal(c.GoogleVoicemailDetectionPlan)
	}
	if c.typ == "OpenAiVoicemailDetectionPlan" || c.OpenAiVoicemailDetectionPlan != nil {
		return json.Marshal(c.OpenAiVoicemailDetectionPlan)
	}
	if c.typ == "TwilioVoicemailDetectionPlan" || c.TwilioVoicemailDetectionPlan != nil {
		return json.Marshal(c.TwilioVoicemailDetectionPlan)
	}
	if c.typ == "VapiVoicemailDetectionPlan" || c.VapiVoicemailDetectionPlan != nil {
		return json.Marshal(c.VapiVoicemailDetectionPlan)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoVoicemailDetectionVisitor interface {
	VisitGoogleVoicemailDetectionPlan(*GoogleVoicemailDetectionPlan) error
	VisitOpenAiVoicemailDetectionPlan(*OpenAiVoicemailDetectionPlan) error
	VisitTwilioVoicemailDetectionPlan(*TwilioVoicemailDetectionPlan) error
	VisitVapiVoicemailDetectionPlan(*VapiVoicemailDetectionPlan) error
}

func (c *CreateAssistantDtoVoicemailDetection) Accept(visitor CreateAssistantDtoVoicemailDetectionVisitor) error {
	if c.typ == "GoogleVoicemailDetectionPlan" || c.GoogleVoicemailDetectionPlan != nil {
		return visitor.VisitGoogleVoicemailDetectionPlan(c.GoogleVoicemailDetectionPlan)
	}
	if c.typ == "OpenAiVoicemailDetectionPlan" || c.OpenAiVoicemailDetectionPlan != nil {
		return visitor.VisitOpenAiVoicemailDetectionPlan(c.OpenAiVoicemailDetectionPlan)
	}
	if c.typ == "TwilioVoicemailDetectionPlan" || c.TwilioVoicemailDetectionPlan != nil {
		return visitor.VisitTwilioVoicemailDetectionPlan(c.TwilioVoicemailDetectionPlan)
	}
	if c.typ == "VapiVoicemailDetectionPlan" || c.VapiVoicemailDetectionPlan != nil {
		return visitor.VisitVapiVoicemailDetectionPlan(c.VapiVoicemailDetectionPlan)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAzureCredentialDto struct {
	// This is the service being used in Azure.
	Service CreateAzureCredentialDtoService `json:"service" url:"service"`
	// This is the region of the Azure resource.
	Region *CreateAzureCredentialDtoRegion `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.
	BucketPlan *AzureBlobStorageBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAzureCredentialDto) GetService() CreateAzureCredentialDtoService {
	if c == nil {
		return ""
	}
	return c.Service
}

func (c *CreateAzureCredentialDto) GetRegion() *CreateAzureCredentialDtoRegion {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateAzureCredentialDto) GetApiKey() *string {
	if c == nil {
		return nil
	}
	return c.ApiKey
}

func (c *CreateAzureCredentialDto) GetBucketPlan() *AzureBlobStorageBucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CreateAzureCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAzureCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAzureCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAzureCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAzureCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAzureCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "azure", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAzureCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAzureCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAzureCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the region of the Azure resource.
type CreateAzureCredentialDtoRegion string

const (
	CreateAzureCredentialDtoRegionAustralia      CreateAzureCredentialDtoRegion = "australia"
	CreateAzureCredentialDtoRegionCanadaeast     CreateAzureCredentialDtoRegion = "canadaeast"
	CreateAzureCredentialDtoRegionCanadacentral  CreateAzureCredentialDtoRegion = "canadacentral"
	CreateAzureCredentialDtoRegionEastus2        CreateAzureCredentialDtoRegion = "eastus2"
	CreateAzureCredentialDtoRegionEastus         CreateAzureCredentialDtoRegion = "eastus"
	CreateAzureCredentialDtoRegionFrance         CreateAzureCredentialDtoRegion = "france"
	CreateAzureCredentialDtoRegionIndia          CreateAzureCredentialDtoRegion = "india"
	CreateAzureCredentialDtoRegionJapaneast      CreateAzureCredentialDtoRegion = "japaneast"
	CreateAzureCredentialDtoRegionJapanwest      CreateAzureCredentialDtoRegion = "japanwest"
	CreateAzureCredentialDtoRegionUaenorth       CreateAzureCredentialDtoRegion = "uaenorth"
	CreateAzureCredentialDtoRegionNorthcentralus CreateAzureCredentialDtoRegion = "northcentralus"
	CreateAzureCredentialDtoRegionNorway         CreateAzureCredentialDtoRegion = "norway"
	CreateAzureCredentialDtoRegionSouthcentralus CreateAzureCredentialDtoRegion = "southcentralus"
	CreateAzureCredentialDtoRegionSwedencentral  CreateAzureCredentialDtoRegion = "swedencentral"
	CreateAzureCredentialDtoRegionSwitzerland    CreateAzureCredentialDtoRegion = "switzerland"
	CreateAzureCredentialDtoRegionUk             CreateAzureCredentialDtoRegion = "uk"
	CreateAzureCredentialDtoRegionWestus         CreateAzureCredentialDtoRegion = "westus"
	CreateAzureCredentialDtoRegionWestus3        CreateAzureCredentialDtoRegion = "westus3"
)

func NewCreateAzureCredentialDtoRegionFromString(s string) (CreateAzureCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return CreateAzureCredentialDtoRegionAustralia, nil
	case "canadaeast":
		return CreateAzureCredentialDtoRegionCanadaeast, nil
	case "canadacentral":
		return CreateAzureCredentialDtoRegionCanadacentral, nil
	case "eastus2":
		return CreateAzureCredentialDtoRegionEastus2, nil
	case "eastus":
		return CreateAzureCredentialDtoRegionEastus, nil
	case "france":
		return CreateAzureCredentialDtoRegionFrance, nil
	case "india":
		return CreateAzureCredentialDtoRegionIndia, nil
	case "japaneast":
		return CreateAzureCredentialDtoRegionJapaneast, nil
	case "japanwest":
		return CreateAzureCredentialDtoRegionJapanwest, nil
	case "uaenorth":
		return CreateAzureCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return CreateAzureCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return CreateAzureCredentialDtoRegionNorway, nil
	case "southcentralus":
		return CreateAzureCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return CreateAzureCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return CreateAzureCredentialDtoRegionSwitzerland, nil
	case "uk":
		return CreateAzureCredentialDtoRegionUk, nil
	case "westus":
		return CreateAzureCredentialDtoRegionWestus, nil
	case "westus3":
		return CreateAzureCredentialDtoRegionWestus3, nil
	}
	var t CreateAzureCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureCredentialDtoRegion) Ptr() *CreateAzureCredentialDtoRegion {
	return &c
}

// This is the service being used in Azure.
type CreateAzureCredentialDtoService string

const (
	CreateAzureCredentialDtoServiceSpeech      CreateAzureCredentialDtoService = "speech"
	CreateAzureCredentialDtoServiceBlobStorage CreateAzureCredentialDtoService = "blob_storage"
)

func NewCreateAzureCredentialDtoServiceFromString(s string) (CreateAzureCredentialDtoService, error) {
	switch s {
	case "speech":
		return CreateAzureCredentialDtoServiceSpeech, nil
	case "blob_storage":
		return CreateAzureCredentialDtoServiceBlobStorage, nil
	}
	var t CreateAzureCredentialDtoService
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureCredentialDtoService) Ptr() *CreateAzureCredentialDtoService {
	return &c
}

type CreateAzureOpenAiCredentialDto struct {
	Region CreateAzureOpenAiCredentialDtoRegion       `json:"region" url:"region"`
	Models []CreateAzureOpenAiCredentialDtoModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey string `json:"openAIKey" url:"openAIKey"`
	// This is not returned in the API.
	OcpApimSubscriptionKey *string `json:"ocpApimSubscriptionKey,omitempty" url:"ocpApimSubscriptionKey,omitempty"`
	OpenAiEndpoint         string  `json:"openAIEndpoint" url:"openAIEndpoint"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAzureOpenAiCredentialDto) GetRegion() CreateAzureOpenAiCredentialDtoRegion {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateAzureOpenAiCredentialDto) GetModels() []CreateAzureOpenAiCredentialDtoModelsItem {
	if c == nil {
		return nil
	}
	return c.Models
}

func (c *CreateAzureOpenAiCredentialDto) GetOpenAiKey() string {
	if c == nil {
		return ""
	}
	return c.OpenAiKey
}

func (c *CreateAzureOpenAiCredentialDto) GetOcpApimSubscriptionKey() *string {
	if c == nil {
		return nil
	}
	return c.OcpApimSubscriptionKey
}

func (c *CreateAzureOpenAiCredentialDto) GetOpenAiEndpoint() string {
	if c == nil {
		return ""
	}
	return c.OpenAiEndpoint
}

func (c *CreateAzureOpenAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAzureOpenAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAzureOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAzureOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAzureOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAzureOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "azure-openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "azure-openai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAzureOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAzureOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "azure-openai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAzureOpenAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAzureOpenAiCredentialDtoModelsItem string

const (
	CreateAzureOpenAiCredentialDtoModelsItemGpt4120250414     CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4.1-2025-04-14"
	CreateAzureOpenAiCredentialDtoModelsItemGpt41Mini20250414 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4.1-mini-2025-04-14"
	CreateAzureOpenAiCredentialDtoModelsItemGpt41Nano20250414 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4.1-nano-2025-04-14"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4O20241120     CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-11-20"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240806     CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-08-06"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240513     CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-05-13"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-mini-2024-07-18"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-turbo-2024-04-09"
	CreateAzureOpenAiCredentialDtoModelsItemGpt40125Preview   CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0125-preview"
	CreateAzureOpenAiCredentialDtoModelsItemGpt41106Preview   CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-1106-preview"
	CreateAzureOpenAiCredentialDtoModelsItemGpt40613          CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0613"
	CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125    CreateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-0125"
	CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106    CreateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-1106"
)

func NewCreateAzureOpenAiCredentialDtoModelsItemFromString(s string) (CreateAzureOpenAiCredentialDtoModelsItem, error) {
	switch s {
	case "gpt-4.1-2025-04-14":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4120250414, nil
	case "gpt-4.1-mini-2025-04-14":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt41Mini20250414, nil
	case "gpt-4.1-nano-2025-04-14":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt41Nano20250414, nil
	case "gpt-4o-2024-11-20":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4O20241120, nil
	case "gpt-4o-2024-08-06":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240806, nil
	case "gpt-4o-2024-05-13":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240513, nil
	case "gpt-4o-mini-2024-07-18":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718, nil
	case "gpt-4-turbo-2024-04-09":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106, nil
	}
	var t CreateAzureOpenAiCredentialDtoModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureOpenAiCredentialDtoModelsItem) Ptr() *CreateAzureOpenAiCredentialDtoModelsItem {
	return &c
}

type CreateAzureOpenAiCredentialDtoRegion string

const (
	CreateAzureOpenAiCredentialDtoRegionAustralia      CreateAzureOpenAiCredentialDtoRegion = "australia"
	CreateAzureOpenAiCredentialDtoRegionCanadaeast     CreateAzureOpenAiCredentialDtoRegion = "canadaeast"
	CreateAzureOpenAiCredentialDtoRegionCanadacentral  CreateAzureOpenAiCredentialDtoRegion = "canadacentral"
	CreateAzureOpenAiCredentialDtoRegionEastus2        CreateAzureOpenAiCredentialDtoRegion = "eastus2"
	CreateAzureOpenAiCredentialDtoRegionEastus         CreateAzureOpenAiCredentialDtoRegion = "eastus"
	CreateAzureOpenAiCredentialDtoRegionFrance         CreateAzureOpenAiCredentialDtoRegion = "france"
	CreateAzureOpenAiCredentialDtoRegionIndia          CreateAzureOpenAiCredentialDtoRegion = "india"
	CreateAzureOpenAiCredentialDtoRegionJapaneast      CreateAzureOpenAiCredentialDtoRegion = "japaneast"
	CreateAzureOpenAiCredentialDtoRegionJapanwest      CreateAzureOpenAiCredentialDtoRegion = "japanwest"
	CreateAzureOpenAiCredentialDtoRegionUaenorth       CreateAzureOpenAiCredentialDtoRegion = "uaenorth"
	CreateAzureOpenAiCredentialDtoRegionNorthcentralus CreateAzureOpenAiCredentialDtoRegion = "northcentralus"
	CreateAzureOpenAiCredentialDtoRegionNorway         CreateAzureOpenAiCredentialDtoRegion = "norway"
	CreateAzureOpenAiCredentialDtoRegionSouthcentralus CreateAzureOpenAiCredentialDtoRegion = "southcentralus"
	CreateAzureOpenAiCredentialDtoRegionSwedencentral  CreateAzureOpenAiCredentialDtoRegion = "swedencentral"
	CreateAzureOpenAiCredentialDtoRegionSwitzerland    CreateAzureOpenAiCredentialDtoRegion = "switzerland"
	CreateAzureOpenAiCredentialDtoRegionUk             CreateAzureOpenAiCredentialDtoRegion = "uk"
	CreateAzureOpenAiCredentialDtoRegionWestus         CreateAzureOpenAiCredentialDtoRegion = "westus"
	CreateAzureOpenAiCredentialDtoRegionWestus3        CreateAzureOpenAiCredentialDtoRegion = "westus3"
)

func NewCreateAzureOpenAiCredentialDtoRegionFromString(s string) (CreateAzureOpenAiCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return CreateAzureOpenAiCredentialDtoRegionAustralia, nil
	case "canadaeast":
		return CreateAzureOpenAiCredentialDtoRegionCanadaeast, nil
	case "canadacentral":
		return CreateAzureOpenAiCredentialDtoRegionCanadacentral, nil
	case "eastus2":
		return CreateAzureOpenAiCredentialDtoRegionEastus2, nil
	case "eastus":
		return CreateAzureOpenAiCredentialDtoRegionEastus, nil
	case "france":
		return CreateAzureOpenAiCredentialDtoRegionFrance, nil
	case "india":
		return CreateAzureOpenAiCredentialDtoRegionIndia, nil
	case "japaneast":
		return CreateAzureOpenAiCredentialDtoRegionJapaneast, nil
	case "japanwest":
		return CreateAzureOpenAiCredentialDtoRegionJapanwest, nil
	case "uaenorth":
		return CreateAzureOpenAiCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return CreateAzureOpenAiCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return CreateAzureOpenAiCredentialDtoRegionNorway, nil
	case "southcentralus":
		return CreateAzureOpenAiCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return CreateAzureOpenAiCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return CreateAzureOpenAiCredentialDtoRegionSwitzerland, nil
	case "uk":
		return CreateAzureOpenAiCredentialDtoRegionUk, nil
	case "westus":
		return CreateAzureOpenAiCredentialDtoRegionWestus, nil
	case "westus3":
		return CreateAzureOpenAiCredentialDtoRegionWestus3, nil
	}
	var t CreateAzureOpenAiCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureOpenAiCredentialDtoRegion) Ptr() *CreateAzureOpenAiCredentialDtoRegion {
	return &c
}

type CreateBashToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateBashToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	// The name of the tool, fixed to 'bash'
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server  *Server `json:"server,omitempty" url:"server,omitempty"`
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateBashToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateBashToolDto) GetMessages() []*CreateBashToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateBashToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateBashToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateBashToolDto) Type() string {
	return c.type_
}

func (c *CreateBashToolDto) SubType() string {
	return c.subType
}

func (c *CreateBashToolDto) Name() string {
	return c.name
}

func (c *CreateBashToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBashToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateBashToolDto
	var unmarshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateBashToolDto(unmarshaler.embed)
	if unmarshaler.Type != "bash" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "bash", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	if unmarshaler.SubType != "bash_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "bash_20241022", unmarshaler.SubType)
	}
	c.subType = unmarshaler.SubType
	if unmarshaler.Name != "bash" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "bash", unmarshaler.Name)
	}
	c.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type", "subType", "name")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBashToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateBashToolDto
	var marshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed:   embed(*c),
		Type:    "bash",
		SubType: "bash_20241022",
		Name:    "bash",
	}
	return json.Marshal(marshaler)
}

func (c *CreateBashToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateBashToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateBashToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateBashToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateBashToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateBashToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateBashToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateBashToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateBashToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateBashToolDtoMessagesItem) Accept(visitor CreateBashToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateByoSipTrunkCredentialDto struct {
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This can be used to configure the tech prefix on outbound calls. This is an advanced property.
	TechPrefix *string `json:"techPrefix,omitempty" url:"techPrefix,omitempty"`
	// This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.
	SipDiversionHeader *string `json:"sipDiversionHeader,omitempty" url:"sipDiversionHeader,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateByoSipTrunkCredentialDto) GetGateways() []*SipTrunkGateway {
	if c == nil {
		return nil
	}
	return c.Gateways
}

func (c *CreateByoSipTrunkCredentialDto) GetOutboundAuthenticationPlan() *SipTrunkOutboundAuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.OutboundAuthenticationPlan
}

func (c *CreateByoSipTrunkCredentialDto) GetOutboundLeadingPlusEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.OutboundLeadingPlusEnabled
}

func (c *CreateByoSipTrunkCredentialDto) GetTechPrefix() *string {
	if c == nil {
		return nil
	}
	return c.TechPrefix
}

func (c *CreateByoSipTrunkCredentialDto) GetSipDiversionHeader() *string {
	if c == nil {
		return nil
	}
	return c.SipDiversionHeader
}

func (c *CreateByoSipTrunkCredentialDto) GetSbcConfiguration() *SbcConfiguration {
	if c == nil {
		return nil
	}
	return c.SbcConfiguration
}

func (c *CreateByoSipTrunkCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateByoSipTrunkCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateByoSipTrunkCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateByoSipTrunkCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateByoSipTrunkCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateByoSipTrunkCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "byo-sip-trunk" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "byo-sip-trunk", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateByoSipTrunkCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateByoSipTrunkCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "byo-sip-trunk",
	}
	return json.Marshal(marshaler)
}

func (c *CreateByoSipTrunkCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCartesiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCartesiaCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateCartesiaCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCartesiaCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCartesiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCartesiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCartesiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCartesiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCartesiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCartesiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCartesiaCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCerebrasCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCerebrasCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateCerebrasCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCerebrasCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCerebrasCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCerebrasCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCerebrasCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCerebrasCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cerebras" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cerebras", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCerebrasCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCerebrasCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cerebras",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCerebrasCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCloudflareCredentialDto struct {
	// Cloudflare Account Id.
	AccountId *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Cloudflare API Key / Token.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// Cloudflare Account Email.
	AccountEmail *string `json:"accountEmail,omitempty" url:"accountEmail,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in R2
	BucketPlan *CloudflareR2BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCloudflareCredentialDto) GetAccountId() *string {
	if c == nil {
		return nil
	}
	return c.AccountId
}

func (c *CreateCloudflareCredentialDto) GetApiKey() *string {
	if c == nil {
		return nil
	}
	return c.ApiKey
}

func (c *CreateCloudflareCredentialDto) GetAccountEmail() *string {
	if c == nil {
		return nil
	}
	return c.AccountEmail
}

func (c *CreateCloudflareCredentialDto) GetBucketPlan() *CloudflareR2BucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CreateCloudflareCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCloudflareCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCloudflareCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCloudflareCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCloudflareCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCloudflareCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cloudflare" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cloudflare", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCloudflareCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCloudflareCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cloudflare",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCloudflareCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateComputerToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateComputerToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	// The name of the tool, fixed to 'computer'
	// The display width in pixels
	DisplayWidthPx float64 `json:"displayWidthPx" url:"displayWidthPx"`
	// The display height in pixels
	DisplayHeightPx float64 `json:"displayHeightPx" url:"displayHeightPx"`
	// Optional display number
	DisplayNumber *float64 `json:"displayNumber,omitempty" url:"displayNumber,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server  *Server `json:"server,omitempty" url:"server,omitempty"`
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateComputerToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateComputerToolDto) GetMessages() []*CreateComputerToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateComputerToolDto) GetDisplayWidthPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayWidthPx
}

func (c *CreateComputerToolDto) GetDisplayHeightPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayHeightPx
}

func (c *CreateComputerToolDto) GetDisplayNumber() *float64 {
	if c == nil {
		return nil
	}
	return c.DisplayNumber
}

func (c *CreateComputerToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateComputerToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateComputerToolDto) Type() string {
	return c.type_
}

func (c *CreateComputerToolDto) SubType() string {
	return c.subType
}

func (c *CreateComputerToolDto) Name() string {
	return c.name
}

func (c *CreateComputerToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateComputerToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateComputerToolDto
	var unmarshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateComputerToolDto(unmarshaler.embed)
	if unmarshaler.Type != "computer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	if unmarshaler.SubType != "computer_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer_20241022", unmarshaler.SubType)
	}
	c.subType = unmarshaler.SubType
	if unmarshaler.Name != "computer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer", unmarshaler.Name)
	}
	c.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type", "subType", "name")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateComputerToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateComputerToolDto
	var marshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed:   embed(*c),
		Type:    "computer",
		SubType: "computer_20241022",
		Name:    "computer",
	}
	return json.Marshal(marshaler)
}

func (c *CreateComputerToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateComputerToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateComputerToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateComputerToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateComputerToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateComputerToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateComputerToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateComputerToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateComputerToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateComputerToolDtoMessagesItem) Accept(visitor CreateComputerToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateCustomKnowledgeBaseDto struct {
	// This is where the knowledge base request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "knowledge-base-request",
	//	    "messages": [
	//	      {
	//	        "role": "user",
	//	        "content": "Why is ocean blue?"
	//	      }
	//	    ],
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected:
	// ```
	//
	//	{
	//	  "message": {
	//	     "role": "assistant",
	//	     "content": "The ocean is blue because water absorbs everything but blue.",
	//	  }, // YOU CAN RETURN THE EXACT RESPONSE TO SPEAK
	//	  "documents": [
	//	    {
	//	      "content": "The ocean is blue primarily because water absorbs colors in the red part of the light spectrum and scatters the blue light, making it more visible to our eyes.",
	//	      "similarity": 1
	//	    },
	//	    {
	//	      "content": "Blue light is scattered more by the water molecules than other colors, enhancing the blue appearance of the ocean.",
	//	      "similarity": .5
	//	    }
	//	  ] // OR, YOU CAN RETURN AN ARRAY OF DOCUMENTS THAT WILL BE SENT TO THE MODEL
	//	}
	//
	// ```
	Server   *Server `json:"server,omitempty" url:"server,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCustomKnowledgeBaseDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateCustomKnowledgeBaseDto) Provider() string {
	return c.provider
}

func (c *CreateCustomKnowledgeBaseDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomKnowledgeBaseDto) UnmarshalJSON(data []byte) error {
	type embed CreateCustomKnowledgeBaseDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCustomKnowledgeBaseDto(unmarshaler.embed)
	if unmarshaler.Provider != "custom-knowledge-base" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-knowledge-base", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomKnowledgeBaseDto) MarshalJSON() ([]byte, error) {
	type embed CreateCustomKnowledgeBaseDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-knowledge-base",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCustomKnowledgeBaseDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCustomLlmCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCustomLlmCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateCustomLlmCredentialDto) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.AuthenticationPlan
}

func (c *CreateCustomLlmCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCustomLlmCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCustomLlmCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomLlmCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCustomLlmCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCustomLlmCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomLlmCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCustomLlmCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCustomLlmCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepInfraCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDeepInfraCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateDeepInfraCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateDeepInfraCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepInfraCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepInfraCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepInfraCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepInfraCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deepinfra", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepInfraCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepInfraCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepInfraCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepSeekCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDeepSeekCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateDeepSeekCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateDeepSeekCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepSeekCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepSeekCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepSeekCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepSeekCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deep-seek" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deep-seek", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepSeekCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepSeekCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deep-seek",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepSeekCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepgramCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDeepgramCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateDeepgramCredentialDto) GetApiUrl() *string {
	if c == nil {
		return nil
	}
	return c.ApiUrl
}

func (c *CreateDeepgramCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateDeepgramCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepgramCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepgramCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepgramCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepgramCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deepgram", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepgramCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepgramCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepgramCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDtmfToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateDtmfToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDtmfToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateDtmfToolDto) GetMessages() []*CreateDtmfToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateDtmfToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateDtmfToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateDtmfToolDto) Type() string {
	return c.type_
}

func (c *CreateDtmfToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDtmfToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateDtmfToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDtmfToolDto(unmarshaler.embed)
	if unmarshaler.Type != "dtmf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "dtmf", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDtmfToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateDtmfToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "dtmf",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDtmfToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDtmfToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateDtmfToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateDtmfToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateDtmfToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateDtmfToolDtoMessagesItem) Accept(visitor CreateDtmfToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateElevenLabsCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateElevenLabsCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateElevenLabsCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateElevenLabsCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateElevenLabsCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateElevenLabsCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateElevenLabsCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateElevenLabsCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "11labs", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateElevenLabsCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateElevenLabsCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (c *CreateElevenLabsCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEndCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateEndCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEndCallToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateEndCallToolDto) GetMessages() []*CreateEndCallToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateEndCallToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateEndCallToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateEndCallToolDto) Type() string {
	return c.type_
}

func (c *CreateEndCallToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEndCallToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateEndCallToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateEndCallToolDto(unmarshaler.embed)
	if unmarshaler.Type != "endCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "endCall", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEndCallToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateEndCallToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "endCall",
	}
	return json.Marshal(marshaler)
}

func (c *CreateEndCallToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEndCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateEndCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEndCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEndCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateEndCallToolDtoMessagesItem) Accept(visitor CreateEndCallToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateFunctionToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateFunctionToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateFunctionToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateFunctionToolDto) GetMessages() []*CreateFunctionToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateFunctionToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateFunctionToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateFunctionToolDto) Type() string {
	return c.type_
}

func (c *CreateFunctionToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFunctionToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateFunctionToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateFunctionToolDto(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "function", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateFunctionToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateFunctionToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (c *CreateFunctionToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFunctionToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateFunctionToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateFunctionToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateFunctionToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateFunctionToolDtoMessagesItem) Accept(visitor CreateFunctionToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGcpCredentialDto struct {
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGcpCredentialDto) GetGcpKey() *GcpKey {
	if c == nil {
		return nil
	}
	return c.GcpKey
}

func (c *CreateGcpCredentialDto) GetBucketPlan() *BucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CreateGcpCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGcpCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGcpCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGcpCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGcpCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gcp", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGcpCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGcpCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gcp",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGcpCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGladiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGladiaCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGladiaCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGladiaCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGladiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGladiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGladiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGladiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gladia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGladiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGladiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGladiaCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelCalendarAvailabilityToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) GetMessages() []*CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) Type() string {
	return c.type_
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelCalendarAvailabilityToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelCalendarAvailabilityToolDto(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gohighlevel.calendar.availability.check", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelCalendarAvailabilityToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "gohighlevel.calendar.availability.check",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) Accept(visitor CreateGoHighLevelCalendarAvailabilityToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelCalendarEventCreateToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) GetMessages() []*CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) Type() string {
	return c.type_
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelCalendarEventCreateToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelCalendarEventCreateToolDto(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gohighlevel.calendar.event.create", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelCalendarEventCreateToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "gohighlevel.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelCalendarEventCreateToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelCalendarEventCreateToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGoHighLevelCalendarEventCreateToolDtoMessagesItem) Accept(visitor CreateGoHighLevelCalendarEventCreateToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelContactCreateToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGoHighLevelContactCreateToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoHighLevelContactCreateToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGoHighLevelContactCreateToolDto) GetMessages() []*CreateGoHighLevelContactCreateToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGoHighLevelContactCreateToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGoHighLevelContactCreateToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGoHighLevelContactCreateToolDto) Type() string {
	return c.type_
}

func (c *CreateGoHighLevelContactCreateToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelContactCreateToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelContactCreateToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelContactCreateToolDto(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.contact.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gohighlevel.contact.create", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelContactCreateToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelContactCreateToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "gohighlevel.contact.create",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelContactCreateToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelContactCreateToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGoHighLevelContactCreateToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGoHighLevelContactCreateToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelContactCreateToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGoHighLevelContactCreateToolDtoMessagesItem) Accept(visitor CreateGoHighLevelContactCreateToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelContactGetToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGoHighLevelContactGetToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoHighLevelContactGetToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGoHighLevelContactGetToolDto) GetMessages() []*CreateGoHighLevelContactGetToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGoHighLevelContactGetToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGoHighLevelContactGetToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGoHighLevelContactGetToolDto) Type() string {
	return c.type_
}

func (c *CreateGoHighLevelContactGetToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelContactGetToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelContactGetToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelContactGetToolDto(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.contact.get" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gohighlevel.contact.get", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelContactGetToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelContactGetToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "gohighlevel.contact.get",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelContactGetToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelContactGetToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGoHighLevelContactGetToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGoHighLevelContactGetToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelContactGetToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGoHighLevelContactGetToolDtoMessagesItem) Accept(visitor CreateGoHighLevelContactGetToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoHighLevelCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoHighLevelCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGoHighLevelCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoHighLevelCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoHighLevelCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gohighlevel" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gohighlevel", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gohighlevel",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelMcpCredentialDto struct {
	// This is the authentication session for the credential.
	AuthenticationSession *Oauth2AuthenticationSession `json:"authenticationSession,omitempty" url:"authenticationSession,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoHighLevelMcpCredentialDto) GetAuthenticationSession() *Oauth2AuthenticationSession {
	if c == nil {
		return nil
	}
	return c.AuthenticationSession
}

func (c *CreateGoHighLevelMcpCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoHighLevelMcpCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoHighLevelMcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelMcpCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelMcpCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelMcpCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "ghl.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "ghl.oauth2-authorization", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelMcpCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelMcpCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "ghl.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelMcpCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleCalendarCheckAvailabilityToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) GetMessages() []*CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) Type() string {
	return c.type_
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleCalendarCheckAvailabilityToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleCalendarCheckAvailabilityToolDto(unmarshaler.embed)
	if unmarshaler.Type != "google.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google.calendar.availability.check", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleCalendarCheckAvailabilityToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "google.calendar.availability.check",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) Accept(visitor CreateGoogleCalendarCheckAvailabilityToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoogleCalendarCreateEventToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGoogleCalendarCreateEventToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleCalendarCreateEventToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGoogleCalendarCreateEventToolDto) GetMessages() []*CreateGoogleCalendarCreateEventToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGoogleCalendarCreateEventToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGoogleCalendarCreateEventToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGoogleCalendarCreateEventToolDto) Type() string {
	return c.type_
}

func (c *CreateGoogleCalendarCreateEventToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleCalendarCreateEventToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleCalendarCreateEventToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleCalendarCreateEventToolDto(unmarshaler.embed)
	if unmarshaler.Type != "google.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google.calendar.event.create", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleCalendarCreateEventToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleCalendarCreateEventToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "google.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleCalendarCreateEventToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleCalendarCreateEventToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGoogleCalendarCreateEventToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGoogleCalendarCreateEventToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoogleCalendarCreateEventToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGoogleCalendarCreateEventToolDtoMessagesItem) Accept(visitor CreateGoogleCalendarCreateEventToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoogleCalendarOAuth2AuthorizationCredentialDto struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId string `json:"authorizationId" url:"authorizationId"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleCalendarOAuth2AuthorizationCredentialDto) GetAuthorizationId() string {
	if c == nil {
		return ""
	}
	return c.AuthorizationId
}

func (c *CreateGoogleCalendarOAuth2AuthorizationCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoogleCalendarOAuth2AuthorizationCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoogleCalendarOAuth2AuthorizationCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleCalendarOAuth2AuthorizationCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleCalendarOAuth2AuthorizationCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleCalendarOAuth2AuthorizationCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "google.calendar.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google.calendar.oauth2-authorization", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleCalendarOAuth2AuthorizationCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleCalendarOAuth2AuthorizationCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "google.calendar.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleCalendarOAuth2AuthorizationCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleCalendarOAuth2ClientCredentialDto struct {
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleCalendarOAuth2ClientCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoogleCalendarOAuth2ClientCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoogleCalendarOAuth2ClientCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleCalendarOAuth2ClientCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleCalendarOAuth2ClientCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleCalendarOAuth2ClientCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "google.calendar.oauth2-client" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google.calendar.oauth2-client", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleCalendarOAuth2ClientCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleCalendarOAuth2ClientCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "google.calendar.oauth2-client",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleCalendarOAuth2ClientCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGoogleCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoogleCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoogleCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleSheetsOAuth2AuthorizationCredentialDto struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId string `json:"authorizationId" url:"authorizationId"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleSheetsOAuth2AuthorizationCredentialDto) GetAuthorizationId() string {
	if c == nil {
		return ""
	}
	return c.AuthorizationId
}

func (c *CreateGoogleSheetsOAuth2AuthorizationCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoogleSheetsOAuth2AuthorizationCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoogleSheetsOAuth2AuthorizationCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleSheetsOAuth2AuthorizationCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleSheetsOAuth2AuthorizationCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleSheetsOAuth2AuthorizationCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "google.sheets.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google.sheets.oauth2-authorization", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleSheetsOAuth2AuthorizationCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleSheetsOAuth2AuthorizationCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "google.sheets.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleSheetsOAuth2AuthorizationCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleSheetsRowAppendToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGoogleSheetsRowAppendToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleSheetsRowAppendToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGoogleSheetsRowAppendToolDto) GetMessages() []*CreateGoogleSheetsRowAppendToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGoogleSheetsRowAppendToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGoogleSheetsRowAppendToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGoogleSheetsRowAppendToolDto) Type() string {
	return c.type_
}

func (c *CreateGoogleSheetsRowAppendToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleSheetsRowAppendToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleSheetsRowAppendToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleSheetsRowAppendToolDto(unmarshaler.embed)
	if unmarshaler.Type != "google.sheets.row.append" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google.sheets.row.append", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleSheetsRowAppendToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleSheetsRowAppendToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "google.sheets.row.append",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleSheetsRowAppendToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleSheetsRowAppendToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGoogleSheetsRowAppendToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGoogleSheetsRowAppendToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGoogleSheetsRowAppendToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGoogleSheetsRowAppendToolDtoMessagesItem) Accept(visitor CreateGoogleSheetsRowAppendToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGroqCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGroqCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGroqCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGroqCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGroqCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGroqCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGroqCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGroqCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "groq", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGroqCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGroqCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "groq",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGroqCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateHumeCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateHumeCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateHumeCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateHumeCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateHumeCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateHumeCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateHumeCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateHumeCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "hume" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "hume", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateHumeCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateHumeCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "hume",
	}
	return json.Marshal(marshaler)
}

func (c *CreateHumeCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateInflectionAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateInflectionAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateInflectionAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateInflectionAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateInflectionAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateInflectionAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateInflectionAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateInflectionAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "inflection-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "inflection-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateInflectionAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateInflectionAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "inflection-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateInflectionAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLangfuseCredentialDto struct {
	// The public key for Langfuse project. Eg: pk-lf-...
	PublicKey string `json:"publicKey" url:"publicKey"`
	// The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// The host URL for Langfuse project. Eg: https://cloud.langfuse.com
	ApiUrl string `json:"apiUrl" url:"apiUrl"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLangfuseCredentialDto) GetPublicKey() string {
	if c == nil {
		return ""
	}
	return c.PublicKey
}

func (c *CreateLangfuseCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateLangfuseCredentialDto) GetApiUrl() string {
	if c == nil {
		return ""
	}
	return c.ApiUrl
}

func (c *CreateLangfuseCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLangfuseCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateLangfuseCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLangfuseCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateLangfuseCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateLangfuseCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "langfuse" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "langfuse", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLangfuseCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateLangfuseCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "langfuse",
	}
	return json.Marshal(marshaler)
}

func (c *CreateLangfuseCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLmntCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLmntCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateLmntCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLmntCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateLmntCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLmntCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateLmntCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateLmntCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "lmnt", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLmntCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateLmntCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (c *CreateLmntCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeCredentialDto struct {
	// Team ID
	TeamId string `json:"teamId" url:"teamId"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region string `json:"region" url:"region"`
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateMakeCredentialDto) GetTeamId() string {
	if c == nil {
		return ""
	}
	return c.TeamId
}

func (c *CreateMakeCredentialDto) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateMakeCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateMakeCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateMakeCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateMakeCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMakeCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateMakeCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMakeCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "make", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMakeCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateMakeCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "make",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMakeCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMcpToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateMcpToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateMcpToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateMcpToolDto) GetMessages() []*CreateMcpToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateMcpToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateMcpToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateMcpToolDto) Type() string {
	return c.type_
}

func (c *CreateMcpToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMcpToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateMcpToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMcpToolDto(unmarshaler.embed)
	if unmarshaler.Type != "mcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "mcp", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMcpToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateMcpToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "mcp",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMcpToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMcpToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateMcpToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateMcpToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateMcpToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateMcpToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateMcpToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateMcpToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateMcpToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateMcpToolDtoMessagesItem) Accept(visitor CreateMcpToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateMistralCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateMistralCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateMistralCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateMistralCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateMistralCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMistralCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateMistralCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMistralCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "mistral" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "mistral", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMistralCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateMistralCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "mistral",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMistralCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateNeuphonicCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateNeuphonicCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateNeuphonicCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateNeuphonicCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateNeuphonicCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateNeuphonicCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateNeuphonicCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateNeuphonicCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "neuphonic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "neuphonic", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateNeuphonicCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateNeuphonicCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "neuphonic",
	}
	return json.Marshal(marshaler)
}

func (c *CreateNeuphonicCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOpenAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOpenAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateOpenAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOpenAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "openai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOpenAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOpenRouterCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOpenRouterCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateOpenRouterCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOpenRouterCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateOpenRouterCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOpenRouterCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateOpenRouterCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOpenRouterCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "openrouter", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOpenRouterCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateOpenRouterCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "openrouter",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOpenRouterCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOrgDto struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the ID of the subscription the org belongs to.
	SubscriptionId *string `json:"subscriptionId,omitempty" url:"subscriptionId,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
	Channel *CreateOrgDtoChannel `json:"channel,omitempty" url:"channel,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`
	// Stores the information about the compliance plan enforced at the organization level. Currently pciEnabled is supported through this field.
	// When this is enabled, any logs, recordings, or transcriptions will be shipped to the customer endpoints if provided else lost.
	// At the end of the call, you will receive an end-of-call-report message to store on your server, if webhook is provided.
	// Defaults to false.
	// When PCI is enabled, only PCI-compliant Providers will be available for LLM, Voice and transcribers.
	// This is due to the compliance requirements of PCI. Other providers may not meet these requirements.
	CompliancePlan *CompliancePlan `json:"compliancePlan,omitempty" url:"compliancePlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOrgDto) GetHipaaEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.HipaaEnabled
}

func (c *CreateOrgDto) GetSubscriptionId() *string {
	if c == nil {
		return nil
	}
	return c.SubscriptionId
}

func (c *CreateOrgDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOrgDto) GetChannel() *CreateOrgDtoChannel {
	if c == nil {
		return nil
	}
	return c.Channel
}

func (c *CreateOrgDto) GetBillingLimit() *float64 {
	if c == nil {
		return nil
	}
	return c.BillingLimit
}

func (c *CreateOrgDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateOrgDto) GetConcurrencyLimit() *float64 {
	if c == nil {
		return nil
	}
	return c.ConcurrencyLimit
}

func (c *CreateOrgDto) GetCompliancePlan() *CompliancePlan {
	if c == nil {
		return nil
	}
	return c.CompliancePlan
}

func (c *CreateOrgDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrgDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrgDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrgDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrgDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
type CreateOrgDtoChannel string

const (
	CreateOrgDtoChannelDefault CreateOrgDtoChannel = "default"
	CreateOrgDtoChannelWeekly  CreateOrgDtoChannel = "weekly"
)

func NewCreateOrgDtoChannelFromString(s string) (CreateOrgDtoChannel, error) {
	switch s {
	case "default":
		return CreateOrgDtoChannelDefault, nil
	case "weekly":
		return CreateOrgDtoChannelWeekly, nil
	}
	var t CreateOrgDtoChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateOrgDtoChannel) Ptr() *CreateOrgDtoChannel {
	return &c
}

type CreateOutboundCallDto struct {
	// This is used to issue batch calls to multiple customers.
	//
	// Only relevant for `outboundPhoneCall`. To call a single customer, use `customer` instead.
	Customers []*CreateCustomerDto `json:"customers,omitempty" url:"customers,omitempty"`
	// This is the name of the call. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the schedule plan of the call.
	SchedulePlan *SchedulePlan `json:"schedulePlan,omitempty" url:"schedulePlan,omitempty"`
	// This is the transport of the call.
	Transport map[string]interface{} `json:"transport,omitempty" url:"transport,omitempty"`
	// This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.
	//
	// To start a call with:
	// - Assistant, use `assistantId` or `assistant`
	// - Squad, use `squadId` or `squad`
	// - Workflow, use `workflowId` or `workflow`
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant`
	// - Squad, use `squad`
	// - Workflow, use `workflow`
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// [BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.
	//
	// This is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	// [BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.
	//
	// This is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	Workflow *CreateWorkflowDto `json:"workflow,omitempty" url:"workflow,omitempty"`
	// This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"phoneNumberId,omitempty"`
	// This is the phone number that will be used for the call. To use an existing number, use `phoneNumberId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumber *ImportTwilioPhoneNumberDto `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the customer that will be called. To call a transient customer , use `customer` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	CustomerId *string `json:"customerId,omitempty" url:"customerId,omitempty"`
	// This is the customer that will be called. To call an existing customer, use `customerId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOutboundCallDto) GetCustomers() []*CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customers
}

func (c *CreateOutboundCallDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOutboundCallDto) GetSchedulePlan() *SchedulePlan {
	if c == nil {
		return nil
	}
	return c.SchedulePlan
}

func (c *CreateOutboundCallDto) GetTransport() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Transport
}

func (c *CreateOutboundCallDto) GetAssistantId() *string {
	if c == nil {
		return nil
	}
	return c.AssistantId
}

func (c *CreateOutboundCallDto) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *CreateOutboundCallDto) GetAssistantOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.AssistantOverrides
}

func (c *CreateOutboundCallDto) GetSquadId() *string {
	if c == nil {
		return nil
	}
	return c.SquadId
}

func (c *CreateOutboundCallDto) GetSquad() *CreateSquadDto {
	if c == nil {
		return nil
	}
	return c.Squad
}

func (c *CreateOutboundCallDto) GetWorkflowId() *string {
	if c == nil {
		return nil
	}
	return c.WorkflowId
}

func (c *CreateOutboundCallDto) GetWorkflow() *CreateWorkflowDto {
	if c == nil {
		return nil
	}
	return c.Workflow
}

func (c *CreateOutboundCallDto) GetPhoneNumberId() *string {
	if c == nil {
		return nil
	}
	return c.PhoneNumberId
}

func (c *CreateOutboundCallDto) GetPhoneNumber() *ImportTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *CreateOutboundCallDto) GetCustomerId() *string {
	if c == nil {
		return nil
	}
	return c.CustomerId
}

func (c *CreateOutboundCallDto) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *CreateOutboundCallDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOutboundCallDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOutboundCallDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOutboundCallDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOutboundCallDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePerplexityAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreatePerplexityAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreatePerplexityAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreatePerplexityAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreatePerplexityAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePerplexityAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreatePerplexityAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreatePerplexityAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "perplexity-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePerplexityAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreatePerplexityAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreatePerplexityAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePlayHtCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	UserId string `json:"userId" url:"userId"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreatePlayHtCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreatePlayHtCredentialDto) GetUserId() string {
	if c == nil {
		return ""
	}
	return c.UserId
}

func (c *CreatePlayHtCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreatePlayHtCredentialDto) Provider() string {
	return c.provider
}

func (c *CreatePlayHtCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePlayHtCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreatePlayHtCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreatePlayHtCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "playht", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePlayHtCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreatePlayHtCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (c *CreatePlayHtCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateQueryToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateQueryToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The knowledge bases to query
	KnowledgeBases []*KnowledgeBase `json:"knowledgeBases,omitempty" url:"knowledgeBases,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateQueryToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateQueryToolDto) GetMessages() []*CreateQueryToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateQueryToolDto) GetKnowledgeBases() []*KnowledgeBase {
	if c == nil {
		return nil
	}
	return c.KnowledgeBases
}

func (c *CreateQueryToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateQueryToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateQueryToolDto) Type() string {
	return c.type_
}

func (c *CreateQueryToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateQueryToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateQueryToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateQueryToolDto(unmarshaler.embed)
	if unmarshaler.Type != "query" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "query", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateQueryToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateQueryToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "query",
	}
	return json.Marshal(marshaler)
}

func (c *CreateQueryToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateQueryToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateQueryToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateQueryToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateQueryToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateQueryToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateQueryToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateQueryToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateQueryToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateQueryToolDtoMessagesItem) Accept(visitor CreateQueryToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateRimeAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateRimeAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateRimeAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateRimeAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateRimeAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRimeAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateRimeAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateRimeAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "rime-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRimeAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateRimeAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateRimeAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateRunpodCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateRunpodCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateRunpodCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateRunpodCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateRunpodCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRunpodCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateRunpodCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateRunpodCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "runpod" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "runpod", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRunpodCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateRunpodCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "runpod",
	}
	return json.Marshal(marshaler)
}

func (c *CreateRunpodCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateS3CredentialDto struct {
	// AWS access key ID.
	AwsAccessKeyId string `json:"awsAccessKeyId" url:"awsAccessKeyId"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey string `json:"awsSecretAccessKey" url:"awsSecretAccessKey"`
	// AWS region in which the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// AWS S3 bucket name.
	S3BucketName string `json:"s3BucketName" url:"s3BucketName"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix string `json:"s3PathPrefix" url:"s3PathPrefix"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateS3CredentialDto) GetAwsAccessKeyId() string {
	if c == nil {
		return ""
	}
	return c.AwsAccessKeyId
}

func (c *CreateS3CredentialDto) GetAwsSecretAccessKey() string {
	if c == nil {
		return ""
	}
	return c.AwsSecretAccessKey
}

func (c *CreateS3CredentialDto) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateS3CredentialDto) GetS3BucketName() string {
	if c == nil {
		return ""
	}
	return c.S3BucketName
}

func (c *CreateS3CredentialDto) GetS3PathPrefix() string {
	if c == nil {
		return ""
	}
	return c.S3PathPrefix
}

func (c *CreateS3CredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateS3CredentialDto) Provider() string {
	return c.provider
}

func (c *CreateS3CredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateS3CredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateS3CredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateS3CredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "s3" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "s3", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateS3CredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateS3CredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "s3",
	}
	return json.Marshal(marshaler)
}

func (c *CreateS3CredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSesameVoiceDto struct {
	// The name of the voice.
	VoiceName *string `json:"voiceName,omitempty" url:"voiceName,omitempty"`
	// The transcript of the utterance.
	Transcription *string `json:"transcription,omitempty" url:"transcription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSesameVoiceDto) GetVoiceName() *string {
	if c == nil {
		return nil
	}
	return c.VoiceName
}

func (c *CreateSesameVoiceDto) GetTranscription() *string {
	if c == nil {
		return nil
	}
	return c.Transcription
}

func (c *CreateSesameVoiceDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSesameVoiceDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSesameVoiceDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSesameVoiceDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSesameVoiceDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSlackOAuth2AuthorizationCredentialDto struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId string `json:"authorizationId" url:"authorizationId"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSlackOAuth2AuthorizationCredentialDto) GetAuthorizationId() string {
	if c == nil {
		return ""
	}
	return c.AuthorizationId
}

func (c *CreateSlackOAuth2AuthorizationCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateSlackOAuth2AuthorizationCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateSlackOAuth2AuthorizationCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSlackOAuth2AuthorizationCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateSlackOAuth2AuthorizationCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateSlackOAuth2AuthorizationCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "slack.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "slack.oauth2-authorization", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSlackOAuth2AuthorizationCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateSlackOAuth2AuthorizationCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "slack.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (c *CreateSlackOAuth2AuthorizationCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSlackSendMessageToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateSlackSendMessageToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSlackSendMessageToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateSlackSendMessageToolDto) GetMessages() []*CreateSlackSendMessageToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateSlackSendMessageToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateSlackSendMessageToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateSlackSendMessageToolDto) Type() string {
	return c.type_
}

func (c *CreateSlackSendMessageToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSlackSendMessageToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateSlackSendMessageToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateSlackSendMessageToolDto(unmarshaler.embed)
	if unmarshaler.Type != "slack.message.send" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "slack.message.send", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSlackSendMessageToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateSlackSendMessageToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "slack.message.send",
	}
	return json.Marshal(marshaler)
}

func (c *CreateSlackSendMessageToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSlackSendMessageToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateSlackSendMessageToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateSlackSendMessageToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateSlackSendMessageToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateSlackSendMessageToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateSlackSendMessageToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateSlackSendMessageToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateSlackSendMessageToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateSlackSendMessageToolDtoMessagesItem) Accept(visitor CreateSlackSendMessageToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateSmallestAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSmallestAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateSmallestAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateSmallestAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateSmallestAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSmallestAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateSmallestAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateSmallestAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "smallest-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSmallestAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateSmallestAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateSmallestAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSmsToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateSmsToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSmsToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateSmsToolDto) GetMessages() []*CreateSmsToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateSmsToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateSmsToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateSmsToolDto) Type() string {
	return c.type_
}

func (c *CreateSmsToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSmsToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateSmsToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateSmsToolDto(unmarshaler.embed)
	if unmarshaler.Type != "sms" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "sms", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSmsToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateSmsToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "sms",
	}
	return json.Marshal(marshaler)
}

func (c *CreateSmsToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSmsToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateSmsToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateSmsToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateSmsToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateSmsToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateSmsToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateSmsToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateSmsToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateSmsToolDtoMessagesItem) Accept(visitor CreateSmsToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateSpeechmaticsCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSpeechmaticsCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateSpeechmaticsCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateSpeechmaticsCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateSpeechmaticsCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSpeechmaticsCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateSpeechmaticsCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateSpeechmaticsCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "speechmatics" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "speechmatics", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSpeechmaticsCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateSpeechmaticsCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "speechmatics",
	}
	return json.Marshal(marshaler)
}

func (c *CreateSpeechmaticsCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSquadDto struct {
	// This is the name of the squad.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of assistants that make up the squad.
	//
	// The call will start with the first assistant in the list.
	Members []*SquadMemberDto `json:"members,omitempty" url:"members,omitempty"`
	// This can be used to override all the assistants' settings and provide values for their template variables.
	//
	// Both `membersOverrides` and `members[n].assistantOverrides` can be used together. First, `members[n].assistantOverrides` is applied. Then, `membersOverrides` is applied as a global override.
	MembersOverrides *AssistantOverrides `json:"membersOverrides,omitempty" url:"membersOverrides,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSquadDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateSquadDto) GetMembers() []*SquadMemberDto {
	if c == nil {
		return nil
	}
	return c.Members
}

func (c *CreateSquadDto) GetMembersOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.MembersOverrides
}

func (c *CreateSquadDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSquadDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSquadDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSquadDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSquadDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSupabaseCredentialDto struct {
	BucketPlan *SupabaseBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSupabaseCredentialDto) GetBucketPlan() *SupabaseBucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CreateSupabaseCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateSupabaseCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateSupabaseCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSupabaseCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateSupabaseCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateSupabaseCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "supabase" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "supabase", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSupabaseCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateSupabaseCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "supabase",
	}
	return json.Marshal(marshaler)
}

func (c *CreateSupabaseCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTavusCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTavusCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateTavusCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTavusCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTavusCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTavusCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTavusCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTavusCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tavus", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTavusCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTavusCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "tavus",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTavusCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTextEditorToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateTextEditorToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	// The name of the tool, fixed to 'str_replace_editor'
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server  *Server `json:"server,omitempty" url:"server,omitempty"`
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTextEditorToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateTextEditorToolDto) GetMessages() []*CreateTextEditorToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateTextEditorToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateTextEditorToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateTextEditorToolDto) Type() string {
	return c.type_
}

func (c *CreateTextEditorToolDto) SubType() string {
	return c.subType
}

func (c *CreateTextEditorToolDto) Name() string {
	return c.name
}

func (c *CreateTextEditorToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTextEditorToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateTextEditorToolDto
	var unmarshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTextEditorToolDto(unmarshaler.embed)
	if unmarshaler.Type != "textEditor" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "textEditor", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	if unmarshaler.SubType != "text_editor_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "text_editor_20241022", unmarshaler.SubType)
	}
	c.subType = unmarshaler.SubType
	if unmarshaler.Name != "str_replace_editor" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "str_replace_editor", unmarshaler.Name)
	}
	c.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type", "subType", "name")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTextEditorToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateTextEditorToolDto
	var marshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed:   embed(*c),
		Type:    "textEditor",
		SubType: "text_editor_20241022",
		Name:    "str_replace_editor",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTextEditorToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTextEditorToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateTextEditorToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateTextEditorToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateTextEditorToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateTextEditorToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateTextEditorToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTextEditorToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTextEditorToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateTextEditorToolDtoMessagesItem) Accept(visitor CreateTextEditorToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTogetherAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTogetherAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateTogetherAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTogetherAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTogetherAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTogetherAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTogetherAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTogetherAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "together-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTogetherAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTogetherAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "together-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTogetherAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTokenDto struct {
	// This is the tag for the token. It represents its scope.
	Tag *CreateTokenDtoTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTokenDto) GetTag() *CreateTokenDtoTag {
	if c == nil {
		return nil
	}
	return c.Tag
}

func (c *CreateTokenDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTokenDto) GetRestrictions() *TokenRestrictions {
	if c == nil {
		return nil
	}
	return c.Restrictions
}

func (c *CreateTokenDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTokenDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTokenDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTokenDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTokenDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the tag for the token. It represents its scope.
type CreateTokenDtoTag string

const (
	CreateTokenDtoTagPrivate CreateTokenDtoTag = "private"
	CreateTokenDtoTagPublic  CreateTokenDtoTag = "public"
)

func NewCreateTokenDtoTagFromString(s string) (CreateTokenDtoTag, error) {
	switch s {
	case "private":
		return CreateTokenDtoTagPrivate, nil
	case "public":
		return CreateTokenDtoTagPublic, nil
	}
	var t CreateTokenDtoTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateTokenDtoTag) Ptr() *CreateTokenDtoTag {
	return &c
}

type CreateToolTemplateDto struct {
	Details         *CreateToolTemplateDtoDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *CreateToolTemplateDtoProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata                 `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *CreateToolTemplateDtoVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string                        `json:"name,omitempty" url:"name,omitempty"`
	Provider *CreateToolTemplateDtoProvider `json:"provider,omitempty" url:"provider,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateToolTemplateDto) GetDetails() *CreateToolTemplateDtoDetails {
	if c == nil {
		return nil
	}
	return c.Details
}

func (c *CreateToolTemplateDto) GetProviderDetails() *CreateToolTemplateDtoProviderDetails {
	if c == nil {
		return nil
	}
	return c.ProviderDetails
}

func (c *CreateToolTemplateDto) GetMetadata() *ToolTemplateMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateToolTemplateDto) GetVisibility() *CreateToolTemplateDtoVisibility {
	if c == nil {
		return nil
	}
	return c.Visibility
}

func (c *CreateToolTemplateDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateToolTemplateDto) GetProvider() *CreateToolTemplateDtoProvider {
	if c == nil {
		return nil
	}
	return c.Provider
}

func (c *CreateToolTemplateDto) Type() string {
	return c.type_
}

func (c *CreateToolTemplateDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateToolTemplateDto) UnmarshalJSON(data []byte) error {
	type embed CreateToolTemplateDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateToolTemplateDto(unmarshaler.embed)
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateToolTemplateDto) MarshalJSON() ([]byte, error) {
	type embed CreateToolTemplateDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool",
	}
	return json.Marshal(marshaler)
}

func (c *CreateToolTemplateDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateToolTemplateDtoDetails struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (c *CreateToolTemplateDtoDetails) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if c == nil {
		return nil
	}
	return c.CreateApiRequestToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateBashToolDto() *CreateBashToolDto {
	if c == nil {
		return nil
	}
	return c.CreateBashToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateComputerToolDto() *CreateComputerToolDto {
	if c == nil {
		return nil
	}
	return c.CreateComputerToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if c == nil {
		return nil
	}
	return c.CreateDtmfToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateEndCallToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if c == nil {
		return nil
	}
	return c.CreateFunctionToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarEventCreateToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactCreateToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactGetToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCreateEventToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleSheetsRowAppendToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateMcpToolDto() *CreateMcpToolDto {
	if c == nil {
		return nil
	}
	return c.CreateMcpToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateQueryToolDto() *CreateQueryToolDto {
	if c == nil {
		return nil
	}
	return c.CreateQueryToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSlackSendMessageToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateSmsToolDto() *CreateSmsToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSmsToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTextEditorToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTransferCallToolDto
}

func (c *CreateToolTemplateDtoDetails) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		c.typ = "CreateApiRequestToolDto"
		c.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		c.typ = "CreateBashToolDto"
		c.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		c.typ = "CreateComputerToolDto"
		c.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.typ = "CreateDtmfToolDto"
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.typ = "CreateEndCallToolDto"
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.typ = "CreateFunctionToolDto"
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		c.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		c.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactCreateToolDto"
		c.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactGetToolDto"
		c.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		c.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCreateEventToolDto"
		c.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		c.typ = "CreateGoogleSheetsRowAppendToolDto"
		c.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		c.typ = "CreateMcpToolDto"
		c.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		c.typ = "CreateQueryToolDto"
		c.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		c.typ = "CreateSlackSendMessageToolDto"
		c.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		c.typ = "CreateSmsToolDto"
		c.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		c.typ = "CreateTextEditorToolDto"
		c.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.typ = "CreateTransferCallToolDto"
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolTemplateDtoDetails) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return json.Marshal(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return json.Marshal(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return json.Marshal(c.CreateComputerToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactGetToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return json.Marshal(c.CreateMcpToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return json.Marshal(c.CreateQueryToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return json.Marshal(c.CreateSmsToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return json.Marshal(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoDetailsVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CreateToolTemplateDtoDetails) Accept(visitor CreateToolTemplateDtoDetailsVisitor) error {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(c.CreateComputerToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(c.CreateGoHighLevelContactGetToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(c.CreateMcpToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(c.CreateQueryToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(c.CreateSmsToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoProvider string

const (
	CreateToolTemplateDtoProviderMake        CreateToolTemplateDtoProvider = "make"
	CreateToolTemplateDtoProviderGohighlevel CreateToolTemplateDtoProvider = "gohighlevel"
	CreateToolTemplateDtoProviderFunction    CreateToolTemplateDtoProvider = "function"
)

func NewCreateToolTemplateDtoProviderFromString(s string) (CreateToolTemplateDtoProvider, error) {
	switch s {
	case "make":
		return CreateToolTemplateDtoProviderMake, nil
	case "gohighlevel":
		return CreateToolTemplateDtoProviderGohighlevel, nil
	case "function":
		return CreateToolTemplateDtoProviderFunction, nil
	}
	var t CreateToolTemplateDtoProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateToolTemplateDtoProvider) Ptr() *CreateToolTemplateDtoProvider {
	return &c
}

type CreateToolTemplateDtoProviderDetails struct {
	MakeToolProviderDetails                            *MakeToolProviderDetails
	GhlToolProviderDetails                             *GhlToolProviderDetails
	FunctionToolProviderDetails                        *FunctionToolProviderDetails
	GoogleCalendarCreateEventToolProviderDetails       *GoogleCalendarCreateEventToolProviderDetails
	GoogleSheetsRowAppendToolProviderDetails           *GoogleSheetsRowAppendToolProviderDetails
	GoHighLevelCalendarAvailabilityToolProviderDetails *GoHighLevelCalendarAvailabilityToolProviderDetails
	GoHighLevelCalendarEventCreateToolProviderDetails  *GoHighLevelCalendarEventCreateToolProviderDetails
	GoHighLevelContactCreateToolProviderDetails        *GoHighLevelContactCreateToolProviderDetails
	GoHighLevelContactGetToolProviderDetails           *GoHighLevelContactGetToolProviderDetails

	typ string
}

func (c *CreateToolTemplateDtoProviderDetails) GetMakeToolProviderDetails() *MakeToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.MakeToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGhlToolProviderDetails() *GhlToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GhlToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetFunctionToolProviderDetails() *FunctionToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.FunctionToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGoogleCalendarCreateEventToolProviderDetails() *GoogleCalendarCreateEventToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GoogleCalendarCreateEventToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGoogleSheetsRowAppendToolProviderDetails() *GoogleSheetsRowAppendToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GoogleSheetsRowAppendToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGoHighLevelCalendarAvailabilityToolProviderDetails() *GoHighLevelCalendarAvailabilityToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GoHighLevelCalendarAvailabilityToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGoHighLevelCalendarEventCreateToolProviderDetails() *GoHighLevelCalendarEventCreateToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GoHighLevelCalendarEventCreateToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGoHighLevelContactCreateToolProviderDetails() *GoHighLevelContactCreateToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GoHighLevelContactCreateToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGoHighLevelContactGetToolProviderDetails() *GoHighLevelContactGetToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GoHighLevelContactGetToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		c.typ = "MakeToolProviderDetails"
		c.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		c.typ = "GhlToolProviderDetails"
		c.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		c.typ = "FunctionToolProviderDetails"
		c.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	valueGoogleCalendarCreateEventToolProviderDetails := new(GoogleCalendarCreateEventToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventToolProviderDetails); err == nil {
		c.typ = "GoogleCalendarCreateEventToolProviderDetails"
		c.GoogleCalendarCreateEventToolProviderDetails = valueGoogleCalendarCreateEventToolProviderDetails
		return nil
	}
	valueGoogleSheetsRowAppendToolProviderDetails := new(GoogleSheetsRowAppendToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendToolProviderDetails); err == nil {
		c.typ = "GoogleSheetsRowAppendToolProviderDetails"
		c.GoogleSheetsRowAppendToolProviderDetails = valueGoogleSheetsRowAppendToolProviderDetails
		return nil
	}
	valueGoHighLevelCalendarAvailabilityToolProviderDetails := new(GoHighLevelCalendarAvailabilityToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityToolProviderDetails); err == nil {
		c.typ = "GoHighLevelCalendarAvailabilityToolProviderDetails"
		c.GoHighLevelCalendarAvailabilityToolProviderDetails = valueGoHighLevelCalendarAvailabilityToolProviderDetails
		return nil
	}
	valueGoHighLevelCalendarEventCreateToolProviderDetails := new(GoHighLevelCalendarEventCreateToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateToolProviderDetails); err == nil {
		c.typ = "GoHighLevelCalendarEventCreateToolProviderDetails"
		c.GoHighLevelCalendarEventCreateToolProviderDetails = valueGoHighLevelCalendarEventCreateToolProviderDetails
		return nil
	}
	valueGoHighLevelContactCreateToolProviderDetails := new(GoHighLevelContactCreateToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateToolProviderDetails); err == nil {
		c.typ = "GoHighLevelContactCreateToolProviderDetails"
		c.GoHighLevelContactCreateToolProviderDetails = valueGoHighLevelContactCreateToolProviderDetails
		return nil
	}
	valueGoHighLevelContactGetToolProviderDetails := new(GoHighLevelContactGetToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetToolProviderDetails); err == nil {
		c.typ = "GoHighLevelContactGetToolProviderDetails"
		c.GoHighLevelContactGetToolProviderDetails = valueGoHighLevelContactGetToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolTemplateDtoProviderDetails) MarshalJSON() ([]byte, error) {
	if c.typ == "MakeToolProviderDetails" || c.MakeToolProviderDetails != nil {
		return json.Marshal(c.MakeToolProviderDetails)
	}
	if c.typ == "GhlToolProviderDetails" || c.GhlToolProviderDetails != nil {
		return json.Marshal(c.GhlToolProviderDetails)
	}
	if c.typ == "FunctionToolProviderDetails" || c.FunctionToolProviderDetails != nil {
		return json.Marshal(c.FunctionToolProviderDetails)
	}
	if c.typ == "GoogleCalendarCreateEventToolProviderDetails" || c.GoogleCalendarCreateEventToolProviderDetails != nil {
		return json.Marshal(c.GoogleCalendarCreateEventToolProviderDetails)
	}
	if c.typ == "GoogleSheetsRowAppendToolProviderDetails" || c.GoogleSheetsRowAppendToolProviderDetails != nil {
		return json.Marshal(c.GoogleSheetsRowAppendToolProviderDetails)
	}
	if c.typ == "GoHighLevelCalendarAvailabilityToolProviderDetails" || c.GoHighLevelCalendarAvailabilityToolProviderDetails != nil {
		return json.Marshal(c.GoHighLevelCalendarAvailabilityToolProviderDetails)
	}
	if c.typ == "GoHighLevelCalendarEventCreateToolProviderDetails" || c.GoHighLevelCalendarEventCreateToolProviderDetails != nil {
		return json.Marshal(c.GoHighLevelCalendarEventCreateToolProviderDetails)
	}
	if c.typ == "GoHighLevelContactCreateToolProviderDetails" || c.GoHighLevelContactCreateToolProviderDetails != nil {
		return json.Marshal(c.GoHighLevelContactCreateToolProviderDetails)
	}
	if c.typ == "GoHighLevelContactGetToolProviderDetails" || c.GoHighLevelContactGetToolProviderDetails != nil {
		return json.Marshal(c.GoHighLevelContactGetToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
	VisitGoogleCalendarCreateEventToolProviderDetails(*GoogleCalendarCreateEventToolProviderDetails) error
	VisitGoogleSheetsRowAppendToolProviderDetails(*GoogleSheetsRowAppendToolProviderDetails) error
	VisitGoHighLevelCalendarAvailabilityToolProviderDetails(*GoHighLevelCalendarAvailabilityToolProviderDetails) error
	VisitGoHighLevelCalendarEventCreateToolProviderDetails(*GoHighLevelCalendarEventCreateToolProviderDetails) error
	VisitGoHighLevelContactCreateToolProviderDetails(*GoHighLevelContactCreateToolProviderDetails) error
	VisitGoHighLevelContactGetToolProviderDetails(*GoHighLevelContactGetToolProviderDetails) error
}

func (c *CreateToolTemplateDtoProviderDetails) Accept(visitor CreateToolTemplateDtoProviderDetailsVisitor) error {
	if c.typ == "MakeToolProviderDetails" || c.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(c.MakeToolProviderDetails)
	}
	if c.typ == "GhlToolProviderDetails" || c.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(c.GhlToolProviderDetails)
	}
	if c.typ == "FunctionToolProviderDetails" || c.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(c.FunctionToolProviderDetails)
	}
	if c.typ == "GoogleCalendarCreateEventToolProviderDetails" || c.GoogleCalendarCreateEventToolProviderDetails != nil {
		return visitor.VisitGoogleCalendarCreateEventToolProviderDetails(c.GoogleCalendarCreateEventToolProviderDetails)
	}
	if c.typ == "GoogleSheetsRowAppendToolProviderDetails" || c.GoogleSheetsRowAppendToolProviderDetails != nil {
		return visitor.VisitGoogleSheetsRowAppendToolProviderDetails(c.GoogleSheetsRowAppendToolProviderDetails)
	}
	if c.typ == "GoHighLevelCalendarAvailabilityToolProviderDetails" || c.GoHighLevelCalendarAvailabilityToolProviderDetails != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityToolProviderDetails(c.GoHighLevelCalendarAvailabilityToolProviderDetails)
	}
	if c.typ == "GoHighLevelCalendarEventCreateToolProviderDetails" || c.GoHighLevelCalendarEventCreateToolProviderDetails != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateToolProviderDetails(c.GoHighLevelCalendarEventCreateToolProviderDetails)
	}
	if c.typ == "GoHighLevelContactCreateToolProviderDetails" || c.GoHighLevelContactCreateToolProviderDetails != nil {
		return visitor.VisitGoHighLevelContactCreateToolProviderDetails(c.GoHighLevelContactCreateToolProviderDetails)
	}
	if c.typ == "GoHighLevelContactGetToolProviderDetails" || c.GoHighLevelContactGetToolProviderDetails != nil {
		return visitor.VisitGoHighLevelContactGetToolProviderDetails(c.GoHighLevelContactGetToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoVisibility string

const (
	CreateToolTemplateDtoVisibilityPublic  CreateToolTemplateDtoVisibility = "public"
	CreateToolTemplateDtoVisibilityPrivate CreateToolTemplateDtoVisibility = "private"
)

func NewCreateToolTemplateDtoVisibilityFromString(s string) (CreateToolTemplateDtoVisibility, error) {
	switch s {
	case "public":
		return CreateToolTemplateDtoVisibilityPublic, nil
	case "private":
		return CreateToolTemplateDtoVisibilityPrivate, nil
	}
	var t CreateToolTemplateDtoVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateToolTemplateDtoVisibility) Ptr() *CreateToolTemplateDtoVisibility {
	return &c
}

type CreateTransferCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateTransferCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*CreateTransferCallToolDtoDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTransferCallToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateTransferCallToolDto) GetMessages() []*CreateTransferCallToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateTransferCallToolDto) GetDestinations() []*CreateTransferCallToolDtoDestinationsItem {
	if c == nil {
		return nil
	}
	return c.Destinations
}

func (c *CreateTransferCallToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateTransferCallToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateTransferCallToolDto) Type() string {
	return c.type_
}

func (c *CreateTransferCallToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTransferCallToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateTransferCallToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTransferCallToolDto(unmarshaler.embed)
	if unmarshaler.Type != "transferCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transferCall", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTransferCallToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateTransferCallToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transferCall",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTransferCallToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTransferCallToolDtoDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (c *CreateTransferCallToolDtoDestinationsItem) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if c == nil {
		return nil
	}
	return c.TransferDestinationAssistant
}

func (c *CreateTransferCallToolDtoDestinationsItem) GetTransferDestinationNumber() *TransferDestinationNumber {
	if c == nil {
		return nil
	}
	return c.TransferDestinationNumber
}

func (c *CreateTransferCallToolDtoDestinationsItem) GetTransferDestinationSip() *TransferDestinationSip {
	if c == nil {
		return nil
	}
	return c.TransferDestinationSip
}

func (c *CreateTransferCallToolDtoDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		c.typ = "TransferDestinationAssistant"
		c.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.typ = "TransferDestinationNumber"
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.typ = "TransferDestinationSip"
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTransferCallToolDtoDestinationsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return json.Marshal(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CreateTransferCallToolDtoDestinationsItem) Accept(visitor CreateTransferCallToolDtoDestinationsItemVisitor) error {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateTransferCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTransferCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateTransferCallToolDtoMessagesItem) Accept(visitor CreateTransferCallToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTrieveCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTrieveCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateTrieveCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTrieveCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTrieveCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTrieveCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTrieveCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTrieveCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "trieve" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "trieve", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTrieveCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTrieveCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "trieve",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTrieveCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTwilioCredentialDto struct {
	// This is not returned in the API.
	AuthToken *string `json:"authToken,omitempty" url:"authToken,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is not returned in the API.
	ApiSecret  *string `json:"apiSecret,omitempty" url:"apiSecret,omitempty"`
	AccountSid string  `json:"accountSid" url:"accountSid"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTwilioCredentialDto) GetAuthToken() *string {
	if c == nil {
		return nil
	}
	return c.AuthToken
}

func (c *CreateTwilioCredentialDto) GetApiKey() *string {
	if c == nil {
		return nil
	}
	return c.ApiKey
}

func (c *CreateTwilioCredentialDto) GetApiSecret() *string {
	if c == nil {
		return nil
	}
	return c.ApiSecret
}

func (c *CreateTwilioCredentialDto) GetAccountSid() string {
	if c == nil {
		return ""
	}
	return c.AccountSid
}

func (c *CreateTwilioCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTwilioCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTwilioCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTwilioCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTwilioCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTwilioCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "twilio", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTwilioCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTwilioCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTwilioCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateVoicemailToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateVoicemailToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "voicemail". This uses the model itself to determine if a voicemil was reached. Can be used alternatively/alongside with TwilioVoicemailDetection
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateVoicemailToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateVoicemailToolDto) GetMessages() []*CreateVoicemailToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateVoicemailToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateVoicemailToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateVoicemailToolDto) Type() string {
	return c.type_
}

func (c *CreateVoicemailToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVoicemailToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateVoicemailToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVoicemailToolDto(unmarshaler.embed)
	if unmarshaler.Type != "voicemail" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "voicemail", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVoicemailToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateVoicemailToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "voicemail",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVoicemailToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateVoicemailToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateVoicemailToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateVoicemailToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVoicemailToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateVoicemailToolDtoMessagesItem) Accept(visitor CreateVoicemailToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVonageCredentialDto struct {
	// This is not returned in the API.
	ApiSecret string `json:"apiSecret" url:"apiSecret"`
	ApiKey    string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateVonageCredentialDto) GetApiSecret() string {
	if c == nil {
		return ""
	}
	return c.ApiSecret
}

func (c *CreateVonageCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateVonageCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateVonageCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateVonageCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVonageCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateVonageCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVonageCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "vonage", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVonageCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateVonageCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "vonage",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVonageCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWebCallDto struct {
	// This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.
	//
	// To start a call with:
	// - Assistant, use `assistantId` or `assistant`
	// - Squad, use `squadId` or `squad`
	// - Workflow, use `workflowId` or `workflow`
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant`
	// - Squad, use `squad`
	// - Workflow, use `workflow`
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// [BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.
	//
	// This is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	// [BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.
	//
	// This is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	Workflow *CreateWorkflowDto `json:"workflow,omitempty" url:"workflow,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateWebCallDto) GetAssistantId() *string {
	if c == nil {
		return nil
	}
	return c.AssistantId
}

func (c *CreateWebCallDto) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *CreateWebCallDto) GetAssistantOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.AssistantOverrides
}

func (c *CreateWebCallDto) GetSquadId() *string {
	if c == nil {
		return nil
	}
	return c.SquadId
}

func (c *CreateWebCallDto) GetSquad() *CreateSquadDto {
	if c == nil {
		return nil
	}
	return c.Squad
}

func (c *CreateWebCallDto) GetWorkflowId() *string {
	if c == nil {
		return nil
	}
	return c.WorkflowId
}

func (c *CreateWebCallDto) GetWorkflow() *CreateWorkflowDto {
	if c == nil {
		return nil
	}
	return c.Workflow
}

func (c *CreateWebCallDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebCallDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateWebCallDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateWebCallDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebCallDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWebhookCredentialDto struct {
	// This is the authentication plan. Currently supports OAuth2 RFC 6749.
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateWebhookCredentialDto) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.AuthenticationPlan
}

func (c *CreateWebhookCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateWebhookCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateWebhookCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebhookCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateWebhookCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateWebhookCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "webhook" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "webhook", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebhookCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateWebhookCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "webhook",
	}
	return json.Marshal(marshaler)
}

func (c *CreateWebhookCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWorkflowDto struct {
	Nodes []*CreateWorkflowDtoNodesItem `json:"nodes,omitempty" url:"nodes,omitempty"`
	// These are the options for the workflow's LLM.
	Model *CreateWorkflowDtoModel `json:"model,omitempty" url:"model,omitempty"`
	Name  string                  `json:"name" url:"name"`
	Edges []*Edge                 `json:"edges,omitempty" url:"edges,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateWorkflowDto) GetNodes() []*CreateWorkflowDtoNodesItem {
	if c == nil {
		return nil
	}
	return c.Nodes
}

func (c *CreateWorkflowDto) GetModel() *CreateWorkflowDtoModel {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *CreateWorkflowDto) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateWorkflowDto) GetEdges() []*Edge {
	if c == nil {
		return nil
	}
	return c.Edges
}

func (c *CreateWorkflowDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWorkflowDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateWorkflowDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateWorkflowDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWorkflowDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// These are the options for the workflow's LLM.
type CreateWorkflowDtoModel struct {
	WorkflowOpenAiModel    *WorkflowOpenAiModel
	WorkflowAnthropicModel *WorkflowAnthropicModel

	typ string
}

func (c *CreateWorkflowDtoModel) GetWorkflowOpenAiModel() *WorkflowOpenAiModel {
	if c == nil {
		return nil
	}
	return c.WorkflowOpenAiModel
}

func (c *CreateWorkflowDtoModel) GetWorkflowAnthropicModel() *WorkflowAnthropicModel {
	if c == nil {
		return nil
	}
	return c.WorkflowAnthropicModel
}

func (c *CreateWorkflowDtoModel) UnmarshalJSON(data []byte) error {
	valueWorkflowOpenAiModel := new(WorkflowOpenAiModel)
	if err := json.Unmarshal(data, &valueWorkflowOpenAiModel); err == nil {
		c.typ = "WorkflowOpenAiModel"
		c.WorkflowOpenAiModel = valueWorkflowOpenAiModel
		return nil
	}
	valueWorkflowAnthropicModel := new(WorkflowAnthropicModel)
	if err := json.Unmarshal(data, &valueWorkflowAnthropicModel); err == nil {
		c.typ = "WorkflowAnthropicModel"
		c.WorkflowAnthropicModel = valueWorkflowAnthropicModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateWorkflowDtoModel) MarshalJSON() ([]byte, error) {
	if c.typ == "WorkflowOpenAiModel" || c.WorkflowOpenAiModel != nil {
		return json.Marshal(c.WorkflowOpenAiModel)
	}
	if c.typ == "WorkflowAnthropicModel" || c.WorkflowAnthropicModel != nil {
		return json.Marshal(c.WorkflowAnthropicModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowDtoModelVisitor interface {
	VisitWorkflowOpenAiModel(*WorkflowOpenAiModel) error
	VisitWorkflowAnthropicModel(*WorkflowAnthropicModel) error
}

func (c *CreateWorkflowDtoModel) Accept(visitor CreateWorkflowDtoModelVisitor) error {
	if c.typ == "WorkflowOpenAiModel" || c.WorkflowOpenAiModel != nil {
		return visitor.VisitWorkflowOpenAiModel(c.WorkflowOpenAiModel)
	}
	if c.typ == "WorkflowAnthropicModel" || c.WorkflowAnthropicModel != nil {
		return visitor.VisitWorkflowAnthropicModel(c.WorkflowAnthropicModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowDtoNodesItem struct {
	ConversationNode *ConversationNode
	ToolNode         *ToolNode

	typ string
}

func (c *CreateWorkflowDtoNodesItem) GetConversationNode() *ConversationNode {
	if c == nil {
		return nil
	}
	return c.ConversationNode
}

func (c *CreateWorkflowDtoNodesItem) GetToolNode() *ToolNode {
	if c == nil {
		return nil
	}
	return c.ToolNode
}

func (c *CreateWorkflowDtoNodesItem) UnmarshalJSON(data []byte) error {
	valueConversationNode := new(ConversationNode)
	if err := json.Unmarshal(data, &valueConversationNode); err == nil {
		c.typ = "ConversationNode"
		c.ConversationNode = valueConversationNode
		return nil
	}
	valueToolNode := new(ToolNode)
	if err := json.Unmarshal(data, &valueToolNode); err == nil {
		c.typ = "ToolNode"
		c.ToolNode = valueToolNode
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateWorkflowDtoNodesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ConversationNode" || c.ConversationNode != nil {
		return json.Marshal(c.ConversationNode)
	}
	if c.typ == "ToolNode" || c.ToolNode != nil {
		return json.Marshal(c.ToolNode)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowDtoNodesItemVisitor interface {
	VisitConversationNode(*ConversationNode) error
	VisitToolNode(*ToolNode) error
}

func (c *CreateWorkflowDtoNodesItem) Accept(visitor CreateWorkflowDtoNodesItemVisitor) error {
	if c.typ == "ConversationNode" || c.ConversationNode != nil {
		return visitor.VisitConversationNode(c.ConversationNode)
	}
	if c.typ == "ToolNode" || c.ToolNode != nil {
		return visitor.VisitToolNode(c.ToolNode)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateXAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateXAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateXAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateXAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateXAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateXAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateXAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateXAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "xai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "xai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateXAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateXAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "xai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateXAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialActionRequest struct {
	ActionName string                 `json:"action_name" url:"action_name"`
	Input      map[string]interface{} `json:"input,omitempty" url:"input,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialActionRequest) GetActionName() string {
	if c == nil {
		return ""
	}
	return c.ActionName
}

func (c *CredentialActionRequest) GetInput() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Input
}

func (c *CredentialActionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialActionRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialActionRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialEndUser struct {
	EndUserId      string `json:"endUserId" url:"endUserId"`
	OrganizationId string `json:"organizationId" url:"organizationId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialEndUser) GetEndUserId() string {
	if c == nil {
		return ""
	}
	return c.EndUserId
}

func (c *CredentialEndUser) GetOrganizationId() string {
	if c == nil {
		return ""
	}
	return c.OrganizationId
}

func (c *CredentialEndUser) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialEndUser) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialEndUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialEndUser(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialEndUser) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialSessionDto struct {
	// The type of credential to generate a session for. Only Nango user-facing providers are supported.
	Provider CredentialSessionDtoProvider `json:"provider" url:"provider"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialSessionDto) GetProvider() CredentialSessionDtoProvider {
	if c == nil {
		return ""
	}
	return c.Provider
}

func (c *CredentialSessionDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialSessionDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialSessionDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialSessionDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialSessionDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of credential to generate a session for. Only Nango user-facing providers are supported.
type CredentialSessionDtoProvider string

const (
	CredentialSessionDtoProviderGoogleCalendarOauth2Client        CredentialSessionDtoProvider = "google.calendar.oauth2-client"
	CredentialSessionDtoProviderGoogleCalendarOauth2Authorization CredentialSessionDtoProvider = "google.calendar.oauth2-authorization"
	CredentialSessionDtoProviderGoogleSheetsOauth2Authorization   CredentialSessionDtoProvider = "google.sheets.oauth2-authorization"
	CredentialSessionDtoProviderSlackOauth2Authorization          CredentialSessionDtoProvider = "slack.oauth2-authorization"
)

func NewCredentialSessionDtoProviderFromString(s string) (CredentialSessionDtoProvider, error) {
	switch s {
	case "google.calendar.oauth2-client":
		return CredentialSessionDtoProviderGoogleCalendarOauth2Client, nil
	case "google.calendar.oauth2-authorization":
		return CredentialSessionDtoProviderGoogleCalendarOauth2Authorization, nil
	case "google.sheets.oauth2-authorization":
		return CredentialSessionDtoProviderGoogleSheetsOauth2Authorization, nil
	case "slack.oauth2-authorization":
		return CredentialSessionDtoProviderSlackOauth2Authorization, nil
	}
	var t CredentialSessionDtoProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialSessionDtoProvider) Ptr() *CredentialSessionDtoProvider {
	return &c
}

type CredentialSessionError struct {
	Type        string `json:"type" url:"type"`
	Description string `json:"description" url:"description"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialSessionError) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CredentialSessionError) GetDescription() string {
	if c == nil {
		return ""
	}
	return c.Description
}

func (c *CredentialSessionError) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialSessionError) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialSessionError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialSessionError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialSessionError) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialSessionResponse struct {
	SessionToken string `json:"sessionToken" url:"sessionToken"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialSessionResponse) GetSessionToken() string {
	if c == nil {
		return ""
	}
	return c.SessionToken
}

func (c *CredentialSessionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialSessionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialSessionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialSessionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialSessionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialWebhookDto struct {
	Type              CredentialWebhookDtoType      `json:"type" url:"type"`
	Operation         CredentialWebhookDtoOperation `json:"operation" url:"operation"`
	From              string                        `json:"from" url:"from"`
	ConnectionId      string                        `json:"connectionId" url:"connectionId"`
	AuthMode          CredentialWebhookDtoAuthMode  `json:"authMode" url:"authMode"`
	ProviderConfigKey string                        `json:"providerConfigKey" url:"providerConfigKey"`
	Provider          string                        `json:"provider" url:"provider"`
	Environment       string                        `json:"environment" url:"environment"`
	Success           bool                          `json:"success" url:"success"`
	EndUser           *CredentialEndUser            `json:"endUser,omitempty" url:"endUser,omitempty"`
	Error             *CredentialSessionError       `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialWebhookDto) GetType() CredentialWebhookDtoType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CredentialWebhookDto) GetOperation() CredentialWebhookDtoOperation {
	if c == nil {
		return ""
	}
	return c.Operation
}

func (c *CredentialWebhookDto) GetFrom() string {
	if c == nil {
		return ""
	}
	return c.From
}

func (c *CredentialWebhookDto) GetConnectionId() string {
	if c == nil {
		return ""
	}
	return c.ConnectionId
}

func (c *CredentialWebhookDto) GetAuthMode() CredentialWebhookDtoAuthMode {
	if c == nil {
		return ""
	}
	return c.AuthMode
}

func (c *CredentialWebhookDto) GetProviderConfigKey() string {
	if c == nil {
		return ""
	}
	return c.ProviderConfigKey
}

func (c *CredentialWebhookDto) GetProvider() string {
	if c == nil {
		return ""
	}
	return c.Provider
}

func (c *CredentialWebhookDto) GetEnvironment() string {
	if c == nil {
		return ""
	}
	return c.Environment
}

func (c *CredentialWebhookDto) GetSuccess() bool {
	if c == nil {
		return false
	}
	return c.Success
}

func (c *CredentialWebhookDto) GetEndUser() *CredentialEndUser {
	if c == nil {
		return nil
	}
	return c.EndUser
}

func (c *CredentialWebhookDto) GetError() *CredentialSessionError {
	if c == nil {
		return nil
	}
	return c.Error
}

func (c *CredentialWebhookDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialWebhookDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialWebhookDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialWebhookDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialWebhookDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialWebhookDtoAuthMode string

const (
	CredentialWebhookDtoAuthModeOauth2 CredentialWebhookDtoAuthMode = "OAUTH2"
	CredentialWebhookDtoAuthModeApiKey CredentialWebhookDtoAuthMode = "API_KEY"
	CredentialWebhookDtoAuthModeBasic  CredentialWebhookDtoAuthMode = "BASIC"
)

func NewCredentialWebhookDtoAuthModeFromString(s string) (CredentialWebhookDtoAuthMode, error) {
	switch s {
	case "OAUTH2":
		return CredentialWebhookDtoAuthModeOauth2, nil
	case "API_KEY":
		return CredentialWebhookDtoAuthModeApiKey, nil
	case "BASIC":
		return CredentialWebhookDtoAuthModeBasic, nil
	}
	var t CredentialWebhookDtoAuthMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialWebhookDtoAuthMode) Ptr() *CredentialWebhookDtoAuthMode {
	return &c
}

type CredentialWebhookDtoOperation string

const (
	CredentialWebhookDtoOperationCreation CredentialWebhookDtoOperation = "creation"
	CredentialWebhookDtoOperationOverride CredentialWebhookDtoOperation = "override"
	CredentialWebhookDtoOperationRefresh  CredentialWebhookDtoOperation = "refresh"
)

func NewCredentialWebhookDtoOperationFromString(s string) (CredentialWebhookDtoOperation, error) {
	switch s {
	case "creation":
		return CredentialWebhookDtoOperationCreation, nil
	case "override":
		return CredentialWebhookDtoOperationOverride, nil
	case "refresh":
		return CredentialWebhookDtoOperationRefresh, nil
	}
	var t CredentialWebhookDtoOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialWebhookDtoOperation) Ptr() *CredentialWebhookDtoOperation {
	return &c
}

type CredentialWebhookDtoType string

const (
	CredentialWebhookDtoTypeAuth    CredentialWebhookDtoType = "auth"
	CredentialWebhookDtoTypeSync    CredentialWebhookDtoType = "sync"
	CredentialWebhookDtoTypeForward CredentialWebhookDtoType = "forward"
)

func NewCredentialWebhookDtoTypeFromString(s string) (CredentialWebhookDtoType, error) {
	switch s {
	case "auth":
		return CredentialWebhookDtoTypeAuth, nil
	case "sync":
		return CredentialWebhookDtoTypeSync, nil
	case "forward":
		return CredentialWebhookDtoTypeForward, nil
	}
	var t CredentialWebhookDtoType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialWebhookDtoType) Ptr() *CredentialWebhookDtoType {
	return &c
}

type CustomLlmCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the authentication session for the credential. Available for credentials that have an authentication plan.
	AuthenticationSession *Oauth2AuthenticationSession `json:"authenticationSession,omitempty" url:"authenticationSession,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomLlmCredential) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CustomLlmCredential) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.AuthenticationPlan
}

func (c *CustomLlmCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CustomLlmCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CustomLlmCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CustomLlmCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CustomLlmCredential) GetAuthenticationSession() *Oauth2AuthenticationSession {
	if c == nil {
		return nil
	}
	return c.AuthenticationSession
}

func (c *CustomLlmCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CustomLlmCredential) Provider() string {
	return c.provider
}

func (c *CustomLlmCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLlmCredential) UnmarshalJSON(data []byte) error {
	type embed CustomLlmCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomLlmCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomLlmCredential) MarshalJSON() ([]byte, error) {
	type embed CustomLlmCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CustomLlmCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomLlmModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*CustomLlmModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the provider that will be used for the model. Any service, including your own server, that is compatible with the OpenAI API can be used.
	// This determines whether metadata is sent in requests to the custom provider.
	//
	// - `off` will not send any metadata. payload will look like `{ messages }`
	// - `variable` will send `assistant.metadata` as a variable on the payload. payload will look like `{ messages, metadata }`
	// - `destructured` will send `assistant.metadata` fields directly on the payload. payload will look like `{ messages, ...metadata }`
	//
	// Further, `variable` and `destructured` will send `call`, `phoneNumber`, and `customer` objects in the payload.
	//
	// Default is `variable`.
	MetadataSendMode *CustomLlmModelMetadataSendMode `json:"metadataSendMode,omitempty" url:"metadataSendMode,omitempty"`
	// These is the URL we'll use for the OpenAI client's `baseURL`. Ex. https://openrouter.ai/api/v1
	Url string `json:"url" url:"url"`
	// This sets the timeout for the connection to the custom provider without needing to stream any tokens back. Default is 20 seconds.
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomLlmModel) GetMessages() []*OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CustomLlmModel) GetTools() []*CustomLlmModelToolsItem {
	if c == nil {
		return nil
	}
	return c.Tools
}

func (c *CustomLlmModel) GetToolIds() []string {
	if c == nil {
		return nil
	}
	return c.ToolIds
}

func (c *CustomLlmModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if c == nil {
		return nil
	}
	return c.KnowledgeBase
}

func (c *CustomLlmModel) GetKnowledgeBaseId() *string {
	if c == nil {
		return nil
	}
	return c.KnowledgeBaseId
}

func (c *CustomLlmModel) GetMetadataSendMode() *CustomLlmModelMetadataSendMode {
	if c == nil {
		return nil
	}
	return c.MetadataSendMode
}

func (c *CustomLlmModel) GetUrl() string {
	if c == nil {
		return ""
	}
	return c.Url
}

func (c *CustomLlmModel) GetTimeoutSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.TimeoutSeconds
}

func (c *CustomLlmModel) GetModel() string {
	if c == nil {
		return ""
	}
	return c.Model
}

func (c *CustomLlmModel) GetTemperature() *float64 {
	if c == nil {
		return nil
	}
	return c.Temperature
}

func (c *CustomLlmModel) GetMaxTokens() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxTokens
}

func (c *CustomLlmModel) GetEmotionRecognitionEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.EmotionRecognitionEnabled
}

func (c *CustomLlmModel) GetNumFastTurns() *float64 {
	if c == nil {
		return nil
	}
	return c.NumFastTurns
}

func (c *CustomLlmModel) Provider() string {
	return c.provider
}

func (c *CustomLlmModel) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLlmModel) UnmarshalJSON(data []byte) error {
	type embed CustomLlmModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomLlmModel(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomLlmModel) MarshalJSON() ([]byte, error) {
	type embed CustomLlmModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CustomLlmModel) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This determines whether metadata is sent in requests to the custom provider.
//
// - `off` will not send any metadata. payload will look like `{ messages }`
// - `variable` will send `assistant.metadata` as a variable on the payload. payload will look like `{ messages, metadata }`
// - `destructured` will send `assistant.metadata` fields directly on the payload. payload will look like `{ messages, ...metadata }`
//
// Further, `variable` and `destructured` will send `call`, `phoneNumber`, and `customer` objects in the payload.
//
// Default is `variable`.
type CustomLlmModelMetadataSendMode string

const (
	CustomLlmModelMetadataSendModeOff          CustomLlmModelMetadataSendMode = "off"
	CustomLlmModelMetadataSendModeVariable     CustomLlmModelMetadataSendMode = "variable"
	CustomLlmModelMetadataSendModeDestructured CustomLlmModelMetadataSendMode = "destructured"
)

func NewCustomLlmModelMetadataSendModeFromString(s string) (CustomLlmModelMetadataSendMode, error) {
	switch s {
	case "off":
		return CustomLlmModelMetadataSendModeOff, nil
	case "variable":
		return CustomLlmModelMetadataSendModeVariable, nil
	case "destructured":
		return CustomLlmModelMetadataSendModeDestructured, nil
	}
	var t CustomLlmModelMetadataSendMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomLlmModelMetadataSendMode) Ptr() *CustomLlmModelMetadataSendMode {
	return &c
}

type CustomLlmModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (c *CustomLlmModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if c == nil {
		return nil
	}
	return c.CreateApiRequestToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if c == nil {
		return nil
	}
	return c.CreateBashToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if c == nil {
		return nil
	}
	return c.CreateComputerToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if c == nil {
		return nil
	}
	return c.CreateDtmfToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateEndCallToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if c == nil {
		return nil
	}
	return c.CreateFunctionToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCalendarEventCreateToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactCreateToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelContactGetToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleCalendarCreateEventToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGoogleSheetsRowAppendToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if c == nil {
		return nil
	}
	return c.CreateMcpToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if c == nil {
		return nil
	}
	return c.CreateQueryToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSlackSendMessageToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if c == nil {
		return nil
	}
	return c.CreateSmsToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTextEditorToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTransferCallToolDto
}

func (c *CustomLlmModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		c.typ = "CreateApiRequestToolDto"
		c.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		c.typ = "CreateBashToolDto"
		c.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		c.typ = "CreateComputerToolDto"
		c.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.typ = "CreateDtmfToolDto"
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.typ = "CreateEndCallToolDto"
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.typ = "CreateFunctionToolDto"
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		c.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		c.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactCreateToolDto"
		c.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		c.typ = "CreateGoHighLevelContactGetToolDto"
		c.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		c.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		c.typ = "CreateGoogleCalendarCreateEventToolDto"
		c.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		c.typ = "CreateGoogleSheetsRowAppendToolDto"
		c.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		c.typ = "CreateMcpToolDto"
		c.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		c.typ = "CreateQueryToolDto"
		c.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		c.typ = "CreateSlackSendMessageToolDto"
		c.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		c.typ = "CreateSmsToolDto"
		c.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		c.typ = "CreateTextEditorToolDto"
		c.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.typ = "CreateTransferCallToolDto"
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CustomLlmModelToolsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return json.Marshal(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return json.Marshal(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return json.Marshal(c.CreateComputerToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(c.CreateGoHighLevelContactGetToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return json.Marshal(c.CreateMcpToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return json.Marshal(c.CreateQueryToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return json.Marshal(c.CreateSmsToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return json.Marshal(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CustomLlmModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CustomLlmModelToolsItem) Accept(visitor CustomLlmModelToolsItemVisitor) error {
	if c.typ == "CreateApiRequestToolDto" || c.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(c.CreateApiRequestToolDto)
	}
	if c.typ == "CreateBashToolDto" || c.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(c.CreateBashToolDto)
	}
	if c.typ == "CreateComputerToolDto" || c.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(c.CreateComputerToolDto)
	}
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || c.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(c.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if c.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || c.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(c.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactCreateToolDto" || c.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(c.CreateGoHighLevelContactCreateToolDto)
	}
	if c.typ == "CreateGoHighLevelContactGetToolDto" || c.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(c.CreateGoHighLevelContactGetToolDto)
	}
	if c.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || c.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(c.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if c.typ == "CreateGoogleCalendarCreateEventToolDto" || c.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(c.CreateGoogleCalendarCreateEventToolDto)
	}
	if c.typ == "CreateGoogleSheetsRowAppendToolDto" || c.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(c.CreateGoogleSheetsRowAppendToolDto)
	}
	if c.typ == "CreateMcpToolDto" || c.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(c.CreateMcpToolDto)
	}
	if c.typ == "CreateQueryToolDto" || c.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(c.CreateQueryToolDto)
	}
	if c.typ == "CreateSlackSendMessageToolDto" || c.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(c.CreateSlackSendMessageToolDto)
	}
	if c.typ == "CreateSmsToolDto" || c.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(c.CreateSmsToolDto)
	}
	if c.typ == "CreateTextEditorToolDto" || c.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(c.CreateTextEditorToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CustomMessage struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This is a custom message.
	// This is the content that the assistant will say when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomMessage) GetContents() []*TextContent {
	if c == nil {
		return nil
	}
	return c.Contents
}

func (c *CustomMessage) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *CustomMessage) Type() string {
	return c.type_
}

func (c *CustomMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomMessage) UnmarshalJSON(data []byte) error {
	type embed CustomMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomMessage(unmarshaler.embed)
	if unmarshaler.Type != "custom-message" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-message", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomMessage) MarshalJSON() ([]byte, error) {
	type embed CustomMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "custom-message",
	}
	return json.Marshal(marshaler)
}

func (c *CustomMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomTranscriber struct {
	// This is the transcription provider that will be used. Use `custom-transcriber` for providers that are not natively supported.
	// This is where the transcription request will be sent.
	//
	// Usage:
	// 1. Vapi will initiate a websocket connection with `server.url`.
	//
	// 2. Vapi will send an initial text frame with the sample rate. Format:
	// ```
	//
	//	{
	//	  "type": "start",
	//	  "encoding": "linear16", // 16-bit raw PCM format
	//	  "container": "raw",
	//	  "sampleRate": {{sampleRate}},
	//	  "channels": 2 // customer is channel 0, assistant is channel 1
	//	}
	//
	// ```
	//
	// 3. Vapi will send the audio data in 16-bit raw PCM format as binary frames.
	//
	// 4. You can read the messages something like this:
	// ```
	//
	//	ws.on('message', (data, isBinary) => {
	//	  if (isBinary) {
	//	    pcmBuffer = Buffer.concat([pcmBuffer, data]);
	//	    console.log(`Received PCM data, buffer size: ${pcmBuffer.length}`);
	//	  } else {
	//	    console.log('Received message:', JSON.parse(data.toString()));
	//	  }
	//	});
	//
	// ```
	//
	// 5. You will respond with transcriptions as you have them. Format:
	// ```
	//
	//	{
	//	   "type": "transcriber-response",
	//	   "transcription": "Hello, world!",
	//	   "channel": "customer" | "assistant"
	//	}
	//
	// ```
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomTranscriber) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CustomTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if c == nil {
		return nil
	}
	return c.FallbackPlan
}

func (c *CustomTranscriber) Provider() string {
	return c.provider
}

func (c *CustomTranscriber) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomTranscriber) UnmarshalJSON(data []byte) error {
	type embed CustomTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "custom-transcriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-transcriber", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomTranscriber) MarshalJSON() ([]byte, error) {
	type embed CustomTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-transcriber",
	}
	return json.Marshal(marshaler)
}

func (c *CustomTranscriber) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used. Use `custom-voice` for providers that are not natively supported.
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is where the voice request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "message": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected: 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomVoice) GetCachingEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.CachingEnabled
}

func (c *CustomVoice) GetChunkPlan() *ChunkPlan {
	if c == nil {
		return nil
	}
	return c.ChunkPlan
}

func (c *CustomVoice) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CustomVoice) GetFallbackPlan() *FallbackPlan {
	if c == nil {
		return nil
	}
	return c.FallbackPlan
}

func (c *CustomVoice) Provider() string {
	return c.provider
}

func (c *CustomVoice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomVoice) UnmarshalJSON(data []byte) error {
	type embed CustomVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomVoice(unmarshaler.embed)
	if unmarshaler.Provider != "custom-voice" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-voice", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomVoice) MarshalJSON() ([]byte, error) {
	type embed CustomVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-voice",
	}
	return json.Marshal(marshaler)
}

func (c *CustomVoice) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomerCustomEndpointingRule struct {
	// This endpointing rule is based on current customer message as they are speaking.
	//
	// Flow:
	// - Assistant speaks
	// - Customer starts speaking
	// - Customer transcription comes in
	// - This rule is evaluated on the current customer transcription
	// - If a match is found based on `regex`, the endpointing timeout is set to `timeoutSeconds`
	//
	// Usage:
	// - If you want to wait longer while customer is speaking numbers, you can set a longer timeout.
	// This is the regex pattern to match.
	//
	// Note:
	// - This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test("hello there")` will return `true`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	// - `RegExp.test` does substring matching, so `/cat/.test("I love cats")` will return `true`. To do full string matching, send "^cat$".
	Regex string `json:"regex" url:"regex"`
	// These are the options for the regex match. Defaults to all disabled.
	//
	// @default []
	RegexOptions []*RegexOption `json:"regexOptions,omitempty" url:"regexOptions,omitempty"`
	// This is the endpointing timeout in seconds, if the rule is matched.
	TimeoutSeconds float64 `json:"timeoutSeconds" url:"timeoutSeconds"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomEndpointingRule) GetRegex() string {
	if c == nil {
		return ""
	}
	return c.Regex
}

func (c *CustomerCustomEndpointingRule) GetRegexOptions() []*RegexOption {
	if c == nil {
		return nil
	}
	return c.RegexOptions
}

func (c *CustomerCustomEndpointingRule) GetTimeoutSeconds() float64 {
	if c == nil {
		return 0
	}
	return c.TimeoutSeconds
}

func (c *CustomerCustomEndpointingRule) Type() string {
	return c.type_
}

func (c *CustomerCustomEndpointingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomEndpointingRule) UnmarshalJSON(data []byte) error {
	type embed CustomerCustomEndpointingRule
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomerCustomEndpointingRule(unmarshaler.embed)
	if unmarshaler.Type != "customer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "customer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomEndpointingRule) MarshalJSON() ([]byte, error) {
	type embed CustomerCustomEndpointingRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "customer",
	}
	return json.Marshal(marshaler)
}

func (c *CustomerCustomEndpointingRule) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeepInfraCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepInfraCredential) GetApiKey() string {
	if d == nil {
		return ""
	}
	return d.ApiKey
}

func (d *DeepInfraCredential) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeepInfraCredential) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DeepInfraCredential) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DeepInfraCredential) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DeepInfraCredential) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeepInfraCredential) Provider() string {
	return d.provider
}

func (d *DeepInfraCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepInfraCredential) UnmarshalJSON(data []byte) error {
	type embed DeepInfraCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepInfraCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepinfra", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepInfraCredential) MarshalJSON() ([]byte, error) {
	type embed DeepInfraCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Provider:  "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (d *DeepInfraCredential) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepInfraModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*DeepInfraModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepInfraModel) GetMessages() []*OpenAiMessage {
	if d == nil {
		return nil
	}
	return d.Messages
}

func (d *DeepInfraModel) GetTools() []*DeepInfraModelToolsItem {
	if d == nil {
		return nil
	}
	return d.Tools
}

func (d *DeepInfraModel) GetToolIds() []string {
	if d == nil {
		return nil
	}
	return d.ToolIds
}

func (d *DeepInfraModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if d == nil {
		return nil
	}
	return d.KnowledgeBase
}

func (d *DeepInfraModel) GetKnowledgeBaseId() *string {
	if d == nil {
		return nil
	}
	return d.KnowledgeBaseId
}

func (d *DeepInfraModel) GetModel() string {
	if d == nil {
		return ""
	}
	return d.Model
}

func (d *DeepInfraModel) GetTemperature() *float64 {
	if d == nil {
		return nil
	}
	return d.Temperature
}

func (d *DeepInfraModel) GetMaxTokens() *float64 {
	if d == nil {
		return nil
	}
	return d.MaxTokens
}

func (d *DeepInfraModel) GetEmotionRecognitionEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.EmotionRecognitionEnabled
}

func (d *DeepInfraModel) GetNumFastTurns() *float64 {
	if d == nil {
		return nil
	}
	return d.NumFastTurns
}

func (d *DeepInfraModel) Provider() string {
	return d.provider
}

func (d *DeepInfraModel) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepInfraModel) UnmarshalJSON(data []byte) error {
	type embed DeepInfraModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepInfraModel(unmarshaler.embed)
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepinfra", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepInfraModel) MarshalJSON() ([]byte, error) {
	type embed DeepInfraModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (d *DeepInfraModel) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepInfraModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (d *DeepInfraModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if d == nil {
		return nil
	}
	return d.CreateApiRequestToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if d == nil {
		return nil
	}
	return d.CreateBashToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if d == nil {
		return nil
	}
	return d.CreateComputerToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if d == nil {
		return nil
	}
	return d.CreateDtmfToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateEndCallToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if d == nil {
		return nil
	}
	return d.CreateFunctionToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelCalendarEventCreateToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelContactCreateToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelContactGetToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoogleCalendarCreateEventToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoogleSheetsRowAppendToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if d == nil {
		return nil
	}
	return d.CreateMcpToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if d == nil {
		return nil
	}
	return d.CreateQueryToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if d == nil {
		return nil
	}
	return d.CreateSlackSendMessageToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if d == nil {
		return nil
	}
	return d.CreateSmsToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if d == nil {
		return nil
	}
	return d.CreateTextEditorToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateTransferCallToolDto
}

func (d *DeepInfraModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		d.typ = "CreateApiRequestToolDto"
		d.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		d.typ = "CreateBashToolDto"
		d.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		d.typ = "CreateComputerToolDto"
		d.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		d.typ = "CreateDtmfToolDto"
		d.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		d.typ = "CreateEndCallToolDto"
		d.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		d.typ = "CreateFunctionToolDto"
		d.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		d.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		d.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		d.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		d.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		d.typ = "CreateGoHighLevelContactCreateToolDto"
		d.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		d.typ = "CreateGoHighLevelContactGetToolDto"
		d.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		d.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		d.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		d.typ = "CreateGoogleCalendarCreateEventToolDto"
		d.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		d.typ = "CreateGoogleSheetsRowAppendToolDto"
		d.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		d.typ = "CreateMcpToolDto"
		d.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		d.typ = "CreateQueryToolDto"
		d.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		d.typ = "CreateSlackSendMessageToolDto"
		d.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		d.typ = "CreateSmsToolDto"
		d.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		d.typ = "CreateTextEditorToolDto"
		d.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		d.typ = "CreateTransferCallToolDto"
		d.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeepInfraModelToolsItem) MarshalJSON() ([]byte, error) {
	if d.typ == "CreateApiRequestToolDto" || d.CreateApiRequestToolDto != nil {
		return json.Marshal(d.CreateApiRequestToolDto)
	}
	if d.typ == "CreateBashToolDto" || d.CreateBashToolDto != nil {
		return json.Marshal(d.CreateBashToolDto)
	}
	if d.typ == "CreateComputerToolDto" || d.CreateComputerToolDto != nil {
		return json.Marshal(d.CreateComputerToolDto)
	}
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return json.Marshal(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return json.Marshal(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return json.Marshal(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || d.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || d.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactCreateToolDto" || d.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelContactCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactGetToolDto" || d.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelContactGetToolDto)
	}
	if d.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || d.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(d.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if d.typ == "CreateGoogleCalendarCreateEventToolDto" || d.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(d.CreateGoogleCalendarCreateEventToolDto)
	}
	if d.typ == "CreateGoogleSheetsRowAppendToolDto" || d.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(d.CreateGoogleSheetsRowAppendToolDto)
	}
	if d.typ == "CreateMcpToolDto" || d.CreateMcpToolDto != nil {
		return json.Marshal(d.CreateMcpToolDto)
	}
	if d.typ == "CreateQueryToolDto" || d.CreateQueryToolDto != nil {
		return json.Marshal(d.CreateQueryToolDto)
	}
	if d.typ == "CreateSlackSendMessageToolDto" || d.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(d.CreateSlackSendMessageToolDto)
	}
	if d.typ == "CreateSmsToolDto" || d.CreateSmsToolDto != nil {
		return json.Marshal(d.CreateSmsToolDto)
	}
	if d.typ == "CreateTextEditorToolDto" || d.CreateTextEditorToolDto != nil {
		return json.Marshal(d.CreateTextEditorToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return json.Marshal(d.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepInfraModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (d *DeepInfraModelToolsItem) Accept(visitor DeepInfraModelToolsItemVisitor) error {
	if d.typ == "CreateApiRequestToolDto" || d.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(d.CreateApiRequestToolDto)
	}
	if d.typ == "CreateBashToolDto" || d.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(d.CreateBashToolDto)
	}
	if d.typ == "CreateComputerToolDto" || d.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(d.CreateComputerToolDto)
	}
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || d.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(d.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || d.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(d.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactCreateToolDto" || d.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(d.CreateGoHighLevelContactCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactGetToolDto" || d.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(d.CreateGoHighLevelContactGetToolDto)
	}
	if d.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || d.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(d.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if d.typ == "CreateGoogleCalendarCreateEventToolDto" || d.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(d.CreateGoogleCalendarCreateEventToolDto)
	}
	if d.typ == "CreateGoogleSheetsRowAppendToolDto" || d.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(d.CreateGoogleSheetsRowAppendToolDto)
	}
	if d.typ == "CreateMcpToolDto" || d.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(d.CreateMcpToolDto)
	}
	if d.typ == "CreateQueryToolDto" || d.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(d.CreateQueryToolDto)
	}
	if d.typ == "CreateSlackSendMessageToolDto" || d.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(d.CreateSlackSendMessageToolDto)
	}
	if d.typ == "CreateSmsToolDto" || d.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(d.CreateSmsToolDto)
	}
	if d.typ == "CreateTextEditorToolDto" || d.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(d.CreateTextEditorToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(d.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepSeekCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepSeekCredential) GetApiKey() string {
	if d == nil {
		return ""
	}
	return d.ApiKey
}

func (d *DeepSeekCredential) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeepSeekCredential) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DeepSeekCredential) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DeepSeekCredential) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DeepSeekCredential) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeepSeekCredential) Provider() string {
	return d.provider
}

func (d *DeepSeekCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepSeekCredential) UnmarshalJSON(data []byte) error {
	type embed DeepSeekCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepSeekCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deep-seek" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deep-seek", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepSeekCredential) MarshalJSON() ([]byte, error) {
	type embed DeepSeekCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Provider:  "deep-seek",
	}
	return json.Marshal(marshaler)
}

func (d *DeepSeekCredential) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepSeekModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*DeepSeekModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model DeepSeekModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepSeekModel) GetMessages() []*OpenAiMessage {
	if d == nil {
		return nil
	}
	return d.Messages
}

func (d *DeepSeekModel) GetTools() []*DeepSeekModelToolsItem {
	if d == nil {
		return nil
	}
	return d.Tools
}

func (d *DeepSeekModel) GetToolIds() []string {
	if d == nil {
		return nil
	}
	return d.ToolIds
}

func (d *DeepSeekModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if d == nil {
		return nil
	}
	return d.KnowledgeBase
}

func (d *DeepSeekModel) GetKnowledgeBaseId() *string {
	if d == nil {
		return nil
	}
	return d.KnowledgeBaseId
}

func (d *DeepSeekModel) GetModel() DeepSeekModelModel {
	if d == nil {
		return ""
	}
	return d.Model
}

func (d *DeepSeekModel) GetTemperature() *float64 {
	if d == nil {
		return nil
	}
	return d.Temperature
}

func (d *DeepSeekModel) GetMaxTokens() *float64 {
	if d == nil {
		return nil
	}
	return d.MaxTokens
}

func (d *DeepSeekModel) GetEmotionRecognitionEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.EmotionRecognitionEnabled
}

func (d *DeepSeekModel) GetNumFastTurns() *float64 {
	if d == nil {
		return nil
	}
	return d.NumFastTurns
}

func (d *DeepSeekModel) Provider() string {
	return d.provider
}

func (d *DeepSeekModel) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepSeekModel) UnmarshalJSON(data []byte) error {
	type embed DeepSeekModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepSeekModel(unmarshaler.embed)
	if unmarshaler.Provider != "deep-seek" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deep-seek", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepSeekModel) MarshalJSON() ([]byte, error) {
	type embed DeepSeekModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deep-seek",
	}
	return json.Marshal(marshaler)
}

func (d *DeepSeekModel) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
type DeepSeekModelModel string

const (
	DeepSeekModelModelDeepseekChat     DeepSeekModelModel = "deepseek-chat"
	DeepSeekModelModelDeepseekReasoner DeepSeekModelModel = "deepseek-reasoner"
)

func NewDeepSeekModelModelFromString(s string) (DeepSeekModelModel, error) {
	switch s {
	case "deepseek-chat":
		return DeepSeekModelModelDeepseekChat, nil
	case "deepseek-reasoner":
		return DeepSeekModelModelDeepseekReasoner, nil
	}
	var t DeepSeekModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepSeekModelModel) Ptr() *DeepSeekModelModel {
	return &d
}

type DeepSeekModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (d *DeepSeekModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if d == nil {
		return nil
	}
	return d.CreateApiRequestToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if d == nil {
		return nil
	}
	return d.CreateBashToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if d == nil {
		return nil
	}
	return d.CreateComputerToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if d == nil {
		return nil
	}
	return d.CreateDtmfToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateEndCallToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if d == nil {
		return nil
	}
	return d.CreateFunctionToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelCalendarEventCreateToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelContactCreateToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoHighLevelContactGetToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoogleCalendarCreateEventToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGoogleSheetsRowAppendToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if d == nil {
		return nil
	}
	return d.CreateMcpToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if d == nil {
		return nil
	}
	return d.CreateQueryToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if d == nil {
		return nil
	}
	return d.CreateSlackSendMessageToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if d == nil {
		return nil
	}
	return d.CreateSmsToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if d == nil {
		return nil
	}
	return d.CreateTextEditorToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateTransferCallToolDto
}

func (d *DeepSeekModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		d.typ = "CreateApiRequestToolDto"
		d.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		d.typ = "CreateBashToolDto"
		d.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		d.typ = "CreateComputerToolDto"
		d.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		d.typ = "CreateDtmfToolDto"
		d.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		d.typ = "CreateEndCallToolDto"
		d.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		d.typ = "CreateFunctionToolDto"
		d.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		d.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		d.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		d.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		d.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		d.typ = "CreateGoHighLevelContactCreateToolDto"
		d.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		d.typ = "CreateGoHighLevelContactGetToolDto"
		d.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		d.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		d.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		d.typ = "CreateGoogleCalendarCreateEventToolDto"
		d.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		d.typ = "CreateGoogleSheetsRowAppendToolDto"
		d.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		d.typ = "CreateMcpToolDto"
		d.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		d.typ = "CreateQueryToolDto"
		d.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		d.typ = "CreateSlackSendMessageToolDto"
		d.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		d.typ = "CreateSmsToolDto"
		d.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		d.typ = "CreateTextEditorToolDto"
		d.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		d.typ = "CreateTransferCallToolDto"
		d.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeepSeekModelToolsItem) MarshalJSON() ([]byte, error) {
	if d.typ == "CreateApiRequestToolDto" || d.CreateApiRequestToolDto != nil {
		return json.Marshal(d.CreateApiRequestToolDto)
	}
	if d.typ == "CreateBashToolDto" || d.CreateBashToolDto != nil {
		return json.Marshal(d.CreateBashToolDto)
	}
	if d.typ == "CreateComputerToolDto" || d.CreateComputerToolDto != nil {
		return json.Marshal(d.CreateComputerToolDto)
	}
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return json.Marshal(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return json.Marshal(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return json.Marshal(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || d.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || d.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactCreateToolDto" || d.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelContactCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactGetToolDto" || d.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(d.CreateGoHighLevelContactGetToolDto)
	}
	if d.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || d.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(d.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if d.typ == "CreateGoogleCalendarCreateEventToolDto" || d.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(d.CreateGoogleCalendarCreateEventToolDto)
	}
	if d.typ == "CreateGoogleSheetsRowAppendToolDto" || d.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(d.CreateGoogleSheetsRowAppendToolDto)
	}
	if d.typ == "CreateMcpToolDto" || d.CreateMcpToolDto != nil {
		return json.Marshal(d.CreateMcpToolDto)
	}
	if d.typ == "CreateQueryToolDto" || d.CreateQueryToolDto != nil {
		return json.Marshal(d.CreateQueryToolDto)
	}
	if d.typ == "CreateSlackSendMessageToolDto" || d.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(d.CreateSlackSendMessageToolDto)
	}
	if d.typ == "CreateSmsToolDto" || d.CreateSmsToolDto != nil {
		return json.Marshal(d.CreateSmsToolDto)
	}
	if d.typ == "CreateTextEditorToolDto" || d.CreateTextEditorToolDto != nil {
		return json.Marshal(d.CreateTextEditorToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return json.Marshal(d.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepSeekModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (d *DeepSeekModelToolsItem) Accept(visitor DeepSeekModelToolsItemVisitor) error {
	if d.typ == "CreateApiRequestToolDto" || d.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(d.CreateApiRequestToolDto)
	}
	if d.typ == "CreateBashToolDto" || d.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(d.CreateBashToolDto)
	}
	if d.typ == "CreateComputerToolDto" || d.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(d.CreateComputerToolDto)
	}
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || d.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(d.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if d.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || d.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(d.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactCreateToolDto" || d.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(d.CreateGoHighLevelContactCreateToolDto)
	}
	if d.typ == "CreateGoHighLevelContactGetToolDto" || d.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(d.CreateGoHighLevelContactGetToolDto)
	}
	if d.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || d.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(d.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if d.typ == "CreateGoogleCalendarCreateEventToolDto" || d.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(d.CreateGoogleCalendarCreateEventToolDto)
	}
	if d.typ == "CreateGoogleSheetsRowAppendToolDto" || d.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(d.CreateGoogleSheetsRowAppendToolDto)
	}
	if d.typ == "CreateMcpToolDto" || d.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(d.CreateMcpToolDto)
	}
	if d.typ == "CreateQueryToolDto" || d.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(d.CreateQueryToolDto)
	}
	if d.typ == "CreateSlackSendMessageToolDto" || d.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(d.CreateSlackSendMessageToolDto)
	}
	if d.typ == "CreateSmsToolDto" || d.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(d.CreateSmsToolDto)
	}
	if d.typ == "CreateTextEditorToolDto" || d.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(d.CreateTextEditorToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(d.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepgramCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl   *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepgramCredential) GetApiKey() string {
	if d == nil {
		return ""
	}
	return d.ApiKey
}

func (d *DeepgramCredential) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeepgramCredential) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DeepgramCredential) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DeepgramCredential) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DeepgramCredential) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeepgramCredential) GetApiUrl() *string {
	if d == nil {
		return nil
	}
	return d.ApiUrl
}

func (d *DeepgramCredential) Provider() string {
	return d.provider
}

func (d *DeepgramCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramCredential) UnmarshalJSON(data []byte) error {
	type embed DeepgramCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramCredential) MarshalJSON() ([]byte, error) {
	type embed DeepgramCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Provider:  "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramCredential) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepgramTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the Deepgram model that will be used. A list of models can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Model *DeepgramTranscriberModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Deepgram supports can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Language *DeepgramTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This will be use smart format option provided by Deepgram. It's default disabled because it can sometimes format numbers as times but it's getting better.
	SmartFormat *bool `json:"smartFormat,omitempty" url:"smartFormat,omitempty"`
	// This automatically switches the transcriber's language when the customer's language changes. Defaults to false.
	//
	// Usage:
	// - If your customers switch languages mid-call, you can set this to true.
	//
	// Note:
	// - To detect language changes, Vapi uses a custom trained model. Languages supported (X = limited support):
	//  1. Arabic
	//  2. Bengali
	//  3. Cantonese
	//  4. Chinese
	//  5. Chinese Simplified (X)
	//  6. Chinese Traditional (X)
	//  7. English
	//  8. Farsi (X)
	//  9. French
	//  10. German
	//  11. Haitian Creole (X)
	//  12. Hindi
	//  13. Italian
	//  14. Japanese
	//  15. Korean
	//  16. Portuguese
	//  17. Russian
	//  18. Spanish
	//  19. Thai
	//  20. Urdu
	//  21. Vietnamese
	//
	// - To receive `language-change-detected` webhook events, add it to `assistant.serverMessages`.
	//
	// @default false
	CodeSwitchingEnabled *bool `json:"codeSwitchingEnabled,omitempty" url:"codeSwitchingEnabled,omitempty"`
	// If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out
	//
	// This will only be used if you are using your own Deepgram API key.
	//
	// @default false
	MipOptOut *bool `json:"mipOptOut,omitempty" url:"mipOptOut,omitempty"`
	// If set to true, this will cause deepgram to convert spoken numbers to literal numerals. For example, "my phone number is nine-seven-two..." would become "my phone number is 972..."
	//
	// @default false
	Numerals *bool `json:"numerals,omitempty" url:"numerals,omitempty"`
	// Transcripts below this confidence threshold will be discarded.
	//
	// @default 0.4
	ConfidenceThreshold *float64 `json:"confidenceThreshold,omitempty" url:"confidenceThreshold,omitempty"`
	// These keywords are passed to the transcription model to help it pick up use-case specific words. Anything that may not be a common word, like your company name, should be added here.
	Keywords []string `json:"keywords,omitempty" url:"keywords,omitempty"`
	// Keyterm Prompting allows you improve Keyword Recall Rate (KRR) for important keyterms or phrases up to 90%.
	Keyterm []string `json:"keyterm,omitempty" url:"keyterm,omitempty"`
	// This is the timeout after which Deepgram will send transcription on user silence. You can read in-depth documentation here: https://developers.deepgram.com/docs/endpointing.
	//
	// Here are the most important bits:
	// - Defaults to 10. This is recommended for most use cases to optimize for latency.
	// - 10 can cause some missing transcriptions since because of the shorter context. This mostly happens for one-word utterances. For those uses cases, it's recommended to try 300. It will add a bit of latency but the quality and reliability of the experience will be better.
	// - If neither 10 nor 300 work, contact support@vapi.ai and we'll find another solution.
	//
	// @default 10
	Endpointing *float64 `json:"endpointing,omitempty" url:"endpointing,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepgramTranscriber) GetModel() *DeepgramTranscriberModel {
	if d == nil {
		return nil
	}
	return d.Model
}

func (d *DeepgramTranscriber) GetLanguage() *DeepgramTranscriberLanguage {
	if d == nil {
		return nil
	}
	return d.Language
}

func (d *DeepgramTranscriber) GetSmartFormat() *bool {
	if d == nil {
		return nil
	}
	return d.SmartFormat
}

func (d *DeepgramTranscriber) GetCodeSwitchingEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.CodeSwitchingEnabled
}

func (d *DeepgramTranscriber) GetMipOptOut() *bool {
	if d == nil {
		return nil
	}
	return d.MipOptOut
}

func (d *DeepgramTranscriber) GetNumerals() *bool {
	if d == nil {
		return nil
	}
	return d.Numerals
}

func (d *DeepgramTranscriber) GetConfidenceThreshold() *float64 {
	if d == nil {
		return nil
	}
	return d.ConfidenceThreshold
}

func (d *DeepgramTranscriber) GetKeywords() []string {
	if d == nil {
		return nil
	}
	return d.Keywords
}

func (d *DeepgramTranscriber) GetKeyterm() []string {
	if d == nil {
		return nil
	}
	return d.Keyterm
}

func (d *DeepgramTranscriber) GetEndpointing() *float64 {
	if d == nil {
		return nil
	}
	return d.Endpointing
}

func (d *DeepgramTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if d == nil {
		return nil
	}
	return d.FallbackPlan
}

func (d *DeepgramTranscriber) Provider() string {
	return d.provider
}

func (d *DeepgramTranscriber) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramTranscriber) UnmarshalJSON(data []byte) error {
	type embed DeepgramTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramTranscriber) MarshalJSON() ([]byte, error) {
	type embed DeepgramTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramTranscriber) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepgramTranscriberLanguage string

const (
	DeepgramTranscriberLanguageBg      DeepgramTranscriberLanguage = "bg"
	DeepgramTranscriberLanguageCa      DeepgramTranscriberLanguage = "ca"
	DeepgramTranscriberLanguageCs      DeepgramTranscriberLanguage = "cs"
	DeepgramTranscriberLanguageDa      DeepgramTranscriberLanguage = "da"
	DeepgramTranscriberLanguageDaDk    DeepgramTranscriberLanguage = "da-DK"
	DeepgramTranscriberLanguageDe      DeepgramTranscriberLanguage = "de"
	DeepgramTranscriberLanguageDeCh    DeepgramTranscriberLanguage = "de-CH"
	DeepgramTranscriberLanguageEl      DeepgramTranscriberLanguage = "el"
	DeepgramTranscriberLanguageEn      DeepgramTranscriberLanguage = "en"
	DeepgramTranscriberLanguageEnAu    DeepgramTranscriberLanguage = "en-AU"
	DeepgramTranscriberLanguageEnGb    DeepgramTranscriberLanguage = "en-GB"
	DeepgramTranscriberLanguageEnIn    DeepgramTranscriberLanguage = "en-IN"
	DeepgramTranscriberLanguageEnNz    DeepgramTranscriberLanguage = "en-NZ"
	DeepgramTranscriberLanguageEnUs    DeepgramTranscriberLanguage = "en-US"
	DeepgramTranscriberLanguageEs      DeepgramTranscriberLanguage = "es"
	DeepgramTranscriberLanguageEs419   DeepgramTranscriberLanguage = "es-419"
	DeepgramTranscriberLanguageEsLatam DeepgramTranscriberLanguage = "es-LATAM"
	DeepgramTranscriberLanguageEt      DeepgramTranscriberLanguage = "et"
	DeepgramTranscriberLanguageFi      DeepgramTranscriberLanguage = "fi"
	DeepgramTranscriberLanguageFr      DeepgramTranscriberLanguage = "fr"
	DeepgramTranscriberLanguageFrCa    DeepgramTranscriberLanguage = "fr-CA"
	DeepgramTranscriberLanguageHi      DeepgramTranscriberLanguage = "hi"
	DeepgramTranscriberLanguageHiLatn  DeepgramTranscriberLanguage = "hi-Latn"
	DeepgramTranscriberLanguageHu      DeepgramTranscriberLanguage = "hu"
	DeepgramTranscriberLanguageId      DeepgramTranscriberLanguage = "id"
	DeepgramTranscriberLanguageIt      DeepgramTranscriberLanguage = "it"
	DeepgramTranscriberLanguageJa      DeepgramTranscriberLanguage = "ja"
	DeepgramTranscriberLanguageKo      DeepgramTranscriberLanguage = "ko"
	DeepgramTranscriberLanguageKoKr    DeepgramTranscriberLanguage = "ko-KR"
	DeepgramTranscriberLanguageLt      DeepgramTranscriberLanguage = "lt"
	DeepgramTranscriberLanguageLv      DeepgramTranscriberLanguage = "lv"
	DeepgramTranscriberLanguageMs      DeepgramTranscriberLanguage = "ms"
	DeepgramTranscriberLanguageMulti   DeepgramTranscriberLanguage = "multi"
	DeepgramTranscriberLanguageNl      DeepgramTranscriberLanguage = "nl"
	DeepgramTranscriberLanguageNlBe    DeepgramTranscriberLanguage = "nl-BE"
	DeepgramTranscriberLanguageNo      DeepgramTranscriberLanguage = "no"
	DeepgramTranscriberLanguagePl      DeepgramTranscriberLanguage = "pl"
	DeepgramTranscriberLanguagePt      DeepgramTranscriberLanguage = "pt"
	DeepgramTranscriberLanguagePtBr    DeepgramTranscriberLanguage = "pt-BR"
	DeepgramTranscriberLanguageRo      DeepgramTranscriberLanguage = "ro"
	DeepgramTranscriberLanguageRu      DeepgramTranscriberLanguage = "ru"
	DeepgramTranscriberLanguageSk      DeepgramTranscriberLanguage = "sk"
	DeepgramTranscriberLanguageSv      DeepgramTranscriberLanguage = "sv"
	DeepgramTranscriberLanguageSvSe    DeepgramTranscriberLanguage = "sv-SE"
	DeepgramTranscriberLanguageTa      DeepgramTranscriberLanguage = "ta"
	DeepgramTranscriberLanguageTaq     DeepgramTranscriberLanguage = "taq"
	DeepgramTranscriberLanguageTh      DeepgramTranscriberLanguage = "th"
	DeepgramTranscriberLanguageThTh    DeepgramTranscriberLanguage = "th-TH"
	DeepgramTranscriberLanguageTr      DeepgramTranscriberLanguage = "tr"
	DeepgramTranscriberLanguageUk      DeepgramTranscriberLanguage = "uk"
	DeepgramTranscriberLanguageVi      DeepgramTranscriberLanguage = "vi"
	DeepgramTranscriberLanguageZh      DeepgramTranscriberLanguage = "zh"
	DeepgramTranscriberLanguageZhCn    DeepgramTranscriberLanguage = "zh-CN"
	DeepgramTranscriberLanguageZhHans  DeepgramTranscriberLanguage = "zh-Hans"
	DeepgramTranscriberLanguageZhHant  DeepgramTranscriberLanguage = "zh-Hant"
	DeepgramTranscriberLanguageZhTw    DeepgramTranscriberLanguage = "zh-TW"
)

func NewDeepgramTranscriberLanguageFromString(s string) (DeepgramTranscriberLanguage, error) {
	switch s {
	case "bg":
		return DeepgramTranscriberLanguageBg, nil
	case "ca":
		return DeepgramTranscriberLanguageCa, nil
	case "cs":
		return DeepgramTranscriberLanguageCs, nil
	case "da":
		return DeepgramTranscriberLanguageDa, nil
	case "da-DK":
		return DeepgramTranscriberLanguageDaDk, nil
	case "de":
		return DeepgramTranscriberLanguageDe, nil
	case "de-CH":
		return DeepgramTranscriberLanguageDeCh, nil
	case "el":
		return DeepgramTranscriberLanguageEl, nil
	case "en":
		return DeepgramTranscriberLanguageEn, nil
	case "en-AU":
		return DeepgramTranscriberLanguageEnAu, nil
	case "en-GB":
		return DeepgramTranscriberLanguageEnGb, nil
	case "en-IN":
		return DeepgramTranscriberLanguageEnIn, nil
	case "en-NZ":
		return DeepgramTranscriberLanguageEnNz, nil
	case "en-US":
		return DeepgramTranscriberLanguageEnUs, nil
	case "es":
		return DeepgramTranscriberLanguageEs, nil
	case "es-419":
		return DeepgramTranscriberLanguageEs419, nil
	case "es-LATAM":
		return DeepgramTranscriberLanguageEsLatam, nil
	case "et":
		return DeepgramTranscriberLanguageEt, nil
	case "fi":
		return DeepgramTranscriberLanguageFi, nil
	case "fr":
		return DeepgramTranscriberLanguageFr, nil
	case "fr-CA":
		return DeepgramTranscriberLanguageFrCa, nil
	case "hi":
		return DeepgramTranscriberLanguageHi, nil
	case "hi-Latn":
		return DeepgramTranscriberLanguageHiLatn, nil
	case "hu":
		return DeepgramTranscriberLanguageHu, nil
	case "id":
		return DeepgramTranscriberLanguageId, nil
	case "it":
		return DeepgramTranscriberLanguageIt, nil
	case "ja":
		return DeepgramTranscriberLanguageJa, nil
	case "ko":
		return DeepgramTranscriberLanguageKo, nil
	case "ko-KR":
		return DeepgramTranscriberLanguageKoKr, nil
	case "lt":
		return DeepgramTranscriberLanguageLt, nil
	case "lv":
		return DeepgramTranscriberLanguageLv, nil
	case "ms":
		return DeepgramTranscriberLanguageMs, nil
	case "multi":
		return DeepgramTranscriberLanguageMulti, nil
	case "nl":
		return DeepgramTranscriberLanguageNl, nil
	case "nl-BE":
		return DeepgramTranscriberLanguageNlBe, nil
	case "no":
		return DeepgramTranscriberLanguageNo, nil
	case "pl":
		return DeepgramTranscriberLanguagePl, nil
	case "pt":
		return DeepgramTranscriberLanguagePt, nil
	case "pt-BR":
		return DeepgramTranscriberLanguagePtBr, nil
	case "ro":
		return DeepgramTranscriberLanguageRo, nil
	case "ru":
		return DeepgramTranscriberLanguageRu, nil
	case "sk":
		return DeepgramTranscriberLanguageSk, nil
	case "sv":
		return DeepgramTranscriberLanguageSv, nil
	case "sv-SE":
		return DeepgramTranscriberLanguageSvSe, nil
	case "ta":
		return DeepgramTranscriberLanguageTa, nil
	case "taq":
		return DeepgramTranscriberLanguageTaq, nil
	case "th":
		return DeepgramTranscriberLanguageTh, nil
	case "th-TH":
		return DeepgramTranscriberLanguageThTh, nil
	case "tr":
		return DeepgramTranscriberLanguageTr, nil
	case "uk":
		return DeepgramTranscriberLanguageUk, nil
	case "vi":
		return DeepgramTranscriberLanguageVi, nil
	case "zh":
		return DeepgramTranscriberLanguageZh, nil
	case "zh-CN":
		return DeepgramTranscriberLanguageZhCn, nil
	case "zh-Hans":
		return DeepgramTranscriberLanguageZhHans, nil
	case "zh-Hant":
		return DeepgramTranscriberLanguageZhHant, nil
	case "zh-TW":
		return DeepgramTranscriberLanguageZhTw, nil
	}
	var t DeepgramTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramTranscriberLanguage) Ptr() *DeepgramTranscriberLanguage {
	return &d
}

type DeepgramTranscriberModel string

const (
	DeepgramTranscriberModelNova3                 DeepgramTranscriberModel = "nova-3"
	DeepgramTranscriberModelNova3General          DeepgramTranscriberModel = "nova-3-general"
	DeepgramTranscriberModelNova3Medical          DeepgramTranscriberModel = "nova-3-medical"
	DeepgramTranscriberModelNova2                 DeepgramTranscriberModel = "nova-2"
	DeepgramTranscriberModelNova2General          DeepgramTranscriberModel = "nova-2-general"
	DeepgramTranscriberModelNova2Meeting          DeepgramTranscriberModel = "nova-2-meeting"
	DeepgramTranscriberModelNova2Phonecall        DeepgramTranscriberModel = "nova-2-phonecall"
	DeepgramTranscriberModelNova2Finance          DeepgramTranscriberModel = "nova-2-finance"
	DeepgramTranscriberModelNova2Conversationalai DeepgramTranscriberModel = "nova-2-conversationalai"
	DeepgramTranscriberModelNova2Voicemail        DeepgramTranscriberModel = "nova-2-voicemail"
	DeepgramTranscriberModelNova2Video            DeepgramTranscriberModel = "nova-2-video"
	DeepgramTranscriberModelNova2Medical          DeepgramTranscriberModel = "nova-2-medical"
	DeepgramTranscriberModelNova2Drivethru        DeepgramTranscriberModel = "nova-2-drivethru"
	DeepgramTranscriberModelNova2Automotive       DeepgramTranscriberModel = "nova-2-automotive"
	DeepgramTranscriberModelNova                  DeepgramTranscriberModel = "nova"
	DeepgramTranscriberModelNovaGeneral           DeepgramTranscriberModel = "nova-general"
	DeepgramTranscriberModelNovaPhonecall         DeepgramTranscriberModel = "nova-phonecall"
	DeepgramTranscriberModelNovaMedical           DeepgramTranscriberModel = "nova-medical"
	DeepgramTranscriberModelEnhanced              DeepgramTranscriberModel = "enhanced"
	DeepgramTranscriberModelEnhancedGeneral       DeepgramTranscriberModel = "enhanced-general"
	DeepgramTranscriberModelEnhancedMeeting       DeepgramTranscriberModel = "enhanced-meeting"
	DeepgramTranscriberModelEnhancedPhonecall     DeepgramTranscriberModel = "enhanced-phonecall"
	DeepgramTranscriberModelEnhancedFinance       DeepgramTranscriberModel = "enhanced-finance"
	DeepgramTranscriberModelBase                  DeepgramTranscriberModel = "base"
	DeepgramTranscriberModelBaseGeneral           DeepgramTranscriberModel = "base-general"
	DeepgramTranscriberModelBaseMeeting           DeepgramTranscriberModel = "base-meeting"
	DeepgramTranscriberModelBasePhonecall         DeepgramTranscriberModel = "base-phonecall"
	DeepgramTranscriberModelBaseFinance           DeepgramTranscriberModel = "base-finance"
	DeepgramTranscriberModelBaseConversationalai  DeepgramTranscriberModel = "base-conversationalai"
	DeepgramTranscriberModelBaseVoicemail         DeepgramTranscriberModel = "base-voicemail"
	DeepgramTranscriberModelBaseVideo             DeepgramTranscriberModel = "base-video"
)

func NewDeepgramTranscriberModelFromString(s string) (DeepgramTranscriberModel, error) {
	switch s {
	case "nova-3":
		return DeepgramTranscriberModelNova3, nil
	case "nova-3-general":
		return DeepgramTranscriberModelNova3General, nil
	case "nova-3-medical":
		return DeepgramTranscriberModelNova3Medical, nil
	case "nova-2":
		return DeepgramTranscriberModelNova2, nil
	case "nova-2-general":
		return DeepgramTranscriberModelNova2General, nil
	case "nova-2-meeting":
		return DeepgramTranscriberModelNova2Meeting, nil
	case "nova-2-phonecall":
		return DeepgramTranscriberModelNova2Phonecall, nil
	case "nova-2-finance":
		return DeepgramTranscriberModelNova2Finance, nil
	case "nova-2-conversationalai":
		return DeepgramTranscriberModelNova2Conversationalai, nil
	case "nova-2-voicemail":
		return DeepgramTranscriberModelNova2Voicemail, nil
	case "nova-2-video":
		return DeepgramTranscriberModelNova2Video, nil
	case "nova-2-medical":
		return DeepgramTranscriberModelNova2Medical, nil
	case "nova-2-drivethru":
		return DeepgramTranscriberModelNova2Drivethru, nil
	case "nova-2-automotive":
		return DeepgramTranscriberModelNova2Automotive, nil
	case "nova":
		return DeepgramTranscriberModelNova, nil
	case "nova-general":
		return DeepgramTranscriberModelNovaGeneral, nil
	case "nova-phonecall":
		return DeepgramTranscriberModelNovaPhonecall, nil
	case "nova-medical":
		return DeepgramTranscriberModelNovaMedical, nil
	case "enhanced":
		return DeepgramTranscriberModelEnhanced, nil
	case "enhanced-general":
		return DeepgramTranscriberModelEnhancedGeneral, nil
	case "enhanced-meeting":
		return DeepgramTranscriberModelEnhancedMeeting, nil
	case "enhanced-phonecall":
		return DeepgramTranscriberModelEnhancedPhonecall, nil
	case "enhanced-finance":
		return DeepgramTranscriberModelEnhancedFinance, nil
	case "base":
		return DeepgramTranscriberModelBase, nil
	case "base-general":
		return DeepgramTranscriberModelBaseGeneral, nil
	case "base-meeting":
		return DeepgramTranscriberModelBaseMeeting, nil
	case "base-phonecall":
		return DeepgramTranscriberModelBasePhonecall, nil
	case "base-finance":
		return DeepgramTranscriberModelBaseFinance, nil
	case "base-conversationalai":
		return DeepgramTranscriberModelBaseConversationalai, nil
	case "base-voicemail":
		return DeepgramTranscriberModelBaseVoicemail, nil
	case "base-video":
		return DeepgramTranscriberModelBaseVideo, nil
	}
	var t DeepgramTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramTranscriberModel) Ptr() *DeepgramTranscriberModel {
	return &d
}

type DeepgramVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId DeepgramVoiceId `json:"voiceId" url:"voiceId"`
	// This is the model that will be used. Defaults to 'aura-2' when not specified.
	Model *DeepgramVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out
	//
	// This will only be used if you are using your own Deepgram API key.
	//
	// @default false
	MipOptOut *bool `json:"mipOptOut,omitempty" url:"mipOptOut,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepgramVoice) GetCachingEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.CachingEnabled
}

func (d *DeepgramVoice) GetVoiceId() DeepgramVoiceId {
	if d == nil {
		return ""
	}
	return d.VoiceId
}

func (d *DeepgramVoice) GetModel() *DeepgramVoiceModel {
	if d == nil {
		return nil
	}
	return d.Model
}

func (d *DeepgramVoice) GetMipOptOut() *bool {
	if d == nil {
		return nil
	}
	return d.MipOptOut
}

func (d *DeepgramVoice) GetChunkPlan() *ChunkPlan {
	if d == nil {
		return nil
	}
	return d.ChunkPlan
}

func (d *DeepgramVoice) GetFallbackPlan() *FallbackPlan {
	if d == nil {
		return nil
	}
	return d.FallbackPlan
}

func (d *DeepgramVoice) Provider() string {
	return d.provider
}

func (d *DeepgramVoice) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramVoice) UnmarshalJSON(data []byte) error {
	type embed DeepgramVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramVoice(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramVoice) MarshalJSON() ([]byte, error) {
	type embed DeepgramVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramVoice) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// This is the provider-specific ID that will be used.
type DeepgramVoiceId string

const (
	DeepgramVoiceIdAsteria   DeepgramVoiceId = "asteria"
	DeepgramVoiceIdLuna      DeepgramVoiceId = "luna"
	DeepgramVoiceIdStella    DeepgramVoiceId = "stella"
	DeepgramVoiceIdAthena    DeepgramVoiceId = "athena"
	DeepgramVoiceIdHera      DeepgramVoiceId = "hera"
	DeepgramVoiceIdOrion     DeepgramVoiceId = "orion"
	DeepgramVoiceIdArcas     DeepgramVoiceId = "arcas"
	DeepgramVoiceIdPerseus   DeepgramVoiceId = "perseus"
	DeepgramVoiceIdAngus     DeepgramVoiceId = "angus"
	DeepgramVoiceIdOrpheus   DeepgramVoiceId = "orpheus"
	DeepgramVoiceIdHelios    DeepgramVoiceId = "helios"
	DeepgramVoiceIdZeus      DeepgramVoiceId = "zeus"
	DeepgramVoiceIdThalia    DeepgramVoiceId = "thalia"
	DeepgramVoiceIdAndromeda DeepgramVoiceId = "andromeda"
	DeepgramVoiceIdHelena    DeepgramVoiceId = "helena"
	DeepgramVoiceIdApollo    DeepgramVoiceId = "apollo"
	DeepgramVoiceIdAries     DeepgramVoiceId = "aries"
	DeepgramVoiceIdAmalthea  DeepgramVoiceId = "amalthea"
	DeepgramVoiceIdAtlas     DeepgramVoiceId = "atlas"
	DeepgramVoiceIdAurora    DeepgramVoiceId = "aurora"
	DeepgramVoiceIdCallista  DeepgramVoiceId = "callista"
	DeepgramVoiceIdCora      DeepgramVoiceId = "cora"
	DeepgramVoiceIdCordelia  DeepgramVoiceId = "cordelia"
	DeepgramVoiceIdDelia     DeepgramVoiceId = "delia"
	DeepgramVoiceIdDraco     DeepgramVoiceId = "draco"
	DeepgramVoiceIdElectra   DeepgramVoiceId = "electra"
	DeepgramVoiceIdHarmonia  DeepgramVoiceId = "harmonia"
	DeepgramVoiceIdHermes    DeepgramVoiceId = "hermes"
	DeepgramVoiceIdHyperion  DeepgramVoiceId = "hyperion"
	DeepgramVoiceIdIris      DeepgramVoiceId = "iris"
	DeepgramVoiceIdJanus     DeepgramVoiceId = "janus"
	DeepgramVoiceIdJuno      DeepgramVoiceId = "juno"
	DeepgramVoiceIdJupiter   DeepgramVoiceId = "jupiter"
	DeepgramVoiceIdMars      DeepgramVoiceId = "mars"
	DeepgramVoiceIdMinerva   DeepgramVoiceId = "minerva"
	DeepgramVoiceIdNeptune   DeepgramVoiceId = "neptune"
	DeepgramVoiceIdOdysseus  DeepgramVoiceId = "odysseus"
	DeepgramVoiceIdOphelia   DeepgramVoiceId = "ophelia"
	DeepgramVoiceIdPandora   DeepgramVoiceId = "pandora"
	DeepgramVoiceIdPhoebe    DeepgramVoiceId = "phoebe"
	DeepgramVoiceIdPluto     DeepgramVoiceId = "pluto"
	DeepgramVoiceIdSaturn    DeepgramVoiceId = "saturn"
	DeepgramVoiceIdSelene    DeepgramVoiceId = "selene"
	DeepgramVoiceIdTheia     DeepgramVoiceId = "theia"
	DeepgramVoiceIdVesta     DeepgramVoiceId = "vesta"
)

func NewDeepgramVoiceIdFromString(s string) (DeepgramVoiceId, error) {
	switch s {
	case "asteria":
		return DeepgramVoiceIdAsteria, nil
	case "luna":
		return DeepgramVoiceIdLuna, nil
	case "stella":
		return DeepgramVoiceIdStella, nil
	case "athena":
		return DeepgramVoiceIdAthena, nil
	case "hera":
		return DeepgramVoiceIdHera, nil
	case "orion":
		return DeepgramVoiceIdOrion, nil
	case "arcas":
		return DeepgramVoiceIdArcas, nil
	case "perseus":
		return DeepgramVoiceIdPerseus, nil
	case "angus":
		return DeepgramVoiceIdAngus, nil
	case "orpheus":
		return DeepgramVoiceIdOrpheus, nil
	case "helios":
		return DeepgramVoiceIdHelios, nil
	case "zeus":
		return DeepgramVoiceIdZeus, nil
	case "thalia":
		return DeepgramVoiceIdThalia, nil
	case "andromeda":
		return DeepgramVoiceIdAndromeda, nil
	case "helena":
		return DeepgramVoiceIdHelena, nil
	case "apollo":
		return DeepgramVoiceIdApollo, nil
	case "aries":
		return DeepgramVoiceIdAries, nil
	case "amalthea":
		return DeepgramVoiceIdAmalthea, nil
	case "atlas":
		return DeepgramVoiceIdAtlas, nil
	case "aurora":
		return DeepgramVoiceIdAurora, nil
	case "callista":
		return DeepgramVoiceIdCallista, nil
	case "cora":
		return DeepgramVoiceIdCora, nil
	case "cordelia":
		return DeepgramVoiceIdCordelia, nil
	case "delia":
		return DeepgramVoiceIdDelia, nil
	case "draco":
		return DeepgramVoiceIdDraco, nil
	case "electra":
		return DeepgramVoiceIdElectra, nil
	case "harmonia":
		return DeepgramVoiceIdHarmonia, nil
	case "hermes":
		return DeepgramVoiceIdHermes, nil
	case "hyperion":
		return DeepgramVoiceIdHyperion, nil
	case "iris":
		return DeepgramVoiceIdIris, nil
	case "janus":
		return DeepgramVoiceIdJanus, nil
	case "juno":
		return DeepgramVoiceIdJuno, nil
	case "jupiter":
		return DeepgramVoiceIdJupiter, nil
	case "mars":
		return DeepgramVoiceIdMars, nil
	case "minerva":
		return DeepgramVoiceIdMinerva, nil
	case "neptune":
		return DeepgramVoiceIdNeptune, nil
	case "odysseus":
		return DeepgramVoiceIdOdysseus, nil
	case "ophelia":
		return DeepgramVoiceIdOphelia, nil
	case "pandora":
		return DeepgramVoiceIdPandora, nil
	case "phoebe":
		return DeepgramVoiceIdPhoebe, nil
	case "pluto":
		return DeepgramVoiceIdPluto, nil
	case "saturn":
		return DeepgramVoiceIdSaturn, nil
	case "selene":
		return DeepgramVoiceIdSelene, nil
	case "theia":
		return DeepgramVoiceIdTheia, nil
	case "vesta":
		return DeepgramVoiceIdVesta, nil
	}
	var t DeepgramVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramVoiceId) Ptr() *DeepgramVoiceId {
	return &d
}

// This is the model that will be used. Defaults to 'aura-2' when not specified.
type DeepgramVoiceModel string

const (
	DeepgramVoiceModelAura  DeepgramVoiceModel = "aura"
	DeepgramVoiceModelAura2 DeepgramVoiceModel = "aura-2"
)

func NewDeepgramVoiceModelFromString(s string) (DeepgramVoiceModel, error) {
	switch s {
	case "aura":
		return DeepgramVoiceModelAura, nil
	case "aura-2":
		return DeepgramVoiceModelAura2, nil
	}
	var t DeepgramVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramVoiceModel) Ptr() *DeepgramVoiceModel {
	return &d
}

type Edge struct {
	Condition *EdgeCondition `json:"condition,omitempty" url:"condition,omitempty"`
	From      string         `json:"from" url:"from"`
	To        string         `json:"to" url:"to"`
	// This is for metadata you want to store on the edge.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Edge) GetCondition() *EdgeCondition {
	if e == nil {
		return nil
	}
	return e.Condition
}

func (e *Edge) GetFrom() string {
	if e == nil {
		return ""
	}
	return e.From
}

func (e *Edge) GetTo() string {
	if e == nil {
		return ""
	}
	return e.To
}

func (e *Edge) GetMetadata() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *Edge) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Edge) UnmarshalJSON(data []byte) error {
	type unmarshaler Edge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Edge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Edge) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EdgeCondition struct {
	AiEdgeCondition     *AiEdgeCondition
	LogicEdgeCondition  *LogicEdgeCondition
	FailedEdgeCondition *FailedEdgeCondition

	typ string
}

func (e *EdgeCondition) GetAiEdgeCondition() *AiEdgeCondition {
	if e == nil {
		return nil
	}
	return e.AiEdgeCondition
}

func (e *EdgeCondition) GetLogicEdgeCondition() *LogicEdgeCondition {
	if e == nil {
		return nil
	}
	return e.LogicEdgeCondition
}

func (e *EdgeCondition) GetFailedEdgeCondition() *FailedEdgeCondition {
	if e == nil {
		return nil
	}
	return e.FailedEdgeCondition
}

func (e *EdgeCondition) UnmarshalJSON(data []byte) error {
	valueAiEdgeCondition := new(AiEdgeCondition)
	if err := json.Unmarshal(data, &valueAiEdgeCondition); err == nil {
		e.typ = "AiEdgeCondition"
		e.AiEdgeCondition = valueAiEdgeCondition
		return nil
	}
	valueLogicEdgeCondition := new(LogicEdgeCondition)
	if err := json.Unmarshal(data, &valueLogicEdgeCondition); err == nil {
		e.typ = "LogicEdgeCondition"
		e.LogicEdgeCondition = valueLogicEdgeCondition
		return nil
	}
	valueFailedEdgeCondition := new(FailedEdgeCondition)
	if err := json.Unmarshal(data, &valueFailedEdgeCondition); err == nil {
		e.typ = "FailedEdgeCondition"
		e.FailedEdgeCondition = valueFailedEdgeCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EdgeCondition) MarshalJSON() ([]byte, error) {
	if e.typ == "AiEdgeCondition" || e.AiEdgeCondition != nil {
		return json.Marshal(e.AiEdgeCondition)
	}
	if e.typ == "LogicEdgeCondition" || e.LogicEdgeCondition != nil {
		return json.Marshal(e.LogicEdgeCondition)
	}
	if e.typ == "FailedEdgeCondition" || e.FailedEdgeCondition != nil {
		return json.Marshal(e.FailedEdgeCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EdgeConditionVisitor interface {
	VisitAiEdgeCondition(*AiEdgeCondition) error
	VisitLogicEdgeCondition(*LogicEdgeCondition) error
	VisitFailedEdgeCondition(*FailedEdgeCondition) error
}

func (e *EdgeCondition) Accept(visitor EdgeConditionVisitor) error {
	if e.typ == "AiEdgeCondition" || e.AiEdgeCondition != nil {
		return visitor.VisitAiEdgeCondition(e.AiEdgeCondition)
	}
	if e.typ == "LogicEdgeCondition" || e.LogicEdgeCondition != nil {
		return visitor.VisitLogicEdgeCondition(e.LogicEdgeCondition)
	}
	if e.typ == "FailedEdgeCondition" || e.FailedEdgeCondition != nil {
		return visitor.VisitFailedEdgeCondition(e.FailedEdgeCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ElevenLabsCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ElevenLabsCredential) GetApiKey() string {
	if e == nil {
		return ""
	}
	return e.ApiKey
}

func (e *ElevenLabsCredential) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElevenLabsCredential) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *ElevenLabsCredential) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *ElevenLabsCredential) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *ElevenLabsCredential) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ElevenLabsCredential) Provider() string {
	return e.provider
}

func (e *ElevenLabsCredential) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElevenLabsCredential) UnmarshalJSON(data []byte) error {
	type embed ElevenLabsCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ElevenLabsCredential(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "11labs", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElevenLabsCredential) MarshalJSON() ([]byte, error) {
	type embed ElevenLabsCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
		Provider:  "11labs",
	}
	return json.Marshal(marshaler)
}

func (e *ElevenLabsCredential) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElevenLabsTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model    *string                        `json:"model,omitempty" url:"model,omitempty"`
	Language *ElevenLabsTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ElevenLabsTranscriber) GetLanguage() *ElevenLabsTranscriberLanguage {
	if e == nil {
		return nil
	}
	return e.Language
}

func (e *ElevenLabsTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if e == nil {
		return nil
	}
	return e.FallbackPlan
}

func (e *ElevenLabsTranscriber) Provider() string {
	return e.provider
}

func (e *ElevenLabsTranscriber) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElevenLabsTranscriber) UnmarshalJSON(data []byte) error {
	type embed ElevenLabsTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ElevenLabsTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "11labs", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElevenLabsTranscriber) MarshalJSON() ([]byte, error) {
	type embed ElevenLabsTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (e *ElevenLabsTranscriber) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElevenLabsTranscriberLanguage string

const (
	ElevenLabsTranscriberLanguageAa  ElevenLabsTranscriberLanguage = "aa"
	ElevenLabsTranscriberLanguageAb  ElevenLabsTranscriberLanguage = "ab"
	ElevenLabsTranscriberLanguageAe  ElevenLabsTranscriberLanguage = "ae"
	ElevenLabsTranscriberLanguageAf  ElevenLabsTranscriberLanguage = "af"
	ElevenLabsTranscriberLanguageAk  ElevenLabsTranscriberLanguage = "ak"
	ElevenLabsTranscriberLanguageAm  ElevenLabsTranscriberLanguage = "am"
	ElevenLabsTranscriberLanguageAn  ElevenLabsTranscriberLanguage = "an"
	ElevenLabsTranscriberLanguageAr  ElevenLabsTranscriberLanguage = "ar"
	ElevenLabsTranscriberLanguageAs  ElevenLabsTranscriberLanguage = "as"
	ElevenLabsTranscriberLanguageAv  ElevenLabsTranscriberLanguage = "av"
	ElevenLabsTranscriberLanguageAy  ElevenLabsTranscriberLanguage = "ay"
	ElevenLabsTranscriberLanguageAz  ElevenLabsTranscriberLanguage = "az"
	ElevenLabsTranscriberLanguageBa  ElevenLabsTranscriberLanguage = "ba"
	ElevenLabsTranscriberLanguageBe  ElevenLabsTranscriberLanguage = "be"
	ElevenLabsTranscriberLanguageBg  ElevenLabsTranscriberLanguage = "bg"
	ElevenLabsTranscriberLanguageBh  ElevenLabsTranscriberLanguage = "bh"
	ElevenLabsTranscriberLanguageBi  ElevenLabsTranscriberLanguage = "bi"
	ElevenLabsTranscriberLanguageBm  ElevenLabsTranscriberLanguage = "bm"
	ElevenLabsTranscriberLanguageBn  ElevenLabsTranscriberLanguage = "bn"
	ElevenLabsTranscriberLanguageBo  ElevenLabsTranscriberLanguage = "bo"
	ElevenLabsTranscriberLanguageBr  ElevenLabsTranscriberLanguage = "br"
	ElevenLabsTranscriberLanguageBs  ElevenLabsTranscriberLanguage = "bs"
	ElevenLabsTranscriberLanguageCa  ElevenLabsTranscriberLanguage = "ca"
	ElevenLabsTranscriberLanguageCe  ElevenLabsTranscriberLanguage = "ce"
	ElevenLabsTranscriberLanguageCh  ElevenLabsTranscriberLanguage = "ch"
	ElevenLabsTranscriberLanguageCo  ElevenLabsTranscriberLanguage = "co"
	ElevenLabsTranscriberLanguageCr  ElevenLabsTranscriberLanguage = "cr"
	ElevenLabsTranscriberLanguageCs  ElevenLabsTranscriberLanguage = "cs"
	ElevenLabsTranscriberLanguageCu  ElevenLabsTranscriberLanguage = "cu"
	ElevenLabsTranscriberLanguageCv  ElevenLabsTranscriberLanguage = "cv"
	ElevenLabsTranscriberLanguageCy  ElevenLabsTranscriberLanguage = "cy"
	ElevenLabsTranscriberLanguageDa  ElevenLabsTranscriberLanguage = "da"
	ElevenLabsTranscriberLanguageDe  ElevenLabsTranscriberLanguage = "de"
	ElevenLabsTranscriberLanguageDv  ElevenLabsTranscriberLanguage = "dv"
	ElevenLabsTranscriberLanguageDz  ElevenLabsTranscriberLanguage = "dz"
	ElevenLabsTranscriberLanguageEe  ElevenLabsTranscriberLanguage = "ee"
	ElevenLabsTranscriberLanguageEl  ElevenLabsTranscriberLanguage = "el"
	ElevenLabsTranscriberLanguageEn  ElevenLabsTranscriberLanguage = "en"
	ElevenLabsTranscriberLanguageEo  ElevenLabsTranscriberLanguage = "eo"
	ElevenLabsTranscriberLanguageEs  ElevenLabsTranscriberLanguage = "es"
	ElevenLabsTranscriberLanguageEt  ElevenLabsTranscriberLanguage = "et"
	ElevenLabsTranscriberLanguageEu  ElevenLabsTranscriberLanguage = "eu"
	ElevenLabsTranscriberLanguageFa  ElevenLabsTranscriberLanguage = "fa"
	ElevenLabsTranscriberLanguageFf  ElevenLabsTranscriberLanguage = "ff"
	ElevenLabsTranscriberLanguageFi  ElevenLabsTranscriberLanguage = "fi"
	ElevenLabsTranscriberLanguageFj  ElevenLabsTranscriberLanguage = "fj"
	ElevenLabsTranscriberLanguageFo  ElevenLabsTranscriberLanguage = "fo"
	ElevenLabsTranscriberLanguageFr  ElevenLabsTranscriberLanguage = "fr"
	ElevenLabsTranscriberLanguageFy  ElevenLabsTranscriberLanguage = "fy"
	ElevenLabsTranscriberLanguageGa  ElevenLabsTranscriberLanguage = "ga"
	ElevenLabsTranscriberLanguageGd  ElevenLabsTranscriberLanguage = "gd"
	ElevenLabsTranscriberLanguageGl  ElevenLabsTranscriberLanguage = "gl"
	ElevenLabsTranscriberLanguageGn  ElevenLabsTranscriberLanguage = "gn"
	ElevenLabsTranscriberLanguageGu  ElevenLabsTranscriberLanguage = "gu"
	ElevenLabsTranscriberLanguageGv  ElevenLabsTranscriberLanguage = "gv"
	ElevenLabsTranscriberLanguageHa  ElevenLabsTranscriberLanguage = "ha"
	ElevenLabsTranscriberLanguageHe  ElevenLabsTranscriberLanguage = "he"
	ElevenLabsTranscriberLanguageHi  ElevenLabsTranscriberLanguage = "hi"
	ElevenLabsTranscriberLanguageHo  ElevenLabsTranscriberLanguage = "ho"
	ElevenLabsTranscriberLanguageHr  ElevenLabsTranscriberLanguage = "hr"
	ElevenLabsTranscriberLanguageHt  ElevenLabsTranscriberLanguage = "ht"
	ElevenLabsTranscriberLanguageHu  ElevenLabsTranscriberLanguage = "hu"
	ElevenLabsTranscriberLanguageHy  ElevenLabsTranscriberLanguage = "hy"
	ElevenLabsTranscriberLanguageHz  ElevenLabsTranscriberLanguage = "hz"
	ElevenLabsTranscriberLanguageIa  ElevenLabsTranscriberLanguage = "ia"
	ElevenLabsTranscriberLanguageId  ElevenLabsTranscriberLanguage = "id"
	ElevenLabsTranscriberLanguageIe  ElevenLabsTranscriberLanguage = "ie"
	ElevenLabsTranscriberLanguageIg  ElevenLabsTranscriberLanguage = "ig"
	ElevenLabsTranscriberLanguageIi  ElevenLabsTranscriberLanguage = "ii"
	ElevenLabsTranscriberLanguageIk  ElevenLabsTranscriberLanguage = "ik"
	ElevenLabsTranscriberLanguageIo  ElevenLabsTranscriberLanguage = "io"
	ElevenLabsTranscriberLanguageIs  ElevenLabsTranscriberLanguage = "is"
	ElevenLabsTranscriberLanguageIt  ElevenLabsTranscriberLanguage = "it"
	ElevenLabsTranscriberLanguageIu  ElevenLabsTranscriberLanguage = "iu"
	ElevenLabsTranscriberLanguageJa  ElevenLabsTranscriberLanguage = "ja"
	ElevenLabsTranscriberLanguageJv  ElevenLabsTranscriberLanguage = "jv"
	ElevenLabsTranscriberLanguageKa  ElevenLabsTranscriberLanguage = "ka"
	ElevenLabsTranscriberLanguageKg  ElevenLabsTranscriberLanguage = "kg"
	ElevenLabsTranscriberLanguageKi  ElevenLabsTranscriberLanguage = "ki"
	ElevenLabsTranscriberLanguageKj  ElevenLabsTranscriberLanguage = "kj"
	ElevenLabsTranscriberLanguageKk  ElevenLabsTranscriberLanguage = "kk"
	ElevenLabsTranscriberLanguageKl  ElevenLabsTranscriberLanguage = "kl"
	ElevenLabsTranscriberLanguageKm  ElevenLabsTranscriberLanguage = "km"
	ElevenLabsTranscriberLanguageKn  ElevenLabsTranscriberLanguage = "kn"
	ElevenLabsTranscriberLanguageKo  ElevenLabsTranscriberLanguage = "ko"
	ElevenLabsTranscriberLanguageKr  ElevenLabsTranscriberLanguage = "kr"
	ElevenLabsTranscriberLanguageKs  ElevenLabsTranscriberLanguage = "ks"
	ElevenLabsTranscriberLanguageKu  ElevenLabsTranscriberLanguage = "ku"
	ElevenLabsTranscriberLanguageKv  ElevenLabsTranscriberLanguage = "kv"
	ElevenLabsTranscriberLanguageKw  ElevenLabsTranscriberLanguage = "kw"
	ElevenLabsTranscriberLanguageKy  ElevenLabsTranscriberLanguage = "ky"
	ElevenLabsTranscriberLanguageLa  ElevenLabsTranscriberLanguage = "la"
	ElevenLabsTranscriberLanguageLb  ElevenLabsTranscriberLanguage = "lb"
	ElevenLabsTranscriberLanguageLg  ElevenLabsTranscriberLanguage = "lg"
	ElevenLabsTranscriberLanguageLi  ElevenLabsTranscriberLanguage = "li"
	ElevenLabsTranscriberLanguageLn  ElevenLabsTranscriberLanguage = "ln"
	ElevenLabsTranscriberLanguageLo  ElevenLabsTranscriberLanguage = "lo"
	ElevenLabsTranscriberLanguageLt  ElevenLabsTranscriberLanguage = "lt"
	ElevenLabsTranscriberLanguageLu  ElevenLabsTranscriberLanguage = "lu"
	ElevenLabsTranscriberLanguageLv  ElevenLabsTranscriberLanguage = "lv"
	ElevenLabsTranscriberLanguageMg  ElevenLabsTranscriberLanguage = "mg"
	ElevenLabsTranscriberLanguageMh  ElevenLabsTranscriberLanguage = "mh"
	ElevenLabsTranscriberLanguageMi  ElevenLabsTranscriberLanguage = "mi"
	ElevenLabsTranscriberLanguageMk  ElevenLabsTranscriberLanguage = "mk"
	ElevenLabsTranscriberLanguageMl  ElevenLabsTranscriberLanguage = "ml"
	ElevenLabsTranscriberLanguageMn  ElevenLabsTranscriberLanguage = "mn"
	ElevenLabsTranscriberLanguageMr  ElevenLabsTranscriberLanguage = "mr"
	ElevenLabsTranscriberLanguageMs  ElevenLabsTranscriberLanguage = "ms"
	ElevenLabsTranscriberLanguageMt  ElevenLabsTranscriberLanguage = "mt"
	ElevenLabsTranscriberLanguageMy  ElevenLabsTranscriberLanguage = "my"
	ElevenLabsTranscriberLanguageNa  ElevenLabsTranscriberLanguage = "na"
	ElevenLabsTranscriberLanguageNb  ElevenLabsTranscriberLanguage = "nb"
	ElevenLabsTranscriberLanguageNd  ElevenLabsTranscriberLanguage = "nd"
	ElevenLabsTranscriberLanguageNe  ElevenLabsTranscriberLanguage = "ne"
	ElevenLabsTranscriberLanguageNg  ElevenLabsTranscriberLanguage = "ng"
	ElevenLabsTranscriberLanguageNl  ElevenLabsTranscriberLanguage = "nl"
	ElevenLabsTranscriberLanguageNn  ElevenLabsTranscriberLanguage = "nn"
	ElevenLabsTranscriberLanguageNo  ElevenLabsTranscriberLanguage = "no"
	ElevenLabsTranscriberLanguageNr  ElevenLabsTranscriberLanguage = "nr"
	ElevenLabsTranscriberLanguageNv  ElevenLabsTranscriberLanguage = "nv"
	ElevenLabsTranscriberLanguageNy  ElevenLabsTranscriberLanguage = "ny"
	ElevenLabsTranscriberLanguageOc  ElevenLabsTranscriberLanguage = "oc"
	ElevenLabsTranscriberLanguageOj  ElevenLabsTranscriberLanguage = "oj"
	ElevenLabsTranscriberLanguageOm  ElevenLabsTranscriberLanguage = "om"
	ElevenLabsTranscriberLanguageOr  ElevenLabsTranscriberLanguage = "or"
	ElevenLabsTranscriberLanguageOs  ElevenLabsTranscriberLanguage = "os"
	ElevenLabsTranscriberLanguagePa  ElevenLabsTranscriberLanguage = "pa"
	ElevenLabsTranscriberLanguagePi  ElevenLabsTranscriberLanguage = "pi"
	ElevenLabsTranscriberLanguagePl  ElevenLabsTranscriberLanguage = "pl"
	ElevenLabsTranscriberLanguagePs  ElevenLabsTranscriberLanguage = "ps"
	ElevenLabsTranscriberLanguagePt  ElevenLabsTranscriberLanguage = "pt"
	ElevenLabsTranscriberLanguageQu  ElevenLabsTranscriberLanguage = "qu"
	ElevenLabsTranscriberLanguageRm  ElevenLabsTranscriberLanguage = "rm"
	ElevenLabsTranscriberLanguageRn  ElevenLabsTranscriberLanguage = "rn"
	ElevenLabsTranscriberLanguageRo  ElevenLabsTranscriberLanguage = "ro"
	ElevenLabsTranscriberLanguageRu  ElevenLabsTranscriberLanguage = "ru"
	ElevenLabsTranscriberLanguageRw  ElevenLabsTranscriberLanguage = "rw"
	ElevenLabsTranscriberLanguageSa  ElevenLabsTranscriberLanguage = "sa"
	ElevenLabsTranscriberLanguageSc  ElevenLabsTranscriberLanguage = "sc"
	ElevenLabsTranscriberLanguageSd  ElevenLabsTranscriberLanguage = "sd"
	ElevenLabsTranscriberLanguageSe  ElevenLabsTranscriberLanguage = "se"
	ElevenLabsTranscriberLanguageSg  ElevenLabsTranscriberLanguage = "sg"
	ElevenLabsTranscriberLanguageSi  ElevenLabsTranscriberLanguage = "si"
	ElevenLabsTranscriberLanguageSk  ElevenLabsTranscriberLanguage = "sk"
	ElevenLabsTranscriberLanguageSl  ElevenLabsTranscriberLanguage = "sl"
	ElevenLabsTranscriberLanguageSm  ElevenLabsTranscriberLanguage = "sm"
	ElevenLabsTranscriberLanguageSn  ElevenLabsTranscriberLanguage = "sn"
	ElevenLabsTranscriberLanguageSo  ElevenLabsTranscriberLanguage = "so"
	ElevenLabsTranscriberLanguageSq  ElevenLabsTranscriberLanguage = "sq"
	ElevenLabsTranscriberLanguageSr  ElevenLabsTranscriberLanguage = "sr"
	ElevenLabsTranscriberLanguageSs  ElevenLabsTranscriberLanguage = "ss"
	ElevenLabsTranscriberLanguageSt  ElevenLabsTranscriberLanguage = "st"
	ElevenLabsTranscriberLanguageSu  ElevenLabsTranscriberLanguage = "su"
	ElevenLabsTranscriberLanguageSv  ElevenLabsTranscriberLanguage = "sv"
	ElevenLabsTranscriberLanguageSw  ElevenLabsTranscriberLanguage = "sw"
	ElevenLabsTranscriberLanguageTa  ElevenLabsTranscriberLanguage = "ta"
	ElevenLabsTranscriberLanguageTe  ElevenLabsTranscriberLanguage = "te"
	ElevenLabsTranscriberLanguageTg  ElevenLabsTranscriberLanguage = "tg"
	ElevenLabsTranscriberLanguageTh  ElevenLabsTranscriberLanguage = "th"
	ElevenLabsTranscriberLanguageTi  ElevenLabsTranscriberLanguage = "ti"
	ElevenLabsTranscriberLanguageTk  ElevenLabsTranscriberLanguage = "tk"
	ElevenLabsTranscriberLanguageTl  ElevenLabsTranscriberLanguage = "tl"
	ElevenLabsTranscriberLanguageTn  ElevenLabsTranscriberLanguage = "tn"
	ElevenLabsTranscriberLanguageTo  ElevenLabsTranscriberLanguage = "to"
	ElevenLabsTranscriberLanguageTr  ElevenLabsTranscriberLanguage = "tr"
	ElevenLabsTranscriberLanguageTs  ElevenLabsTranscriberLanguage = "ts"
	ElevenLabsTranscriberLanguageTt  ElevenLabsTranscriberLanguage = "tt"
	ElevenLabsTranscriberLanguageTw  ElevenLabsTranscriberLanguage = "tw"
	ElevenLabsTranscriberLanguageTy  ElevenLabsTranscriberLanguage = "ty"
	ElevenLabsTranscriberLanguageUg  ElevenLabsTranscriberLanguage = "ug"
	ElevenLabsTranscriberLanguageUk  ElevenLabsTranscriberLanguage = "uk"
	ElevenLabsTranscriberLanguageUr  ElevenLabsTranscriberLanguage = "ur"
	ElevenLabsTranscriberLanguageUz  ElevenLabsTranscriberLanguage = "uz"
	ElevenLabsTranscriberLanguageVe  ElevenLabsTranscriberLanguage = "ve"
	ElevenLabsTranscriberLanguageVi  ElevenLabsTranscriberLanguage = "vi"
	ElevenLabsTranscriberLanguageVo  ElevenLabsTranscriberLanguage = "vo"
	ElevenLabsTranscriberLanguageWa  ElevenLabsTranscriberLanguage = "wa"
	ElevenLabsTranscriberLanguageWo  ElevenLabsTranscriberLanguage = "wo"
	ElevenLabsTranscriberLanguageXh  ElevenLabsTranscriberLanguage = "xh"
	ElevenLabsTranscriberLanguageYi  ElevenLabsTranscriberLanguage = "yi"
	ElevenLabsTranscriberLanguageYue ElevenLabsTranscriberLanguage = "yue"
	ElevenLabsTranscriberLanguageYo  ElevenLabsTranscriberLanguage = "yo"
	ElevenLabsTranscriberLanguageZa  ElevenLabsTranscriberLanguage = "za"
	ElevenLabsTranscriberLanguageZh  ElevenLabsTranscriberLanguage = "zh"
	ElevenLabsTranscriberLanguageZu  ElevenLabsTranscriberLanguage = "zu"
)

func NewElevenLabsTranscriberLanguageFromString(s string) (ElevenLabsTranscriberLanguage, error) {
	switch s {
	case "aa":
		return ElevenLabsTranscriberLanguageAa, nil
	case "ab":
		return ElevenLabsTranscriberLanguageAb, nil
	case "ae":
		return ElevenLabsTranscriberLanguageAe, nil
	case "af":
		return ElevenLabsTranscriberLanguageAf, nil
	case "ak":
		return ElevenLabsTranscriberLanguageAk, nil
	case "am":
		return ElevenLabsTranscriberLanguageAm, nil
	case "an":
		return ElevenLabsTranscriberLanguageAn, nil
	case "ar":
		return ElevenLabsTranscriberLanguageAr, nil
	case "as":
		return ElevenLabsTranscriberLanguageAs, nil
	case "av":
		return ElevenLabsTranscriberLanguageAv, nil
	case "ay":
		return ElevenLabsTranscriberLanguageAy, nil
	case "az":
		return ElevenLabsTranscriberLanguageAz, nil
	case "ba":
		return ElevenLabsTranscriberLanguageBa, nil
	case "be":
		return ElevenLabsTranscriberLanguageBe, nil
	case "bg":
		return ElevenLabsTranscriberLanguageBg, nil
	case "bh":
		return ElevenLabsTranscriberLanguageBh, nil
	case "bi":
		return ElevenLabsTranscriberLanguageBi, nil
	case "bm":
		return ElevenLabsTranscriberLanguageBm, nil
	case "bn":
		return ElevenLabsTranscriberLanguageBn, nil
	case "bo":
		return ElevenLabsTranscriberLanguageBo, nil
	case "br":
		return ElevenLabsTranscriberLanguageBr, nil
	case "bs":
		return ElevenLabsTranscriberLanguageBs, nil
	case "ca":
		return ElevenLabsTranscriberLanguageCa, nil
	case "ce":
		return ElevenLabsTranscriberLanguageCe, nil
	case "ch":
		return ElevenLabsTranscriberLanguageCh, nil
	case "co":
		return ElevenLabsTranscriberLanguageCo, nil
	case "cr":
		return ElevenLabsTranscriberLanguageCr, nil
	case "cs":
		return ElevenLabsTranscriberLanguageCs, nil
	case "cu":
		return ElevenLabsTranscriberLanguageCu, nil
	case "cv":
		return ElevenLabsTranscriberLanguageCv, nil
	case "cy":
		return ElevenLabsTranscriberLanguageCy, nil
	case "da":
		return ElevenLabsTranscriberLanguageDa, nil
	case "de":
		return ElevenLabsTranscriberLanguageDe, nil
	case "dv":
		return ElevenLabsTranscriberLanguageDv, nil
	case "dz":
		return ElevenLabsTranscriberLanguageDz, nil
	case "ee":
		return ElevenLabsTranscriberLanguageEe, nil
	case "el":
		return ElevenLabsTranscriberLanguageEl, nil
	case "en":
		return ElevenLabsTranscriberLanguageEn, nil
	case "eo":
		return ElevenLabsTranscriberLanguageEo, nil
	case "es":
		return ElevenLabsTranscriberLanguageEs, nil
	case "et":
		return ElevenLabsTranscriberLanguageEt, nil
	case "eu":
		return ElevenLabsTranscriberLanguageEu, nil
	case "fa":
		return ElevenLabsTranscriberLanguageFa, nil
	case "ff":
		return ElevenLabsTranscriberLanguageFf, nil
	case "fi":
		return ElevenLabsTranscriberLanguageFi, nil
	case "fj":
		return ElevenLabsTranscriberLanguageFj, nil
	case "fo":
		return ElevenLabsTranscriberLanguageFo, nil
	case "fr":
		return ElevenLabsTranscriberLanguageFr, nil
	case "fy":
		return ElevenLabsTranscriberLanguageFy, nil
	case "ga":
		return ElevenLabsTranscriberLanguageGa, nil
	case "gd":
		return ElevenLabsTranscriberLanguageGd, nil
	case "gl":
		return ElevenLabsTranscriberLanguageGl, nil
	case "gn":
		return ElevenLabsTranscriberLanguageGn, nil
	case "gu":
		return ElevenLabsTranscriberLanguageGu, nil
	case "gv":
		return ElevenLabsTranscriberLanguageGv, nil
	case "ha":
		return ElevenLabsTranscriberLanguageHa, nil
	case "he":
		return ElevenLabsTranscriberLanguageHe, nil
	case "hi":
		return ElevenLabsTranscriberLanguageHi, nil
	case "ho":
		return ElevenLabsTranscriberLanguageHo, nil
	case "hr":
		return ElevenLabsTranscriberLanguageHr, nil
	case "ht":
		return ElevenLabsTranscriberLanguageHt, nil
	case "hu":
		return ElevenLabsTranscriberLanguageHu, nil
	case "hy":
		return ElevenLabsTranscriberLanguageHy, nil
	case "hz":
		return ElevenLabsTranscriberLanguageHz, nil
	case "ia":
		return ElevenLabsTranscriberLanguageIa, nil
	case "id":
		return ElevenLabsTranscriberLanguageId, nil
	case "ie":
		return ElevenLabsTranscriberLanguageIe, nil
	case "ig":
		return ElevenLabsTranscriberLanguageIg, nil
	case "ii":
		return ElevenLabsTranscriberLanguageIi, nil
	case "ik":
		return ElevenLabsTranscriberLanguageIk, nil
	case "io":
		return ElevenLabsTranscriberLanguageIo, nil
	case "is":
		return ElevenLabsTranscriberLanguageIs, nil
	case "it":
		return ElevenLabsTranscriberLanguageIt, nil
	case "iu":
		return ElevenLabsTranscriberLanguageIu, nil
	case "ja":
		return ElevenLabsTranscriberLanguageJa, nil
	case "jv":
		return ElevenLabsTranscriberLanguageJv, nil
	case "ka":
		return ElevenLabsTranscriberLanguageKa, nil
	case "kg":
		return ElevenLabsTranscriberLanguageKg, nil
	case "ki":
		return ElevenLabsTranscriberLanguageKi, nil
	case "kj":
		return ElevenLabsTranscriberLanguageKj, nil
	case "kk":
		return ElevenLabsTranscriberLanguageKk, nil
	case "kl":
		return ElevenLabsTranscriberLanguageKl, nil
	case "km":
		return ElevenLabsTranscriberLanguageKm, nil
	case "kn":
		return ElevenLabsTranscriberLanguageKn, nil
	case "ko":
		return ElevenLabsTranscriberLanguageKo, nil
	case "kr":
		return ElevenLabsTranscriberLanguageKr, nil
	case "ks":
		return ElevenLabsTranscriberLanguageKs, nil
	case "ku":
		return ElevenLabsTranscriberLanguageKu, nil
	case "kv":
		return ElevenLabsTranscriberLanguageKv, nil
	case "kw":
		return ElevenLabsTranscriberLanguageKw, nil
	case "ky":
		return ElevenLabsTranscriberLanguageKy, nil
	case "la":
		return ElevenLabsTranscriberLanguageLa, nil
	case "lb":
		return ElevenLabsTranscriberLanguageLb, nil
	case "lg":
		return ElevenLabsTranscriberLanguageLg, nil
	case "li":
		return ElevenLabsTranscriberLanguageLi, nil
	case "ln":
		return ElevenLabsTranscriberLanguageLn, nil
	case "lo":
		return ElevenLabsTranscriberLanguageLo, nil
	case "lt":
		return ElevenLabsTranscriberLanguageLt, nil
	case "lu":
		return ElevenLabsTranscriberLanguageLu, nil
	case "lv":
		return ElevenLabsTranscriberLanguageLv, nil
	case "mg":
		return ElevenLabsTranscriberLanguageMg, nil
	case "mh":
		return ElevenLabsTranscriberLanguageMh, nil
	case "mi":
		return ElevenLabsTranscriberLanguageMi, nil
	case "mk":
		return ElevenLabsTranscriberLanguageMk, nil
	case "ml":
		return ElevenLabsTranscriberLanguageMl, nil
	case "mn":
		return ElevenLabsTranscriberLanguageMn, nil
	case "mr":
		return ElevenLabsTranscriberLanguageMr, nil
	case "ms":
		return ElevenLabsTranscriberLanguageMs, nil
	case "mt":
		return ElevenLabsTranscriberLanguageMt, nil
	case "my":
		return ElevenLabsTranscriberLanguageMy, nil
	case "na":
		return ElevenLabsTranscriberLanguageNa, nil
	case "nb":
		return ElevenLabsTranscriberLanguageNb, nil
	case "nd":
		return ElevenLabsTranscriberLanguageNd, nil
	case "ne":
		return ElevenLabsTranscriberLanguageNe, nil
	case "ng":
		return ElevenLabsTranscriberLanguageNg, nil
	case "nl":
		return ElevenLabsTranscriberLanguageNl, nil
	case "nn":
		return ElevenLabsTranscriberLanguageNn, nil
	case "no":
		return ElevenLabsTranscriberLanguageNo, nil
	case "nr":
		return ElevenLabsTranscriberLanguageNr, nil
	case "nv":
		return ElevenLabsTranscriberLanguageNv, nil
	case "ny":
		return ElevenLabsTranscriberLanguageNy, nil
	case "oc":
		return ElevenLabsTranscriberLanguageOc, nil
	case "oj":
		return ElevenLabsTranscriberLanguageOj, nil
	case "om":
		return ElevenLabsTranscriberLanguageOm, nil
	case "or":
		return ElevenLabsTranscriberLanguageOr, nil
	case "os":
		return ElevenLabsTranscriberLanguageOs, nil
	case "pa":
		return ElevenLabsTranscriberLanguagePa, nil
	case "pi":
		return ElevenLabsTranscriberLanguagePi, nil
	case "pl":
		return ElevenLabsTranscriberLanguagePl, nil
	case "ps":
		return ElevenLabsTranscriberLanguagePs, nil
	case "pt":
		return ElevenLabsTranscriberLanguagePt, nil
	case "qu":
		return ElevenLabsTranscriberLanguageQu, nil
	case "rm":
		return ElevenLabsTranscriberLanguageRm, nil
	case "rn":
		return ElevenLabsTranscriberLanguageRn, nil
	case "ro":
		return ElevenLabsTranscriberLanguageRo, nil
	case "ru":
		return ElevenLabsTranscriberLanguageRu, nil
	case "rw":
		return ElevenLabsTranscriberLanguageRw, nil
	case "sa":
		return ElevenLabsTranscriberLanguageSa, nil
	case "sc":
		return ElevenLabsTranscriberLanguageSc, nil
	case "sd":
		return ElevenLabsTranscriberLanguageSd, nil
	case "se":
		return ElevenLabsTranscriberLanguageSe, nil
	case "sg":
		return ElevenLabsTranscriberLanguageSg, nil
	case "si":
		return ElevenLabsTranscriberLanguageSi, nil
	case "sk":
		return ElevenLabsTranscriberLanguageSk, nil
	case "sl":
		return ElevenLabsTranscriberLanguageSl, nil
	case "sm":
		return ElevenLabsTranscriberLanguageSm, nil
	case "sn":
		return ElevenLabsTranscriberLanguageSn, nil
	case "so":
		return ElevenLabsTranscriberLanguageSo, nil
	case "sq":
		return ElevenLabsTranscriberLanguageSq, nil
	case "sr":
		return ElevenLabsTranscriberLanguageSr, nil
	case "ss":
		return ElevenLabsTranscriberLanguageSs, nil
	case "st":
		return ElevenLabsTranscriberLanguageSt, nil
	case "su":
		return ElevenLabsTranscriberLanguageSu, nil
	case "sv":
		return ElevenLabsTranscriberLanguageSv, nil
	case "sw":
		return ElevenLabsTranscriberLanguageSw, nil
	case "ta":
		return ElevenLabsTranscriberLanguageTa, nil
	case "te":
		return ElevenLabsTranscriberLanguageTe, nil
	case "tg":
		return ElevenLabsTranscriberLanguageTg, nil
	case "th":
		return ElevenLabsTranscriberLanguageTh, nil
	case "ti":
		return ElevenLabsTranscriberLanguageTi, nil
	case "tk":
		return ElevenLabsTranscriberLanguageTk, nil
	case "tl":
		return ElevenLabsTranscriberLanguageTl, nil
	case "tn":
		return ElevenLabsTranscriberLanguageTn, nil
	case "to":
		return ElevenLabsTranscriberLanguageTo, nil
	case "tr":
		return ElevenLabsTranscriberLanguageTr, nil
	case "ts":
		return ElevenLabsTranscriberLanguageTs, nil
	case "tt":
		return ElevenLabsTranscriberLanguageTt, nil
	case "tw":
		return ElevenLabsTranscriberLanguageTw, nil
	case "ty":
		return ElevenLabsTranscriberLanguageTy, nil
	case "ug":
		return ElevenLabsTranscriberLanguageUg, nil
	case "uk":
		return ElevenLabsTranscriberLanguageUk, nil
	case "ur":
		return ElevenLabsTranscriberLanguageUr, nil
	case "uz":
		return ElevenLabsTranscriberLanguageUz, nil
	case "ve":
		return ElevenLabsTranscriberLanguageVe, nil
	case "vi":
		return ElevenLabsTranscriberLanguageVi, nil
	case "vo":
		return ElevenLabsTranscriberLanguageVo, nil
	case "wa":
		return ElevenLabsTranscriberLanguageWa, nil
	case "wo":
		return ElevenLabsTranscriberLanguageWo, nil
	case "xh":
		return ElevenLabsTranscriberLanguageXh, nil
	case "yi":
		return ElevenLabsTranscriberLanguageYi, nil
	case "yue":
		return ElevenLabsTranscriberLanguageYue, nil
	case "yo":
		return ElevenLabsTranscriberLanguageYo, nil
	case "za":
		return ElevenLabsTranscriberLanguageZa, nil
	case "zh":
		return ElevenLabsTranscriberLanguageZh, nil
	case "zu":
		return ElevenLabsTranscriberLanguageZu, nil
	}
	var t ElevenLabsTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ElevenLabsTranscriberLanguage) Ptr() *ElevenLabsTranscriberLanguage {
	return &e
}

type ElevenLabsVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
	VoiceId *ElevenLabsVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Defines the stability for voice settings.
	Stability *float64 `json:"stability,omitempty" url:"stability,omitempty"`
	// Defines the similarity boost for voice settings.
	SimilarityBoost *float64 `json:"similarityBoost,omitempty" url:"similarityBoost,omitempty"`
	// Defines the style for voice settings.
	Style *float64 `json:"style,omitempty" url:"style,omitempty"`
	// Defines the use speaker boost for voice settings.
	UseSpeakerBoost *bool `json:"useSpeakerBoost,omitempty" url:"useSpeakerBoost,omitempty"`
	// Defines the speed for voice settings.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// Defines the optimize streaming latency for voice settings. Defaults to 3.
	OptimizeStreamingLatency *float64 `json:"optimizeStreamingLatency,omitempty" url:"optimizeStreamingLatency,omitempty"`
	// This enables the use of https://elevenlabs.io/docs/speech-synthesis/prompting#pronunciation. Defaults to false to save latency.
	//
	// @default false
	EnableSsmlParsing *bool `json:"enableSsmlParsing,omitempty" url:"enableSsmlParsing,omitempty"`
	// Defines the auto mode for voice settings. Defaults to false.
	AutoMode *bool `json:"autoMode,omitempty" url:"autoMode,omitempty"`
	// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
	Model *ElevenLabsVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the language (ISO 639-1) that is enforced for the model. Currently only Turbo v2.5 supports language enforcement. For other models, an error will be returned if language code is provided.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ElevenLabsVoice) GetCachingEnabled() *bool {
	if e == nil {
		return nil
	}
	return e.CachingEnabled
}

func (e *ElevenLabsVoice) GetVoiceId() *ElevenLabsVoiceId {
	if e == nil {
		return nil
	}
	return e.VoiceId
}

func (e *ElevenLabsVoice) GetStability() *float64 {
	if e == nil {
		return nil
	}
	return e.Stability
}

func (e *ElevenLabsVoice) GetSimilarityBoost() *float64 {
	if e == nil {
		return nil
	}
	return e.SimilarityBoost
}

func (e *ElevenLabsVoice) GetStyle() *float64 {
	if e == nil {
		return nil
	}
	return e.Style
}

func (e *ElevenLabsVoice) GetUseSpeakerBoost() *bool {
	if e == nil {
		return nil
	}
	return e.UseSpeakerBoost
}

func (e *ElevenLabsVoice) GetSpeed() *float64 {
	if e == nil {
		return nil
	}
	return e.Speed
}

func (e *ElevenLabsVoice) GetOptimizeStreamingLatency() *float64 {
	if e == nil {
		return nil
	}
	return e.OptimizeStreamingLatency
}

func (e *ElevenLabsVoice) GetEnableSsmlParsing() *bool {
	if e == nil {
		return nil
	}
	return e.EnableSsmlParsing
}

func (e *ElevenLabsVoice) GetAutoMode() *bool {
	if e == nil {
		return nil
	}
	return e.AutoMode
}

func (e *ElevenLabsVoice) GetModel() *ElevenLabsVoiceModel {
	if e == nil {
		return nil
	}
	return e.Model
}

func (e *ElevenLabsVoice) GetChunkPlan() *ChunkPlan {
	if e == nil {
		return nil
	}
	return e.ChunkPlan
}

func (e *ElevenLabsVoice) GetLanguage() *string {
	if e == nil {
		return nil
	}
	return e.Language
}

func (e *ElevenLabsVoice) GetFallbackPlan() *FallbackPlan {
	if e == nil {
		return nil
	}
	return e.FallbackPlan
}

func (e *ElevenLabsVoice) Provider() string {
	return e.provider
}

func (e *ElevenLabsVoice) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElevenLabsVoice) UnmarshalJSON(data []byte) error {
	type embed ElevenLabsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ElevenLabsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "11labs", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElevenLabsVoice) MarshalJSON() ([]byte, error) {
	type embed ElevenLabsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (e *ElevenLabsVoice) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
type ElevenLabsVoiceId struct {
	ElevenLabsVoiceIdEnum ElevenLabsVoiceIdEnum
	String                string

	typ string
}

func (e *ElevenLabsVoiceId) GetElevenLabsVoiceIdEnum() ElevenLabsVoiceIdEnum {
	if e == nil {
		return ""
	}
	return e.ElevenLabsVoiceIdEnum
}

func (e *ElevenLabsVoiceId) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *ElevenLabsVoiceId) UnmarshalJSON(data []byte) error {
	var valueElevenLabsVoiceIdEnum ElevenLabsVoiceIdEnum
	if err := json.Unmarshal(data, &valueElevenLabsVoiceIdEnum); err == nil {
		e.typ = "ElevenLabsVoiceIdEnum"
		e.ElevenLabsVoiceIdEnum = valueElevenLabsVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ElevenLabsVoiceId) MarshalJSON() ([]byte, error) {
	if e.typ == "ElevenLabsVoiceIdEnum" || e.ElevenLabsVoiceIdEnum != "" {
		return json.Marshal(e.ElevenLabsVoiceIdEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ElevenLabsVoiceIdVisitor interface {
	VisitElevenLabsVoiceIdEnum(ElevenLabsVoiceIdEnum) error
	VisitString(string) error
}

func (e *ElevenLabsVoiceId) Accept(visitor ElevenLabsVoiceIdVisitor) error {
	if e.typ == "ElevenLabsVoiceIdEnum" || e.ElevenLabsVoiceIdEnum != "" {
		return visitor.VisitElevenLabsVoiceIdEnum(e.ElevenLabsVoiceIdEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ElevenLabsVoiceIdEnum string

const (
	ElevenLabsVoiceIdEnumBurt    ElevenLabsVoiceIdEnum = "burt"
	ElevenLabsVoiceIdEnumMarissa ElevenLabsVoiceIdEnum = "marissa"
	ElevenLabsVoiceIdEnumAndrea  ElevenLabsVoiceIdEnum = "andrea"
	ElevenLabsVoiceIdEnumSarah   ElevenLabsVoiceIdEnum = "sarah"
	ElevenLabsVoiceIdEnumPhillip ElevenLabsVoiceIdEnum = "phillip"
	ElevenLabsVoiceIdEnumSteve   ElevenLabsVoiceIdEnum = "steve"
	ElevenLabsVoiceIdEnumJoseph  ElevenLabsVoiceIdEnum = "joseph"
	ElevenLabsVoiceIdEnumMyra    ElevenLabsVoiceIdEnum = "myra"
	ElevenLabsVoiceIdEnumPaula   ElevenLabsVoiceIdEnum = "paula"
	ElevenLabsVoiceIdEnumRyan    ElevenLabsVoiceIdEnum = "ryan"
	ElevenLabsVoiceIdEnumDrew    ElevenLabsVoiceIdEnum = "drew"
	ElevenLabsVoiceIdEnumPaul    ElevenLabsVoiceIdEnum = "paul"
	ElevenLabsVoiceIdEnumMrb     ElevenLabsVoiceIdEnum = "mrb"
	ElevenLabsVoiceIdEnumMatilda ElevenLabsVoiceIdEnum = "matilda"
	ElevenLabsVoiceIdEnumMark    ElevenLabsVoiceIdEnum = "mark"
)

func NewElevenLabsVoiceIdEnumFromString(s string) (ElevenLabsVoiceIdEnum, error) {
	switch s {
	case "burt":
		return ElevenLabsVoiceIdEnumBurt, nil
	case "marissa":
		return ElevenLabsVoiceIdEnumMarissa, nil
	case "andrea":
		return ElevenLabsVoiceIdEnumAndrea, nil
	case "sarah":
		return ElevenLabsVoiceIdEnumSarah, nil
	case "phillip":
		return ElevenLabsVoiceIdEnumPhillip, nil
	case "steve":
		return ElevenLabsVoiceIdEnumSteve, nil
	case "joseph":
		return ElevenLabsVoiceIdEnumJoseph, nil
	case "myra":
		return ElevenLabsVoiceIdEnumMyra, nil
	case "paula":
		return ElevenLabsVoiceIdEnumPaula, nil
	case "ryan":
		return ElevenLabsVoiceIdEnumRyan, nil
	case "drew":
		return ElevenLabsVoiceIdEnumDrew, nil
	case "paul":
		return ElevenLabsVoiceIdEnumPaul, nil
	case "mrb":
		return ElevenLabsVoiceIdEnumMrb, nil
	case "matilda":
		return ElevenLabsVoiceIdEnumMatilda, nil
	case "mark":
		return ElevenLabsVoiceIdEnumMark, nil
	}
	var t ElevenLabsVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ElevenLabsVoiceIdEnum) Ptr() *ElevenLabsVoiceIdEnum {
	return &e
}

// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
type ElevenLabsVoiceModel string

const (
	ElevenLabsVoiceModelElevenMultilingualV2 ElevenLabsVoiceModel = "eleven_multilingual_v2"
	ElevenLabsVoiceModelElevenTurboV2        ElevenLabsVoiceModel = "eleven_turbo_v2"
	ElevenLabsVoiceModelElevenTurboV25       ElevenLabsVoiceModel = "eleven_turbo_v2_5"
	ElevenLabsVoiceModelElevenFlashV2        ElevenLabsVoiceModel = "eleven_flash_v2"
	ElevenLabsVoiceModelElevenFlashV25       ElevenLabsVoiceModel = "eleven_flash_v2_5"
	ElevenLabsVoiceModelElevenMonolingualV1  ElevenLabsVoiceModel = "eleven_monolingual_v1"
)

func NewElevenLabsVoiceModelFromString(s string) (ElevenLabsVoiceModel, error) {
	switch s {
	case "eleven_multilingual_v2":
		return ElevenLabsVoiceModelElevenMultilingualV2, nil
	case "eleven_turbo_v2":
		return ElevenLabsVoiceModelElevenTurboV2, nil
	case "eleven_turbo_v2_5":
		return ElevenLabsVoiceModelElevenTurboV25, nil
	case "eleven_flash_v2":
		return ElevenLabsVoiceModelElevenFlashV2, nil
	case "eleven_flash_v2_5":
		return ElevenLabsVoiceModelElevenFlashV25, nil
	case "eleven_monolingual_v1":
		return ElevenLabsVoiceModelElevenMonolingualV1, nil
	}
	var t ElevenLabsVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ElevenLabsVoiceModel) Ptr() *ElevenLabsVoiceModel {
	return &e
}

type ExactReplacement struct {
	// This is the exact replacement type. You can use this to replace a specific word or phrase with a different word or phrase.
	//
	// Usage:
	// - Replace "hello" with "hi": { type: 'exact', key: 'hello', value: 'hi' }
	// - Replace "good morning" with "good day": { type: 'exact', key: 'good morning', value: 'good day' }
	// - Replace a specific name: { type: 'exact', key: 'John Doe', value: 'Jane Smith' }
	// - Replace an acronym: { type: 'exact', key: 'AI', value: 'Artificial Intelligence' }
	// - Replace a company name with its phonetic pronunciation: { type: 'exact', key: 'Vapi', value: 'Vappy' }
	// This option let's you control whether to replace all instances of the key or only the first one. By default, it only replaces the first instance.
	// Examples:
	// - For { type: 'exact', key: 'hello', value: 'hi', replaceAllEnabled: false }. Before: "hello world, hello universe" | After: "hi world, hello universe"
	// - For { type: 'exact', key: 'hello', value: 'hi', replaceAllEnabled: true }. Before: "hello world, hello universe" | After: "hi world, hi universe"
	// @default false
	ReplaceAllEnabled *bool `json:"replaceAllEnabled,omitempty" url:"replaceAllEnabled,omitempty"`
	// This is the key to replace.
	Key string `json:"key" url:"key"`
	// This is the value that will replace the match.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExactReplacement) GetReplaceAllEnabled() *bool {
	if e == nil {
		return nil
	}
	return e.ReplaceAllEnabled
}

func (e *ExactReplacement) GetKey() string {
	if e == nil {
		return ""
	}
	return e.Key
}

func (e *ExactReplacement) GetValue() string {
	if e == nil {
		return ""
	}
	return e.Value
}

func (e *ExactReplacement) Type() string {
	return e.type_
}

func (e *ExactReplacement) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExactReplacement) UnmarshalJSON(data []byte) error {
	type embed ExactReplacement
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExactReplacement(unmarshaler.embed)
	if unmarshaler.Type != "exact" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "exact", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExactReplacement) MarshalJSON() ([]byte, error) {
	type embed ExactReplacement
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
		Type:  "exact",
	}
	return json.Marshal(marshaler)
}

func (e *ExactReplacement) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FailedEdgeCondition struct {
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FailedEdgeCondition) Type() string {
	return f.type_
}

func (f *FailedEdgeCondition) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FailedEdgeCondition) UnmarshalJSON(data []byte) error {
	type embed FailedEdgeCondition
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FailedEdgeCondition(unmarshaler.embed)
	if unmarshaler.Type != "failed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "failed", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FailedEdgeCondition) MarshalJSON() ([]byte, error) {
	type embed FailedEdgeCondition
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "failed",
	}
	return json.Marshal(marshaler)
}

func (f *FailedEdgeCondition) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackAssemblyAiTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the language that will be set for the transcription.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// Transcripts below this confidence threshold will be discarded.
	//
	// @default 0.4
	ConfidenceThreshold *float64 `json:"confidenceThreshold,omitempty" url:"confidenceThreshold,omitempty"`
	// The WebSocket URL that the transcriber connects to.
	RealtimeUrl *string `json:"realtimeUrl,omitempty" url:"realtimeUrl,omitempty"`
	// Add up to 2500 characters of custom vocabulary.
	WordBoost []string `json:"wordBoost,omitempty" url:"wordBoost,omitempty"`
	// The duration of the end utterance silence threshold in milliseconds.
	EndUtteranceSilenceThreshold *float64 `json:"endUtteranceSilenceThreshold,omitempty" url:"endUtteranceSilenceThreshold,omitempty"`
	// Disable partial transcripts.
	// Set to `true` to not receive partial transcripts. Defaults to `false`.
	DisablePartialTranscripts *bool `json:"disablePartialTranscripts,omitempty" url:"disablePartialTranscripts,omitempty"`
	provider                  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackAssemblyAiTranscriber) GetConfidenceThreshold() *float64 {
	if f == nil {
		return nil
	}
	return f.ConfidenceThreshold
}

func (f *FallbackAssemblyAiTranscriber) GetRealtimeUrl() *string {
	if f == nil {
		return nil
	}
	return f.RealtimeUrl
}

func (f *FallbackAssemblyAiTranscriber) GetWordBoost() []string {
	if f == nil {
		return nil
	}
	return f.WordBoost
}

func (f *FallbackAssemblyAiTranscriber) GetEndUtteranceSilenceThreshold() *float64 {
	if f == nil {
		return nil
	}
	return f.EndUtteranceSilenceThreshold
}

func (f *FallbackAssemblyAiTranscriber) GetDisablePartialTranscripts() *bool {
	if f == nil {
		return nil
	}
	return f.DisablePartialTranscripts
}

func (f *FallbackAssemblyAiTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackAssemblyAiTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackAssemblyAiTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackAssemblyAiTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackAssemblyAiTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "assembly-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "assembly-ai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackAssemblyAiTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackAssemblyAiTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "assembly-ai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackAssemblyAiTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackAzureSpeechTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt
	Language *FallbackAzureSpeechTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackAzureSpeechTranscriber) GetLanguage() *FallbackAzureSpeechTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackAzureSpeechTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackAzureSpeechTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackAzureSpeechTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackAzureSpeechTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackAzureSpeechTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "azure", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackAzureSpeechTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackAzureSpeechTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackAzureSpeechTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt
type FallbackAzureSpeechTranscriberLanguage string

const (
	FallbackAzureSpeechTranscriberLanguageAfZa         FallbackAzureSpeechTranscriberLanguage = "af-ZA"
	FallbackAzureSpeechTranscriberLanguageAmEt         FallbackAzureSpeechTranscriberLanguage = "am-ET"
	FallbackAzureSpeechTranscriberLanguageArAe         FallbackAzureSpeechTranscriberLanguage = "ar-AE"
	FallbackAzureSpeechTranscriberLanguageArBh         FallbackAzureSpeechTranscriberLanguage = "ar-BH"
	FallbackAzureSpeechTranscriberLanguageArDz         FallbackAzureSpeechTranscriberLanguage = "ar-DZ"
	FallbackAzureSpeechTranscriberLanguageArEg         FallbackAzureSpeechTranscriberLanguage = "ar-EG"
	FallbackAzureSpeechTranscriberLanguageArIl         FallbackAzureSpeechTranscriberLanguage = "ar-IL"
	FallbackAzureSpeechTranscriberLanguageArIq         FallbackAzureSpeechTranscriberLanguage = "ar-IQ"
	FallbackAzureSpeechTranscriberLanguageArJo         FallbackAzureSpeechTranscriberLanguage = "ar-JO"
	FallbackAzureSpeechTranscriberLanguageArKw         FallbackAzureSpeechTranscriberLanguage = "ar-KW"
	FallbackAzureSpeechTranscriberLanguageArLb         FallbackAzureSpeechTranscriberLanguage = "ar-LB"
	FallbackAzureSpeechTranscriberLanguageArLy         FallbackAzureSpeechTranscriberLanguage = "ar-LY"
	FallbackAzureSpeechTranscriberLanguageArMa         FallbackAzureSpeechTranscriberLanguage = "ar-MA"
	FallbackAzureSpeechTranscriberLanguageArOm         FallbackAzureSpeechTranscriberLanguage = "ar-OM"
	FallbackAzureSpeechTranscriberLanguageArPs         FallbackAzureSpeechTranscriberLanguage = "ar-PS"
	FallbackAzureSpeechTranscriberLanguageArQa         FallbackAzureSpeechTranscriberLanguage = "ar-QA"
	FallbackAzureSpeechTranscriberLanguageArSa         FallbackAzureSpeechTranscriberLanguage = "ar-SA"
	FallbackAzureSpeechTranscriberLanguageArSy         FallbackAzureSpeechTranscriberLanguage = "ar-SY"
	FallbackAzureSpeechTranscriberLanguageArTn         FallbackAzureSpeechTranscriberLanguage = "ar-TN"
	FallbackAzureSpeechTranscriberLanguageArYe         FallbackAzureSpeechTranscriberLanguage = "ar-YE"
	FallbackAzureSpeechTranscriberLanguageAzAz         FallbackAzureSpeechTranscriberLanguage = "az-AZ"
	FallbackAzureSpeechTranscriberLanguageBgBg         FallbackAzureSpeechTranscriberLanguage = "bg-BG"
	FallbackAzureSpeechTranscriberLanguageBnIn         FallbackAzureSpeechTranscriberLanguage = "bn-IN"
	FallbackAzureSpeechTranscriberLanguageBsBa         FallbackAzureSpeechTranscriberLanguage = "bs-BA"
	FallbackAzureSpeechTranscriberLanguageCaEs         FallbackAzureSpeechTranscriberLanguage = "ca-ES"
	FallbackAzureSpeechTranscriberLanguageCsCz         FallbackAzureSpeechTranscriberLanguage = "cs-CZ"
	FallbackAzureSpeechTranscriberLanguageCyGb         FallbackAzureSpeechTranscriberLanguage = "cy-GB"
	FallbackAzureSpeechTranscriberLanguageDaDk         FallbackAzureSpeechTranscriberLanguage = "da-DK"
	FallbackAzureSpeechTranscriberLanguageDeAt         FallbackAzureSpeechTranscriberLanguage = "de-AT"
	FallbackAzureSpeechTranscriberLanguageDeCh         FallbackAzureSpeechTranscriberLanguage = "de-CH"
	FallbackAzureSpeechTranscriberLanguageDeDe         FallbackAzureSpeechTranscriberLanguage = "de-DE"
	FallbackAzureSpeechTranscriberLanguageElGr         FallbackAzureSpeechTranscriberLanguage = "el-GR"
	FallbackAzureSpeechTranscriberLanguageEnAu         FallbackAzureSpeechTranscriberLanguage = "en-AU"
	FallbackAzureSpeechTranscriberLanguageEnCa         FallbackAzureSpeechTranscriberLanguage = "en-CA"
	FallbackAzureSpeechTranscriberLanguageEnGb         FallbackAzureSpeechTranscriberLanguage = "en-GB"
	FallbackAzureSpeechTranscriberLanguageEnGh         FallbackAzureSpeechTranscriberLanguage = "en-GH"
	FallbackAzureSpeechTranscriberLanguageEnHk         FallbackAzureSpeechTranscriberLanguage = "en-HK"
	FallbackAzureSpeechTranscriberLanguageEnIe         FallbackAzureSpeechTranscriberLanguage = "en-IE"
	FallbackAzureSpeechTranscriberLanguageEnIn         FallbackAzureSpeechTranscriberLanguage = "en-IN"
	FallbackAzureSpeechTranscriberLanguageEnKe         FallbackAzureSpeechTranscriberLanguage = "en-KE"
	FallbackAzureSpeechTranscriberLanguageEnNg         FallbackAzureSpeechTranscriberLanguage = "en-NG"
	FallbackAzureSpeechTranscriberLanguageEnNz         FallbackAzureSpeechTranscriberLanguage = "en-NZ"
	FallbackAzureSpeechTranscriberLanguageEnPh         FallbackAzureSpeechTranscriberLanguage = "en-PH"
	FallbackAzureSpeechTranscriberLanguageEnSg         FallbackAzureSpeechTranscriberLanguage = "en-SG"
	FallbackAzureSpeechTranscriberLanguageEnTz         FallbackAzureSpeechTranscriberLanguage = "en-TZ"
	FallbackAzureSpeechTranscriberLanguageEnUs         FallbackAzureSpeechTranscriberLanguage = "en-US"
	FallbackAzureSpeechTranscriberLanguageEnZa         FallbackAzureSpeechTranscriberLanguage = "en-ZA"
	FallbackAzureSpeechTranscriberLanguageEsAr         FallbackAzureSpeechTranscriberLanguage = "es-AR"
	FallbackAzureSpeechTranscriberLanguageEsBo         FallbackAzureSpeechTranscriberLanguage = "es-BO"
	FallbackAzureSpeechTranscriberLanguageEsCl         FallbackAzureSpeechTranscriberLanguage = "es-CL"
	FallbackAzureSpeechTranscriberLanguageEsCo         FallbackAzureSpeechTranscriberLanguage = "es-CO"
	FallbackAzureSpeechTranscriberLanguageEsCr         FallbackAzureSpeechTranscriberLanguage = "es-CR"
	FallbackAzureSpeechTranscriberLanguageEsCu         FallbackAzureSpeechTranscriberLanguage = "es-CU"
	FallbackAzureSpeechTranscriberLanguageEsDo         FallbackAzureSpeechTranscriberLanguage = "es-DO"
	FallbackAzureSpeechTranscriberLanguageEsEc         FallbackAzureSpeechTranscriberLanguage = "es-EC"
	FallbackAzureSpeechTranscriberLanguageEsEs         FallbackAzureSpeechTranscriberLanguage = "es-ES"
	FallbackAzureSpeechTranscriberLanguageEsGq         FallbackAzureSpeechTranscriberLanguage = "es-GQ"
	FallbackAzureSpeechTranscriberLanguageEsGt         FallbackAzureSpeechTranscriberLanguage = "es-GT"
	FallbackAzureSpeechTranscriberLanguageEsHn         FallbackAzureSpeechTranscriberLanguage = "es-HN"
	FallbackAzureSpeechTranscriberLanguageEsMx         FallbackAzureSpeechTranscriberLanguage = "es-MX"
	FallbackAzureSpeechTranscriberLanguageEsNi         FallbackAzureSpeechTranscriberLanguage = "es-NI"
	FallbackAzureSpeechTranscriberLanguageEsPa         FallbackAzureSpeechTranscriberLanguage = "es-PA"
	FallbackAzureSpeechTranscriberLanguageEsPe         FallbackAzureSpeechTranscriberLanguage = "es-PE"
	FallbackAzureSpeechTranscriberLanguageEsPr         FallbackAzureSpeechTranscriberLanguage = "es-PR"
	FallbackAzureSpeechTranscriberLanguageEsPy         FallbackAzureSpeechTranscriberLanguage = "es-PY"
	FallbackAzureSpeechTranscriberLanguageEsSv         FallbackAzureSpeechTranscriberLanguage = "es-SV"
	FallbackAzureSpeechTranscriberLanguageEsUs         FallbackAzureSpeechTranscriberLanguage = "es-US"
	FallbackAzureSpeechTranscriberLanguageEsUy         FallbackAzureSpeechTranscriberLanguage = "es-UY"
	FallbackAzureSpeechTranscriberLanguageEsVe         FallbackAzureSpeechTranscriberLanguage = "es-VE"
	FallbackAzureSpeechTranscriberLanguageEtEe         FallbackAzureSpeechTranscriberLanguage = "et-EE"
	FallbackAzureSpeechTranscriberLanguageEuEs         FallbackAzureSpeechTranscriberLanguage = "eu-ES"
	FallbackAzureSpeechTranscriberLanguageFaIr         FallbackAzureSpeechTranscriberLanguage = "fa-IR"
	FallbackAzureSpeechTranscriberLanguageFiFi         FallbackAzureSpeechTranscriberLanguage = "fi-FI"
	FallbackAzureSpeechTranscriberLanguageFilPh        FallbackAzureSpeechTranscriberLanguage = "fil-PH"
	FallbackAzureSpeechTranscriberLanguageFrBe         FallbackAzureSpeechTranscriberLanguage = "fr-BE"
	FallbackAzureSpeechTranscriberLanguageFrCa         FallbackAzureSpeechTranscriberLanguage = "fr-CA"
	FallbackAzureSpeechTranscriberLanguageFrCh         FallbackAzureSpeechTranscriberLanguage = "fr-CH"
	FallbackAzureSpeechTranscriberLanguageFrFr         FallbackAzureSpeechTranscriberLanguage = "fr-FR"
	FallbackAzureSpeechTranscriberLanguageGaIe         FallbackAzureSpeechTranscriberLanguage = "ga-IE"
	FallbackAzureSpeechTranscriberLanguageGlEs         FallbackAzureSpeechTranscriberLanguage = "gl-ES"
	FallbackAzureSpeechTranscriberLanguageGuIn         FallbackAzureSpeechTranscriberLanguage = "gu-IN"
	FallbackAzureSpeechTranscriberLanguageHeIl         FallbackAzureSpeechTranscriberLanguage = "he-IL"
	FallbackAzureSpeechTranscriberLanguageHiIn         FallbackAzureSpeechTranscriberLanguage = "hi-IN"
	FallbackAzureSpeechTranscriberLanguageHrHr         FallbackAzureSpeechTranscriberLanguage = "hr-HR"
	FallbackAzureSpeechTranscriberLanguageHuHu         FallbackAzureSpeechTranscriberLanguage = "hu-HU"
	FallbackAzureSpeechTranscriberLanguageHyAm         FallbackAzureSpeechTranscriberLanguage = "hy-AM"
	FallbackAzureSpeechTranscriberLanguageIdId         FallbackAzureSpeechTranscriberLanguage = "id-ID"
	FallbackAzureSpeechTranscriberLanguageIsIs         FallbackAzureSpeechTranscriberLanguage = "is-IS"
	FallbackAzureSpeechTranscriberLanguageItCh         FallbackAzureSpeechTranscriberLanguage = "it-CH"
	FallbackAzureSpeechTranscriberLanguageItIt         FallbackAzureSpeechTranscriberLanguage = "it-IT"
	FallbackAzureSpeechTranscriberLanguageJaJp         FallbackAzureSpeechTranscriberLanguage = "ja-JP"
	FallbackAzureSpeechTranscriberLanguageJvId         FallbackAzureSpeechTranscriberLanguage = "jv-ID"
	FallbackAzureSpeechTranscriberLanguageKaGe         FallbackAzureSpeechTranscriberLanguage = "ka-GE"
	FallbackAzureSpeechTranscriberLanguageKkKz         FallbackAzureSpeechTranscriberLanguage = "kk-KZ"
	FallbackAzureSpeechTranscriberLanguageKmKh         FallbackAzureSpeechTranscriberLanguage = "km-KH"
	FallbackAzureSpeechTranscriberLanguageKnIn         FallbackAzureSpeechTranscriberLanguage = "kn-IN"
	FallbackAzureSpeechTranscriberLanguageKoKr         FallbackAzureSpeechTranscriberLanguage = "ko-KR"
	FallbackAzureSpeechTranscriberLanguageLoLa         FallbackAzureSpeechTranscriberLanguage = "lo-LA"
	FallbackAzureSpeechTranscriberLanguageLtLt         FallbackAzureSpeechTranscriberLanguage = "lt-LT"
	FallbackAzureSpeechTranscriberLanguageLvLv         FallbackAzureSpeechTranscriberLanguage = "lv-LV"
	FallbackAzureSpeechTranscriberLanguageMkMk         FallbackAzureSpeechTranscriberLanguage = "mk-MK"
	FallbackAzureSpeechTranscriberLanguageMlIn         FallbackAzureSpeechTranscriberLanguage = "ml-IN"
	FallbackAzureSpeechTranscriberLanguageMnMn         FallbackAzureSpeechTranscriberLanguage = "mn-MN"
	FallbackAzureSpeechTranscriberLanguageMrIn         FallbackAzureSpeechTranscriberLanguage = "mr-IN"
	FallbackAzureSpeechTranscriberLanguageMsMy         FallbackAzureSpeechTranscriberLanguage = "ms-MY"
	FallbackAzureSpeechTranscriberLanguageMtMt         FallbackAzureSpeechTranscriberLanguage = "mt-MT"
	FallbackAzureSpeechTranscriberLanguageMyMm         FallbackAzureSpeechTranscriberLanguage = "my-MM"
	FallbackAzureSpeechTranscriberLanguageNbNo         FallbackAzureSpeechTranscriberLanguage = "nb-NO"
	FallbackAzureSpeechTranscriberLanguageNeNp         FallbackAzureSpeechTranscriberLanguage = "ne-NP"
	FallbackAzureSpeechTranscriberLanguageNlBe         FallbackAzureSpeechTranscriberLanguage = "nl-BE"
	FallbackAzureSpeechTranscriberLanguageNlNl         FallbackAzureSpeechTranscriberLanguage = "nl-NL"
	FallbackAzureSpeechTranscriberLanguagePaIn         FallbackAzureSpeechTranscriberLanguage = "pa-IN"
	FallbackAzureSpeechTranscriberLanguagePlPl         FallbackAzureSpeechTranscriberLanguage = "pl-PL"
	FallbackAzureSpeechTranscriberLanguagePsAf         FallbackAzureSpeechTranscriberLanguage = "ps-AF"
	FallbackAzureSpeechTranscriberLanguagePtBr         FallbackAzureSpeechTranscriberLanguage = "pt-BR"
	FallbackAzureSpeechTranscriberLanguagePtPt         FallbackAzureSpeechTranscriberLanguage = "pt-PT"
	FallbackAzureSpeechTranscriberLanguageRoRo         FallbackAzureSpeechTranscriberLanguage = "ro-RO"
	FallbackAzureSpeechTranscriberLanguageRuRu         FallbackAzureSpeechTranscriberLanguage = "ru-RU"
	FallbackAzureSpeechTranscriberLanguageSiLk         FallbackAzureSpeechTranscriberLanguage = "si-LK"
	FallbackAzureSpeechTranscriberLanguageSkSk         FallbackAzureSpeechTranscriberLanguage = "sk-SK"
	FallbackAzureSpeechTranscriberLanguageSlSi         FallbackAzureSpeechTranscriberLanguage = "sl-SI"
	FallbackAzureSpeechTranscriberLanguageSoSo         FallbackAzureSpeechTranscriberLanguage = "so-SO"
	FallbackAzureSpeechTranscriberLanguageSqAl         FallbackAzureSpeechTranscriberLanguage = "sq-AL"
	FallbackAzureSpeechTranscriberLanguageSrRs         FallbackAzureSpeechTranscriberLanguage = "sr-RS"
	FallbackAzureSpeechTranscriberLanguageSvSe         FallbackAzureSpeechTranscriberLanguage = "sv-SE"
	FallbackAzureSpeechTranscriberLanguageSwKe         FallbackAzureSpeechTranscriberLanguage = "sw-KE"
	FallbackAzureSpeechTranscriberLanguageSwTz         FallbackAzureSpeechTranscriberLanguage = "sw-TZ"
	FallbackAzureSpeechTranscriberLanguageTaIn         FallbackAzureSpeechTranscriberLanguage = "ta-IN"
	FallbackAzureSpeechTranscriberLanguageTeIn         FallbackAzureSpeechTranscriberLanguage = "te-IN"
	FallbackAzureSpeechTranscriberLanguageThTh         FallbackAzureSpeechTranscriberLanguage = "th-TH"
	FallbackAzureSpeechTranscriberLanguageTrTr         FallbackAzureSpeechTranscriberLanguage = "tr-TR"
	FallbackAzureSpeechTranscriberLanguageUkUa         FallbackAzureSpeechTranscriberLanguage = "uk-UA"
	FallbackAzureSpeechTranscriberLanguageUrIn         FallbackAzureSpeechTranscriberLanguage = "ur-IN"
	FallbackAzureSpeechTranscriberLanguageUzUz         FallbackAzureSpeechTranscriberLanguage = "uz-UZ"
	FallbackAzureSpeechTranscriberLanguageViVn         FallbackAzureSpeechTranscriberLanguage = "vi-VN"
	FallbackAzureSpeechTranscriberLanguageWuuCn        FallbackAzureSpeechTranscriberLanguage = "wuu-CN"
	FallbackAzureSpeechTranscriberLanguageYueCn        FallbackAzureSpeechTranscriberLanguage = "yue-CN"
	FallbackAzureSpeechTranscriberLanguageZhCn         FallbackAzureSpeechTranscriberLanguage = "zh-CN"
	FallbackAzureSpeechTranscriberLanguageZhCnShandong FallbackAzureSpeechTranscriberLanguage = "zh-CN-shandong"
	FallbackAzureSpeechTranscriberLanguageZhCnSichuan  FallbackAzureSpeechTranscriberLanguage = "zh-CN-sichuan"
	FallbackAzureSpeechTranscriberLanguageZhHk         FallbackAzureSpeechTranscriberLanguage = "zh-HK"
	FallbackAzureSpeechTranscriberLanguageZhTw         FallbackAzureSpeechTranscriberLanguage = "zh-TW"
	FallbackAzureSpeechTranscriberLanguageZuZa         FallbackAzureSpeechTranscriberLanguage = "zu-ZA"
)

func NewFallbackAzureSpeechTranscriberLanguageFromString(s string) (FallbackAzureSpeechTranscriberLanguage, error) {
	switch s {
	case "af-ZA":
		return FallbackAzureSpeechTranscriberLanguageAfZa, nil
	case "am-ET":
		return FallbackAzureSpeechTranscriberLanguageAmEt, nil
	case "ar-AE":
		return FallbackAzureSpeechTranscriberLanguageArAe, nil
	case "ar-BH":
		return FallbackAzureSpeechTranscriberLanguageArBh, nil
	case "ar-DZ":
		return FallbackAzureSpeechTranscriberLanguageArDz, nil
	case "ar-EG":
		return FallbackAzureSpeechTranscriberLanguageArEg, nil
	case "ar-IL":
		return FallbackAzureSpeechTranscriberLanguageArIl, nil
	case "ar-IQ":
		return FallbackAzureSpeechTranscriberLanguageArIq, nil
	case "ar-JO":
		return FallbackAzureSpeechTranscriberLanguageArJo, nil
	case "ar-KW":
		return FallbackAzureSpeechTranscriberLanguageArKw, nil
	case "ar-LB":
		return FallbackAzureSpeechTranscriberLanguageArLb, nil
	case "ar-LY":
		return FallbackAzureSpeechTranscriberLanguageArLy, nil
	case "ar-MA":
		return FallbackAzureSpeechTranscriberLanguageArMa, nil
	case "ar-OM":
		return FallbackAzureSpeechTranscriberLanguageArOm, nil
	case "ar-PS":
		return FallbackAzureSpeechTranscriberLanguageArPs, nil
	case "ar-QA":
		return FallbackAzureSpeechTranscriberLanguageArQa, nil
	case "ar-SA":
		return FallbackAzureSpeechTranscriberLanguageArSa, nil
	case "ar-SY":
		return FallbackAzureSpeechTranscriberLanguageArSy, nil
	case "ar-TN":
		return FallbackAzureSpeechTranscriberLanguageArTn, nil
	case "ar-YE":
		return FallbackAzureSpeechTranscriberLanguageArYe, nil
	case "az-AZ":
		return FallbackAzureSpeechTranscriberLanguageAzAz, nil
	case "bg-BG":
		return FallbackAzureSpeechTranscriberLanguageBgBg, nil
	case "bn-IN":
		return FallbackAzureSpeechTranscriberLanguageBnIn, nil
	case "bs-BA":
		return FallbackAzureSpeechTranscriberLanguageBsBa, nil
	case "ca-ES":
		return FallbackAzureSpeechTranscriberLanguageCaEs, nil
	case "cs-CZ":
		return FallbackAzureSpeechTranscriberLanguageCsCz, nil
	case "cy-GB":
		return FallbackAzureSpeechTranscriberLanguageCyGb, nil
	case "da-DK":
		return FallbackAzureSpeechTranscriberLanguageDaDk, nil
	case "de-AT":
		return FallbackAzureSpeechTranscriberLanguageDeAt, nil
	case "de-CH":
		return FallbackAzureSpeechTranscriberLanguageDeCh, nil
	case "de-DE":
		return FallbackAzureSpeechTranscriberLanguageDeDe, nil
	case "el-GR":
		return FallbackAzureSpeechTranscriberLanguageElGr, nil
	case "en-AU":
		return FallbackAzureSpeechTranscriberLanguageEnAu, nil
	case "en-CA":
		return FallbackAzureSpeechTranscriberLanguageEnCa, nil
	case "en-GB":
		return FallbackAzureSpeechTranscriberLanguageEnGb, nil
	case "en-GH":
		return FallbackAzureSpeechTranscriberLanguageEnGh, nil
	case "en-HK":
		return FallbackAzureSpeechTranscriberLanguageEnHk, nil
	case "en-IE":
		return FallbackAzureSpeechTranscriberLanguageEnIe, nil
	case "en-IN":
		return FallbackAzureSpeechTranscriberLanguageEnIn, nil
	case "en-KE":
		return FallbackAzureSpeechTranscriberLanguageEnKe, nil
	case "en-NG":
		return FallbackAzureSpeechTranscriberLanguageEnNg, nil
	case "en-NZ":
		return FallbackAzureSpeechTranscriberLanguageEnNz, nil
	case "en-PH":
		return FallbackAzureSpeechTranscriberLanguageEnPh, nil
	case "en-SG":
		return FallbackAzureSpeechTranscriberLanguageEnSg, nil
	case "en-TZ":
		return FallbackAzureSpeechTranscriberLanguageEnTz, nil
	case "en-US":
		return FallbackAzureSpeechTranscriberLanguageEnUs, nil
	case "en-ZA":
		return FallbackAzureSpeechTranscriberLanguageEnZa, nil
	case "es-AR":
		return FallbackAzureSpeechTranscriberLanguageEsAr, nil
	case "es-BO":
		return FallbackAzureSpeechTranscriberLanguageEsBo, nil
	case "es-CL":
		return FallbackAzureSpeechTranscriberLanguageEsCl, nil
	case "es-CO":
		return FallbackAzureSpeechTranscriberLanguageEsCo, nil
	case "es-CR":
		return FallbackAzureSpeechTranscriberLanguageEsCr, nil
	case "es-CU":
		return FallbackAzureSpeechTranscriberLanguageEsCu, nil
	case "es-DO":
		return FallbackAzureSpeechTranscriberLanguageEsDo, nil
	case "es-EC":
		return FallbackAzureSpeechTranscriberLanguageEsEc, nil
	case "es-ES":
		return FallbackAzureSpeechTranscriberLanguageEsEs, nil
	case "es-GQ":
		return FallbackAzureSpeechTranscriberLanguageEsGq, nil
	case "es-GT":
		return FallbackAzureSpeechTranscriberLanguageEsGt, nil
	case "es-HN":
		return FallbackAzureSpeechTranscriberLanguageEsHn, nil
	case "es-MX":
		return FallbackAzureSpeechTranscriberLanguageEsMx, nil
	case "es-NI":
		return FallbackAzureSpeechTranscriberLanguageEsNi, nil
	case "es-PA":
		return FallbackAzureSpeechTranscriberLanguageEsPa, nil
	case "es-PE":
		return FallbackAzureSpeechTranscriberLanguageEsPe, nil
	case "es-PR":
		return FallbackAzureSpeechTranscriberLanguageEsPr, nil
	case "es-PY":
		return FallbackAzureSpeechTranscriberLanguageEsPy, nil
	case "es-SV":
		return FallbackAzureSpeechTranscriberLanguageEsSv, nil
	case "es-US":
		return FallbackAzureSpeechTranscriberLanguageEsUs, nil
	case "es-UY":
		return FallbackAzureSpeechTranscriberLanguageEsUy, nil
	case "es-VE":
		return FallbackAzureSpeechTranscriberLanguageEsVe, nil
	case "et-EE":
		return FallbackAzureSpeechTranscriberLanguageEtEe, nil
	case "eu-ES":
		return FallbackAzureSpeechTranscriberLanguageEuEs, nil
	case "fa-IR":
		return FallbackAzureSpeechTranscriberLanguageFaIr, nil
	case "fi-FI":
		return FallbackAzureSpeechTranscriberLanguageFiFi, nil
	case "fil-PH":
		return FallbackAzureSpeechTranscriberLanguageFilPh, nil
	case "fr-BE":
		return FallbackAzureSpeechTranscriberLanguageFrBe, nil
	case "fr-CA":
		return FallbackAzureSpeechTranscriberLanguageFrCa, nil
	case "fr-CH":
		return FallbackAzureSpeechTranscriberLanguageFrCh, nil
	case "fr-FR":
		return FallbackAzureSpeechTranscriberLanguageFrFr, nil
	case "ga-IE":
		return FallbackAzureSpeechTranscriberLanguageGaIe, nil
	case "gl-ES":
		return FallbackAzureSpeechTranscriberLanguageGlEs, nil
	case "gu-IN":
		return FallbackAzureSpeechTranscriberLanguageGuIn, nil
	case "he-IL":
		return FallbackAzureSpeechTranscriberLanguageHeIl, nil
	case "hi-IN":
		return FallbackAzureSpeechTranscriberLanguageHiIn, nil
	case "hr-HR":
		return FallbackAzureSpeechTranscriberLanguageHrHr, nil
	case "hu-HU":
		return FallbackAzureSpeechTranscriberLanguageHuHu, nil
	case "hy-AM":
		return FallbackAzureSpeechTranscriberLanguageHyAm, nil
	case "id-ID":
		return FallbackAzureSpeechTranscriberLanguageIdId, nil
	case "is-IS":
		return FallbackAzureSpeechTranscriberLanguageIsIs, nil
	case "it-CH":
		return FallbackAzureSpeechTranscriberLanguageItCh, nil
	case "it-IT":
		return FallbackAzureSpeechTranscriberLanguageItIt, nil
	case "ja-JP":
		return FallbackAzureSpeechTranscriberLanguageJaJp, nil
	case "jv-ID":
		return FallbackAzureSpeechTranscriberLanguageJvId, nil
	case "ka-GE":
		return FallbackAzureSpeechTranscriberLanguageKaGe, nil
	case "kk-KZ":
		return FallbackAzureSpeechTranscriberLanguageKkKz, nil
	case "km-KH":
		return FallbackAzureSpeechTranscriberLanguageKmKh, nil
	case "kn-IN":
		return FallbackAzureSpeechTranscriberLanguageKnIn, nil
	case "ko-KR":
		return FallbackAzureSpeechTranscriberLanguageKoKr, nil
	case "lo-LA":
		return FallbackAzureSpeechTranscriberLanguageLoLa, nil
	case "lt-LT":
		return FallbackAzureSpeechTranscriberLanguageLtLt, nil
	case "lv-LV":
		return FallbackAzureSpeechTranscriberLanguageLvLv, nil
	case "mk-MK":
		return FallbackAzureSpeechTranscriberLanguageMkMk, nil
	case "ml-IN":
		return FallbackAzureSpeechTranscriberLanguageMlIn, nil
	case "mn-MN":
		return FallbackAzureSpeechTranscriberLanguageMnMn, nil
	case "mr-IN":
		return FallbackAzureSpeechTranscriberLanguageMrIn, nil
	case "ms-MY":
		return FallbackAzureSpeechTranscriberLanguageMsMy, nil
	case "mt-MT":
		return FallbackAzureSpeechTranscriberLanguageMtMt, nil
	case "my-MM":
		return FallbackAzureSpeechTranscriberLanguageMyMm, nil
	case "nb-NO":
		return FallbackAzureSpeechTranscriberLanguageNbNo, nil
	case "ne-NP":
		return FallbackAzureSpeechTranscriberLanguageNeNp, nil
	case "nl-BE":
		return FallbackAzureSpeechTranscriberLanguageNlBe, nil
	case "nl-NL":
		return FallbackAzureSpeechTranscriberLanguageNlNl, nil
	case "pa-IN":
		return FallbackAzureSpeechTranscriberLanguagePaIn, nil
	case "pl-PL":
		return FallbackAzureSpeechTranscriberLanguagePlPl, nil
	case "ps-AF":
		return FallbackAzureSpeechTranscriberLanguagePsAf, nil
	case "pt-BR":
		return FallbackAzureSpeechTranscriberLanguagePtBr, nil
	case "pt-PT":
		return FallbackAzureSpeechTranscriberLanguagePtPt, nil
	case "ro-RO":
		return FallbackAzureSpeechTranscriberLanguageRoRo, nil
	case "ru-RU":
		return FallbackAzureSpeechTranscriberLanguageRuRu, nil
	case "si-LK":
		return FallbackAzureSpeechTranscriberLanguageSiLk, nil
	case "sk-SK":
		return FallbackAzureSpeechTranscriberLanguageSkSk, nil
	case "sl-SI":
		return FallbackAzureSpeechTranscriberLanguageSlSi, nil
	case "so-SO":
		return FallbackAzureSpeechTranscriberLanguageSoSo, nil
	case "sq-AL":
		return FallbackAzureSpeechTranscriberLanguageSqAl, nil
	case "sr-RS":
		return FallbackAzureSpeechTranscriberLanguageSrRs, nil
	case "sv-SE":
		return FallbackAzureSpeechTranscriberLanguageSvSe, nil
	case "sw-KE":
		return FallbackAzureSpeechTranscriberLanguageSwKe, nil
	case "sw-TZ":
		return FallbackAzureSpeechTranscriberLanguageSwTz, nil
	case "ta-IN":
		return FallbackAzureSpeechTranscriberLanguageTaIn, nil
	case "te-IN":
		return FallbackAzureSpeechTranscriberLanguageTeIn, nil
	case "th-TH":
		return FallbackAzureSpeechTranscriberLanguageThTh, nil
	case "tr-TR":
		return FallbackAzureSpeechTranscriberLanguageTrTr, nil
	case "uk-UA":
		return FallbackAzureSpeechTranscriberLanguageUkUa, nil
	case "ur-IN":
		return FallbackAzureSpeechTranscriberLanguageUrIn, nil
	case "uz-UZ":
		return FallbackAzureSpeechTranscriberLanguageUzUz, nil
	case "vi-VN":
		return FallbackAzureSpeechTranscriberLanguageViVn, nil
	case "wuu-CN":
		return FallbackAzureSpeechTranscriberLanguageWuuCn, nil
	case "yue-CN":
		return FallbackAzureSpeechTranscriberLanguageYueCn, nil
	case "zh-CN":
		return FallbackAzureSpeechTranscriberLanguageZhCn, nil
	case "zh-CN-shandong":
		return FallbackAzureSpeechTranscriberLanguageZhCnShandong, nil
	case "zh-CN-sichuan":
		return FallbackAzureSpeechTranscriberLanguageZhCnSichuan, nil
	case "zh-HK":
		return FallbackAzureSpeechTranscriberLanguageZhHk, nil
	case "zh-TW":
		return FallbackAzureSpeechTranscriberLanguageZhTw, nil
	case "zu-ZA":
		return FallbackAzureSpeechTranscriberLanguageZuZa, nil
	}
	var t FallbackAzureSpeechTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackAzureSpeechTranscriberLanguage) Ptr() *FallbackAzureSpeechTranscriberLanguage {
	return &f
}

type FallbackAzureVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackAzureVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan  `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	OneOf     interface{} `json:"oneOf,omitempty" url:"oneOf,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackAzureVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackAzureVoice) GetVoiceId() *FallbackAzureVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackAzureVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackAzureVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackAzureVoice) GetOneOf() interface{} {
	if f == nil {
		return nil
	}
	return f.OneOf
}

func (f *FallbackAzureVoice) Provider() string {
	return f.provider
}

func (f *FallbackAzureVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackAzureVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackAzureVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackAzureVoice(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "azure", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackAzureVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackAzureVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackAzureVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackAzureVoiceId struct {
	FallbackAzureVoiceVoiceId FallbackAzureVoiceVoiceId
	String                    string

	typ string
}

func (f *FallbackAzureVoiceId) GetFallbackAzureVoiceVoiceId() FallbackAzureVoiceVoiceId {
	if f == nil {
		return ""
	}
	return f.FallbackAzureVoiceVoiceId
}

func (f *FallbackAzureVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackAzureVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackAzureVoiceVoiceId FallbackAzureVoiceVoiceId
	if err := json.Unmarshal(data, &valueFallbackAzureVoiceVoiceId); err == nil {
		f.typ = "FallbackAzureVoiceVoiceId"
		f.FallbackAzureVoiceVoiceId = valueFallbackAzureVoiceVoiceId
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackAzureVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackAzureVoiceVoiceId" || f.FallbackAzureVoiceVoiceId != "" {
		return json.Marshal(f.FallbackAzureVoiceVoiceId)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackAzureVoiceIdVisitor interface {
	VisitFallbackAzureVoiceVoiceId(FallbackAzureVoiceVoiceId) error
	VisitString(string) error
}

func (f *FallbackAzureVoiceId) Accept(visitor FallbackAzureVoiceIdVisitor) error {
	if f.typ == "FallbackAzureVoiceVoiceId" || f.FallbackAzureVoiceVoiceId != "" {
		return visitor.VisitFallbackAzureVoiceVoiceId(f.FallbackAzureVoiceVoiceId)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackAzureVoiceVoiceId string

const (
	FallbackAzureVoiceVoiceIdAndrew FallbackAzureVoiceVoiceId = "andrew"
	FallbackAzureVoiceVoiceIdBrian  FallbackAzureVoiceVoiceId = "brian"
	FallbackAzureVoiceVoiceIdEmma   FallbackAzureVoiceVoiceId = "emma"
)

func NewFallbackAzureVoiceVoiceIdFromString(s string) (FallbackAzureVoiceVoiceId, error) {
	switch s {
	case "andrew":
		return FallbackAzureVoiceVoiceIdAndrew, nil
	case "brian":
		return FallbackAzureVoiceVoiceIdBrian, nil
	case "emma":
		return FallbackAzureVoiceVoiceIdEmma, nil
	}
	var t FallbackAzureVoiceVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackAzureVoiceVoiceId) Ptr() *FallbackAzureVoiceVoiceId {
	return &f
}

type FallbackCartesiaVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// The ID of the particular voice you want to use.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
	Model *FallbackCartesiaVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
	Language *FallbackCartesiaVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// Experimental controls for Cartesia voice generation
	ExperimentalControls *CartesiaExperimentalControls `json:"experimentalControls,omitempty" url:"experimentalControls,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackCartesiaVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackCartesiaVoice) GetVoiceId() string {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackCartesiaVoice) GetModel() *FallbackCartesiaVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackCartesiaVoice) GetLanguage() *FallbackCartesiaVoiceLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackCartesiaVoice) GetExperimentalControls() *CartesiaExperimentalControls {
	if f == nil {
		return nil
	}
	return f.ExperimentalControls
}

func (f *FallbackCartesiaVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackCartesiaVoice) Provider() string {
	return f.provider
}

func (f *FallbackCartesiaVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackCartesiaVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackCartesiaVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackCartesiaVoice(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "cartesia", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackCartesiaVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackCartesiaVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackCartesiaVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
type FallbackCartesiaVoiceLanguage string

const (
	FallbackCartesiaVoiceLanguageEn FallbackCartesiaVoiceLanguage = "en"
	FallbackCartesiaVoiceLanguageDe FallbackCartesiaVoiceLanguage = "de"
	FallbackCartesiaVoiceLanguageEs FallbackCartesiaVoiceLanguage = "es"
	FallbackCartesiaVoiceLanguageFr FallbackCartesiaVoiceLanguage = "fr"
	FallbackCartesiaVoiceLanguageJa FallbackCartesiaVoiceLanguage = "ja"
	FallbackCartesiaVoiceLanguagePt FallbackCartesiaVoiceLanguage = "pt"
	FallbackCartesiaVoiceLanguageZh FallbackCartesiaVoiceLanguage = "zh"
	FallbackCartesiaVoiceLanguageHi FallbackCartesiaVoiceLanguage = "hi"
	FallbackCartesiaVoiceLanguageIt FallbackCartesiaVoiceLanguage = "it"
	FallbackCartesiaVoiceLanguageKo FallbackCartesiaVoiceLanguage = "ko"
	FallbackCartesiaVoiceLanguageNl FallbackCartesiaVoiceLanguage = "nl"
	FallbackCartesiaVoiceLanguagePl FallbackCartesiaVoiceLanguage = "pl"
	FallbackCartesiaVoiceLanguageRu FallbackCartesiaVoiceLanguage = "ru"
	FallbackCartesiaVoiceLanguageSv FallbackCartesiaVoiceLanguage = "sv"
	FallbackCartesiaVoiceLanguageTr FallbackCartesiaVoiceLanguage = "tr"
)

func NewFallbackCartesiaVoiceLanguageFromString(s string) (FallbackCartesiaVoiceLanguage, error) {
	switch s {
	case "en":
		return FallbackCartesiaVoiceLanguageEn, nil
	case "de":
		return FallbackCartesiaVoiceLanguageDe, nil
	case "es":
		return FallbackCartesiaVoiceLanguageEs, nil
	case "fr":
		return FallbackCartesiaVoiceLanguageFr, nil
	case "ja":
		return FallbackCartesiaVoiceLanguageJa, nil
	case "pt":
		return FallbackCartesiaVoiceLanguagePt, nil
	case "zh":
		return FallbackCartesiaVoiceLanguageZh, nil
	case "hi":
		return FallbackCartesiaVoiceLanguageHi, nil
	case "it":
		return FallbackCartesiaVoiceLanguageIt, nil
	case "ko":
		return FallbackCartesiaVoiceLanguageKo, nil
	case "nl":
		return FallbackCartesiaVoiceLanguageNl, nil
	case "pl":
		return FallbackCartesiaVoiceLanguagePl, nil
	case "ru":
		return FallbackCartesiaVoiceLanguageRu, nil
	case "sv":
		return FallbackCartesiaVoiceLanguageSv, nil
	case "tr":
		return FallbackCartesiaVoiceLanguageTr, nil
	}
	var t FallbackCartesiaVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackCartesiaVoiceLanguage) Ptr() *FallbackCartesiaVoiceLanguage {
	return &f
}

// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
type FallbackCartesiaVoiceModel string

const (
	FallbackCartesiaVoiceModelSonic2            FallbackCartesiaVoiceModel = "sonic-2"
	FallbackCartesiaVoiceModelSonicEnglish      FallbackCartesiaVoiceModel = "sonic-english"
	FallbackCartesiaVoiceModelSonicMultilingual FallbackCartesiaVoiceModel = "sonic-multilingual"
	FallbackCartesiaVoiceModelSonicPreview      FallbackCartesiaVoiceModel = "sonic-preview"
	FallbackCartesiaVoiceModelSonic             FallbackCartesiaVoiceModel = "sonic"
)

func NewFallbackCartesiaVoiceModelFromString(s string) (FallbackCartesiaVoiceModel, error) {
	switch s {
	case "sonic-2":
		return FallbackCartesiaVoiceModelSonic2, nil
	case "sonic-english":
		return FallbackCartesiaVoiceModelSonicEnglish, nil
	case "sonic-multilingual":
		return FallbackCartesiaVoiceModelSonicMultilingual, nil
	case "sonic-preview":
		return FallbackCartesiaVoiceModelSonicPreview, nil
	case "sonic":
		return FallbackCartesiaVoiceModelSonic, nil
	}
	var t FallbackCartesiaVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackCartesiaVoiceModel) Ptr() *FallbackCartesiaVoiceModel {
	return &f
}

type FallbackCustomTranscriber struct {
	// This is the transcription provider that will be used. Use `custom-transcriber` for providers that are not natively supported.
	// This is where the transcription request will be sent.
	//
	// Usage:
	// 1. Vapi will initiate a websocket connection with `server.url`.
	//
	// 2. Vapi will send an initial text frame with the sample rate. Format:
	// ```
	//
	//	{
	//	  "type": "start",
	//	  "encoding": "linear16", // 16-bit raw PCM format
	//	  "container": "raw",
	//	  "sampleRate": {{sampleRate}},
	//	  "channels": 2 // customer is channel 0, assistant is channel 1
	//	}
	//
	// ```
	//
	// 3. Vapi will send the audio data in 16-bit raw PCM format as binary frames.
	//
	// 4. You can read the messages something like this:
	// ```
	//
	//	ws.on('message', (data, isBinary) => {
	//	  if (isBinary) {
	//	    pcmBuffer = Buffer.concat([pcmBuffer, data]);
	//	    console.log(`Received PCM data, buffer size: ${pcmBuffer.length}`);
	//	  } else {
	//	    console.log('Received message:', JSON.parse(data.toString()));
	//	  }
	//	});
	//
	// ```
	//
	// 5. You will respond with transcriptions as you have them. Format:
	// ```
	//
	//	{
	//	   "type": "transcriber-response",
	//	   "transcription": "Hello, world!",
	//	   "channel": "customer" | "assistant"
	//	}
	//
	// ```
	Server   *Server `json:"server,omitempty" url:"server,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackCustomTranscriber) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FallbackCustomTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackCustomTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackCustomTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackCustomTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackCustomTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "custom-transcriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "custom-transcriber", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackCustomTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackCustomTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "custom-transcriber",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackCustomTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackCustomVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used. Use `custom-voice` for providers that are not natively supported.
	// This is where the voice request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "message": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected: 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackCustomVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackCustomVoice) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FallbackCustomVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackCustomVoice) Provider() string {
	return f.provider
}

func (f *FallbackCustomVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackCustomVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackCustomVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackCustomVoice(unmarshaler.embed)
	if unmarshaler.Provider != "custom-voice" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "custom-voice", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackCustomVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackCustomVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "custom-voice",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackCustomVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackDeepgramTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the Deepgram model that will be used. A list of models can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Model *DeepgramTranscriberModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Deepgram supports can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Language *DeepgramTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This will be use smart format option provided by Deepgram. It's default disabled because it can sometimes format numbers as times but it's getting better.
	SmartFormat *bool `json:"smartFormat,omitempty" url:"smartFormat,omitempty"`
	// This automatically switches the transcriber's language when the customer's language changes. Defaults to false.
	//
	// Usage:
	// - If your customers switch languages mid-call, you can set this to true.
	//
	// Note:
	// - To detect language changes, Vapi uses a custom trained model. Languages supported (X = limited support):
	//  1. Arabic
	//  2. Bengali
	//  3. Cantonese
	//  4. Chinese
	//  5. Chinese Simplified (X)
	//  6. Chinese Traditional (X)
	//  7. English
	//  8. Farsi (X)
	//  9. French
	//  10. German
	//  11. Haitian Creole (X)
	//  12. Hindi
	//  13. Italian
	//  14. Japanese
	//  15. Korean
	//  16. Portuguese
	//  17. Russian
	//  18. Spanish
	//  19. Thai
	//  20. Urdu
	//  21. Vietnamese
	//
	// - To receive `language-change-detected` webhook events, add it to `assistant.serverMessages`.
	//
	// @default false
	CodeSwitchingEnabled *bool `json:"codeSwitchingEnabled,omitempty" url:"codeSwitchingEnabled,omitempty"`
	// If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out
	//
	// This will only be used if you are using your own Deepgram API key.
	//
	// @default false
	MipOptOut *bool `json:"mipOptOut,omitempty" url:"mipOptOut,omitempty"`
	// If set to true, this will cause deepgram to convert spoken numbers to literal numerals. For example, "my phone number is nine-seven-two..." would become "my phone number is 972..."
	//
	// @default false
	Numerals *bool `json:"numerals,omitempty" url:"numerals,omitempty"`
	// Transcripts below this confidence threshold will be discarded.
	//
	// @default 0.4
	ConfidenceThreshold *float64 `json:"confidenceThreshold,omitempty" url:"confidenceThreshold,omitempty"`
	// These keywords are passed to the transcription model to help it pick up use-case specific words. Anything that may not be a common word, like your company name, should be added here.
	Keywords []string `json:"keywords,omitempty" url:"keywords,omitempty"`
	// Keyterm Prompting allows you improve Keyword Recall Rate (KRR) for important keyterms or phrases up to 90%.
	Keyterm []string `json:"keyterm,omitempty" url:"keyterm,omitempty"`
	// This is the timeout after which Deepgram will send transcription on user silence. You can read in-depth documentation here: https://developers.deepgram.com/docs/endpointing.
	//
	// Here are the most important bits:
	// - Defaults to 10. This is recommended for most use cases to optimize for latency.
	// - 10 can cause some missing transcriptions since because of the shorter context. This mostly happens for one-word utterances. For those uses cases, it's recommended to try 300. It will add a bit of latency but the quality and reliability of the experience will be better.
	// - If neither 10 nor 300 work, contact support@vapi.ai and we'll find another solution.
	//
	// @default 10
	Endpointing *float64 `json:"endpointing,omitempty" url:"endpointing,omitempty"`
	provider    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackDeepgramTranscriber) GetModel() *DeepgramTranscriberModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackDeepgramTranscriber) GetLanguage() *DeepgramTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackDeepgramTranscriber) GetSmartFormat() *bool {
	if f == nil {
		return nil
	}
	return f.SmartFormat
}

func (f *FallbackDeepgramTranscriber) GetCodeSwitchingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CodeSwitchingEnabled
}

func (f *FallbackDeepgramTranscriber) GetMipOptOut() *bool {
	if f == nil {
		return nil
	}
	return f.MipOptOut
}

func (f *FallbackDeepgramTranscriber) GetNumerals() *bool {
	if f == nil {
		return nil
	}
	return f.Numerals
}

func (f *FallbackDeepgramTranscriber) GetConfidenceThreshold() *float64 {
	if f == nil {
		return nil
	}
	return f.ConfidenceThreshold
}

func (f *FallbackDeepgramTranscriber) GetKeywords() []string {
	if f == nil {
		return nil
	}
	return f.Keywords
}

func (f *FallbackDeepgramTranscriber) GetKeyterm() []string {
	if f == nil {
		return nil
	}
	return f.Keyterm
}

func (f *FallbackDeepgramTranscriber) GetEndpointing() *float64 {
	if f == nil {
		return nil
	}
	return f.Endpointing
}

func (f *FallbackDeepgramTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackDeepgramTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackDeepgramTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackDeepgramTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackDeepgramTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "deepgram", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackDeepgramTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackDeepgramTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackDeepgramTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackDeepgramTranscriberLanguage string

const (
	FallbackDeepgramTranscriberLanguageBg      FallbackDeepgramTranscriberLanguage = "bg"
	FallbackDeepgramTranscriberLanguageCa      FallbackDeepgramTranscriberLanguage = "ca"
	FallbackDeepgramTranscriberLanguageCs      FallbackDeepgramTranscriberLanguage = "cs"
	FallbackDeepgramTranscriberLanguageDa      FallbackDeepgramTranscriberLanguage = "da"
	FallbackDeepgramTranscriberLanguageDaDk    FallbackDeepgramTranscriberLanguage = "da-DK"
	FallbackDeepgramTranscriberLanguageDe      FallbackDeepgramTranscriberLanguage = "de"
	FallbackDeepgramTranscriberLanguageDeCh    FallbackDeepgramTranscriberLanguage = "de-CH"
	FallbackDeepgramTranscriberLanguageEl      FallbackDeepgramTranscriberLanguage = "el"
	FallbackDeepgramTranscriberLanguageEn      FallbackDeepgramTranscriberLanguage = "en"
	FallbackDeepgramTranscriberLanguageEnAu    FallbackDeepgramTranscriberLanguage = "en-AU"
	FallbackDeepgramTranscriberLanguageEnGb    FallbackDeepgramTranscriberLanguage = "en-GB"
	FallbackDeepgramTranscriberLanguageEnIn    FallbackDeepgramTranscriberLanguage = "en-IN"
	FallbackDeepgramTranscriberLanguageEnNz    FallbackDeepgramTranscriberLanguage = "en-NZ"
	FallbackDeepgramTranscriberLanguageEnUs    FallbackDeepgramTranscriberLanguage = "en-US"
	FallbackDeepgramTranscriberLanguageEs      FallbackDeepgramTranscriberLanguage = "es"
	FallbackDeepgramTranscriberLanguageEs419   FallbackDeepgramTranscriberLanguage = "es-419"
	FallbackDeepgramTranscriberLanguageEsLatam FallbackDeepgramTranscriberLanguage = "es-LATAM"
	FallbackDeepgramTranscriberLanguageEt      FallbackDeepgramTranscriberLanguage = "et"
	FallbackDeepgramTranscriberLanguageFi      FallbackDeepgramTranscriberLanguage = "fi"
	FallbackDeepgramTranscriberLanguageFr      FallbackDeepgramTranscriberLanguage = "fr"
	FallbackDeepgramTranscriberLanguageFrCa    FallbackDeepgramTranscriberLanguage = "fr-CA"
	FallbackDeepgramTranscriberLanguageHi      FallbackDeepgramTranscriberLanguage = "hi"
	FallbackDeepgramTranscriberLanguageHiLatn  FallbackDeepgramTranscriberLanguage = "hi-Latn"
	FallbackDeepgramTranscriberLanguageHu      FallbackDeepgramTranscriberLanguage = "hu"
	FallbackDeepgramTranscriberLanguageId      FallbackDeepgramTranscriberLanguage = "id"
	FallbackDeepgramTranscriberLanguageIt      FallbackDeepgramTranscriberLanguage = "it"
	FallbackDeepgramTranscriberLanguageJa      FallbackDeepgramTranscriberLanguage = "ja"
	FallbackDeepgramTranscriberLanguageKo      FallbackDeepgramTranscriberLanguage = "ko"
	FallbackDeepgramTranscriberLanguageKoKr    FallbackDeepgramTranscriberLanguage = "ko-KR"
	FallbackDeepgramTranscriberLanguageLt      FallbackDeepgramTranscriberLanguage = "lt"
	FallbackDeepgramTranscriberLanguageLv      FallbackDeepgramTranscriberLanguage = "lv"
	FallbackDeepgramTranscriberLanguageMs      FallbackDeepgramTranscriberLanguage = "ms"
	FallbackDeepgramTranscriberLanguageMulti   FallbackDeepgramTranscriberLanguage = "multi"
	FallbackDeepgramTranscriberLanguageNl      FallbackDeepgramTranscriberLanguage = "nl"
	FallbackDeepgramTranscriberLanguageNlBe    FallbackDeepgramTranscriberLanguage = "nl-BE"
	FallbackDeepgramTranscriberLanguageNo      FallbackDeepgramTranscriberLanguage = "no"
	FallbackDeepgramTranscriberLanguagePl      FallbackDeepgramTranscriberLanguage = "pl"
	FallbackDeepgramTranscriberLanguagePt      FallbackDeepgramTranscriberLanguage = "pt"
	FallbackDeepgramTranscriberLanguagePtBr    FallbackDeepgramTranscriberLanguage = "pt-BR"
	FallbackDeepgramTranscriberLanguageRo      FallbackDeepgramTranscriberLanguage = "ro"
	FallbackDeepgramTranscriberLanguageRu      FallbackDeepgramTranscriberLanguage = "ru"
	FallbackDeepgramTranscriberLanguageSk      FallbackDeepgramTranscriberLanguage = "sk"
	FallbackDeepgramTranscriberLanguageSv      FallbackDeepgramTranscriberLanguage = "sv"
	FallbackDeepgramTranscriberLanguageSvSe    FallbackDeepgramTranscriberLanguage = "sv-SE"
	FallbackDeepgramTranscriberLanguageTa      FallbackDeepgramTranscriberLanguage = "ta"
	FallbackDeepgramTranscriberLanguageTaq     FallbackDeepgramTranscriberLanguage = "taq"
	FallbackDeepgramTranscriberLanguageTh      FallbackDeepgramTranscriberLanguage = "th"
	FallbackDeepgramTranscriberLanguageThTh    FallbackDeepgramTranscriberLanguage = "th-TH"
	FallbackDeepgramTranscriberLanguageTr      FallbackDeepgramTranscriberLanguage = "tr"
	FallbackDeepgramTranscriberLanguageUk      FallbackDeepgramTranscriberLanguage = "uk"
	FallbackDeepgramTranscriberLanguageVi      FallbackDeepgramTranscriberLanguage = "vi"
	FallbackDeepgramTranscriberLanguageZh      FallbackDeepgramTranscriberLanguage = "zh"
	FallbackDeepgramTranscriberLanguageZhCn    FallbackDeepgramTranscriberLanguage = "zh-CN"
	FallbackDeepgramTranscriberLanguageZhHans  FallbackDeepgramTranscriberLanguage = "zh-Hans"
	FallbackDeepgramTranscriberLanguageZhHant  FallbackDeepgramTranscriberLanguage = "zh-Hant"
	FallbackDeepgramTranscriberLanguageZhTw    FallbackDeepgramTranscriberLanguage = "zh-TW"
)

func NewFallbackDeepgramTranscriberLanguageFromString(s string) (FallbackDeepgramTranscriberLanguage, error) {
	switch s {
	case "bg":
		return FallbackDeepgramTranscriberLanguageBg, nil
	case "ca":
		return FallbackDeepgramTranscriberLanguageCa, nil
	case "cs":
		return FallbackDeepgramTranscriberLanguageCs, nil
	case "da":
		return FallbackDeepgramTranscriberLanguageDa, nil
	case "da-DK":
		return FallbackDeepgramTranscriberLanguageDaDk, nil
	case "de":
		return FallbackDeepgramTranscriberLanguageDe, nil
	case "de-CH":
		return FallbackDeepgramTranscriberLanguageDeCh, nil
	case "el":
		return FallbackDeepgramTranscriberLanguageEl, nil
	case "en":
		return FallbackDeepgramTranscriberLanguageEn, nil
	case "en-AU":
		return FallbackDeepgramTranscriberLanguageEnAu, nil
	case "en-GB":
		return FallbackDeepgramTranscriberLanguageEnGb, nil
	case "en-IN":
		return FallbackDeepgramTranscriberLanguageEnIn, nil
	case "en-NZ":
		return FallbackDeepgramTranscriberLanguageEnNz, nil
	case "en-US":
		return FallbackDeepgramTranscriberLanguageEnUs, nil
	case "es":
		return FallbackDeepgramTranscriberLanguageEs, nil
	case "es-419":
		return FallbackDeepgramTranscriberLanguageEs419, nil
	case "es-LATAM":
		return FallbackDeepgramTranscriberLanguageEsLatam, nil
	case "et":
		return FallbackDeepgramTranscriberLanguageEt, nil
	case "fi":
		return FallbackDeepgramTranscriberLanguageFi, nil
	case "fr":
		return FallbackDeepgramTranscriberLanguageFr, nil
	case "fr-CA":
		return FallbackDeepgramTranscriberLanguageFrCa, nil
	case "hi":
		return FallbackDeepgramTranscriberLanguageHi, nil
	case "hi-Latn":
		return FallbackDeepgramTranscriberLanguageHiLatn, nil
	case "hu":
		return FallbackDeepgramTranscriberLanguageHu, nil
	case "id":
		return FallbackDeepgramTranscriberLanguageId, nil
	case "it":
		return FallbackDeepgramTranscriberLanguageIt, nil
	case "ja":
		return FallbackDeepgramTranscriberLanguageJa, nil
	case "ko":
		return FallbackDeepgramTranscriberLanguageKo, nil
	case "ko-KR":
		return FallbackDeepgramTranscriberLanguageKoKr, nil
	case "lt":
		return FallbackDeepgramTranscriberLanguageLt, nil
	case "lv":
		return FallbackDeepgramTranscriberLanguageLv, nil
	case "ms":
		return FallbackDeepgramTranscriberLanguageMs, nil
	case "multi":
		return FallbackDeepgramTranscriberLanguageMulti, nil
	case "nl":
		return FallbackDeepgramTranscriberLanguageNl, nil
	case "nl-BE":
		return FallbackDeepgramTranscriberLanguageNlBe, nil
	case "no":
		return FallbackDeepgramTranscriberLanguageNo, nil
	case "pl":
		return FallbackDeepgramTranscriberLanguagePl, nil
	case "pt":
		return FallbackDeepgramTranscriberLanguagePt, nil
	case "pt-BR":
		return FallbackDeepgramTranscriberLanguagePtBr, nil
	case "ro":
		return FallbackDeepgramTranscriberLanguageRo, nil
	case "ru":
		return FallbackDeepgramTranscriberLanguageRu, nil
	case "sk":
		return FallbackDeepgramTranscriberLanguageSk, nil
	case "sv":
		return FallbackDeepgramTranscriberLanguageSv, nil
	case "sv-SE":
		return FallbackDeepgramTranscriberLanguageSvSe, nil
	case "ta":
		return FallbackDeepgramTranscriberLanguageTa, nil
	case "taq":
		return FallbackDeepgramTranscriberLanguageTaq, nil
	case "th":
		return FallbackDeepgramTranscriberLanguageTh, nil
	case "th-TH":
		return FallbackDeepgramTranscriberLanguageThTh, nil
	case "tr":
		return FallbackDeepgramTranscriberLanguageTr, nil
	case "uk":
		return FallbackDeepgramTranscriberLanguageUk, nil
	case "vi":
		return FallbackDeepgramTranscriberLanguageVi, nil
	case "zh":
		return FallbackDeepgramTranscriberLanguageZh, nil
	case "zh-CN":
		return FallbackDeepgramTranscriberLanguageZhCn, nil
	case "zh-Hans":
		return FallbackDeepgramTranscriberLanguageZhHans, nil
	case "zh-Hant":
		return FallbackDeepgramTranscriberLanguageZhHant, nil
	case "zh-TW":
		return FallbackDeepgramTranscriberLanguageZhTw, nil
	}
	var t FallbackDeepgramTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackDeepgramTranscriberLanguage) Ptr() *FallbackDeepgramTranscriberLanguage {
	return &f
}

type FallbackDeepgramTranscriberModel string

const (
	FallbackDeepgramTranscriberModelNova3                 FallbackDeepgramTranscriberModel = "nova-3"
	FallbackDeepgramTranscriberModelNova3General          FallbackDeepgramTranscriberModel = "nova-3-general"
	FallbackDeepgramTranscriberModelNova3Medical          FallbackDeepgramTranscriberModel = "nova-3-medical"
	FallbackDeepgramTranscriberModelNova2                 FallbackDeepgramTranscriberModel = "nova-2"
	FallbackDeepgramTranscriberModelNova2General          FallbackDeepgramTranscriberModel = "nova-2-general"
	FallbackDeepgramTranscriberModelNova2Meeting          FallbackDeepgramTranscriberModel = "nova-2-meeting"
	FallbackDeepgramTranscriberModelNova2Phonecall        FallbackDeepgramTranscriberModel = "nova-2-phonecall"
	FallbackDeepgramTranscriberModelNova2Finance          FallbackDeepgramTranscriberModel = "nova-2-finance"
	FallbackDeepgramTranscriberModelNova2Conversationalai FallbackDeepgramTranscriberModel = "nova-2-conversationalai"
	FallbackDeepgramTranscriberModelNova2Voicemail        FallbackDeepgramTranscriberModel = "nova-2-voicemail"
	FallbackDeepgramTranscriberModelNova2Video            FallbackDeepgramTranscriberModel = "nova-2-video"
	FallbackDeepgramTranscriberModelNova2Medical          FallbackDeepgramTranscriberModel = "nova-2-medical"
	FallbackDeepgramTranscriberModelNova2Drivethru        FallbackDeepgramTranscriberModel = "nova-2-drivethru"
	FallbackDeepgramTranscriberModelNova2Automotive       FallbackDeepgramTranscriberModel = "nova-2-automotive"
	FallbackDeepgramTranscriberModelNova                  FallbackDeepgramTranscriberModel = "nova"
	FallbackDeepgramTranscriberModelNovaGeneral           FallbackDeepgramTranscriberModel = "nova-general"
	FallbackDeepgramTranscriberModelNovaPhonecall         FallbackDeepgramTranscriberModel = "nova-phonecall"
	FallbackDeepgramTranscriberModelNovaMedical           FallbackDeepgramTranscriberModel = "nova-medical"
	FallbackDeepgramTranscriberModelEnhanced              FallbackDeepgramTranscriberModel = "enhanced"
	FallbackDeepgramTranscriberModelEnhancedGeneral       FallbackDeepgramTranscriberModel = "enhanced-general"
	FallbackDeepgramTranscriberModelEnhancedMeeting       FallbackDeepgramTranscriberModel = "enhanced-meeting"
	FallbackDeepgramTranscriberModelEnhancedPhonecall     FallbackDeepgramTranscriberModel = "enhanced-phonecall"
	FallbackDeepgramTranscriberModelEnhancedFinance       FallbackDeepgramTranscriberModel = "enhanced-finance"
	FallbackDeepgramTranscriberModelBase                  FallbackDeepgramTranscriberModel = "base"
	FallbackDeepgramTranscriberModelBaseGeneral           FallbackDeepgramTranscriberModel = "base-general"
	FallbackDeepgramTranscriberModelBaseMeeting           FallbackDeepgramTranscriberModel = "base-meeting"
	FallbackDeepgramTranscriberModelBasePhonecall         FallbackDeepgramTranscriberModel = "base-phonecall"
	FallbackDeepgramTranscriberModelBaseFinance           FallbackDeepgramTranscriberModel = "base-finance"
	FallbackDeepgramTranscriberModelBaseConversationalai  FallbackDeepgramTranscriberModel = "base-conversationalai"
	FallbackDeepgramTranscriberModelBaseVoicemail         FallbackDeepgramTranscriberModel = "base-voicemail"
	FallbackDeepgramTranscriberModelBaseVideo             FallbackDeepgramTranscriberModel = "base-video"
)

func NewFallbackDeepgramTranscriberModelFromString(s string) (FallbackDeepgramTranscriberModel, error) {
	switch s {
	case "nova-3":
		return FallbackDeepgramTranscriberModelNova3, nil
	case "nova-3-general":
		return FallbackDeepgramTranscriberModelNova3General, nil
	case "nova-3-medical":
		return FallbackDeepgramTranscriberModelNova3Medical, nil
	case "nova-2":
		return FallbackDeepgramTranscriberModelNova2, nil
	case "nova-2-general":
		return FallbackDeepgramTranscriberModelNova2General, nil
	case "nova-2-meeting":
		return FallbackDeepgramTranscriberModelNova2Meeting, nil
	case "nova-2-phonecall":
		return FallbackDeepgramTranscriberModelNova2Phonecall, nil
	case "nova-2-finance":
		return FallbackDeepgramTranscriberModelNova2Finance, nil
	case "nova-2-conversationalai":
		return FallbackDeepgramTranscriberModelNova2Conversationalai, nil
	case "nova-2-voicemail":
		return FallbackDeepgramTranscriberModelNova2Voicemail, nil
	case "nova-2-video":
		return FallbackDeepgramTranscriberModelNova2Video, nil
	case "nova-2-medical":
		return FallbackDeepgramTranscriberModelNova2Medical, nil
	case "nova-2-drivethru":
		return FallbackDeepgramTranscriberModelNova2Drivethru, nil
	case "nova-2-automotive":
		return FallbackDeepgramTranscriberModelNova2Automotive, nil
	case "nova":
		return FallbackDeepgramTranscriberModelNova, nil
	case "nova-general":
		return FallbackDeepgramTranscriberModelNovaGeneral, nil
	case "nova-phonecall":
		return FallbackDeepgramTranscriberModelNovaPhonecall, nil
	case "nova-medical":
		return FallbackDeepgramTranscriberModelNovaMedical, nil
	case "enhanced":
		return FallbackDeepgramTranscriberModelEnhanced, nil
	case "enhanced-general":
		return FallbackDeepgramTranscriberModelEnhancedGeneral, nil
	case "enhanced-meeting":
		return FallbackDeepgramTranscriberModelEnhancedMeeting, nil
	case "enhanced-phonecall":
		return FallbackDeepgramTranscriberModelEnhancedPhonecall, nil
	case "enhanced-finance":
		return FallbackDeepgramTranscriberModelEnhancedFinance, nil
	case "base":
		return FallbackDeepgramTranscriberModelBase, nil
	case "base-general":
		return FallbackDeepgramTranscriberModelBaseGeneral, nil
	case "base-meeting":
		return FallbackDeepgramTranscriberModelBaseMeeting, nil
	case "base-phonecall":
		return FallbackDeepgramTranscriberModelBasePhonecall, nil
	case "base-finance":
		return FallbackDeepgramTranscriberModelBaseFinance, nil
	case "base-conversationalai":
		return FallbackDeepgramTranscriberModelBaseConversationalai, nil
	case "base-voicemail":
		return FallbackDeepgramTranscriberModelBaseVoicemail, nil
	case "base-video":
		return FallbackDeepgramTranscriberModelBaseVideo, nil
	}
	var t FallbackDeepgramTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackDeepgramTranscriberModel) Ptr() *FallbackDeepgramTranscriberModel {
	return &f
}

type FallbackDeepgramVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId FallbackDeepgramVoiceId `json:"voiceId" url:"voiceId"`
	// This is the model that will be used. Defaults to 'aura-2' when not specified.
	Model *FallbackDeepgramVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out
	//
	// This will only be used if you are using your own Deepgram API key.
	//
	// @default false
	MipOptOut *bool `json:"mipOptOut,omitempty" url:"mipOptOut,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackDeepgramVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackDeepgramVoice) GetVoiceId() FallbackDeepgramVoiceId {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackDeepgramVoice) GetModel() *FallbackDeepgramVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackDeepgramVoice) GetMipOptOut() *bool {
	if f == nil {
		return nil
	}
	return f.MipOptOut
}

func (f *FallbackDeepgramVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackDeepgramVoice) Provider() string {
	return f.provider
}

func (f *FallbackDeepgramVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackDeepgramVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackDeepgramVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackDeepgramVoice(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "deepgram", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackDeepgramVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackDeepgramVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackDeepgramVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackDeepgramVoiceId string

const (
	FallbackDeepgramVoiceIdAsteria   FallbackDeepgramVoiceId = "asteria"
	FallbackDeepgramVoiceIdLuna      FallbackDeepgramVoiceId = "luna"
	FallbackDeepgramVoiceIdStella    FallbackDeepgramVoiceId = "stella"
	FallbackDeepgramVoiceIdAthena    FallbackDeepgramVoiceId = "athena"
	FallbackDeepgramVoiceIdHera      FallbackDeepgramVoiceId = "hera"
	FallbackDeepgramVoiceIdOrion     FallbackDeepgramVoiceId = "orion"
	FallbackDeepgramVoiceIdArcas     FallbackDeepgramVoiceId = "arcas"
	FallbackDeepgramVoiceIdPerseus   FallbackDeepgramVoiceId = "perseus"
	FallbackDeepgramVoiceIdAngus     FallbackDeepgramVoiceId = "angus"
	FallbackDeepgramVoiceIdOrpheus   FallbackDeepgramVoiceId = "orpheus"
	FallbackDeepgramVoiceIdHelios    FallbackDeepgramVoiceId = "helios"
	FallbackDeepgramVoiceIdZeus      FallbackDeepgramVoiceId = "zeus"
	FallbackDeepgramVoiceIdThalia    FallbackDeepgramVoiceId = "thalia"
	FallbackDeepgramVoiceIdAndromeda FallbackDeepgramVoiceId = "andromeda"
	FallbackDeepgramVoiceIdHelena    FallbackDeepgramVoiceId = "helena"
	FallbackDeepgramVoiceIdApollo    FallbackDeepgramVoiceId = "apollo"
	FallbackDeepgramVoiceIdAries     FallbackDeepgramVoiceId = "aries"
	FallbackDeepgramVoiceIdAmalthea  FallbackDeepgramVoiceId = "amalthea"
	FallbackDeepgramVoiceIdAtlas     FallbackDeepgramVoiceId = "atlas"
	FallbackDeepgramVoiceIdAurora    FallbackDeepgramVoiceId = "aurora"
	FallbackDeepgramVoiceIdCallista  FallbackDeepgramVoiceId = "callista"
	FallbackDeepgramVoiceIdCora      FallbackDeepgramVoiceId = "cora"
	FallbackDeepgramVoiceIdCordelia  FallbackDeepgramVoiceId = "cordelia"
	FallbackDeepgramVoiceIdDelia     FallbackDeepgramVoiceId = "delia"
	FallbackDeepgramVoiceIdDraco     FallbackDeepgramVoiceId = "draco"
	FallbackDeepgramVoiceIdElectra   FallbackDeepgramVoiceId = "electra"
	FallbackDeepgramVoiceIdHarmonia  FallbackDeepgramVoiceId = "harmonia"
	FallbackDeepgramVoiceIdHermes    FallbackDeepgramVoiceId = "hermes"
	FallbackDeepgramVoiceIdHyperion  FallbackDeepgramVoiceId = "hyperion"
	FallbackDeepgramVoiceIdIris      FallbackDeepgramVoiceId = "iris"
	FallbackDeepgramVoiceIdJanus     FallbackDeepgramVoiceId = "janus"
	FallbackDeepgramVoiceIdJuno      FallbackDeepgramVoiceId = "juno"
	FallbackDeepgramVoiceIdJupiter   FallbackDeepgramVoiceId = "jupiter"
	FallbackDeepgramVoiceIdMars      FallbackDeepgramVoiceId = "mars"
	FallbackDeepgramVoiceIdMinerva   FallbackDeepgramVoiceId = "minerva"
	FallbackDeepgramVoiceIdNeptune   FallbackDeepgramVoiceId = "neptune"
	FallbackDeepgramVoiceIdOdysseus  FallbackDeepgramVoiceId = "odysseus"
	FallbackDeepgramVoiceIdOphelia   FallbackDeepgramVoiceId = "ophelia"
	FallbackDeepgramVoiceIdPandora   FallbackDeepgramVoiceId = "pandora"
	FallbackDeepgramVoiceIdPhoebe    FallbackDeepgramVoiceId = "phoebe"
	FallbackDeepgramVoiceIdPluto     FallbackDeepgramVoiceId = "pluto"
	FallbackDeepgramVoiceIdSaturn    FallbackDeepgramVoiceId = "saturn"
	FallbackDeepgramVoiceIdSelene    FallbackDeepgramVoiceId = "selene"
	FallbackDeepgramVoiceIdTheia     FallbackDeepgramVoiceId = "theia"
	FallbackDeepgramVoiceIdVesta     FallbackDeepgramVoiceId = "vesta"
)

func NewFallbackDeepgramVoiceIdFromString(s string) (FallbackDeepgramVoiceId, error) {
	switch s {
	case "asteria":
		return FallbackDeepgramVoiceIdAsteria, nil
	case "luna":
		return FallbackDeepgramVoiceIdLuna, nil
	case "stella":
		return FallbackDeepgramVoiceIdStella, nil
	case "athena":
		return FallbackDeepgramVoiceIdAthena, nil
	case "hera":
		return FallbackDeepgramVoiceIdHera, nil
	case "orion":
		return FallbackDeepgramVoiceIdOrion, nil
	case "arcas":
		return FallbackDeepgramVoiceIdArcas, nil
	case "perseus":
		return FallbackDeepgramVoiceIdPerseus, nil
	case "angus":
		return FallbackDeepgramVoiceIdAngus, nil
	case "orpheus":
		return FallbackDeepgramVoiceIdOrpheus, nil
	case "helios":
		return FallbackDeepgramVoiceIdHelios, nil
	case "zeus":
		return FallbackDeepgramVoiceIdZeus, nil
	case "thalia":
		return FallbackDeepgramVoiceIdThalia, nil
	case "andromeda":
		return FallbackDeepgramVoiceIdAndromeda, nil
	case "helena":
		return FallbackDeepgramVoiceIdHelena, nil
	case "apollo":
		return FallbackDeepgramVoiceIdApollo, nil
	case "aries":
		return FallbackDeepgramVoiceIdAries, nil
	case "amalthea":
		return FallbackDeepgramVoiceIdAmalthea, nil
	case "atlas":
		return FallbackDeepgramVoiceIdAtlas, nil
	case "aurora":
		return FallbackDeepgramVoiceIdAurora, nil
	case "callista":
		return FallbackDeepgramVoiceIdCallista, nil
	case "cora":
		return FallbackDeepgramVoiceIdCora, nil
	case "cordelia":
		return FallbackDeepgramVoiceIdCordelia, nil
	case "delia":
		return FallbackDeepgramVoiceIdDelia, nil
	case "draco":
		return FallbackDeepgramVoiceIdDraco, nil
	case "electra":
		return FallbackDeepgramVoiceIdElectra, nil
	case "harmonia":
		return FallbackDeepgramVoiceIdHarmonia, nil
	case "hermes":
		return FallbackDeepgramVoiceIdHermes, nil
	case "hyperion":
		return FallbackDeepgramVoiceIdHyperion, nil
	case "iris":
		return FallbackDeepgramVoiceIdIris, nil
	case "janus":
		return FallbackDeepgramVoiceIdJanus, nil
	case "juno":
		return FallbackDeepgramVoiceIdJuno, nil
	case "jupiter":
		return FallbackDeepgramVoiceIdJupiter, nil
	case "mars":
		return FallbackDeepgramVoiceIdMars, nil
	case "minerva":
		return FallbackDeepgramVoiceIdMinerva, nil
	case "neptune":
		return FallbackDeepgramVoiceIdNeptune, nil
	case "odysseus":
		return FallbackDeepgramVoiceIdOdysseus, nil
	case "ophelia":
		return FallbackDeepgramVoiceIdOphelia, nil
	case "pandora":
		return FallbackDeepgramVoiceIdPandora, nil
	case "phoebe":
		return FallbackDeepgramVoiceIdPhoebe, nil
	case "pluto":
		return FallbackDeepgramVoiceIdPluto, nil
	case "saturn":
		return FallbackDeepgramVoiceIdSaturn, nil
	case "selene":
		return FallbackDeepgramVoiceIdSelene, nil
	case "theia":
		return FallbackDeepgramVoiceIdTheia, nil
	case "vesta":
		return FallbackDeepgramVoiceIdVesta, nil
	}
	var t FallbackDeepgramVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackDeepgramVoiceId) Ptr() *FallbackDeepgramVoiceId {
	return &f
}

// This is the model that will be used. Defaults to 'aura-2' when not specified.
type FallbackDeepgramVoiceModel string

const (
	FallbackDeepgramVoiceModelAura  FallbackDeepgramVoiceModel = "aura"
	FallbackDeepgramVoiceModelAura2 FallbackDeepgramVoiceModel = "aura-2"
)

func NewFallbackDeepgramVoiceModelFromString(s string) (FallbackDeepgramVoiceModel, error) {
	switch s {
	case "aura":
		return FallbackDeepgramVoiceModelAura, nil
	case "aura-2":
		return FallbackDeepgramVoiceModelAura2, nil
	}
	var t FallbackDeepgramVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackDeepgramVoiceModel) Ptr() *FallbackDeepgramVoiceModel {
	return &f
}

type FallbackElevenLabsTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model    *string                                `json:"model,omitempty" url:"model,omitempty"`
	Language *FallbackElevenLabsTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackElevenLabsTranscriber) GetLanguage() *FallbackElevenLabsTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackElevenLabsTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackElevenLabsTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackElevenLabsTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackElevenLabsTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackElevenLabsTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "11labs", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackElevenLabsTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackElevenLabsTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackElevenLabsTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackElevenLabsTranscriberLanguage string

const (
	FallbackElevenLabsTranscriberLanguageAa  FallbackElevenLabsTranscriberLanguage = "aa"
	FallbackElevenLabsTranscriberLanguageAb  FallbackElevenLabsTranscriberLanguage = "ab"
	FallbackElevenLabsTranscriberLanguageAe  FallbackElevenLabsTranscriberLanguage = "ae"
	FallbackElevenLabsTranscriberLanguageAf  FallbackElevenLabsTranscriberLanguage = "af"
	FallbackElevenLabsTranscriberLanguageAk  FallbackElevenLabsTranscriberLanguage = "ak"
	FallbackElevenLabsTranscriberLanguageAm  FallbackElevenLabsTranscriberLanguage = "am"
	FallbackElevenLabsTranscriberLanguageAn  FallbackElevenLabsTranscriberLanguage = "an"
	FallbackElevenLabsTranscriberLanguageAr  FallbackElevenLabsTranscriberLanguage = "ar"
	FallbackElevenLabsTranscriberLanguageAs  FallbackElevenLabsTranscriberLanguage = "as"
	FallbackElevenLabsTranscriberLanguageAv  FallbackElevenLabsTranscriberLanguage = "av"
	FallbackElevenLabsTranscriberLanguageAy  FallbackElevenLabsTranscriberLanguage = "ay"
	FallbackElevenLabsTranscriberLanguageAz  FallbackElevenLabsTranscriberLanguage = "az"
	FallbackElevenLabsTranscriberLanguageBa  FallbackElevenLabsTranscriberLanguage = "ba"
	FallbackElevenLabsTranscriberLanguageBe  FallbackElevenLabsTranscriberLanguage = "be"
	FallbackElevenLabsTranscriberLanguageBg  FallbackElevenLabsTranscriberLanguage = "bg"
	FallbackElevenLabsTranscriberLanguageBh  FallbackElevenLabsTranscriberLanguage = "bh"
	FallbackElevenLabsTranscriberLanguageBi  FallbackElevenLabsTranscriberLanguage = "bi"
	FallbackElevenLabsTranscriberLanguageBm  FallbackElevenLabsTranscriberLanguage = "bm"
	FallbackElevenLabsTranscriberLanguageBn  FallbackElevenLabsTranscriberLanguage = "bn"
	FallbackElevenLabsTranscriberLanguageBo  FallbackElevenLabsTranscriberLanguage = "bo"
	FallbackElevenLabsTranscriberLanguageBr  FallbackElevenLabsTranscriberLanguage = "br"
	FallbackElevenLabsTranscriberLanguageBs  FallbackElevenLabsTranscriberLanguage = "bs"
	FallbackElevenLabsTranscriberLanguageCa  FallbackElevenLabsTranscriberLanguage = "ca"
	FallbackElevenLabsTranscriberLanguageCe  FallbackElevenLabsTranscriberLanguage = "ce"
	FallbackElevenLabsTranscriberLanguageCh  FallbackElevenLabsTranscriberLanguage = "ch"
	FallbackElevenLabsTranscriberLanguageCo  FallbackElevenLabsTranscriberLanguage = "co"
	FallbackElevenLabsTranscriberLanguageCr  FallbackElevenLabsTranscriberLanguage = "cr"
	FallbackElevenLabsTranscriberLanguageCs  FallbackElevenLabsTranscriberLanguage = "cs"
	FallbackElevenLabsTranscriberLanguageCu  FallbackElevenLabsTranscriberLanguage = "cu"
	FallbackElevenLabsTranscriberLanguageCv  FallbackElevenLabsTranscriberLanguage = "cv"
	FallbackElevenLabsTranscriberLanguageCy  FallbackElevenLabsTranscriberLanguage = "cy"
	FallbackElevenLabsTranscriberLanguageDa  FallbackElevenLabsTranscriberLanguage = "da"
	FallbackElevenLabsTranscriberLanguageDe  FallbackElevenLabsTranscriberLanguage = "de"
	FallbackElevenLabsTranscriberLanguageDv  FallbackElevenLabsTranscriberLanguage = "dv"
	FallbackElevenLabsTranscriberLanguageDz  FallbackElevenLabsTranscriberLanguage = "dz"
	FallbackElevenLabsTranscriberLanguageEe  FallbackElevenLabsTranscriberLanguage = "ee"
	FallbackElevenLabsTranscriberLanguageEl  FallbackElevenLabsTranscriberLanguage = "el"
	FallbackElevenLabsTranscriberLanguageEn  FallbackElevenLabsTranscriberLanguage = "en"
	FallbackElevenLabsTranscriberLanguageEo  FallbackElevenLabsTranscriberLanguage = "eo"
	FallbackElevenLabsTranscriberLanguageEs  FallbackElevenLabsTranscriberLanguage = "es"
	FallbackElevenLabsTranscriberLanguageEt  FallbackElevenLabsTranscriberLanguage = "et"
	FallbackElevenLabsTranscriberLanguageEu  FallbackElevenLabsTranscriberLanguage = "eu"
	FallbackElevenLabsTranscriberLanguageFa  FallbackElevenLabsTranscriberLanguage = "fa"
	FallbackElevenLabsTranscriberLanguageFf  FallbackElevenLabsTranscriberLanguage = "ff"
	FallbackElevenLabsTranscriberLanguageFi  FallbackElevenLabsTranscriberLanguage = "fi"
	FallbackElevenLabsTranscriberLanguageFj  FallbackElevenLabsTranscriberLanguage = "fj"
	FallbackElevenLabsTranscriberLanguageFo  FallbackElevenLabsTranscriberLanguage = "fo"
	FallbackElevenLabsTranscriberLanguageFr  FallbackElevenLabsTranscriberLanguage = "fr"
	FallbackElevenLabsTranscriberLanguageFy  FallbackElevenLabsTranscriberLanguage = "fy"
	FallbackElevenLabsTranscriberLanguageGa  FallbackElevenLabsTranscriberLanguage = "ga"
	FallbackElevenLabsTranscriberLanguageGd  FallbackElevenLabsTranscriberLanguage = "gd"
	FallbackElevenLabsTranscriberLanguageGl  FallbackElevenLabsTranscriberLanguage = "gl"
	FallbackElevenLabsTranscriberLanguageGn  FallbackElevenLabsTranscriberLanguage = "gn"
	FallbackElevenLabsTranscriberLanguageGu  FallbackElevenLabsTranscriberLanguage = "gu"
	FallbackElevenLabsTranscriberLanguageGv  FallbackElevenLabsTranscriberLanguage = "gv"
	FallbackElevenLabsTranscriberLanguageHa  FallbackElevenLabsTranscriberLanguage = "ha"
	FallbackElevenLabsTranscriberLanguageHe  FallbackElevenLabsTranscriberLanguage = "he"
	FallbackElevenLabsTranscriberLanguageHi  FallbackElevenLabsTranscriberLanguage = "hi"
	FallbackElevenLabsTranscriberLanguageHo  FallbackElevenLabsTranscriberLanguage = "ho"
	FallbackElevenLabsTranscriberLanguageHr  FallbackElevenLabsTranscriberLanguage = "hr"
	FallbackElevenLabsTranscriberLanguageHt  FallbackElevenLabsTranscriberLanguage = "ht"
	FallbackElevenLabsTranscriberLanguageHu  FallbackElevenLabsTranscriberLanguage = "hu"
	FallbackElevenLabsTranscriberLanguageHy  FallbackElevenLabsTranscriberLanguage = "hy"
	FallbackElevenLabsTranscriberLanguageHz  FallbackElevenLabsTranscriberLanguage = "hz"
	FallbackElevenLabsTranscriberLanguageIa  FallbackElevenLabsTranscriberLanguage = "ia"
	FallbackElevenLabsTranscriberLanguageId  FallbackElevenLabsTranscriberLanguage = "id"
	FallbackElevenLabsTranscriberLanguageIe  FallbackElevenLabsTranscriberLanguage = "ie"
	FallbackElevenLabsTranscriberLanguageIg  FallbackElevenLabsTranscriberLanguage = "ig"
	FallbackElevenLabsTranscriberLanguageIi  FallbackElevenLabsTranscriberLanguage = "ii"
	FallbackElevenLabsTranscriberLanguageIk  FallbackElevenLabsTranscriberLanguage = "ik"
	FallbackElevenLabsTranscriberLanguageIo  FallbackElevenLabsTranscriberLanguage = "io"
	FallbackElevenLabsTranscriberLanguageIs  FallbackElevenLabsTranscriberLanguage = "is"
	FallbackElevenLabsTranscriberLanguageIt  FallbackElevenLabsTranscriberLanguage = "it"
	FallbackElevenLabsTranscriberLanguageIu  FallbackElevenLabsTranscriberLanguage = "iu"
	FallbackElevenLabsTranscriberLanguageJa  FallbackElevenLabsTranscriberLanguage = "ja"
	FallbackElevenLabsTranscriberLanguageJv  FallbackElevenLabsTranscriberLanguage = "jv"
	FallbackElevenLabsTranscriberLanguageKa  FallbackElevenLabsTranscriberLanguage = "ka"
	FallbackElevenLabsTranscriberLanguageKg  FallbackElevenLabsTranscriberLanguage = "kg"
	FallbackElevenLabsTranscriberLanguageKi  FallbackElevenLabsTranscriberLanguage = "ki"
	FallbackElevenLabsTranscriberLanguageKj  FallbackElevenLabsTranscriberLanguage = "kj"
	FallbackElevenLabsTranscriberLanguageKk  FallbackElevenLabsTranscriberLanguage = "kk"
	FallbackElevenLabsTranscriberLanguageKl  FallbackElevenLabsTranscriberLanguage = "kl"
	FallbackElevenLabsTranscriberLanguageKm  FallbackElevenLabsTranscriberLanguage = "km"
	FallbackElevenLabsTranscriberLanguageKn  FallbackElevenLabsTranscriberLanguage = "kn"
	FallbackElevenLabsTranscriberLanguageKo  FallbackElevenLabsTranscriberLanguage = "ko"
	FallbackElevenLabsTranscriberLanguageKr  FallbackElevenLabsTranscriberLanguage = "kr"
	FallbackElevenLabsTranscriberLanguageKs  FallbackElevenLabsTranscriberLanguage = "ks"
	FallbackElevenLabsTranscriberLanguageKu  FallbackElevenLabsTranscriberLanguage = "ku"
	FallbackElevenLabsTranscriberLanguageKv  FallbackElevenLabsTranscriberLanguage = "kv"
	FallbackElevenLabsTranscriberLanguageKw  FallbackElevenLabsTranscriberLanguage = "kw"
	FallbackElevenLabsTranscriberLanguageKy  FallbackElevenLabsTranscriberLanguage = "ky"
	FallbackElevenLabsTranscriberLanguageLa  FallbackElevenLabsTranscriberLanguage = "la"
	FallbackElevenLabsTranscriberLanguageLb  FallbackElevenLabsTranscriberLanguage = "lb"
	FallbackElevenLabsTranscriberLanguageLg  FallbackElevenLabsTranscriberLanguage = "lg"
	FallbackElevenLabsTranscriberLanguageLi  FallbackElevenLabsTranscriberLanguage = "li"
	FallbackElevenLabsTranscriberLanguageLn  FallbackElevenLabsTranscriberLanguage = "ln"
	FallbackElevenLabsTranscriberLanguageLo  FallbackElevenLabsTranscriberLanguage = "lo"
	FallbackElevenLabsTranscriberLanguageLt  FallbackElevenLabsTranscriberLanguage = "lt"
	FallbackElevenLabsTranscriberLanguageLu  FallbackElevenLabsTranscriberLanguage = "lu"
	FallbackElevenLabsTranscriberLanguageLv  FallbackElevenLabsTranscriberLanguage = "lv"
	FallbackElevenLabsTranscriberLanguageMg  FallbackElevenLabsTranscriberLanguage = "mg"
	FallbackElevenLabsTranscriberLanguageMh  FallbackElevenLabsTranscriberLanguage = "mh"
	FallbackElevenLabsTranscriberLanguageMi  FallbackElevenLabsTranscriberLanguage = "mi"
	FallbackElevenLabsTranscriberLanguageMk  FallbackElevenLabsTranscriberLanguage = "mk"
	FallbackElevenLabsTranscriberLanguageMl  FallbackElevenLabsTranscriberLanguage = "ml"
	FallbackElevenLabsTranscriberLanguageMn  FallbackElevenLabsTranscriberLanguage = "mn"
	FallbackElevenLabsTranscriberLanguageMr  FallbackElevenLabsTranscriberLanguage = "mr"
	FallbackElevenLabsTranscriberLanguageMs  FallbackElevenLabsTranscriberLanguage = "ms"
	FallbackElevenLabsTranscriberLanguageMt  FallbackElevenLabsTranscriberLanguage = "mt"
	FallbackElevenLabsTranscriberLanguageMy  FallbackElevenLabsTranscriberLanguage = "my"
	FallbackElevenLabsTranscriberLanguageNa  FallbackElevenLabsTranscriberLanguage = "na"
	FallbackElevenLabsTranscriberLanguageNb  FallbackElevenLabsTranscriberLanguage = "nb"
	FallbackElevenLabsTranscriberLanguageNd  FallbackElevenLabsTranscriberLanguage = "nd"
	FallbackElevenLabsTranscriberLanguageNe  FallbackElevenLabsTranscriberLanguage = "ne"
	FallbackElevenLabsTranscriberLanguageNg  FallbackElevenLabsTranscriberLanguage = "ng"
	FallbackElevenLabsTranscriberLanguageNl  FallbackElevenLabsTranscriberLanguage = "nl"
	FallbackElevenLabsTranscriberLanguageNn  FallbackElevenLabsTranscriberLanguage = "nn"
	FallbackElevenLabsTranscriberLanguageNo  FallbackElevenLabsTranscriberLanguage = "no"
	FallbackElevenLabsTranscriberLanguageNr  FallbackElevenLabsTranscriberLanguage = "nr"
	FallbackElevenLabsTranscriberLanguageNv  FallbackElevenLabsTranscriberLanguage = "nv"
	FallbackElevenLabsTranscriberLanguageNy  FallbackElevenLabsTranscriberLanguage = "ny"
	FallbackElevenLabsTranscriberLanguageOc  FallbackElevenLabsTranscriberLanguage = "oc"
	FallbackElevenLabsTranscriberLanguageOj  FallbackElevenLabsTranscriberLanguage = "oj"
	FallbackElevenLabsTranscriberLanguageOm  FallbackElevenLabsTranscriberLanguage = "om"
	FallbackElevenLabsTranscriberLanguageOr  FallbackElevenLabsTranscriberLanguage = "or"
	FallbackElevenLabsTranscriberLanguageOs  FallbackElevenLabsTranscriberLanguage = "os"
	FallbackElevenLabsTranscriberLanguagePa  FallbackElevenLabsTranscriberLanguage = "pa"
	FallbackElevenLabsTranscriberLanguagePi  FallbackElevenLabsTranscriberLanguage = "pi"
	FallbackElevenLabsTranscriberLanguagePl  FallbackElevenLabsTranscriberLanguage = "pl"
	FallbackElevenLabsTranscriberLanguagePs  FallbackElevenLabsTranscriberLanguage = "ps"
	FallbackElevenLabsTranscriberLanguagePt  FallbackElevenLabsTranscriberLanguage = "pt"
	FallbackElevenLabsTranscriberLanguageQu  FallbackElevenLabsTranscriberLanguage = "qu"
	FallbackElevenLabsTranscriberLanguageRm  FallbackElevenLabsTranscriberLanguage = "rm"
	FallbackElevenLabsTranscriberLanguageRn  FallbackElevenLabsTranscriberLanguage = "rn"
	FallbackElevenLabsTranscriberLanguageRo  FallbackElevenLabsTranscriberLanguage = "ro"
	FallbackElevenLabsTranscriberLanguageRu  FallbackElevenLabsTranscriberLanguage = "ru"
	FallbackElevenLabsTranscriberLanguageRw  FallbackElevenLabsTranscriberLanguage = "rw"
	FallbackElevenLabsTranscriberLanguageSa  FallbackElevenLabsTranscriberLanguage = "sa"
	FallbackElevenLabsTranscriberLanguageSc  FallbackElevenLabsTranscriberLanguage = "sc"
	FallbackElevenLabsTranscriberLanguageSd  FallbackElevenLabsTranscriberLanguage = "sd"
	FallbackElevenLabsTranscriberLanguageSe  FallbackElevenLabsTranscriberLanguage = "se"
	FallbackElevenLabsTranscriberLanguageSg  FallbackElevenLabsTranscriberLanguage = "sg"
	FallbackElevenLabsTranscriberLanguageSi  FallbackElevenLabsTranscriberLanguage = "si"
	FallbackElevenLabsTranscriberLanguageSk  FallbackElevenLabsTranscriberLanguage = "sk"
	FallbackElevenLabsTranscriberLanguageSl  FallbackElevenLabsTranscriberLanguage = "sl"
	FallbackElevenLabsTranscriberLanguageSm  FallbackElevenLabsTranscriberLanguage = "sm"
	FallbackElevenLabsTranscriberLanguageSn  FallbackElevenLabsTranscriberLanguage = "sn"
	FallbackElevenLabsTranscriberLanguageSo  FallbackElevenLabsTranscriberLanguage = "so"
	FallbackElevenLabsTranscriberLanguageSq  FallbackElevenLabsTranscriberLanguage = "sq"
	FallbackElevenLabsTranscriberLanguageSr  FallbackElevenLabsTranscriberLanguage = "sr"
	FallbackElevenLabsTranscriberLanguageSs  FallbackElevenLabsTranscriberLanguage = "ss"
	FallbackElevenLabsTranscriberLanguageSt  FallbackElevenLabsTranscriberLanguage = "st"
	FallbackElevenLabsTranscriberLanguageSu  FallbackElevenLabsTranscriberLanguage = "su"
	FallbackElevenLabsTranscriberLanguageSv  FallbackElevenLabsTranscriberLanguage = "sv"
	FallbackElevenLabsTranscriberLanguageSw  FallbackElevenLabsTranscriberLanguage = "sw"
	FallbackElevenLabsTranscriberLanguageTa  FallbackElevenLabsTranscriberLanguage = "ta"
	FallbackElevenLabsTranscriberLanguageTe  FallbackElevenLabsTranscriberLanguage = "te"
	FallbackElevenLabsTranscriberLanguageTg  FallbackElevenLabsTranscriberLanguage = "tg"
	FallbackElevenLabsTranscriberLanguageTh  FallbackElevenLabsTranscriberLanguage = "th"
	FallbackElevenLabsTranscriberLanguageTi  FallbackElevenLabsTranscriberLanguage = "ti"
	FallbackElevenLabsTranscriberLanguageTk  FallbackElevenLabsTranscriberLanguage = "tk"
	FallbackElevenLabsTranscriberLanguageTl  FallbackElevenLabsTranscriberLanguage = "tl"
	FallbackElevenLabsTranscriberLanguageTn  FallbackElevenLabsTranscriberLanguage = "tn"
	FallbackElevenLabsTranscriberLanguageTo  FallbackElevenLabsTranscriberLanguage = "to"
	FallbackElevenLabsTranscriberLanguageTr  FallbackElevenLabsTranscriberLanguage = "tr"
	FallbackElevenLabsTranscriberLanguageTs  FallbackElevenLabsTranscriberLanguage = "ts"
	FallbackElevenLabsTranscriberLanguageTt  FallbackElevenLabsTranscriberLanguage = "tt"
	FallbackElevenLabsTranscriberLanguageTw  FallbackElevenLabsTranscriberLanguage = "tw"
	FallbackElevenLabsTranscriberLanguageTy  FallbackElevenLabsTranscriberLanguage = "ty"
	FallbackElevenLabsTranscriberLanguageUg  FallbackElevenLabsTranscriberLanguage = "ug"
	FallbackElevenLabsTranscriberLanguageUk  FallbackElevenLabsTranscriberLanguage = "uk"
	FallbackElevenLabsTranscriberLanguageUr  FallbackElevenLabsTranscriberLanguage = "ur"
	FallbackElevenLabsTranscriberLanguageUz  FallbackElevenLabsTranscriberLanguage = "uz"
	FallbackElevenLabsTranscriberLanguageVe  FallbackElevenLabsTranscriberLanguage = "ve"
	FallbackElevenLabsTranscriberLanguageVi  FallbackElevenLabsTranscriberLanguage = "vi"
	FallbackElevenLabsTranscriberLanguageVo  FallbackElevenLabsTranscriberLanguage = "vo"
	FallbackElevenLabsTranscriberLanguageWa  FallbackElevenLabsTranscriberLanguage = "wa"
	FallbackElevenLabsTranscriberLanguageWo  FallbackElevenLabsTranscriberLanguage = "wo"
	FallbackElevenLabsTranscriberLanguageXh  FallbackElevenLabsTranscriberLanguage = "xh"
	FallbackElevenLabsTranscriberLanguageYi  FallbackElevenLabsTranscriberLanguage = "yi"
	FallbackElevenLabsTranscriberLanguageYue FallbackElevenLabsTranscriberLanguage = "yue"
	FallbackElevenLabsTranscriberLanguageYo  FallbackElevenLabsTranscriberLanguage = "yo"
	FallbackElevenLabsTranscriberLanguageZa  FallbackElevenLabsTranscriberLanguage = "za"
	FallbackElevenLabsTranscriberLanguageZh  FallbackElevenLabsTranscriberLanguage = "zh"
	FallbackElevenLabsTranscriberLanguageZu  FallbackElevenLabsTranscriberLanguage = "zu"
)

func NewFallbackElevenLabsTranscriberLanguageFromString(s string) (FallbackElevenLabsTranscriberLanguage, error) {
	switch s {
	case "aa":
		return FallbackElevenLabsTranscriberLanguageAa, nil
	case "ab":
		return FallbackElevenLabsTranscriberLanguageAb, nil
	case "ae":
		return FallbackElevenLabsTranscriberLanguageAe, nil
	case "af":
		return FallbackElevenLabsTranscriberLanguageAf, nil
	case "ak":
		return FallbackElevenLabsTranscriberLanguageAk, nil
	case "am":
		return FallbackElevenLabsTranscriberLanguageAm, nil
	case "an":
		return FallbackElevenLabsTranscriberLanguageAn, nil
	case "ar":
		return FallbackElevenLabsTranscriberLanguageAr, nil
	case "as":
		return FallbackElevenLabsTranscriberLanguageAs, nil
	case "av":
		return FallbackElevenLabsTranscriberLanguageAv, nil
	case "ay":
		return FallbackElevenLabsTranscriberLanguageAy, nil
	case "az":
		return FallbackElevenLabsTranscriberLanguageAz, nil
	case "ba":
		return FallbackElevenLabsTranscriberLanguageBa, nil
	case "be":
		return FallbackElevenLabsTranscriberLanguageBe, nil
	case "bg":
		return FallbackElevenLabsTranscriberLanguageBg, nil
	case "bh":
		return FallbackElevenLabsTranscriberLanguageBh, nil
	case "bi":
		return FallbackElevenLabsTranscriberLanguageBi, nil
	case "bm":
		return FallbackElevenLabsTranscriberLanguageBm, nil
	case "bn":
		return FallbackElevenLabsTranscriberLanguageBn, nil
	case "bo":
		return FallbackElevenLabsTranscriberLanguageBo, nil
	case "br":
		return FallbackElevenLabsTranscriberLanguageBr, nil
	case "bs":
		return FallbackElevenLabsTranscriberLanguageBs, nil
	case "ca":
		return FallbackElevenLabsTranscriberLanguageCa, nil
	case "ce":
		return FallbackElevenLabsTranscriberLanguageCe, nil
	case "ch":
		return FallbackElevenLabsTranscriberLanguageCh, nil
	case "co":
		return FallbackElevenLabsTranscriberLanguageCo, nil
	case "cr":
		return FallbackElevenLabsTranscriberLanguageCr, nil
	case "cs":
		return FallbackElevenLabsTranscriberLanguageCs, nil
	case "cu":
		return FallbackElevenLabsTranscriberLanguageCu, nil
	case "cv":
		return FallbackElevenLabsTranscriberLanguageCv, nil
	case "cy":
		return FallbackElevenLabsTranscriberLanguageCy, nil
	case "da":
		return FallbackElevenLabsTranscriberLanguageDa, nil
	case "de":
		return FallbackElevenLabsTranscriberLanguageDe, nil
	case "dv":
		return FallbackElevenLabsTranscriberLanguageDv, nil
	case "dz":
		return FallbackElevenLabsTranscriberLanguageDz, nil
	case "ee":
		return FallbackElevenLabsTranscriberLanguageEe, nil
	case "el":
		return FallbackElevenLabsTranscriberLanguageEl, nil
	case "en":
		return FallbackElevenLabsTranscriberLanguageEn, nil
	case "eo":
		return FallbackElevenLabsTranscriberLanguageEo, nil
	case "es":
		return FallbackElevenLabsTranscriberLanguageEs, nil
	case "et":
		return FallbackElevenLabsTranscriberLanguageEt, nil
	case "eu":
		return FallbackElevenLabsTranscriberLanguageEu, nil
	case "fa":
		return FallbackElevenLabsTranscriberLanguageFa, nil
	case "ff":
		return FallbackElevenLabsTranscriberLanguageFf, nil
	case "fi":
		return FallbackElevenLabsTranscriberLanguageFi, nil
	case "fj":
		return FallbackElevenLabsTranscriberLanguageFj, nil
	case "fo":
		return FallbackElevenLabsTranscriberLanguageFo, nil
	case "fr":
		return FallbackElevenLabsTranscriberLanguageFr, nil
	case "fy":
		return FallbackElevenLabsTranscriberLanguageFy, nil
	case "ga":
		return FallbackElevenLabsTranscriberLanguageGa, nil
	case "gd":
		return FallbackElevenLabsTranscriberLanguageGd, nil
	case "gl":
		return FallbackElevenLabsTranscriberLanguageGl, nil
	case "gn":
		return FallbackElevenLabsTranscriberLanguageGn, nil
	case "gu":
		return FallbackElevenLabsTranscriberLanguageGu, nil
	case "gv":
		return FallbackElevenLabsTranscriberLanguageGv, nil
	case "ha":
		return FallbackElevenLabsTranscriberLanguageHa, nil
	case "he":
		return FallbackElevenLabsTranscriberLanguageHe, nil
	case "hi":
		return FallbackElevenLabsTranscriberLanguageHi, nil
	case "ho":
		return FallbackElevenLabsTranscriberLanguageHo, nil
	case "hr":
		return FallbackElevenLabsTranscriberLanguageHr, nil
	case "ht":
		return FallbackElevenLabsTranscriberLanguageHt, nil
	case "hu":
		return FallbackElevenLabsTranscriberLanguageHu, nil
	case "hy":
		return FallbackElevenLabsTranscriberLanguageHy, nil
	case "hz":
		return FallbackElevenLabsTranscriberLanguageHz, nil
	case "ia":
		return FallbackElevenLabsTranscriberLanguageIa, nil
	case "id":
		return FallbackElevenLabsTranscriberLanguageId, nil
	case "ie":
		return FallbackElevenLabsTranscriberLanguageIe, nil
	case "ig":
		return FallbackElevenLabsTranscriberLanguageIg, nil
	case "ii":
		return FallbackElevenLabsTranscriberLanguageIi, nil
	case "ik":
		return FallbackElevenLabsTranscriberLanguageIk, nil
	case "io":
		return FallbackElevenLabsTranscriberLanguageIo, nil
	case "is":
		return FallbackElevenLabsTranscriberLanguageIs, nil
	case "it":
		return FallbackElevenLabsTranscriberLanguageIt, nil
	case "iu":
		return FallbackElevenLabsTranscriberLanguageIu, nil
	case "ja":
		return FallbackElevenLabsTranscriberLanguageJa, nil
	case "jv":
		return FallbackElevenLabsTranscriberLanguageJv, nil
	case "ka":
		return FallbackElevenLabsTranscriberLanguageKa, nil
	case "kg":
		return FallbackElevenLabsTranscriberLanguageKg, nil
	case "ki":
		return FallbackElevenLabsTranscriberLanguageKi, nil
	case "kj":
		return FallbackElevenLabsTranscriberLanguageKj, nil
	case "kk":
		return FallbackElevenLabsTranscriberLanguageKk, nil
	case "kl":
		return FallbackElevenLabsTranscriberLanguageKl, nil
	case "km":
		return FallbackElevenLabsTranscriberLanguageKm, nil
	case "kn":
		return FallbackElevenLabsTranscriberLanguageKn, nil
	case "ko":
		return FallbackElevenLabsTranscriberLanguageKo, nil
	case "kr":
		return FallbackElevenLabsTranscriberLanguageKr, nil
	case "ks":
		return FallbackElevenLabsTranscriberLanguageKs, nil
	case "ku":
		return FallbackElevenLabsTranscriberLanguageKu, nil
	case "kv":
		return FallbackElevenLabsTranscriberLanguageKv, nil
	case "kw":
		return FallbackElevenLabsTranscriberLanguageKw, nil
	case "ky":
		return FallbackElevenLabsTranscriberLanguageKy, nil
	case "la":
		return FallbackElevenLabsTranscriberLanguageLa, nil
	case "lb":
		return FallbackElevenLabsTranscriberLanguageLb, nil
	case "lg":
		return FallbackElevenLabsTranscriberLanguageLg, nil
	case "li":
		return FallbackElevenLabsTranscriberLanguageLi, nil
	case "ln":
		return FallbackElevenLabsTranscriberLanguageLn, nil
	case "lo":
		return FallbackElevenLabsTranscriberLanguageLo, nil
	case "lt":
		return FallbackElevenLabsTranscriberLanguageLt, nil
	case "lu":
		return FallbackElevenLabsTranscriberLanguageLu, nil
	case "lv":
		return FallbackElevenLabsTranscriberLanguageLv, nil
	case "mg":
		return FallbackElevenLabsTranscriberLanguageMg, nil
	case "mh":
		return FallbackElevenLabsTranscriberLanguageMh, nil
	case "mi":
		return FallbackElevenLabsTranscriberLanguageMi, nil
	case "mk":
		return FallbackElevenLabsTranscriberLanguageMk, nil
	case "ml":
		return FallbackElevenLabsTranscriberLanguageMl, nil
	case "mn":
		return FallbackElevenLabsTranscriberLanguageMn, nil
	case "mr":
		return FallbackElevenLabsTranscriberLanguageMr, nil
	case "ms":
		return FallbackElevenLabsTranscriberLanguageMs, nil
	case "mt":
		return FallbackElevenLabsTranscriberLanguageMt, nil
	case "my":
		return FallbackElevenLabsTranscriberLanguageMy, nil
	case "na":
		return FallbackElevenLabsTranscriberLanguageNa, nil
	case "nb":
		return FallbackElevenLabsTranscriberLanguageNb, nil
	case "nd":
		return FallbackElevenLabsTranscriberLanguageNd, nil
	case "ne":
		return FallbackElevenLabsTranscriberLanguageNe, nil
	case "ng":
		return FallbackElevenLabsTranscriberLanguageNg, nil
	case "nl":
		return FallbackElevenLabsTranscriberLanguageNl, nil
	case "nn":
		return FallbackElevenLabsTranscriberLanguageNn, nil
	case "no":
		return FallbackElevenLabsTranscriberLanguageNo, nil
	case "nr":
		return FallbackElevenLabsTranscriberLanguageNr, nil
	case "nv":
		return FallbackElevenLabsTranscriberLanguageNv, nil
	case "ny":
		return FallbackElevenLabsTranscriberLanguageNy, nil
	case "oc":
		return FallbackElevenLabsTranscriberLanguageOc, nil
	case "oj":
		return FallbackElevenLabsTranscriberLanguageOj, nil
	case "om":
		return FallbackElevenLabsTranscriberLanguageOm, nil
	case "or":
		return FallbackElevenLabsTranscriberLanguageOr, nil
	case "os":
		return FallbackElevenLabsTranscriberLanguageOs, nil
	case "pa":
		return FallbackElevenLabsTranscriberLanguagePa, nil
	case "pi":
		return FallbackElevenLabsTranscriberLanguagePi, nil
	case "pl":
		return FallbackElevenLabsTranscriberLanguagePl, nil
	case "ps":
		return FallbackElevenLabsTranscriberLanguagePs, nil
	case "pt":
		return FallbackElevenLabsTranscriberLanguagePt, nil
	case "qu":
		return FallbackElevenLabsTranscriberLanguageQu, nil
	case "rm":
		return FallbackElevenLabsTranscriberLanguageRm, nil
	case "rn":
		return FallbackElevenLabsTranscriberLanguageRn, nil
	case "ro":
		return FallbackElevenLabsTranscriberLanguageRo, nil
	case "ru":
		return FallbackElevenLabsTranscriberLanguageRu, nil
	case "rw":
		return FallbackElevenLabsTranscriberLanguageRw, nil
	case "sa":
		return FallbackElevenLabsTranscriberLanguageSa, nil
	case "sc":
		return FallbackElevenLabsTranscriberLanguageSc, nil
	case "sd":
		return FallbackElevenLabsTranscriberLanguageSd, nil
	case "se":
		return FallbackElevenLabsTranscriberLanguageSe, nil
	case "sg":
		return FallbackElevenLabsTranscriberLanguageSg, nil
	case "si":
		return FallbackElevenLabsTranscriberLanguageSi, nil
	case "sk":
		return FallbackElevenLabsTranscriberLanguageSk, nil
	case "sl":
		return FallbackElevenLabsTranscriberLanguageSl, nil
	case "sm":
		return FallbackElevenLabsTranscriberLanguageSm, nil
	case "sn":
		return FallbackElevenLabsTranscriberLanguageSn, nil
	case "so":
		return FallbackElevenLabsTranscriberLanguageSo, nil
	case "sq":
		return FallbackElevenLabsTranscriberLanguageSq, nil
	case "sr":
		return FallbackElevenLabsTranscriberLanguageSr, nil
	case "ss":
		return FallbackElevenLabsTranscriberLanguageSs, nil
	case "st":
		return FallbackElevenLabsTranscriberLanguageSt, nil
	case "su":
		return FallbackElevenLabsTranscriberLanguageSu, nil
	case "sv":
		return FallbackElevenLabsTranscriberLanguageSv, nil
	case "sw":
		return FallbackElevenLabsTranscriberLanguageSw, nil
	case "ta":
		return FallbackElevenLabsTranscriberLanguageTa, nil
	case "te":
		return FallbackElevenLabsTranscriberLanguageTe, nil
	case "tg":
		return FallbackElevenLabsTranscriberLanguageTg, nil
	case "th":
		return FallbackElevenLabsTranscriberLanguageTh, nil
	case "ti":
		return FallbackElevenLabsTranscriberLanguageTi, nil
	case "tk":
		return FallbackElevenLabsTranscriberLanguageTk, nil
	case "tl":
		return FallbackElevenLabsTranscriberLanguageTl, nil
	case "tn":
		return FallbackElevenLabsTranscriberLanguageTn, nil
	case "to":
		return FallbackElevenLabsTranscriberLanguageTo, nil
	case "tr":
		return FallbackElevenLabsTranscriberLanguageTr, nil
	case "ts":
		return FallbackElevenLabsTranscriberLanguageTs, nil
	case "tt":
		return FallbackElevenLabsTranscriberLanguageTt, nil
	case "tw":
		return FallbackElevenLabsTranscriberLanguageTw, nil
	case "ty":
		return FallbackElevenLabsTranscriberLanguageTy, nil
	case "ug":
		return FallbackElevenLabsTranscriberLanguageUg, nil
	case "uk":
		return FallbackElevenLabsTranscriberLanguageUk, nil
	case "ur":
		return FallbackElevenLabsTranscriberLanguageUr, nil
	case "uz":
		return FallbackElevenLabsTranscriberLanguageUz, nil
	case "ve":
		return FallbackElevenLabsTranscriberLanguageVe, nil
	case "vi":
		return FallbackElevenLabsTranscriberLanguageVi, nil
	case "vo":
		return FallbackElevenLabsTranscriberLanguageVo, nil
	case "wa":
		return FallbackElevenLabsTranscriberLanguageWa, nil
	case "wo":
		return FallbackElevenLabsTranscriberLanguageWo, nil
	case "xh":
		return FallbackElevenLabsTranscriberLanguageXh, nil
	case "yi":
		return FallbackElevenLabsTranscriberLanguageYi, nil
	case "yue":
		return FallbackElevenLabsTranscriberLanguageYue, nil
	case "yo":
		return FallbackElevenLabsTranscriberLanguageYo, nil
	case "za":
		return FallbackElevenLabsTranscriberLanguageZa, nil
	case "zh":
		return FallbackElevenLabsTranscriberLanguageZh, nil
	case "zu":
		return FallbackElevenLabsTranscriberLanguageZu, nil
	}
	var t FallbackElevenLabsTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackElevenLabsTranscriberLanguage) Ptr() *FallbackElevenLabsTranscriberLanguage {
	return &f
}

type FallbackElevenLabsVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
	VoiceId *FallbackElevenLabsVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Defines the stability for voice settings.
	Stability *float64 `json:"stability,omitempty" url:"stability,omitempty"`
	// Defines the similarity boost for voice settings.
	SimilarityBoost *float64 `json:"similarityBoost,omitempty" url:"similarityBoost,omitempty"`
	// Defines the style for voice settings.
	Style *float64 `json:"style,omitempty" url:"style,omitempty"`
	// Defines the use speaker boost for voice settings.
	UseSpeakerBoost *bool `json:"useSpeakerBoost,omitempty" url:"useSpeakerBoost,omitempty"`
	// Defines the speed for voice settings.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// Defines the optimize streaming latency for voice settings. Defaults to 3.
	OptimizeStreamingLatency *float64 `json:"optimizeStreamingLatency,omitempty" url:"optimizeStreamingLatency,omitempty"`
	// This enables the use of https://elevenlabs.io/docs/speech-synthesis/prompting#pronunciation. Defaults to false to save latency.
	//
	// @default false
	EnableSsmlParsing *bool `json:"enableSsmlParsing,omitempty" url:"enableSsmlParsing,omitempty"`
	// Defines the auto mode for voice settings. Defaults to false.
	AutoMode *bool `json:"autoMode,omitempty" url:"autoMode,omitempty"`
	// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
	Model *FallbackElevenLabsVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language (ISO 639-1) that is enforced for the model. Currently only Turbo v2.5 supports language enforcement. For other models, an error will be returned if language code is provided.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackElevenLabsVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackElevenLabsVoice) GetVoiceId() *FallbackElevenLabsVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackElevenLabsVoice) GetStability() *float64 {
	if f == nil {
		return nil
	}
	return f.Stability
}

func (f *FallbackElevenLabsVoice) GetSimilarityBoost() *float64 {
	if f == nil {
		return nil
	}
	return f.SimilarityBoost
}

func (f *FallbackElevenLabsVoice) GetStyle() *float64 {
	if f == nil {
		return nil
	}
	return f.Style
}

func (f *FallbackElevenLabsVoice) GetUseSpeakerBoost() *bool {
	if f == nil {
		return nil
	}
	return f.UseSpeakerBoost
}

func (f *FallbackElevenLabsVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackElevenLabsVoice) GetOptimizeStreamingLatency() *float64 {
	if f == nil {
		return nil
	}
	return f.OptimizeStreamingLatency
}

func (f *FallbackElevenLabsVoice) GetEnableSsmlParsing() *bool {
	if f == nil {
		return nil
	}
	return f.EnableSsmlParsing
}

func (f *FallbackElevenLabsVoice) GetAutoMode() *bool {
	if f == nil {
		return nil
	}
	return f.AutoMode
}

func (f *FallbackElevenLabsVoice) GetModel() *FallbackElevenLabsVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackElevenLabsVoice) GetLanguage() *string {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackElevenLabsVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackElevenLabsVoice) Provider() string {
	return f.provider
}

func (f *FallbackElevenLabsVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackElevenLabsVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackElevenLabsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackElevenLabsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "11labs", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackElevenLabsVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackElevenLabsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackElevenLabsVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
type FallbackElevenLabsVoiceId struct {
	FallbackElevenLabsVoiceIdEnum FallbackElevenLabsVoiceIdEnum
	String                        string

	typ string
}

func (f *FallbackElevenLabsVoiceId) GetFallbackElevenLabsVoiceIdEnum() FallbackElevenLabsVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackElevenLabsVoiceIdEnum
}

func (f *FallbackElevenLabsVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackElevenLabsVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackElevenLabsVoiceIdEnum FallbackElevenLabsVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackElevenLabsVoiceIdEnum); err == nil {
		f.typ = "FallbackElevenLabsVoiceIdEnum"
		f.FallbackElevenLabsVoiceIdEnum = valueFallbackElevenLabsVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackElevenLabsVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackElevenLabsVoiceIdEnum" || f.FallbackElevenLabsVoiceIdEnum != "" {
		return json.Marshal(f.FallbackElevenLabsVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackElevenLabsVoiceIdVisitor interface {
	VisitFallbackElevenLabsVoiceIdEnum(FallbackElevenLabsVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackElevenLabsVoiceId) Accept(visitor FallbackElevenLabsVoiceIdVisitor) error {
	if f.typ == "FallbackElevenLabsVoiceIdEnum" || f.FallbackElevenLabsVoiceIdEnum != "" {
		return visitor.VisitFallbackElevenLabsVoiceIdEnum(f.FallbackElevenLabsVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackElevenLabsVoiceIdEnum string

const (
	FallbackElevenLabsVoiceIdEnumBurt    FallbackElevenLabsVoiceIdEnum = "burt"
	FallbackElevenLabsVoiceIdEnumMarissa FallbackElevenLabsVoiceIdEnum = "marissa"
	FallbackElevenLabsVoiceIdEnumAndrea  FallbackElevenLabsVoiceIdEnum = "andrea"
	FallbackElevenLabsVoiceIdEnumSarah   FallbackElevenLabsVoiceIdEnum = "sarah"
	FallbackElevenLabsVoiceIdEnumPhillip FallbackElevenLabsVoiceIdEnum = "phillip"
	FallbackElevenLabsVoiceIdEnumSteve   FallbackElevenLabsVoiceIdEnum = "steve"
	FallbackElevenLabsVoiceIdEnumJoseph  FallbackElevenLabsVoiceIdEnum = "joseph"
	FallbackElevenLabsVoiceIdEnumMyra    FallbackElevenLabsVoiceIdEnum = "myra"
	FallbackElevenLabsVoiceIdEnumPaula   FallbackElevenLabsVoiceIdEnum = "paula"
	FallbackElevenLabsVoiceIdEnumRyan    FallbackElevenLabsVoiceIdEnum = "ryan"
	FallbackElevenLabsVoiceIdEnumDrew    FallbackElevenLabsVoiceIdEnum = "drew"
	FallbackElevenLabsVoiceIdEnumPaul    FallbackElevenLabsVoiceIdEnum = "paul"
	FallbackElevenLabsVoiceIdEnumMrb     FallbackElevenLabsVoiceIdEnum = "mrb"
	FallbackElevenLabsVoiceIdEnumMatilda FallbackElevenLabsVoiceIdEnum = "matilda"
	FallbackElevenLabsVoiceIdEnumMark    FallbackElevenLabsVoiceIdEnum = "mark"
)

func NewFallbackElevenLabsVoiceIdEnumFromString(s string) (FallbackElevenLabsVoiceIdEnum, error) {
	switch s {
	case "burt":
		return FallbackElevenLabsVoiceIdEnumBurt, nil
	case "marissa":
		return FallbackElevenLabsVoiceIdEnumMarissa, nil
	case "andrea":
		return FallbackElevenLabsVoiceIdEnumAndrea, nil
	case "sarah":
		return FallbackElevenLabsVoiceIdEnumSarah, nil
	case "phillip":
		return FallbackElevenLabsVoiceIdEnumPhillip, nil
	case "steve":
		return FallbackElevenLabsVoiceIdEnumSteve, nil
	case "joseph":
		return FallbackElevenLabsVoiceIdEnumJoseph, nil
	case "myra":
		return FallbackElevenLabsVoiceIdEnumMyra, nil
	case "paula":
		return FallbackElevenLabsVoiceIdEnumPaula, nil
	case "ryan":
		return FallbackElevenLabsVoiceIdEnumRyan, nil
	case "drew":
		return FallbackElevenLabsVoiceIdEnumDrew, nil
	case "paul":
		return FallbackElevenLabsVoiceIdEnumPaul, nil
	case "mrb":
		return FallbackElevenLabsVoiceIdEnumMrb, nil
	case "matilda":
		return FallbackElevenLabsVoiceIdEnumMatilda, nil
	case "mark":
		return FallbackElevenLabsVoiceIdEnumMark, nil
	}
	var t FallbackElevenLabsVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackElevenLabsVoiceIdEnum) Ptr() *FallbackElevenLabsVoiceIdEnum {
	return &f
}

// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
type FallbackElevenLabsVoiceModel string

const (
	FallbackElevenLabsVoiceModelElevenMultilingualV2 FallbackElevenLabsVoiceModel = "eleven_multilingual_v2"
	FallbackElevenLabsVoiceModelElevenTurboV2        FallbackElevenLabsVoiceModel = "eleven_turbo_v2"
	FallbackElevenLabsVoiceModelElevenTurboV25       FallbackElevenLabsVoiceModel = "eleven_turbo_v2_5"
	FallbackElevenLabsVoiceModelElevenFlashV2        FallbackElevenLabsVoiceModel = "eleven_flash_v2"
	FallbackElevenLabsVoiceModelElevenFlashV25       FallbackElevenLabsVoiceModel = "eleven_flash_v2_5"
	FallbackElevenLabsVoiceModelElevenMonolingualV1  FallbackElevenLabsVoiceModel = "eleven_monolingual_v1"
)

func NewFallbackElevenLabsVoiceModelFromString(s string) (FallbackElevenLabsVoiceModel, error) {
	switch s {
	case "eleven_multilingual_v2":
		return FallbackElevenLabsVoiceModelElevenMultilingualV2, nil
	case "eleven_turbo_v2":
		return FallbackElevenLabsVoiceModelElevenTurboV2, nil
	case "eleven_turbo_v2_5":
		return FallbackElevenLabsVoiceModelElevenTurboV25, nil
	case "eleven_flash_v2":
		return FallbackElevenLabsVoiceModelElevenFlashV2, nil
	case "eleven_flash_v2_5":
		return FallbackElevenLabsVoiceModelElevenFlashV25, nil
	case "eleven_monolingual_v1":
		return FallbackElevenLabsVoiceModelElevenMonolingualV1, nil
	}
	var t FallbackElevenLabsVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackElevenLabsVoiceModel) Ptr() *FallbackElevenLabsVoiceModel {
	return &f
}

type FallbackGladiaTranscriber struct {
	// This is the transcription provider that will be used.
	Model             *FallbackGladiaTranscriberModel             `json:"model,omitempty" url:"model,omitempty"`
	LanguageBehaviour *FallbackGladiaTranscriberLanguageBehaviour `json:"languageBehaviour,omitempty" url:"languageBehaviour,omitempty"`
	// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
	Language *FallbackGladiaTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// Provides a custom vocabulary to the model to improve accuracy of transcribing context specific words, technical terms, names, etc. If empty, this argument is ignored.
	// ⚠️ Warning ⚠️: Please be aware that the transcription_hint field has a character limit of 600. If you provide a transcription_hint longer than 600 characters, it will be automatically truncated to meet this limit.
	TranscriptionHint *string `json:"transcriptionHint,omitempty" url:"transcriptionHint,omitempty"`
	// If prosody is true, you will get a transcription that can contain prosodies i.e. (laugh) (giggles) (malefic laugh) (toss) (music)… Default value is false.
	Prosody *bool `json:"prosody,omitempty" url:"prosody,omitempty"`
	// If true, audio will be pre-processed to improve accuracy but latency will increase. Default value is false.
	AudioEnhancer *bool `json:"audioEnhancer,omitempty" url:"audioEnhancer,omitempty"`
	// Transcripts below this confidence threshold will be discarded.
	//
	// @default 0.4
	ConfidenceThreshold *float64 `json:"confidenceThreshold,omitempty" url:"confidenceThreshold,omitempty"`
	provider            string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackGladiaTranscriber) GetModel() *FallbackGladiaTranscriberModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackGladiaTranscriber) GetLanguageBehaviour() *FallbackGladiaTranscriberLanguageBehaviour {
	if f == nil {
		return nil
	}
	return f.LanguageBehaviour
}

func (f *FallbackGladiaTranscriber) GetLanguage() *FallbackGladiaTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackGladiaTranscriber) GetTranscriptionHint() *string {
	if f == nil {
		return nil
	}
	return f.TranscriptionHint
}

func (f *FallbackGladiaTranscriber) GetProsody() *bool {
	if f == nil {
		return nil
	}
	return f.Prosody
}

func (f *FallbackGladiaTranscriber) GetAudioEnhancer() *bool {
	if f == nil {
		return nil
	}
	return f.AudioEnhancer
}

func (f *FallbackGladiaTranscriber) GetConfidenceThreshold() *float64 {
	if f == nil {
		return nil
	}
	return f.ConfidenceThreshold
}

func (f *FallbackGladiaTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackGladiaTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackGladiaTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackGladiaTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackGladiaTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "gladia", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackGladiaTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackGladiaTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackGladiaTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
type FallbackGladiaTranscriberLanguage string

const (
	FallbackGladiaTranscriberLanguageAf  FallbackGladiaTranscriberLanguage = "af"
	FallbackGladiaTranscriberLanguageSq  FallbackGladiaTranscriberLanguage = "sq"
	FallbackGladiaTranscriberLanguageAm  FallbackGladiaTranscriberLanguage = "am"
	FallbackGladiaTranscriberLanguageAr  FallbackGladiaTranscriberLanguage = "ar"
	FallbackGladiaTranscriberLanguageHy  FallbackGladiaTranscriberLanguage = "hy"
	FallbackGladiaTranscriberLanguageAs  FallbackGladiaTranscriberLanguage = "as"
	FallbackGladiaTranscriberLanguageAz  FallbackGladiaTranscriberLanguage = "az"
	FallbackGladiaTranscriberLanguageBa  FallbackGladiaTranscriberLanguage = "ba"
	FallbackGladiaTranscriberLanguageEu  FallbackGladiaTranscriberLanguage = "eu"
	FallbackGladiaTranscriberLanguageBe  FallbackGladiaTranscriberLanguage = "be"
	FallbackGladiaTranscriberLanguageBn  FallbackGladiaTranscriberLanguage = "bn"
	FallbackGladiaTranscriberLanguageBs  FallbackGladiaTranscriberLanguage = "bs"
	FallbackGladiaTranscriberLanguageBr  FallbackGladiaTranscriberLanguage = "br"
	FallbackGladiaTranscriberLanguageBg  FallbackGladiaTranscriberLanguage = "bg"
	FallbackGladiaTranscriberLanguageCa  FallbackGladiaTranscriberLanguage = "ca"
	FallbackGladiaTranscriberLanguageZh  FallbackGladiaTranscriberLanguage = "zh"
	FallbackGladiaTranscriberLanguageHr  FallbackGladiaTranscriberLanguage = "hr"
	FallbackGladiaTranscriberLanguageCs  FallbackGladiaTranscriberLanguage = "cs"
	FallbackGladiaTranscriberLanguageDa  FallbackGladiaTranscriberLanguage = "da"
	FallbackGladiaTranscriberLanguageNl  FallbackGladiaTranscriberLanguage = "nl"
	FallbackGladiaTranscriberLanguageEn  FallbackGladiaTranscriberLanguage = "en"
	FallbackGladiaTranscriberLanguageEt  FallbackGladiaTranscriberLanguage = "et"
	FallbackGladiaTranscriberLanguageFo  FallbackGladiaTranscriberLanguage = "fo"
	FallbackGladiaTranscriberLanguageFi  FallbackGladiaTranscriberLanguage = "fi"
	FallbackGladiaTranscriberLanguageFr  FallbackGladiaTranscriberLanguage = "fr"
	FallbackGladiaTranscriberLanguageGl  FallbackGladiaTranscriberLanguage = "gl"
	FallbackGladiaTranscriberLanguageKa  FallbackGladiaTranscriberLanguage = "ka"
	FallbackGladiaTranscriberLanguageDe  FallbackGladiaTranscriberLanguage = "de"
	FallbackGladiaTranscriberLanguageEl  FallbackGladiaTranscriberLanguage = "el"
	FallbackGladiaTranscriberLanguageGu  FallbackGladiaTranscriberLanguage = "gu"
	FallbackGladiaTranscriberLanguageHt  FallbackGladiaTranscriberLanguage = "ht"
	FallbackGladiaTranscriberLanguageHa  FallbackGladiaTranscriberLanguage = "ha"
	FallbackGladiaTranscriberLanguageHaw FallbackGladiaTranscriberLanguage = "haw"
	FallbackGladiaTranscriberLanguageHe  FallbackGladiaTranscriberLanguage = "he"
	FallbackGladiaTranscriberLanguageHi  FallbackGladiaTranscriberLanguage = "hi"
	FallbackGladiaTranscriberLanguageHu  FallbackGladiaTranscriberLanguage = "hu"
	FallbackGladiaTranscriberLanguageIs  FallbackGladiaTranscriberLanguage = "is"
	FallbackGladiaTranscriberLanguageId  FallbackGladiaTranscriberLanguage = "id"
	FallbackGladiaTranscriberLanguageIt  FallbackGladiaTranscriberLanguage = "it"
	FallbackGladiaTranscriberLanguageJa  FallbackGladiaTranscriberLanguage = "ja"
	FallbackGladiaTranscriberLanguageJv  FallbackGladiaTranscriberLanguage = "jv"
	FallbackGladiaTranscriberLanguageKn  FallbackGladiaTranscriberLanguage = "kn"
	FallbackGladiaTranscriberLanguageKk  FallbackGladiaTranscriberLanguage = "kk"
	FallbackGladiaTranscriberLanguageKm  FallbackGladiaTranscriberLanguage = "km"
	FallbackGladiaTranscriberLanguageKo  FallbackGladiaTranscriberLanguage = "ko"
	FallbackGladiaTranscriberLanguageLo  FallbackGladiaTranscriberLanguage = "lo"
	FallbackGladiaTranscriberLanguageLa  FallbackGladiaTranscriberLanguage = "la"
	FallbackGladiaTranscriberLanguageLv  FallbackGladiaTranscriberLanguage = "lv"
	FallbackGladiaTranscriberLanguageLn  FallbackGladiaTranscriberLanguage = "ln"
	FallbackGladiaTranscriberLanguageLt  FallbackGladiaTranscriberLanguage = "lt"
	FallbackGladiaTranscriberLanguageLb  FallbackGladiaTranscriberLanguage = "lb"
	FallbackGladiaTranscriberLanguageMk  FallbackGladiaTranscriberLanguage = "mk"
	FallbackGladiaTranscriberLanguageMg  FallbackGladiaTranscriberLanguage = "mg"
	FallbackGladiaTranscriberLanguageMs  FallbackGladiaTranscriberLanguage = "ms"
	FallbackGladiaTranscriberLanguageMl  FallbackGladiaTranscriberLanguage = "ml"
	FallbackGladiaTranscriberLanguageMt  FallbackGladiaTranscriberLanguage = "mt"
	FallbackGladiaTranscriberLanguageMi  FallbackGladiaTranscriberLanguage = "mi"
	FallbackGladiaTranscriberLanguageMr  FallbackGladiaTranscriberLanguage = "mr"
	FallbackGladiaTranscriberLanguageMn  FallbackGladiaTranscriberLanguage = "mn"
	FallbackGladiaTranscriberLanguageMy  FallbackGladiaTranscriberLanguage = "my"
	FallbackGladiaTranscriberLanguageNe  FallbackGladiaTranscriberLanguage = "ne"
	FallbackGladiaTranscriberLanguageNo  FallbackGladiaTranscriberLanguage = "no"
	FallbackGladiaTranscriberLanguageNn  FallbackGladiaTranscriberLanguage = "nn"
	FallbackGladiaTranscriberLanguageOc  FallbackGladiaTranscriberLanguage = "oc"
	FallbackGladiaTranscriberLanguagePs  FallbackGladiaTranscriberLanguage = "ps"
	FallbackGladiaTranscriberLanguageFa  FallbackGladiaTranscriberLanguage = "fa"
	FallbackGladiaTranscriberLanguagePl  FallbackGladiaTranscriberLanguage = "pl"
	FallbackGladiaTranscriberLanguagePt  FallbackGladiaTranscriberLanguage = "pt"
	FallbackGladiaTranscriberLanguagePa  FallbackGladiaTranscriberLanguage = "pa"
	FallbackGladiaTranscriberLanguageRo  FallbackGladiaTranscriberLanguage = "ro"
	FallbackGladiaTranscriberLanguageRu  FallbackGladiaTranscriberLanguage = "ru"
	FallbackGladiaTranscriberLanguageSa  FallbackGladiaTranscriberLanguage = "sa"
	FallbackGladiaTranscriberLanguageSr  FallbackGladiaTranscriberLanguage = "sr"
	FallbackGladiaTranscriberLanguageSn  FallbackGladiaTranscriberLanguage = "sn"
	FallbackGladiaTranscriberLanguageSd  FallbackGladiaTranscriberLanguage = "sd"
	FallbackGladiaTranscriberLanguageSi  FallbackGladiaTranscriberLanguage = "si"
	FallbackGladiaTranscriberLanguageSk  FallbackGladiaTranscriberLanguage = "sk"
	FallbackGladiaTranscriberLanguageSl  FallbackGladiaTranscriberLanguage = "sl"
	FallbackGladiaTranscriberLanguageSo  FallbackGladiaTranscriberLanguage = "so"
	FallbackGladiaTranscriberLanguageEs  FallbackGladiaTranscriberLanguage = "es"
	FallbackGladiaTranscriberLanguageSu  FallbackGladiaTranscriberLanguage = "su"
	FallbackGladiaTranscriberLanguageSw  FallbackGladiaTranscriberLanguage = "sw"
	FallbackGladiaTranscriberLanguageSv  FallbackGladiaTranscriberLanguage = "sv"
	FallbackGladiaTranscriberLanguageTl  FallbackGladiaTranscriberLanguage = "tl"
	FallbackGladiaTranscriberLanguageTg  FallbackGladiaTranscriberLanguage = "tg"
	FallbackGladiaTranscriberLanguageTa  FallbackGladiaTranscriberLanguage = "ta"
	FallbackGladiaTranscriberLanguageTt  FallbackGladiaTranscriberLanguage = "tt"
	FallbackGladiaTranscriberLanguageTe  FallbackGladiaTranscriberLanguage = "te"
	FallbackGladiaTranscriberLanguageTh  FallbackGladiaTranscriberLanguage = "th"
	FallbackGladiaTranscriberLanguageBo  FallbackGladiaTranscriberLanguage = "bo"
	FallbackGladiaTranscriberLanguageTr  FallbackGladiaTranscriberLanguage = "tr"
	FallbackGladiaTranscriberLanguageTk  FallbackGladiaTranscriberLanguage = "tk"
	FallbackGladiaTranscriberLanguageUk  FallbackGladiaTranscriberLanguage = "uk"
	FallbackGladiaTranscriberLanguageUr  FallbackGladiaTranscriberLanguage = "ur"
	FallbackGladiaTranscriberLanguageUz  FallbackGladiaTranscriberLanguage = "uz"
	FallbackGladiaTranscriberLanguageVi  FallbackGladiaTranscriberLanguage = "vi"
	FallbackGladiaTranscriberLanguageCy  FallbackGladiaTranscriberLanguage = "cy"
	FallbackGladiaTranscriberLanguageYi  FallbackGladiaTranscriberLanguage = "yi"
	FallbackGladiaTranscriberLanguageYo  FallbackGladiaTranscriberLanguage = "yo"
)

func NewFallbackGladiaTranscriberLanguageFromString(s string) (FallbackGladiaTranscriberLanguage, error) {
	switch s {
	case "af":
		return FallbackGladiaTranscriberLanguageAf, nil
	case "sq":
		return FallbackGladiaTranscriberLanguageSq, nil
	case "am":
		return FallbackGladiaTranscriberLanguageAm, nil
	case "ar":
		return FallbackGladiaTranscriberLanguageAr, nil
	case "hy":
		return FallbackGladiaTranscriberLanguageHy, nil
	case "as":
		return FallbackGladiaTranscriberLanguageAs, nil
	case "az":
		return FallbackGladiaTranscriberLanguageAz, nil
	case "ba":
		return FallbackGladiaTranscriberLanguageBa, nil
	case "eu":
		return FallbackGladiaTranscriberLanguageEu, nil
	case "be":
		return FallbackGladiaTranscriberLanguageBe, nil
	case "bn":
		return FallbackGladiaTranscriberLanguageBn, nil
	case "bs":
		return FallbackGladiaTranscriberLanguageBs, nil
	case "br":
		return FallbackGladiaTranscriberLanguageBr, nil
	case "bg":
		return FallbackGladiaTranscriberLanguageBg, nil
	case "ca":
		return FallbackGladiaTranscriberLanguageCa, nil
	case "zh":
		return FallbackGladiaTranscriberLanguageZh, nil
	case "hr":
		return FallbackGladiaTranscriberLanguageHr, nil
	case "cs":
		return FallbackGladiaTranscriberLanguageCs, nil
	case "da":
		return FallbackGladiaTranscriberLanguageDa, nil
	case "nl":
		return FallbackGladiaTranscriberLanguageNl, nil
	case "en":
		return FallbackGladiaTranscriberLanguageEn, nil
	case "et":
		return FallbackGladiaTranscriberLanguageEt, nil
	case "fo":
		return FallbackGladiaTranscriberLanguageFo, nil
	case "fi":
		return FallbackGladiaTranscriberLanguageFi, nil
	case "fr":
		return FallbackGladiaTranscriberLanguageFr, nil
	case "gl":
		return FallbackGladiaTranscriberLanguageGl, nil
	case "ka":
		return FallbackGladiaTranscriberLanguageKa, nil
	case "de":
		return FallbackGladiaTranscriberLanguageDe, nil
	case "el":
		return FallbackGladiaTranscriberLanguageEl, nil
	case "gu":
		return FallbackGladiaTranscriberLanguageGu, nil
	case "ht":
		return FallbackGladiaTranscriberLanguageHt, nil
	case "ha":
		return FallbackGladiaTranscriberLanguageHa, nil
	case "haw":
		return FallbackGladiaTranscriberLanguageHaw, nil
	case "he":
		return FallbackGladiaTranscriberLanguageHe, nil
	case "hi":
		return FallbackGladiaTranscriberLanguageHi, nil
	case "hu":
		return FallbackGladiaTranscriberLanguageHu, nil
	case "is":
		return FallbackGladiaTranscriberLanguageIs, nil
	case "id":
		return FallbackGladiaTranscriberLanguageId, nil
	case "it":
		return FallbackGladiaTranscriberLanguageIt, nil
	case "ja":
		return FallbackGladiaTranscriberLanguageJa, nil
	case "jv":
		return FallbackGladiaTranscriberLanguageJv, nil
	case "kn":
		return FallbackGladiaTranscriberLanguageKn, nil
	case "kk":
		return FallbackGladiaTranscriberLanguageKk, nil
	case "km":
		return FallbackGladiaTranscriberLanguageKm, nil
	case "ko":
		return FallbackGladiaTranscriberLanguageKo, nil
	case "lo":
		return FallbackGladiaTranscriberLanguageLo, nil
	case "la":
		return FallbackGladiaTranscriberLanguageLa, nil
	case "lv":
		return FallbackGladiaTranscriberLanguageLv, nil
	case "ln":
		return FallbackGladiaTranscriberLanguageLn, nil
	case "lt":
		return FallbackGladiaTranscriberLanguageLt, nil
	case "lb":
		return FallbackGladiaTranscriberLanguageLb, nil
	case "mk":
		return FallbackGladiaTranscriberLanguageMk, nil
	case "mg":
		return FallbackGladiaTranscriberLanguageMg, nil
	case "ms":
		return FallbackGladiaTranscriberLanguageMs, nil
	case "ml":
		return FallbackGladiaTranscriberLanguageMl, nil
	case "mt":
		return FallbackGladiaTranscriberLanguageMt, nil
	case "mi":
		return FallbackGladiaTranscriberLanguageMi, nil
	case "mr":
		return FallbackGladiaTranscriberLanguageMr, nil
	case "mn":
		return FallbackGladiaTranscriberLanguageMn, nil
	case "my":
		return FallbackGladiaTranscriberLanguageMy, nil
	case "ne":
		return FallbackGladiaTranscriberLanguageNe, nil
	case "no":
		return FallbackGladiaTranscriberLanguageNo, nil
	case "nn":
		return FallbackGladiaTranscriberLanguageNn, nil
	case "oc":
		return FallbackGladiaTranscriberLanguageOc, nil
	case "ps":
		return FallbackGladiaTranscriberLanguagePs, nil
	case "fa":
		return FallbackGladiaTranscriberLanguageFa, nil
	case "pl":
		return FallbackGladiaTranscriberLanguagePl, nil
	case "pt":
		return FallbackGladiaTranscriberLanguagePt, nil
	case "pa":
		return FallbackGladiaTranscriberLanguagePa, nil
	case "ro":
		return FallbackGladiaTranscriberLanguageRo, nil
	case "ru":
		return FallbackGladiaTranscriberLanguageRu, nil
	case "sa":
		return FallbackGladiaTranscriberLanguageSa, nil
	case "sr":
		return FallbackGladiaTranscriberLanguageSr, nil
	case "sn":
		return FallbackGladiaTranscriberLanguageSn, nil
	case "sd":
		return FallbackGladiaTranscriberLanguageSd, nil
	case "si":
		return FallbackGladiaTranscriberLanguageSi, nil
	case "sk":
		return FallbackGladiaTranscriberLanguageSk, nil
	case "sl":
		return FallbackGladiaTranscriberLanguageSl, nil
	case "so":
		return FallbackGladiaTranscriberLanguageSo, nil
	case "es":
		return FallbackGladiaTranscriberLanguageEs, nil
	case "su":
		return FallbackGladiaTranscriberLanguageSu, nil
	case "sw":
		return FallbackGladiaTranscriberLanguageSw, nil
	case "sv":
		return FallbackGladiaTranscriberLanguageSv, nil
	case "tl":
		return FallbackGladiaTranscriberLanguageTl, nil
	case "tg":
		return FallbackGladiaTranscriberLanguageTg, nil
	case "ta":
		return FallbackGladiaTranscriberLanguageTa, nil
	case "tt":
		return FallbackGladiaTranscriberLanguageTt, nil
	case "te":
		return FallbackGladiaTranscriberLanguageTe, nil
	case "th":
		return FallbackGladiaTranscriberLanguageTh, nil
	case "bo":
		return FallbackGladiaTranscriberLanguageBo, nil
	case "tr":
		return FallbackGladiaTranscriberLanguageTr, nil
	case "tk":
		return FallbackGladiaTranscriberLanguageTk, nil
	case "uk":
		return FallbackGladiaTranscriberLanguageUk, nil
	case "ur":
		return FallbackGladiaTranscriberLanguageUr, nil
	case "uz":
		return FallbackGladiaTranscriberLanguageUz, nil
	case "vi":
		return FallbackGladiaTranscriberLanguageVi, nil
	case "cy":
		return FallbackGladiaTranscriberLanguageCy, nil
	case "yi":
		return FallbackGladiaTranscriberLanguageYi, nil
	case "yo":
		return FallbackGladiaTranscriberLanguageYo, nil
	}
	var t FallbackGladiaTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackGladiaTranscriberLanguage) Ptr() *FallbackGladiaTranscriberLanguage {
	return &f
}

type FallbackGladiaTranscriberLanguageBehaviour string

const (
	FallbackGladiaTranscriberLanguageBehaviourManual                     FallbackGladiaTranscriberLanguageBehaviour = "manual"
	FallbackGladiaTranscriberLanguageBehaviourAutomaticSingleLanguage    FallbackGladiaTranscriberLanguageBehaviour = "automatic single language"
	FallbackGladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages FallbackGladiaTranscriberLanguageBehaviour = "automatic multiple languages"
)

func NewFallbackGladiaTranscriberLanguageBehaviourFromString(s string) (FallbackGladiaTranscriberLanguageBehaviour, error) {
	switch s {
	case "manual":
		return FallbackGladiaTranscriberLanguageBehaviourManual, nil
	case "automatic single language":
		return FallbackGladiaTranscriberLanguageBehaviourAutomaticSingleLanguage, nil
	case "automatic multiple languages":
		return FallbackGladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages, nil
	}
	var t FallbackGladiaTranscriberLanguageBehaviour
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackGladiaTranscriberLanguageBehaviour) Ptr() *FallbackGladiaTranscriberLanguageBehaviour {
	return &f
}

type FallbackGladiaTranscriberModel string

const (
	FallbackGladiaTranscriberModelFast     FallbackGladiaTranscriberModel = "fast"
	FallbackGladiaTranscriberModelAccurate FallbackGladiaTranscriberModel = "accurate"
)

func NewFallbackGladiaTranscriberModelFromString(s string) (FallbackGladiaTranscriberModel, error) {
	switch s {
	case "fast":
		return FallbackGladiaTranscriberModelFast, nil
	case "accurate":
		return FallbackGladiaTranscriberModelAccurate, nil
	}
	var t FallbackGladiaTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackGladiaTranscriberModel) Ptr() *FallbackGladiaTranscriberModel {
	return &f
}

type FallbackGoogleTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model *FallbackGoogleTranscriberModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription.
	Language *FallbackGoogleTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackGoogleTranscriber) GetModel() *FallbackGoogleTranscriberModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackGoogleTranscriber) GetLanguage() *FallbackGoogleTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackGoogleTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackGoogleTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackGoogleTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackGoogleTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackGoogleTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "google", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackGoogleTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackGoogleTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackGoogleTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the language that will be set for the transcription.
type FallbackGoogleTranscriberLanguage string

const (
	FallbackGoogleTranscriberLanguageMultilingual FallbackGoogleTranscriberLanguage = "Multilingual"
	FallbackGoogleTranscriberLanguageArabic       FallbackGoogleTranscriberLanguage = "Arabic"
	FallbackGoogleTranscriberLanguageBengali      FallbackGoogleTranscriberLanguage = "Bengali"
	FallbackGoogleTranscriberLanguageBulgarian    FallbackGoogleTranscriberLanguage = "Bulgarian"
	FallbackGoogleTranscriberLanguageChinese      FallbackGoogleTranscriberLanguage = "Chinese"
	FallbackGoogleTranscriberLanguageCroatian     FallbackGoogleTranscriberLanguage = "Croatian"
	FallbackGoogleTranscriberLanguageCzech        FallbackGoogleTranscriberLanguage = "Czech"
	FallbackGoogleTranscriberLanguageDanish       FallbackGoogleTranscriberLanguage = "Danish"
	FallbackGoogleTranscriberLanguageDutch        FallbackGoogleTranscriberLanguage = "Dutch"
	FallbackGoogleTranscriberLanguageEnglish      FallbackGoogleTranscriberLanguage = "English"
	FallbackGoogleTranscriberLanguageEstonian     FallbackGoogleTranscriberLanguage = "Estonian"
	FallbackGoogleTranscriberLanguageFinnish      FallbackGoogleTranscriberLanguage = "Finnish"
	FallbackGoogleTranscriberLanguageFrench       FallbackGoogleTranscriberLanguage = "French"
	FallbackGoogleTranscriberLanguageGerman       FallbackGoogleTranscriberLanguage = "German"
	FallbackGoogleTranscriberLanguageGreek        FallbackGoogleTranscriberLanguage = "Greek"
	FallbackGoogleTranscriberLanguageHebrew       FallbackGoogleTranscriberLanguage = "Hebrew"
	FallbackGoogleTranscriberLanguageHindi        FallbackGoogleTranscriberLanguage = "Hindi"
	FallbackGoogleTranscriberLanguageHungarian    FallbackGoogleTranscriberLanguage = "Hungarian"
	FallbackGoogleTranscriberLanguageIndonesian   FallbackGoogleTranscriberLanguage = "Indonesian"
	FallbackGoogleTranscriberLanguageItalian      FallbackGoogleTranscriberLanguage = "Italian"
	FallbackGoogleTranscriberLanguageJapanese     FallbackGoogleTranscriberLanguage = "Japanese"
	FallbackGoogleTranscriberLanguageKorean       FallbackGoogleTranscriberLanguage = "Korean"
	FallbackGoogleTranscriberLanguageLatvian      FallbackGoogleTranscriberLanguage = "Latvian"
	FallbackGoogleTranscriberLanguageLithuanian   FallbackGoogleTranscriberLanguage = "Lithuanian"
	FallbackGoogleTranscriberLanguageNorwegian    FallbackGoogleTranscriberLanguage = "Norwegian"
	FallbackGoogleTranscriberLanguagePolish       FallbackGoogleTranscriberLanguage = "Polish"
	FallbackGoogleTranscriberLanguagePortuguese   FallbackGoogleTranscriberLanguage = "Portuguese"
	FallbackGoogleTranscriberLanguageRomanian     FallbackGoogleTranscriberLanguage = "Romanian"
	FallbackGoogleTranscriberLanguageRussian      FallbackGoogleTranscriberLanguage = "Russian"
	FallbackGoogleTranscriberLanguageSerbian      FallbackGoogleTranscriberLanguage = "Serbian"
	FallbackGoogleTranscriberLanguageSlovak       FallbackGoogleTranscriberLanguage = "Slovak"
	FallbackGoogleTranscriberLanguageSlovenian    FallbackGoogleTranscriberLanguage = "Slovenian"
	FallbackGoogleTranscriberLanguageSpanish      FallbackGoogleTranscriberLanguage = "Spanish"
	FallbackGoogleTranscriberLanguageSwahili      FallbackGoogleTranscriberLanguage = "Swahili"
	FallbackGoogleTranscriberLanguageSwedish      FallbackGoogleTranscriberLanguage = "Swedish"
	FallbackGoogleTranscriberLanguageThai         FallbackGoogleTranscriberLanguage = "Thai"
	FallbackGoogleTranscriberLanguageTurkish      FallbackGoogleTranscriberLanguage = "Turkish"
	FallbackGoogleTranscriberLanguageUkrainian    FallbackGoogleTranscriberLanguage = "Ukrainian"
	FallbackGoogleTranscriberLanguageVietnamese   FallbackGoogleTranscriberLanguage = "Vietnamese"
)

func NewFallbackGoogleTranscriberLanguageFromString(s string) (FallbackGoogleTranscriberLanguage, error) {
	switch s {
	case "Multilingual":
		return FallbackGoogleTranscriberLanguageMultilingual, nil
	case "Arabic":
		return FallbackGoogleTranscriberLanguageArabic, nil
	case "Bengali":
		return FallbackGoogleTranscriberLanguageBengali, nil
	case "Bulgarian":
		return FallbackGoogleTranscriberLanguageBulgarian, nil
	case "Chinese":
		return FallbackGoogleTranscriberLanguageChinese, nil
	case "Croatian":
		return FallbackGoogleTranscriberLanguageCroatian, nil
	case "Czech":
		return FallbackGoogleTranscriberLanguageCzech, nil
	case "Danish":
		return FallbackGoogleTranscriberLanguageDanish, nil
	case "Dutch":
		return FallbackGoogleTranscriberLanguageDutch, nil
	case "English":
		return FallbackGoogleTranscriberLanguageEnglish, nil
	case "Estonian":
		return FallbackGoogleTranscriberLanguageEstonian, nil
	case "Finnish":
		return FallbackGoogleTranscriberLanguageFinnish, nil
	case "French":
		return FallbackGoogleTranscriberLanguageFrench, nil
	case "German":
		return FallbackGoogleTranscriberLanguageGerman, nil
	case "Greek":
		return FallbackGoogleTranscriberLanguageGreek, nil
	case "Hebrew":
		return FallbackGoogleTranscriberLanguageHebrew, nil
	case "Hindi":
		return FallbackGoogleTranscriberLanguageHindi, nil
	case "Hungarian":
		return FallbackGoogleTranscriberLanguageHungarian, nil
	case "Indonesian":
		return FallbackGoogleTranscriberLanguageIndonesian, nil
	case "Italian":
		return FallbackGoogleTranscriberLanguageItalian, nil
	case "Japanese":
		return FallbackGoogleTranscriberLanguageJapanese, nil
	case "Korean":
		return FallbackGoogleTranscriberLanguageKorean, nil
	case "Latvian":
		return FallbackGoogleTranscriberLanguageLatvian, nil
	case "Lithuanian":
		return FallbackGoogleTranscriberLanguageLithuanian, nil
	case "Norwegian":
		return FallbackGoogleTranscriberLanguageNorwegian, nil
	case "Polish":
		return FallbackGoogleTranscriberLanguagePolish, nil
	case "Portuguese":
		return FallbackGoogleTranscriberLanguagePortuguese, nil
	case "Romanian":
		return FallbackGoogleTranscriberLanguageRomanian, nil
	case "Russian":
		return FallbackGoogleTranscriberLanguageRussian, nil
	case "Serbian":
		return FallbackGoogleTranscriberLanguageSerbian, nil
	case "Slovak":
		return FallbackGoogleTranscriberLanguageSlovak, nil
	case "Slovenian":
		return FallbackGoogleTranscriberLanguageSlovenian, nil
	case "Spanish":
		return FallbackGoogleTranscriberLanguageSpanish, nil
	case "Swahili":
		return FallbackGoogleTranscriberLanguageSwahili, nil
	case "Swedish":
		return FallbackGoogleTranscriberLanguageSwedish, nil
	case "Thai":
		return FallbackGoogleTranscriberLanguageThai, nil
	case "Turkish":
		return FallbackGoogleTranscriberLanguageTurkish, nil
	case "Ukrainian":
		return FallbackGoogleTranscriberLanguageUkrainian, nil
	case "Vietnamese":
		return FallbackGoogleTranscriberLanguageVietnamese, nil
	}
	var t FallbackGoogleTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackGoogleTranscriberLanguage) Ptr() *FallbackGoogleTranscriberLanguage {
	return &f
}

// This is the model that will be used for the transcription.
type FallbackGoogleTranscriberModel string

const (
	FallbackGoogleTranscriberModelGemini25ProPreview0506       FallbackGoogleTranscriberModel = "gemini-2.5-pro-preview-05-06"
	FallbackGoogleTranscriberModelGemini25FlashPreview0417     FallbackGoogleTranscriberModel = "gemini-2.5-flash-preview-04-17"
	FallbackGoogleTranscriberModelGemini20FlashThinkingExp     FallbackGoogleTranscriberModel = "gemini-2.0-flash-thinking-exp"
	FallbackGoogleTranscriberModelGemini20ProExp0205           FallbackGoogleTranscriberModel = "gemini-2.0-pro-exp-02-05"
	FallbackGoogleTranscriberModelGemini20Flash                FallbackGoogleTranscriberModel = "gemini-2.0-flash"
	FallbackGoogleTranscriberModelGemini20FlashLite            FallbackGoogleTranscriberModel = "gemini-2.0-flash-lite"
	FallbackGoogleTranscriberModelGemini20FlashLitePreview0205 FallbackGoogleTranscriberModel = "gemini-2.0-flash-lite-preview-02-05"
	FallbackGoogleTranscriberModelGemini20FlashExp             FallbackGoogleTranscriberModel = "gemini-2.0-flash-exp"
	FallbackGoogleTranscriberModelGemini20FlashRealtimeExp     FallbackGoogleTranscriberModel = "gemini-2.0-flash-realtime-exp"
	FallbackGoogleTranscriberModelGemini15Flash                FallbackGoogleTranscriberModel = "gemini-1.5-flash"
	FallbackGoogleTranscriberModelGemini15Flash002             FallbackGoogleTranscriberModel = "gemini-1.5-flash-002"
	FallbackGoogleTranscriberModelGemini15Pro                  FallbackGoogleTranscriberModel = "gemini-1.5-pro"
	FallbackGoogleTranscriberModelGemini15Pro002               FallbackGoogleTranscriberModel = "gemini-1.5-pro-002"
	FallbackGoogleTranscriberModelGemini10Pro                  FallbackGoogleTranscriberModel = "gemini-1.0-pro"
)

func NewFallbackGoogleTranscriberModelFromString(s string) (FallbackGoogleTranscriberModel, error) {
	switch s {
	case "gemini-2.5-pro-preview-05-06":
		return FallbackGoogleTranscriberModelGemini25ProPreview0506, nil
	case "gemini-2.5-flash-preview-04-17":
		return FallbackGoogleTranscriberModelGemini25FlashPreview0417, nil
	case "gemini-2.0-flash-thinking-exp":
		return FallbackGoogleTranscriberModelGemini20FlashThinkingExp, nil
	case "gemini-2.0-pro-exp-02-05":
		return FallbackGoogleTranscriberModelGemini20ProExp0205, nil
	case "gemini-2.0-flash":
		return FallbackGoogleTranscriberModelGemini20Flash, nil
	case "gemini-2.0-flash-lite":
		return FallbackGoogleTranscriberModelGemini20FlashLite, nil
	case "gemini-2.0-flash-lite-preview-02-05":
		return FallbackGoogleTranscriberModelGemini20FlashLitePreview0205, nil
	case "gemini-2.0-flash-exp":
		return FallbackGoogleTranscriberModelGemini20FlashExp, nil
	case "gemini-2.0-flash-realtime-exp":
		return FallbackGoogleTranscriberModelGemini20FlashRealtimeExp, nil
	case "gemini-1.5-flash":
		return FallbackGoogleTranscriberModelGemini15Flash, nil
	case "gemini-1.5-flash-002":
		return FallbackGoogleTranscriberModelGemini15Flash002, nil
	case "gemini-1.5-pro":
		return FallbackGoogleTranscriberModelGemini15Pro, nil
	case "gemini-1.5-pro-002":
		return FallbackGoogleTranscriberModelGemini15Pro002, nil
	case "gemini-1.0-pro":
		return FallbackGoogleTranscriberModelGemini10Pro, nil
	}
	var t FallbackGoogleTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackGoogleTranscriberModel) Ptr() *FallbackGoogleTranscriberModel {
	return &f
}

type FallbackHumeVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the model that will be used.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The ID of the particular voice you want to use.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// Indicates whether the chosen voice is a preset Hume AI voice or a custom voice.
	IsCustomHumeVoice *bool `json:"isCustomHumeVoice,omitempty" url:"isCustomHumeVoice,omitempty"`
	// Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent (e.g., 'a soft, gentle voice with a strong British accent').
	//
	// If a Voice is specified in the request, this description serves as acting instructions.
	// If no Voice is specified, a new voice is generated based on this description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackHumeVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackHumeVoice) GetVoiceId() string {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackHumeVoice) GetIsCustomHumeVoice() *bool {
	if f == nil {
		return nil
	}
	return f.IsCustomHumeVoice
}

func (f *FallbackHumeVoice) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FallbackHumeVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackHumeVoice) Provider() string {
	return f.provider
}

func (f *FallbackHumeVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackHumeVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackHumeVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackHumeVoice(unmarshaler.embed)
	if unmarshaler.Provider != "hume" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "hume", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackHumeVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackHumeVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "hume",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackHumeVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackLmntVoiceId struct {
	FallbackLmntVoiceIdEnum FallbackLmntVoiceIdEnum
	String                  string

	typ string
}

func (f *FallbackLmntVoiceId) GetFallbackLmntVoiceIdEnum() FallbackLmntVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackLmntVoiceIdEnum
}

func (f *FallbackLmntVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackLmntVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackLmntVoiceIdEnum FallbackLmntVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackLmntVoiceIdEnum); err == nil {
		f.typ = "FallbackLmntVoiceIdEnum"
		f.FallbackLmntVoiceIdEnum = valueFallbackLmntVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackLmntVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackLmntVoiceIdEnum" || f.FallbackLmntVoiceIdEnum != "" {
		return json.Marshal(f.FallbackLmntVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackLmntVoiceIdVisitor interface {
	VisitFallbackLmntVoiceIdEnum(FallbackLmntVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackLmntVoiceId) Accept(visitor FallbackLmntVoiceIdVisitor) error {
	if f.typ == "FallbackLmntVoiceIdEnum" || f.FallbackLmntVoiceIdEnum != "" {
		return visitor.VisitFallbackLmntVoiceIdEnum(f.FallbackLmntVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackLmntVoiceIdEnum string

const (
	FallbackLmntVoiceIdEnumLily   FallbackLmntVoiceIdEnum = "lily"
	FallbackLmntVoiceIdEnumDaniel FallbackLmntVoiceIdEnum = "daniel"
)

func NewFallbackLmntVoiceIdEnumFromString(s string) (FallbackLmntVoiceIdEnum, error) {
	switch s {
	case "lily":
		return FallbackLmntVoiceIdEnumLily, nil
	case "daniel":
		return FallbackLmntVoiceIdEnumDaniel, nil
	}
	var t FallbackLmntVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackLmntVoiceIdEnum) Ptr() *FallbackLmntVoiceIdEnum {
	return &f
}

type FallbackLmntVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackLmntVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackLmntVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackLmntVoice) GetVoiceId() *FallbackLmntVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackLmntVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackLmntVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackLmntVoice) Provider() string {
	return f.provider
}

func (f *FallbackLmntVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackLmntVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackLmntVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackLmntVoice(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "lmnt", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackLmntVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackLmntVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackLmntVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackNeetsVoice struct {
	VoiceId interface{} `json:"voiceId,omitempty" url:"voiceId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackNeetsVoice) GetVoiceId() interface{} {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackNeetsVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackNeetsVoice) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackNeetsVoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackNeetsVoice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackNeetsVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackNeuphonicVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the model that will be used. Defaults to 'neu_fast' if not specified.
	Model *FallbackNeuphonicVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language (ISO 639-1) that is enforced for the model.
	Language map[string]interface{} `json:"language,omitempty" url:"language,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackNeuphonicVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackNeuphonicVoice) GetVoiceId() string {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackNeuphonicVoice) GetModel() *FallbackNeuphonicVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackNeuphonicVoice) GetLanguage() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackNeuphonicVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackNeuphonicVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackNeuphonicVoice) Provider() string {
	return f.provider
}

func (f *FallbackNeuphonicVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackNeuphonicVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackNeuphonicVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackNeuphonicVoice(unmarshaler.embed)
	if unmarshaler.Provider != "neuphonic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "neuphonic", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackNeuphonicVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackNeuphonicVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "neuphonic",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackNeuphonicVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the model that will be used. Defaults to 'neu_fast' if not specified.
type FallbackNeuphonicVoiceModel string

const (
	FallbackNeuphonicVoiceModelNeuHq   FallbackNeuphonicVoiceModel = "neu_hq"
	FallbackNeuphonicVoiceModelNeuFast FallbackNeuphonicVoiceModel = "neu_fast"
)

func NewFallbackNeuphonicVoiceModelFromString(s string) (FallbackNeuphonicVoiceModel, error) {
	switch s {
	case "neu_hq":
		return FallbackNeuphonicVoiceModelNeuHq, nil
	case "neu_fast":
		return FallbackNeuphonicVoiceModelNeuFast, nil
	}
	var t FallbackNeuphonicVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackNeuphonicVoiceModel) Ptr() *FallbackNeuphonicVoiceModel {
	return &f
}

// This is the provider-specific ID that will be used.
// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
type FallbackOpenAiVoiceId struct {
	FallbackOpenAiVoiceIdEnum FallbackOpenAiVoiceIdEnum
	String                    string

	typ string
}

func (f *FallbackOpenAiVoiceId) GetFallbackOpenAiVoiceIdEnum() FallbackOpenAiVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackOpenAiVoiceIdEnum
}

func (f *FallbackOpenAiVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackOpenAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackOpenAiVoiceIdEnum FallbackOpenAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackOpenAiVoiceIdEnum); err == nil {
		f.typ = "FallbackOpenAiVoiceIdEnum"
		f.FallbackOpenAiVoiceIdEnum = valueFallbackOpenAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackOpenAiVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackOpenAiVoiceIdEnum" || f.FallbackOpenAiVoiceIdEnum != "" {
		return json.Marshal(f.FallbackOpenAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackOpenAiVoiceIdVisitor interface {
	VisitFallbackOpenAiVoiceIdEnum(FallbackOpenAiVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackOpenAiVoiceId) Accept(visitor FallbackOpenAiVoiceIdVisitor) error {
	if f.typ == "FallbackOpenAiVoiceIdEnum" || f.FallbackOpenAiVoiceIdEnum != "" {
		return visitor.VisitFallbackOpenAiVoiceIdEnum(f.FallbackOpenAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackOpenAiVoiceIdEnum string

const (
	FallbackOpenAiVoiceIdEnumAlloy   FallbackOpenAiVoiceIdEnum = "alloy"
	FallbackOpenAiVoiceIdEnumEcho    FallbackOpenAiVoiceIdEnum = "echo"
	FallbackOpenAiVoiceIdEnumFable   FallbackOpenAiVoiceIdEnum = "fable"
	FallbackOpenAiVoiceIdEnumOnyx    FallbackOpenAiVoiceIdEnum = "onyx"
	FallbackOpenAiVoiceIdEnumNova    FallbackOpenAiVoiceIdEnum = "nova"
	FallbackOpenAiVoiceIdEnumShimmer FallbackOpenAiVoiceIdEnum = "shimmer"
)

func NewFallbackOpenAiVoiceIdEnumFromString(s string) (FallbackOpenAiVoiceIdEnum, error) {
	switch s {
	case "alloy":
		return FallbackOpenAiVoiceIdEnumAlloy, nil
	case "echo":
		return FallbackOpenAiVoiceIdEnumEcho, nil
	case "fable":
		return FallbackOpenAiVoiceIdEnumFable, nil
	case "onyx":
		return FallbackOpenAiVoiceIdEnumOnyx, nil
	case "nova":
		return FallbackOpenAiVoiceIdEnumNova, nil
	case "shimmer":
		return FallbackOpenAiVoiceIdEnumShimmer, nil
	}
	var t FallbackOpenAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackOpenAiVoiceIdEnum) Ptr() *FallbackOpenAiVoiceIdEnum {
	return &f
}

type FallbackOpenAiTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model FallbackOpenAiTranscriberModel `json:"model" url:"model"`
	// This is the language that will be set for the transcription.
	Language *FallbackOpenAiTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackOpenAiTranscriber) GetModel() FallbackOpenAiTranscriberModel {
	if f == nil {
		return ""
	}
	return f.Model
}

func (f *FallbackOpenAiTranscriber) GetLanguage() *FallbackOpenAiTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackOpenAiTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackOpenAiTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackOpenAiTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackOpenAiTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackOpenAiTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "openai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackOpenAiTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackOpenAiTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackOpenAiTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the language that will be set for the transcription.
type FallbackOpenAiTranscriberLanguage string

const (
	FallbackOpenAiTranscriberLanguageAf FallbackOpenAiTranscriberLanguage = "af"
	FallbackOpenAiTranscriberLanguageAr FallbackOpenAiTranscriberLanguage = "ar"
	FallbackOpenAiTranscriberLanguageHy FallbackOpenAiTranscriberLanguage = "hy"
	FallbackOpenAiTranscriberLanguageAz FallbackOpenAiTranscriberLanguage = "az"
	FallbackOpenAiTranscriberLanguageBe FallbackOpenAiTranscriberLanguage = "be"
	FallbackOpenAiTranscriberLanguageBs FallbackOpenAiTranscriberLanguage = "bs"
	FallbackOpenAiTranscriberLanguageBg FallbackOpenAiTranscriberLanguage = "bg"
	FallbackOpenAiTranscriberLanguageCa FallbackOpenAiTranscriberLanguage = "ca"
	FallbackOpenAiTranscriberLanguageZh FallbackOpenAiTranscriberLanguage = "zh"
	FallbackOpenAiTranscriberLanguageHr FallbackOpenAiTranscriberLanguage = "hr"
	FallbackOpenAiTranscriberLanguageCs FallbackOpenAiTranscriberLanguage = "cs"
	FallbackOpenAiTranscriberLanguageDa FallbackOpenAiTranscriberLanguage = "da"
	FallbackOpenAiTranscriberLanguageNl FallbackOpenAiTranscriberLanguage = "nl"
	FallbackOpenAiTranscriberLanguageEn FallbackOpenAiTranscriberLanguage = "en"
	FallbackOpenAiTranscriberLanguageEt FallbackOpenAiTranscriberLanguage = "et"
	FallbackOpenAiTranscriberLanguageFi FallbackOpenAiTranscriberLanguage = "fi"
	FallbackOpenAiTranscriberLanguageFr FallbackOpenAiTranscriberLanguage = "fr"
	FallbackOpenAiTranscriberLanguageGl FallbackOpenAiTranscriberLanguage = "gl"
	FallbackOpenAiTranscriberLanguageDe FallbackOpenAiTranscriberLanguage = "de"
	FallbackOpenAiTranscriberLanguageEl FallbackOpenAiTranscriberLanguage = "el"
	FallbackOpenAiTranscriberLanguageHe FallbackOpenAiTranscriberLanguage = "he"
	FallbackOpenAiTranscriberLanguageHi FallbackOpenAiTranscriberLanguage = "hi"
	FallbackOpenAiTranscriberLanguageHu FallbackOpenAiTranscriberLanguage = "hu"
	FallbackOpenAiTranscriberLanguageIs FallbackOpenAiTranscriberLanguage = "is"
	FallbackOpenAiTranscriberLanguageId FallbackOpenAiTranscriberLanguage = "id"
	FallbackOpenAiTranscriberLanguageIt FallbackOpenAiTranscriberLanguage = "it"
	FallbackOpenAiTranscriberLanguageJa FallbackOpenAiTranscriberLanguage = "ja"
	FallbackOpenAiTranscriberLanguageKn FallbackOpenAiTranscriberLanguage = "kn"
	FallbackOpenAiTranscriberLanguageKk FallbackOpenAiTranscriberLanguage = "kk"
	FallbackOpenAiTranscriberLanguageKo FallbackOpenAiTranscriberLanguage = "ko"
	FallbackOpenAiTranscriberLanguageLv FallbackOpenAiTranscriberLanguage = "lv"
	FallbackOpenAiTranscriberLanguageLt FallbackOpenAiTranscriberLanguage = "lt"
	FallbackOpenAiTranscriberLanguageMk FallbackOpenAiTranscriberLanguage = "mk"
	FallbackOpenAiTranscriberLanguageMs FallbackOpenAiTranscriberLanguage = "ms"
	FallbackOpenAiTranscriberLanguageMr FallbackOpenAiTranscriberLanguage = "mr"
	FallbackOpenAiTranscriberLanguageMi FallbackOpenAiTranscriberLanguage = "mi"
	FallbackOpenAiTranscriberLanguageNe FallbackOpenAiTranscriberLanguage = "ne"
	FallbackOpenAiTranscriberLanguageNo FallbackOpenAiTranscriberLanguage = "no"
	FallbackOpenAiTranscriberLanguageFa FallbackOpenAiTranscriberLanguage = "fa"
	FallbackOpenAiTranscriberLanguagePl FallbackOpenAiTranscriberLanguage = "pl"
	FallbackOpenAiTranscriberLanguagePt FallbackOpenAiTranscriberLanguage = "pt"
	FallbackOpenAiTranscriberLanguageRo FallbackOpenAiTranscriberLanguage = "ro"
	FallbackOpenAiTranscriberLanguageRu FallbackOpenAiTranscriberLanguage = "ru"
	FallbackOpenAiTranscriberLanguageSr FallbackOpenAiTranscriberLanguage = "sr"
	FallbackOpenAiTranscriberLanguageSk FallbackOpenAiTranscriberLanguage = "sk"
	FallbackOpenAiTranscriberLanguageSl FallbackOpenAiTranscriberLanguage = "sl"
	FallbackOpenAiTranscriberLanguageEs FallbackOpenAiTranscriberLanguage = "es"
	FallbackOpenAiTranscriberLanguageSw FallbackOpenAiTranscriberLanguage = "sw"
	FallbackOpenAiTranscriberLanguageSv FallbackOpenAiTranscriberLanguage = "sv"
	FallbackOpenAiTranscriberLanguageTl FallbackOpenAiTranscriberLanguage = "tl"
	FallbackOpenAiTranscriberLanguageTa FallbackOpenAiTranscriberLanguage = "ta"
	FallbackOpenAiTranscriberLanguageTh FallbackOpenAiTranscriberLanguage = "th"
	FallbackOpenAiTranscriberLanguageTr FallbackOpenAiTranscriberLanguage = "tr"
	FallbackOpenAiTranscriberLanguageUk FallbackOpenAiTranscriberLanguage = "uk"
	FallbackOpenAiTranscriberLanguageUr FallbackOpenAiTranscriberLanguage = "ur"
	FallbackOpenAiTranscriberLanguageVi FallbackOpenAiTranscriberLanguage = "vi"
	FallbackOpenAiTranscriberLanguageCy FallbackOpenAiTranscriberLanguage = "cy"
)

func NewFallbackOpenAiTranscriberLanguageFromString(s string) (FallbackOpenAiTranscriberLanguage, error) {
	switch s {
	case "af":
		return FallbackOpenAiTranscriberLanguageAf, nil
	case "ar":
		return FallbackOpenAiTranscriberLanguageAr, nil
	case "hy":
		return FallbackOpenAiTranscriberLanguageHy, nil
	case "az":
		return FallbackOpenAiTranscriberLanguageAz, nil
	case "be":
		return FallbackOpenAiTranscriberLanguageBe, nil
	case "bs":
		return FallbackOpenAiTranscriberLanguageBs, nil
	case "bg":
		return FallbackOpenAiTranscriberLanguageBg, nil
	case "ca":
		return FallbackOpenAiTranscriberLanguageCa, nil
	case "zh":
		return FallbackOpenAiTranscriberLanguageZh, nil
	case "hr":
		return FallbackOpenAiTranscriberLanguageHr, nil
	case "cs":
		return FallbackOpenAiTranscriberLanguageCs, nil
	case "da":
		return FallbackOpenAiTranscriberLanguageDa, nil
	case "nl":
		return FallbackOpenAiTranscriberLanguageNl, nil
	case "en":
		return FallbackOpenAiTranscriberLanguageEn, nil
	case "et":
		return FallbackOpenAiTranscriberLanguageEt, nil
	case "fi":
		return FallbackOpenAiTranscriberLanguageFi, nil
	case "fr":
		return FallbackOpenAiTranscriberLanguageFr, nil
	case "gl":
		return FallbackOpenAiTranscriberLanguageGl, nil
	case "de":
		return FallbackOpenAiTranscriberLanguageDe, nil
	case "el":
		return FallbackOpenAiTranscriberLanguageEl, nil
	case "he":
		return FallbackOpenAiTranscriberLanguageHe, nil
	case "hi":
		return FallbackOpenAiTranscriberLanguageHi, nil
	case "hu":
		return FallbackOpenAiTranscriberLanguageHu, nil
	case "is":
		return FallbackOpenAiTranscriberLanguageIs, nil
	case "id":
		return FallbackOpenAiTranscriberLanguageId, nil
	case "it":
		return FallbackOpenAiTranscriberLanguageIt, nil
	case "ja":
		return FallbackOpenAiTranscriberLanguageJa, nil
	case "kn":
		return FallbackOpenAiTranscriberLanguageKn, nil
	case "kk":
		return FallbackOpenAiTranscriberLanguageKk, nil
	case "ko":
		return FallbackOpenAiTranscriberLanguageKo, nil
	case "lv":
		return FallbackOpenAiTranscriberLanguageLv, nil
	case "lt":
		return FallbackOpenAiTranscriberLanguageLt, nil
	case "mk":
		return FallbackOpenAiTranscriberLanguageMk, nil
	case "ms":
		return FallbackOpenAiTranscriberLanguageMs, nil
	case "mr":
		return FallbackOpenAiTranscriberLanguageMr, nil
	case "mi":
		return FallbackOpenAiTranscriberLanguageMi, nil
	case "ne":
		return FallbackOpenAiTranscriberLanguageNe, nil
	case "no":
		return FallbackOpenAiTranscriberLanguageNo, nil
	case "fa":
		return FallbackOpenAiTranscriberLanguageFa, nil
	case "pl":
		return FallbackOpenAiTranscriberLanguagePl, nil
	case "pt":
		return FallbackOpenAiTranscriberLanguagePt, nil
	case "ro":
		return FallbackOpenAiTranscriberLanguageRo, nil
	case "ru":
		return FallbackOpenAiTranscriberLanguageRu, nil
	case "sr":
		return FallbackOpenAiTranscriberLanguageSr, nil
	case "sk":
		return FallbackOpenAiTranscriberLanguageSk, nil
	case "sl":
		return FallbackOpenAiTranscriberLanguageSl, nil
	case "es":
		return FallbackOpenAiTranscriberLanguageEs, nil
	case "sw":
		return FallbackOpenAiTranscriberLanguageSw, nil
	case "sv":
		return FallbackOpenAiTranscriberLanguageSv, nil
	case "tl":
		return FallbackOpenAiTranscriberLanguageTl, nil
	case "ta":
		return FallbackOpenAiTranscriberLanguageTa, nil
	case "th":
		return FallbackOpenAiTranscriberLanguageTh, nil
	case "tr":
		return FallbackOpenAiTranscriberLanguageTr, nil
	case "uk":
		return FallbackOpenAiTranscriberLanguageUk, nil
	case "ur":
		return FallbackOpenAiTranscriberLanguageUr, nil
	case "vi":
		return FallbackOpenAiTranscriberLanguageVi, nil
	case "cy":
		return FallbackOpenAiTranscriberLanguageCy, nil
	}
	var t FallbackOpenAiTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackOpenAiTranscriberLanguage) Ptr() *FallbackOpenAiTranscriberLanguage {
	return &f
}

// This is the model that will be used for the transcription.
type FallbackOpenAiTranscriberModel string

const (
	FallbackOpenAiTranscriberModelGpt4OTranscribe     FallbackOpenAiTranscriberModel = "gpt-4o-transcribe"
	FallbackOpenAiTranscriberModelGpt4OMiniTranscribe FallbackOpenAiTranscriberModel = "gpt-4o-mini-transcribe"
)

func NewFallbackOpenAiTranscriberModelFromString(s string) (FallbackOpenAiTranscriberModel, error) {
	switch s {
	case "gpt-4o-transcribe":
		return FallbackOpenAiTranscriberModelGpt4OTranscribe, nil
	case "gpt-4o-mini-transcribe":
		return FallbackOpenAiTranscriberModelGpt4OMiniTranscribe, nil
	}
	var t FallbackOpenAiTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackOpenAiTranscriberModel) Ptr() *FallbackOpenAiTranscriberModel {
	return &f
}

type FallbackOpenAiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
	VoiceId *FallbackOpenAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the model that will be used for text-to-speech.
	Model *FallbackOpenAiVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is a prompt that allows you to control the voice of your generated audio.
	// Does not work with 'tts-1' or 'tts-1-hd' models.
	Instructions *string `json:"instructions,omitempty" url:"instructions,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackOpenAiVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackOpenAiVoice) GetVoiceId() *FallbackOpenAiVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackOpenAiVoice) GetModel() *FallbackOpenAiVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackOpenAiVoice) GetInstructions() *string {
	if f == nil {
		return nil
	}
	return f.Instructions
}

func (f *FallbackOpenAiVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackOpenAiVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackOpenAiVoice) Provider() string {
	return f.provider
}

func (f *FallbackOpenAiVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackOpenAiVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackOpenAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackOpenAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "openai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackOpenAiVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackOpenAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackOpenAiVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the model that will be used for text-to-speech.
type FallbackOpenAiVoiceModel string

const (
	FallbackOpenAiVoiceModelTts1         FallbackOpenAiVoiceModel = "tts-1"
	FallbackOpenAiVoiceModelTts1Hd       FallbackOpenAiVoiceModel = "tts-1-hd"
	FallbackOpenAiVoiceModelGpt4OMiniTts FallbackOpenAiVoiceModel = "gpt-4o-mini-tts"
)

func NewFallbackOpenAiVoiceModelFromString(s string) (FallbackOpenAiVoiceModel, error) {
	switch s {
	case "tts-1":
		return FallbackOpenAiVoiceModelTts1, nil
	case "tts-1-hd":
		return FallbackOpenAiVoiceModelTts1Hd, nil
	case "gpt-4o-mini-tts":
		return FallbackOpenAiVoiceModelGpt4OMiniTts, nil
	}
	var t FallbackOpenAiVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackOpenAiVoiceModel) Ptr() *FallbackOpenAiVoiceModel {
	return &f
}

type FallbackPlan struct {
	// This is the list of voices to fallback to in the event that the primary voice provider fails.
	Voices []*FallbackPlanVoicesItem `json:"voices,omitempty" url:"voices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackPlan) GetVoices() []*FallbackPlanVoicesItem {
	if f == nil {
		return nil
	}
	return f.Voices
}

func (f *FallbackPlan) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackPlan) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackPlanVoicesItem struct {
	FallbackAzureVoice      *FallbackAzureVoice
	FallbackCartesiaVoice   *FallbackCartesiaVoice
	FallbackHumeVoice       *FallbackHumeVoice
	FallbackCustomVoice     *FallbackCustomVoice
	FallbackDeepgramVoice   *FallbackDeepgramVoice
	FallbackElevenLabsVoice *FallbackElevenLabsVoice
	FallbackVapiVoice       *FallbackVapiVoice
	FallbackLmntVoice       *FallbackLmntVoice
	FallbackOpenAiVoice     *FallbackOpenAiVoice
	FallbackPlayHtVoice     *FallbackPlayHtVoice
	FallbackRimeAiVoice     *FallbackRimeAiVoice
	FallbackSmallestAiVoice *FallbackSmallestAiVoice
	FallbackTavusVoice      *FallbackTavusVoice

	typ string
}

func (f *FallbackPlanVoicesItem) GetFallbackAzureVoice() *FallbackAzureVoice {
	if f == nil {
		return nil
	}
	return f.FallbackAzureVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackCartesiaVoice() *FallbackCartesiaVoice {
	if f == nil {
		return nil
	}
	return f.FallbackCartesiaVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackHumeVoice() *FallbackHumeVoice {
	if f == nil {
		return nil
	}
	return f.FallbackHumeVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackCustomVoice() *FallbackCustomVoice {
	if f == nil {
		return nil
	}
	return f.FallbackCustomVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackDeepgramVoice() *FallbackDeepgramVoice {
	if f == nil {
		return nil
	}
	return f.FallbackDeepgramVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackElevenLabsVoice() *FallbackElevenLabsVoice {
	if f == nil {
		return nil
	}
	return f.FallbackElevenLabsVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackVapiVoice() *FallbackVapiVoice {
	if f == nil {
		return nil
	}
	return f.FallbackVapiVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackLmntVoice() *FallbackLmntVoice {
	if f == nil {
		return nil
	}
	return f.FallbackLmntVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackOpenAiVoice() *FallbackOpenAiVoice {
	if f == nil {
		return nil
	}
	return f.FallbackOpenAiVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackPlayHtVoice() *FallbackPlayHtVoice {
	if f == nil {
		return nil
	}
	return f.FallbackPlayHtVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackRimeAiVoice() *FallbackRimeAiVoice {
	if f == nil {
		return nil
	}
	return f.FallbackRimeAiVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackSmallestAiVoice() *FallbackSmallestAiVoice {
	if f == nil {
		return nil
	}
	return f.FallbackSmallestAiVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackTavusVoice() *FallbackTavusVoice {
	if f == nil {
		return nil
	}
	return f.FallbackTavusVoice
}

func (f *FallbackPlanVoicesItem) UnmarshalJSON(data []byte) error {
	valueFallbackAzureVoice := new(FallbackAzureVoice)
	if err := json.Unmarshal(data, &valueFallbackAzureVoice); err == nil {
		f.typ = "FallbackAzureVoice"
		f.FallbackAzureVoice = valueFallbackAzureVoice
		return nil
	}
	valueFallbackCartesiaVoice := new(FallbackCartesiaVoice)
	if err := json.Unmarshal(data, &valueFallbackCartesiaVoice); err == nil {
		f.typ = "FallbackCartesiaVoice"
		f.FallbackCartesiaVoice = valueFallbackCartesiaVoice
		return nil
	}
	valueFallbackHumeVoice := new(FallbackHumeVoice)
	if err := json.Unmarshal(data, &valueFallbackHumeVoice); err == nil {
		f.typ = "FallbackHumeVoice"
		f.FallbackHumeVoice = valueFallbackHumeVoice
		return nil
	}
	valueFallbackCustomVoice := new(FallbackCustomVoice)
	if err := json.Unmarshal(data, &valueFallbackCustomVoice); err == nil {
		f.typ = "FallbackCustomVoice"
		f.FallbackCustomVoice = valueFallbackCustomVoice
		return nil
	}
	valueFallbackDeepgramVoice := new(FallbackDeepgramVoice)
	if err := json.Unmarshal(data, &valueFallbackDeepgramVoice); err == nil {
		f.typ = "FallbackDeepgramVoice"
		f.FallbackDeepgramVoice = valueFallbackDeepgramVoice
		return nil
	}
	valueFallbackElevenLabsVoice := new(FallbackElevenLabsVoice)
	if err := json.Unmarshal(data, &valueFallbackElevenLabsVoice); err == nil {
		f.typ = "FallbackElevenLabsVoice"
		f.FallbackElevenLabsVoice = valueFallbackElevenLabsVoice
		return nil
	}
	valueFallbackVapiVoice := new(FallbackVapiVoice)
	if err := json.Unmarshal(data, &valueFallbackVapiVoice); err == nil {
		f.typ = "FallbackVapiVoice"
		f.FallbackVapiVoice = valueFallbackVapiVoice
		return nil
	}
	valueFallbackLmntVoice := new(FallbackLmntVoice)
	if err := json.Unmarshal(data, &valueFallbackLmntVoice); err == nil {
		f.typ = "FallbackLmntVoice"
		f.FallbackLmntVoice = valueFallbackLmntVoice
		return nil
	}
	valueFallbackOpenAiVoice := new(FallbackOpenAiVoice)
	if err := json.Unmarshal(data, &valueFallbackOpenAiVoice); err == nil {
		f.typ = "FallbackOpenAiVoice"
		f.FallbackOpenAiVoice = valueFallbackOpenAiVoice
		return nil
	}
	valueFallbackPlayHtVoice := new(FallbackPlayHtVoice)
	if err := json.Unmarshal(data, &valueFallbackPlayHtVoice); err == nil {
		f.typ = "FallbackPlayHtVoice"
		f.FallbackPlayHtVoice = valueFallbackPlayHtVoice
		return nil
	}
	valueFallbackRimeAiVoice := new(FallbackRimeAiVoice)
	if err := json.Unmarshal(data, &valueFallbackRimeAiVoice); err == nil {
		f.typ = "FallbackRimeAiVoice"
		f.FallbackRimeAiVoice = valueFallbackRimeAiVoice
		return nil
	}
	valueFallbackSmallestAiVoice := new(FallbackSmallestAiVoice)
	if err := json.Unmarshal(data, &valueFallbackSmallestAiVoice); err == nil {
		f.typ = "FallbackSmallestAiVoice"
		f.FallbackSmallestAiVoice = valueFallbackSmallestAiVoice
		return nil
	}
	valueFallbackTavusVoice := new(FallbackTavusVoice)
	if err := json.Unmarshal(data, &valueFallbackTavusVoice); err == nil {
		f.typ = "FallbackTavusVoice"
		f.FallbackTavusVoice = valueFallbackTavusVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackPlanVoicesItem) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackAzureVoice" || f.FallbackAzureVoice != nil {
		return json.Marshal(f.FallbackAzureVoice)
	}
	if f.typ == "FallbackCartesiaVoice" || f.FallbackCartesiaVoice != nil {
		return json.Marshal(f.FallbackCartesiaVoice)
	}
	if f.typ == "FallbackHumeVoice" || f.FallbackHumeVoice != nil {
		return json.Marshal(f.FallbackHumeVoice)
	}
	if f.typ == "FallbackCustomVoice" || f.FallbackCustomVoice != nil {
		return json.Marshal(f.FallbackCustomVoice)
	}
	if f.typ == "FallbackDeepgramVoice" || f.FallbackDeepgramVoice != nil {
		return json.Marshal(f.FallbackDeepgramVoice)
	}
	if f.typ == "FallbackElevenLabsVoice" || f.FallbackElevenLabsVoice != nil {
		return json.Marshal(f.FallbackElevenLabsVoice)
	}
	if f.typ == "FallbackVapiVoice" || f.FallbackVapiVoice != nil {
		return json.Marshal(f.FallbackVapiVoice)
	}
	if f.typ == "FallbackLmntVoice" || f.FallbackLmntVoice != nil {
		return json.Marshal(f.FallbackLmntVoice)
	}
	if f.typ == "FallbackOpenAiVoice" || f.FallbackOpenAiVoice != nil {
		return json.Marshal(f.FallbackOpenAiVoice)
	}
	if f.typ == "FallbackPlayHtVoice" || f.FallbackPlayHtVoice != nil {
		return json.Marshal(f.FallbackPlayHtVoice)
	}
	if f.typ == "FallbackRimeAiVoice" || f.FallbackRimeAiVoice != nil {
		return json.Marshal(f.FallbackRimeAiVoice)
	}
	if f.typ == "FallbackSmallestAiVoice" || f.FallbackSmallestAiVoice != nil {
		return json.Marshal(f.FallbackSmallestAiVoice)
	}
	if f.typ == "FallbackTavusVoice" || f.FallbackTavusVoice != nil {
		return json.Marshal(f.FallbackTavusVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackPlanVoicesItemVisitor interface {
	VisitFallbackAzureVoice(*FallbackAzureVoice) error
	VisitFallbackCartesiaVoice(*FallbackCartesiaVoice) error
	VisitFallbackHumeVoice(*FallbackHumeVoice) error
	VisitFallbackCustomVoice(*FallbackCustomVoice) error
	VisitFallbackDeepgramVoice(*FallbackDeepgramVoice) error
	VisitFallbackElevenLabsVoice(*FallbackElevenLabsVoice) error
	VisitFallbackVapiVoice(*FallbackVapiVoice) error
	VisitFallbackLmntVoice(*FallbackLmntVoice) error
	VisitFallbackOpenAiVoice(*FallbackOpenAiVoice) error
	VisitFallbackPlayHtVoice(*FallbackPlayHtVoice) error
	VisitFallbackRimeAiVoice(*FallbackRimeAiVoice) error
	VisitFallbackSmallestAiVoice(*FallbackSmallestAiVoice) error
	VisitFallbackTavusVoice(*FallbackTavusVoice) error
}

func (f *FallbackPlanVoicesItem) Accept(visitor FallbackPlanVoicesItemVisitor) error {
	if f.typ == "FallbackAzureVoice" || f.FallbackAzureVoice != nil {
		return visitor.VisitFallbackAzureVoice(f.FallbackAzureVoice)
	}
	if f.typ == "FallbackCartesiaVoice" || f.FallbackCartesiaVoice != nil {
		return visitor.VisitFallbackCartesiaVoice(f.FallbackCartesiaVoice)
	}
	if f.typ == "FallbackHumeVoice" || f.FallbackHumeVoice != nil {
		return visitor.VisitFallbackHumeVoice(f.FallbackHumeVoice)
	}
	if f.typ == "FallbackCustomVoice" || f.FallbackCustomVoice != nil {
		return visitor.VisitFallbackCustomVoice(f.FallbackCustomVoice)
	}
	if f.typ == "FallbackDeepgramVoice" || f.FallbackDeepgramVoice != nil {
		return visitor.VisitFallbackDeepgramVoice(f.FallbackDeepgramVoice)
	}
	if f.typ == "FallbackElevenLabsVoice" || f.FallbackElevenLabsVoice != nil {
		return visitor.VisitFallbackElevenLabsVoice(f.FallbackElevenLabsVoice)
	}
	if f.typ == "FallbackVapiVoice" || f.FallbackVapiVoice != nil {
		return visitor.VisitFallbackVapiVoice(f.FallbackVapiVoice)
	}
	if f.typ == "FallbackLmntVoice" || f.FallbackLmntVoice != nil {
		return visitor.VisitFallbackLmntVoice(f.FallbackLmntVoice)
	}
	if f.typ == "FallbackOpenAiVoice" || f.FallbackOpenAiVoice != nil {
		return visitor.VisitFallbackOpenAiVoice(f.FallbackOpenAiVoice)
	}
	if f.typ == "FallbackPlayHtVoice" || f.FallbackPlayHtVoice != nil {
		return visitor.VisitFallbackPlayHtVoice(f.FallbackPlayHtVoice)
	}
	if f.typ == "FallbackRimeAiVoice" || f.FallbackRimeAiVoice != nil {
		return visitor.VisitFallbackRimeAiVoice(f.FallbackRimeAiVoice)
	}
	if f.typ == "FallbackSmallestAiVoice" || f.FallbackSmallestAiVoice != nil {
		return visitor.VisitFallbackSmallestAiVoice(f.FallbackSmallestAiVoice)
	}
	if f.typ == "FallbackTavusVoice" || f.FallbackTavusVoice != nil {
		return visitor.VisitFallbackTavusVoice(f.FallbackTavusVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// This is the provider-specific ID that will be used.
type FallbackPlayHtVoiceId struct {
	FallbackPlayHtVoiceIdEnum FallbackPlayHtVoiceIdEnum
	String                    string

	typ string
}

func (f *FallbackPlayHtVoiceId) GetFallbackPlayHtVoiceIdEnum() FallbackPlayHtVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackPlayHtVoiceIdEnum
}

func (f *FallbackPlayHtVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackPlayHtVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackPlayHtVoiceIdEnum FallbackPlayHtVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackPlayHtVoiceIdEnum); err == nil {
		f.typ = "FallbackPlayHtVoiceIdEnum"
		f.FallbackPlayHtVoiceIdEnum = valueFallbackPlayHtVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackPlayHtVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackPlayHtVoiceIdEnum" || f.FallbackPlayHtVoiceIdEnum != "" {
		return json.Marshal(f.FallbackPlayHtVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackPlayHtVoiceIdVisitor interface {
	VisitFallbackPlayHtVoiceIdEnum(FallbackPlayHtVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackPlayHtVoiceId) Accept(visitor FallbackPlayHtVoiceIdVisitor) error {
	if f.typ == "FallbackPlayHtVoiceIdEnum" || f.FallbackPlayHtVoiceIdEnum != "" {
		return visitor.VisitFallbackPlayHtVoiceIdEnum(f.FallbackPlayHtVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackPlayHtVoiceIdEnum string

const (
	FallbackPlayHtVoiceIdEnumJennifer FallbackPlayHtVoiceIdEnum = "jennifer"
	FallbackPlayHtVoiceIdEnumMelissa  FallbackPlayHtVoiceIdEnum = "melissa"
	FallbackPlayHtVoiceIdEnumWill     FallbackPlayHtVoiceIdEnum = "will"
	FallbackPlayHtVoiceIdEnumChris    FallbackPlayHtVoiceIdEnum = "chris"
	FallbackPlayHtVoiceIdEnumMatt     FallbackPlayHtVoiceIdEnum = "matt"
	FallbackPlayHtVoiceIdEnumJack     FallbackPlayHtVoiceIdEnum = "jack"
	FallbackPlayHtVoiceIdEnumRuby     FallbackPlayHtVoiceIdEnum = "ruby"
	FallbackPlayHtVoiceIdEnumDavis    FallbackPlayHtVoiceIdEnum = "davis"
	FallbackPlayHtVoiceIdEnumDonna    FallbackPlayHtVoiceIdEnum = "donna"
	FallbackPlayHtVoiceIdEnumMichael  FallbackPlayHtVoiceIdEnum = "michael"
)

func NewFallbackPlayHtVoiceIdEnumFromString(s string) (FallbackPlayHtVoiceIdEnum, error) {
	switch s {
	case "jennifer":
		return FallbackPlayHtVoiceIdEnumJennifer, nil
	case "melissa":
		return FallbackPlayHtVoiceIdEnumMelissa, nil
	case "will":
		return FallbackPlayHtVoiceIdEnumWill, nil
	case "chris":
		return FallbackPlayHtVoiceIdEnumChris, nil
	case "matt":
		return FallbackPlayHtVoiceIdEnumMatt, nil
	case "jack":
		return FallbackPlayHtVoiceIdEnumJack, nil
	case "ruby":
		return FallbackPlayHtVoiceIdEnumRuby, nil
	case "davis":
		return FallbackPlayHtVoiceIdEnumDavis, nil
	case "donna":
		return FallbackPlayHtVoiceIdEnumDonna, nil
	case "michael":
		return FallbackPlayHtVoiceIdEnumMichael, nil
	}
	var t FallbackPlayHtVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceIdEnum) Ptr() *FallbackPlayHtVoiceIdEnum {
	return &f
}

type FallbackPlayHtVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackPlayHtVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// A floating point number between 0, exclusive, and 2, inclusive. If equal to null or not provided, the model's default temperature will be used. The temperature parameter controls variance. Lower temperatures result in more predictable results, higher temperatures allow each run to vary more, so the voice may sound less like the baseline voice.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// An emotion to be applied to the speech.
	Emotion *FallbackPlayHtVoiceEmotion `json:"emotion,omitempty" url:"emotion,omitempty"`
	// A number between 1 and 6. Use lower numbers to reduce how unique your chosen voice will be compared to other voices.
	VoiceGuidance *float64 `json:"voiceGuidance,omitempty" url:"voiceGuidance,omitempty"`
	// A number between 1 and 30. Use lower numbers to to reduce how strong your chosen emotion will be. Higher numbers will create a very emotional performance.
	StyleGuidance *float64 `json:"styleGuidance,omitempty" url:"styleGuidance,omitempty"`
	// A number between 1 and 2. This number influences how closely the generated speech adheres to the input text. Use lower values to create more fluid speech, but with a higher chance of deviating from the input text. Higher numbers will make the generated speech more accurate to the input text, ensuring that the words spoken align closely with the provided text.
	TextGuidance *float64 `json:"textGuidance,omitempty" url:"textGuidance,omitempty"`
	// Playht voice model/engine to use.
	Model *FallbackPlayHtVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// The language to use for the speech.
	Language *FallbackPlayHtVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackPlayHtVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackPlayHtVoice) GetVoiceId() *FallbackPlayHtVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackPlayHtVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackPlayHtVoice) GetTemperature() *float64 {
	if f == nil {
		return nil
	}
	return f.Temperature
}

func (f *FallbackPlayHtVoice) GetEmotion() *FallbackPlayHtVoiceEmotion {
	if f == nil {
		return nil
	}
	return f.Emotion
}

func (f *FallbackPlayHtVoice) GetVoiceGuidance() *float64 {
	if f == nil {
		return nil
	}
	return f.VoiceGuidance
}

func (f *FallbackPlayHtVoice) GetStyleGuidance() *float64 {
	if f == nil {
		return nil
	}
	return f.StyleGuidance
}

func (f *FallbackPlayHtVoice) GetTextGuidance() *float64 {
	if f == nil {
		return nil
	}
	return f.TextGuidance
}

func (f *FallbackPlayHtVoice) GetModel() *FallbackPlayHtVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackPlayHtVoice) GetLanguage() *FallbackPlayHtVoiceLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackPlayHtVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackPlayHtVoice) Provider() string {
	return f.provider
}

func (f *FallbackPlayHtVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackPlayHtVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackPlayHtVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackPlayHtVoice(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "playht", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackPlayHtVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackPlayHtVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackPlayHtVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// An emotion to be applied to the speech.
type FallbackPlayHtVoiceEmotion string

const (
	FallbackPlayHtVoiceEmotionFemaleHappy     FallbackPlayHtVoiceEmotion = "female_happy"
	FallbackPlayHtVoiceEmotionFemaleSad       FallbackPlayHtVoiceEmotion = "female_sad"
	FallbackPlayHtVoiceEmotionFemaleAngry     FallbackPlayHtVoiceEmotion = "female_angry"
	FallbackPlayHtVoiceEmotionFemaleFearful   FallbackPlayHtVoiceEmotion = "female_fearful"
	FallbackPlayHtVoiceEmotionFemaleDisgust   FallbackPlayHtVoiceEmotion = "female_disgust"
	FallbackPlayHtVoiceEmotionFemaleSurprised FallbackPlayHtVoiceEmotion = "female_surprised"
	FallbackPlayHtVoiceEmotionMaleHappy       FallbackPlayHtVoiceEmotion = "male_happy"
	FallbackPlayHtVoiceEmotionMaleSad         FallbackPlayHtVoiceEmotion = "male_sad"
	FallbackPlayHtVoiceEmotionMaleAngry       FallbackPlayHtVoiceEmotion = "male_angry"
	FallbackPlayHtVoiceEmotionMaleFearful     FallbackPlayHtVoiceEmotion = "male_fearful"
	FallbackPlayHtVoiceEmotionMaleDisgust     FallbackPlayHtVoiceEmotion = "male_disgust"
	FallbackPlayHtVoiceEmotionMaleSurprised   FallbackPlayHtVoiceEmotion = "male_surprised"
)

func NewFallbackPlayHtVoiceEmotionFromString(s string) (FallbackPlayHtVoiceEmotion, error) {
	switch s {
	case "female_happy":
		return FallbackPlayHtVoiceEmotionFemaleHappy, nil
	case "female_sad":
		return FallbackPlayHtVoiceEmotionFemaleSad, nil
	case "female_angry":
		return FallbackPlayHtVoiceEmotionFemaleAngry, nil
	case "female_fearful":
		return FallbackPlayHtVoiceEmotionFemaleFearful, nil
	case "female_disgust":
		return FallbackPlayHtVoiceEmotionFemaleDisgust, nil
	case "female_surprised":
		return FallbackPlayHtVoiceEmotionFemaleSurprised, nil
	case "male_happy":
		return FallbackPlayHtVoiceEmotionMaleHappy, nil
	case "male_sad":
		return FallbackPlayHtVoiceEmotionMaleSad, nil
	case "male_angry":
		return FallbackPlayHtVoiceEmotionMaleAngry, nil
	case "male_fearful":
		return FallbackPlayHtVoiceEmotionMaleFearful, nil
	case "male_disgust":
		return FallbackPlayHtVoiceEmotionMaleDisgust, nil
	case "male_surprised":
		return FallbackPlayHtVoiceEmotionMaleSurprised, nil
	}
	var t FallbackPlayHtVoiceEmotion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceEmotion) Ptr() *FallbackPlayHtVoiceEmotion {
	return &f
}

// The language to use for the speech.
type FallbackPlayHtVoiceLanguage string

const (
	FallbackPlayHtVoiceLanguageAfrikaans  FallbackPlayHtVoiceLanguage = "afrikaans"
	FallbackPlayHtVoiceLanguageAlbanian   FallbackPlayHtVoiceLanguage = "albanian"
	FallbackPlayHtVoiceLanguageAmharic    FallbackPlayHtVoiceLanguage = "amharic"
	FallbackPlayHtVoiceLanguageArabic     FallbackPlayHtVoiceLanguage = "arabic"
	FallbackPlayHtVoiceLanguageBengali    FallbackPlayHtVoiceLanguage = "bengali"
	FallbackPlayHtVoiceLanguageBulgarian  FallbackPlayHtVoiceLanguage = "bulgarian"
	FallbackPlayHtVoiceLanguageCatalan    FallbackPlayHtVoiceLanguage = "catalan"
	FallbackPlayHtVoiceLanguageCroatian   FallbackPlayHtVoiceLanguage = "croatian"
	FallbackPlayHtVoiceLanguageCzech      FallbackPlayHtVoiceLanguage = "czech"
	FallbackPlayHtVoiceLanguageDanish     FallbackPlayHtVoiceLanguage = "danish"
	FallbackPlayHtVoiceLanguageDutch      FallbackPlayHtVoiceLanguage = "dutch"
	FallbackPlayHtVoiceLanguageEnglish    FallbackPlayHtVoiceLanguage = "english"
	FallbackPlayHtVoiceLanguageFrench     FallbackPlayHtVoiceLanguage = "french"
	FallbackPlayHtVoiceLanguageGalician   FallbackPlayHtVoiceLanguage = "galician"
	FallbackPlayHtVoiceLanguageGerman     FallbackPlayHtVoiceLanguage = "german"
	FallbackPlayHtVoiceLanguageGreek      FallbackPlayHtVoiceLanguage = "greek"
	FallbackPlayHtVoiceLanguageHebrew     FallbackPlayHtVoiceLanguage = "hebrew"
	FallbackPlayHtVoiceLanguageHindi      FallbackPlayHtVoiceLanguage = "hindi"
	FallbackPlayHtVoiceLanguageHungarian  FallbackPlayHtVoiceLanguage = "hungarian"
	FallbackPlayHtVoiceLanguageIndonesian FallbackPlayHtVoiceLanguage = "indonesian"
	FallbackPlayHtVoiceLanguageItalian    FallbackPlayHtVoiceLanguage = "italian"
	FallbackPlayHtVoiceLanguageJapanese   FallbackPlayHtVoiceLanguage = "japanese"
	FallbackPlayHtVoiceLanguageKorean     FallbackPlayHtVoiceLanguage = "korean"
	FallbackPlayHtVoiceLanguageMalay      FallbackPlayHtVoiceLanguage = "malay"
	FallbackPlayHtVoiceLanguageMandarin   FallbackPlayHtVoiceLanguage = "mandarin"
	FallbackPlayHtVoiceLanguagePolish     FallbackPlayHtVoiceLanguage = "polish"
	FallbackPlayHtVoiceLanguagePortuguese FallbackPlayHtVoiceLanguage = "portuguese"
	FallbackPlayHtVoiceLanguageRussian    FallbackPlayHtVoiceLanguage = "russian"
	FallbackPlayHtVoiceLanguageSerbian    FallbackPlayHtVoiceLanguage = "serbian"
	FallbackPlayHtVoiceLanguageSpanish    FallbackPlayHtVoiceLanguage = "spanish"
	FallbackPlayHtVoiceLanguageSwedish    FallbackPlayHtVoiceLanguage = "swedish"
	FallbackPlayHtVoiceLanguageTagalog    FallbackPlayHtVoiceLanguage = "tagalog"
	FallbackPlayHtVoiceLanguageThai       FallbackPlayHtVoiceLanguage = "thai"
	FallbackPlayHtVoiceLanguageTurkish    FallbackPlayHtVoiceLanguage = "turkish"
	FallbackPlayHtVoiceLanguageUkrainian  FallbackPlayHtVoiceLanguage = "ukrainian"
	FallbackPlayHtVoiceLanguageUrdu       FallbackPlayHtVoiceLanguage = "urdu"
	FallbackPlayHtVoiceLanguageXhosa      FallbackPlayHtVoiceLanguage = "xhosa"
)

func NewFallbackPlayHtVoiceLanguageFromString(s string) (FallbackPlayHtVoiceLanguage, error) {
	switch s {
	case "afrikaans":
		return FallbackPlayHtVoiceLanguageAfrikaans, nil
	case "albanian":
		return FallbackPlayHtVoiceLanguageAlbanian, nil
	case "amharic":
		return FallbackPlayHtVoiceLanguageAmharic, nil
	case "arabic":
		return FallbackPlayHtVoiceLanguageArabic, nil
	case "bengali":
		return FallbackPlayHtVoiceLanguageBengali, nil
	case "bulgarian":
		return FallbackPlayHtVoiceLanguageBulgarian, nil
	case "catalan":
		return FallbackPlayHtVoiceLanguageCatalan, nil
	case "croatian":
		return FallbackPlayHtVoiceLanguageCroatian, nil
	case "czech":
		return FallbackPlayHtVoiceLanguageCzech, nil
	case "danish":
		return FallbackPlayHtVoiceLanguageDanish, nil
	case "dutch":
		return FallbackPlayHtVoiceLanguageDutch, nil
	case "english":
		return FallbackPlayHtVoiceLanguageEnglish, nil
	case "french":
		return FallbackPlayHtVoiceLanguageFrench, nil
	case "galician":
		return FallbackPlayHtVoiceLanguageGalician, nil
	case "german":
		return FallbackPlayHtVoiceLanguageGerman, nil
	case "greek":
		return FallbackPlayHtVoiceLanguageGreek, nil
	case "hebrew":
		return FallbackPlayHtVoiceLanguageHebrew, nil
	case "hindi":
		return FallbackPlayHtVoiceLanguageHindi, nil
	case "hungarian":
		return FallbackPlayHtVoiceLanguageHungarian, nil
	case "indonesian":
		return FallbackPlayHtVoiceLanguageIndonesian, nil
	case "italian":
		return FallbackPlayHtVoiceLanguageItalian, nil
	case "japanese":
		return FallbackPlayHtVoiceLanguageJapanese, nil
	case "korean":
		return FallbackPlayHtVoiceLanguageKorean, nil
	case "malay":
		return FallbackPlayHtVoiceLanguageMalay, nil
	case "mandarin":
		return FallbackPlayHtVoiceLanguageMandarin, nil
	case "polish":
		return FallbackPlayHtVoiceLanguagePolish, nil
	case "portuguese":
		return FallbackPlayHtVoiceLanguagePortuguese, nil
	case "russian":
		return FallbackPlayHtVoiceLanguageRussian, nil
	case "serbian":
		return FallbackPlayHtVoiceLanguageSerbian, nil
	case "spanish":
		return FallbackPlayHtVoiceLanguageSpanish, nil
	case "swedish":
		return FallbackPlayHtVoiceLanguageSwedish, nil
	case "tagalog":
		return FallbackPlayHtVoiceLanguageTagalog, nil
	case "thai":
		return FallbackPlayHtVoiceLanguageThai, nil
	case "turkish":
		return FallbackPlayHtVoiceLanguageTurkish, nil
	case "ukrainian":
		return FallbackPlayHtVoiceLanguageUkrainian, nil
	case "urdu":
		return FallbackPlayHtVoiceLanguageUrdu, nil
	case "xhosa":
		return FallbackPlayHtVoiceLanguageXhosa, nil
	}
	var t FallbackPlayHtVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceLanguage) Ptr() *FallbackPlayHtVoiceLanguage {
	return &f
}

// Playht voice model/engine to use.
type FallbackPlayHtVoiceModel string

const (
	FallbackPlayHtVoiceModelPlayHt20      FallbackPlayHtVoiceModel = "PlayHT2.0"
	FallbackPlayHtVoiceModelPlayHt20Turbo FallbackPlayHtVoiceModel = "PlayHT2.0-turbo"
	FallbackPlayHtVoiceModelPlay30Mini    FallbackPlayHtVoiceModel = "Play3.0-mini"
	FallbackPlayHtVoiceModelPlayDialog    FallbackPlayHtVoiceModel = "PlayDialog"
)

func NewFallbackPlayHtVoiceModelFromString(s string) (FallbackPlayHtVoiceModel, error) {
	switch s {
	case "PlayHT2.0":
		return FallbackPlayHtVoiceModelPlayHt20, nil
	case "PlayHT2.0-turbo":
		return FallbackPlayHtVoiceModelPlayHt20Turbo, nil
	case "Play3.0-mini":
		return FallbackPlayHtVoiceModelPlay30Mini, nil
	case "PlayDialog":
		return FallbackPlayHtVoiceModelPlayDialog, nil
	}
	var t FallbackPlayHtVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceModel) Ptr() *FallbackPlayHtVoiceModel {
	return &f
}

// This is the provider-specific ID that will be used.
type FallbackRimeAiVoiceId struct {
	FallbackRimeAiVoiceIdEnum FallbackRimeAiVoiceIdEnum
	String                    string

	typ string
}

func (f *FallbackRimeAiVoiceId) GetFallbackRimeAiVoiceIdEnum() FallbackRimeAiVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackRimeAiVoiceIdEnum
}

func (f *FallbackRimeAiVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackRimeAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackRimeAiVoiceIdEnum FallbackRimeAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackRimeAiVoiceIdEnum); err == nil {
		f.typ = "FallbackRimeAiVoiceIdEnum"
		f.FallbackRimeAiVoiceIdEnum = valueFallbackRimeAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackRimeAiVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackRimeAiVoiceIdEnum" || f.FallbackRimeAiVoiceIdEnum != "" {
		return json.Marshal(f.FallbackRimeAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackRimeAiVoiceIdVisitor interface {
	VisitFallbackRimeAiVoiceIdEnum(FallbackRimeAiVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackRimeAiVoiceId) Accept(visitor FallbackRimeAiVoiceIdVisitor) error {
	if f.typ == "FallbackRimeAiVoiceIdEnum" || f.FallbackRimeAiVoiceIdEnum != "" {
		return visitor.VisitFallbackRimeAiVoiceIdEnum(f.FallbackRimeAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackRimeAiVoiceIdEnum string

const (
	FallbackRimeAiVoiceIdEnumAbbie      FallbackRimeAiVoiceIdEnum = "abbie"
	FallbackRimeAiVoiceIdEnumAllison    FallbackRimeAiVoiceIdEnum = "allison"
	FallbackRimeAiVoiceIdEnumAlly       FallbackRimeAiVoiceIdEnum = "ally"
	FallbackRimeAiVoiceIdEnumAlona      FallbackRimeAiVoiceIdEnum = "alona"
	FallbackRimeAiVoiceIdEnumAmber      FallbackRimeAiVoiceIdEnum = "amber"
	FallbackRimeAiVoiceIdEnumAna        FallbackRimeAiVoiceIdEnum = "ana"
	FallbackRimeAiVoiceIdEnumAntoine    FallbackRimeAiVoiceIdEnum = "antoine"
	FallbackRimeAiVoiceIdEnumArmon      FallbackRimeAiVoiceIdEnum = "armon"
	FallbackRimeAiVoiceIdEnumBrenda     FallbackRimeAiVoiceIdEnum = "brenda"
	FallbackRimeAiVoiceIdEnumBrittany   FallbackRimeAiVoiceIdEnum = "brittany"
	FallbackRimeAiVoiceIdEnumCarol      FallbackRimeAiVoiceIdEnum = "carol"
	FallbackRimeAiVoiceIdEnumColin      FallbackRimeAiVoiceIdEnum = "colin"
	FallbackRimeAiVoiceIdEnumCourtney   FallbackRimeAiVoiceIdEnum = "courtney"
	FallbackRimeAiVoiceIdEnumElena      FallbackRimeAiVoiceIdEnum = "elena"
	FallbackRimeAiVoiceIdEnumElliot     FallbackRimeAiVoiceIdEnum = "elliot"
	FallbackRimeAiVoiceIdEnumEva        FallbackRimeAiVoiceIdEnum = "eva"
	FallbackRimeAiVoiceIdEnumGeoff      FallbackRimeAiVoiceIdEnum = "geoff"
	FallbackRimeAiVoiceIdEnumGerald     FallbackRimeAiVoiceIdEnum = "gerald"
	FallbackRimeAiVoiceIdEnumHank       FallbackRimeAiVoiceIdEnum = "hank"
	FallbackRimeAiVoiceIdEnumHelen      FallbackRimeAiVoiceIdEnum = "helen"
	FallbackRimeAiVoiceIdEnumHera       FallbackRimeAiVoiceIdEnum = "hera"
	FallbackRimeAiVoiceIdEnumJen        FallbackRimeAiVoiceIdEnum = "jen"
	FallbackRimeAiVoiceIdEnumJoe        FallbackRimeAiVoiceIdEnum = "joe"
	FallbackRimeAiVoiceIdEnumJoy        FallbackRimeAiVoiceIdEnum = "joy"
	FallbackRimeAiVoiceIdEnumJuan       FallbackRimeAiVoiceIdEnum = "juan"
	FallbackRimeAiVoiceIdEnumKendra     FallbackRimeAiVoiceIdEnum = "kendra"
	FallbackRimeAiVoiceIdEnumKendrick   FallbackRimeAiVoiceIdEnum = "kendrick"
	FallbackRimeAiVoiceIdEnumKenneth    FallbackRimeAiVoiceIdEnum = "kenneth"
	FallbackRimeAiVoiceIdEnumKevin      FallbackRimeAiVoiceIdEnum = "kevin"
	FallbackRimeAiVoiceIdEnumKris       FallbackRimeAiVoiceIdEnum = "kris"
	FallbackRimeAiVoiceIdEnumLinda      FallbackRimeAiVoiceIdEnum = "linda"
	FallbackRimeAiVoiceIdEnumMadison    FallbackRimeAiVoiceIdEnum = "madison"
	FallbackRimeAiVoiceIdEnumMarge      FallbackRimeAiVoiceIdEnum = "marge"
	FallbackRimeAiVoiceIdEnumMarina     FallbackRimeAiVoiceIdEnum = "marina"
	FallbackRimeAiVoiceIdEnumMarissa    FallbackRimeAiVoiceIdEnum = "marissa"
	FallbackRimeAiVoiceIdEnumMarta      FallbackRimeAiVoiceIdEnum = "marta"
	FallbackRimeAiVoiceIdEnumMaya       FallbackRimeAiVoiceIdEnum = "maya"
	FallbackRimeAiVoiceIdEnumNicholas   FallbackRimeAiVoiceIdEnum = "nicholas"
	FallbackRimeAiVoiceIdEnumNyles      FallbackRimeAiVoiceIdEnum = "nyles"
	FallbackRimeAiVoiceIdEnumPhil       FallbackRimeAiVoiceIdEnum = "phil"
	FallbackRimeAiVoiceIdEnumReba       FallbackRimeAiVoiceIdEnum = "reba"
	FallbackRimeAiVoiceIdEnumRex        FallbackRimeAiVoiceIdEnum = "rex"
	FallbackRimeAiVoiceIdEnumRick       FallbackRimeAiVoiceIdEnum = "rick"
	FallbackRimeAiVoiceIdEnumRitu       FallbackRimeAiVoiceIdEnum = "ritu"
	FallbackRimeAiVoiceIdEnumRob        FallbackRimeAiVoiceIdEnum = "rob"
	FallbackRimeAiVoiceIdEnumRodney     FallbackRimeAiVoiceIdEnum = "rodney"
	FallbackRimeAiVoiceIdEnumRohan      FallbackRimeAiVoiceIdEnum = "rohan"
	FallbackRimeAiVoiceIdEnumRosco      FallbackRimeAiVoiceIdEnum = "rosco"
	FallbackRimeAiVoiceIdEnumSamantha   FallbackRimeAiVoiceIdEnum = "samantha"
	FallbackRimeAiVoiceIdEnumSandy      FallbackRimeAiVoiceIdEnum = "sandy"
	FallbackRimeAiVoiceIdEnumSelena     FallbackRimeAiVoiceIdEnum = "selena"
	FallbackRimeAiVoiceIdEnumSeth       FallbackRimeAiVoiceIdEnum = "seth"
	FallbackRimeAiVoiceIdEnumSharon     FallbackRimeAiVoiceIdEnum = "sharon"
	FallbackRimeAiVoiceIdEnumStan       FallbackRimeAiVoiceIdEnum = "stan"
	FallbackRimeAiVoiceIdEnumTamra      FallbackRimeAiVoiceIdEnum = "tamra"
	FallbackRimeAiVoiceIdEnumTanya      FallbackRimeAiVoiceIdEnum = "tanya"
	FallbackRimeAiVoiceIdEnumTibur      FallbackRimeAiVoiceIdEnum = "tibur"
	FallbackRimeAiVoiceIdEnumTj         FallbackRimeAiVoiceIdEnum = "tj"
	FallbackRimeAiVoiceIdEnumTyler      FallbackRimeAiVoiceIdEnum = "tyler"
	FallbackRimeAiVoiceIdEnumViv        FallbackRimeAiVoiceIdEnum = "viv"
	FallbackRimeAiVoiceIdEnumYadira     FallbackRimeAiVoiceIdEnum = "yadira"
	FallbackRimeAiVoiceIdEnumMarsh      FallbackRimeAiVoiceIdEnum = "marsh"
	FallbackRimeAiVoiceIdEnumBayou      FallbackRimeAiVoiceIdEnum = "bayou"
	FallbackRimeAiVoiceIdEnumCreek      FallbackRimeAiVoiceIdEnum = "creek"
	FallbackRimeAiVoiceIdEnumBrook      FallbackRimeAiVoiceIdEnum = "brook"
	FallbackRimeAiVoiceIdEnumFlower     FallbackRimeAiVoiceIdEnum = "flower"
	FallbackRimeAiVoiceIdEnumSpore      FallbackRimeAiVoiceIdEnum = "spore"
	FallbackRimeAiVoiceIdEnumGlacier    FallbackRimeAiVoiceIdEnum = "glacier"
	FallbackRimeAiVoiceIdEnumGulch      FallbackRimeAiVoiceIdEnum = "gulch"
	FallbackRimeAiVoiceIdEnumAlpine     FallbackRimeAiVoiceIdEnum = "alpine"
	FallbackRimeAiVoiceIdEnumCove       FallbackRimeAiVoiceIdEnum = "cove"
	FallbackRimeAiVoiceIdEnumLagoon     FallbackRimeAiVoiceIdEnum = "lagoon"
	FallbackRimeAiVoiceIdEnumTundra     FallbackRimeAiVoiceIdEnum = "tundra"
	FallbackRimeAiVoiceIdEnumSteppe     FallbackRimeAiVoiceIdEnum = "steppe"
	FallbackRimeAiVoiceIdEnumMesa       FallbackRimeAiVoiceIdEnum = "mesa"
	FallbackRimeAiVoiceIdEnumGrove      FallbackRimeAiVoiceIdEnum = "grove"
	FallbackRimeAiVoiceIdEnumRainforest FallbackRimeAiVoiceIdEnum = "rainforest"
	FallbackRimeAiVoiceIdEnumMoraine    FallbackRimeAiVoiceIdEnum = "moraine"
	FallbackRimeAiVoiceIdEnumWildflower FallbackRimeAiVoiceIdEnum = "wildflower"
	FallbackRimeAiVoiceIdEnumPeak       FallbackRimeAiVoiceIdEnum = "peak"
	FallbackRimeAiVoiceIdEnumBoulder    FallbackRimeAiVoiceIdEnum = "boulder"
	FallbackRimeAiVoiceIdEnumGypsum     FallbackRimeAiVoiceIdEnum = "gypsum"
	FallbackRimeAiVoiceIdEnumZest       FallbackRimeAiVoiceIdEnum = "zest"
)

func NewFallbackRimeAiVoiceIdEnumFromString(s string) (FallbackRimeAiVoiceIdEnum, error) {
	switch s {
	case "abbie":
		return FallbackRimeAiVoiceIdEnumAbbie, nil
	case "allison":
		return FallbackRimeAiVoiceIdEnumAllison, nil
	case "ally":
		return FallbackRimeAiVoiceIdEnumAlly, nil
	case "alona":
		return FallbackRimeAiVoiceIdEnumAlona, nil
	case "amber":
		return FallbackRimeAiVoiceIdEnumAmber, nil
	case "ana":
		return FallbackRimeAiVoiceIdEnumAna, nil
	case "antoine":
		return FallbackRimeAiVoiceIdEnumAntoine, nil
	case "armon":
		return FallbackRimeAiVoiceIdEnumArmon, nil
	case "brenda":
		return FallbackRimeAiVoiceIdEnumBrenda, nil
	case "brittany":
		return FallbackRimeAiVoiceIdEnumBrittany, nil
	case "carol":
		return FallbackRimeAiVoiceIdEnumCarol, nil
	case "colin":
		return FallbackRimeAiVoiceIdEnumColin, nil
	case "courtney":
		return FallbackRimeAiVoiceIdEnumCourtney, nil
	case "elena":
		return FallbackRimeAiVoiceIdEnumElena, nil
	case "elliot":
		return FallbackRimeAiVoiceIdEnumElliot, nil
	case "eva":
		return FallbackRimeAiVoiceIdEnumEva, nil
	case "geoff":
		return FallbackRimeAiVoiceIdEnumGeoff, nil
	case "gerald":
		return FallbackRimeAiVoiceIdEnumGerald, nil
	case "hank":
		return FallbackRimeAiVoiceIdEnumHank, nil
	case "helen":
		return FallbackRimeAiVoiceIdEnumHelen, nil
	case "hera":
		return FallbackRimeAiVoiceIdEnumHera, nil
	case "jen":
		return FallbackRimeAiVoiceIdEnumJen, nil
	case "joe":
		return FallbackRimeAiVoiceIdEnumJoe, nil
	case "joy":
		return FallbackRimeAiVoiceIdEnumJoy, nil
	case "juan":
		return FallbackRimeAiVoiceIdEnumJuan, nil
	case "kendra":
		return FallbackRimeAiVoiceIdEnumKendra, nil
	case "kendrick":
		return FallbackRimeAiVoiceIdEnumKendrick, nil
	case "kenneth":
		return FallbackRimeAiVoiceIdEnumKenneth, nil
	case "kevin":
		return FallbackRimeAiVoiceIdEnumKevin, nil
	case "kris":
		return FallbackRimeAiVoiceIdEnumKris, nil
	case "linda":
		return FallbackRimeAiVoiceIdEnumLinda, nil
	case "madison":
		return FallbackRimeAiVoiceIdEnumMadison, nil
	case "marge":
		return FallbackRimeAiVoiceIdEnumMarge, nil
	case "marina":
		return FallbackRimeAiVoiceIdEnumMarina, nil
	case "marissa":
		return FallbackRimeAiVoiceIdEnumMarissa, nil
	case "marta":
		return FallbackRimeAiVoiceIdEnumMarta, nil
	case "maya":
		return FallbackRimeAiVoiceIdEnumMaya, nil
	case "nicholas":
		return FallbackRimeAiVoiceIdEnumNicholas, nil
	case "nyles":
		return FallbackRimeAiVoiceIdEnumNyles, nil
	case "phil":
		return FallbackRimeAiVoiceIdEnumPhil, nil
	case "reba":
		return FallbackRimeAiVoiceIdEnumReba, nil
	case "rex":
		return FallbackRimeAiVoiceIdEnumRex, nil
	case "rick":
		return FallbackRimeAiVoiceIdEnumRick, nil
	case "ritu":
		return FallbackRimeAiVoiceIdEnumRitu, nil
	case "rob":
		return FallbackRimeAiVoiceIdEnumRob, nil
	case "rodney":
		return FallbackRimeAiVoiceIdEnumRodney, nil
	case "rohan":
		return FallbackRimeAiVoiceIdEnumRohan, nil
	case "rosco":
		return FallbackRimeAiVoiceIdEnumRosco, nil
	case "samantha":
		return FallbackRimeAiVoiceIdEnumSamantha, nil
	case "sandy":
		return FallbackRimeAiVoiceIdEnumSandy, nil
	case "selena":
		return FallbackRimeAiVoiceIdEnumSelena, nil
	case "seth":
		return FallbackRimeAiVoiceIdEnumSeth, nil
	case "sharon":
		return FallbackRimeAiVoiceIdEnumSharon, nil
	case "stan":
		return FallbackRimeAiVoiceIdEnumStan, nil
	case "tamra":
		return FallbackRimeAiVoiceIdEnumTamra, nil
	case "tanya":
		return FallbackRimeAiVoiceIdEnumTanya, nil
	case "tibur":
		return FallbackRimeAiVoiceIdEnumTibur, nil
	case "tj":
		return FallbackRimeAiVoiceIdEnumTj, nil
	case "tyler":
		return FallbackRimeAiVoiceIdEnumTyler, nil
	case "viv":
		return FallbackRimeAiVoiceIdEnumViv, nil
	case "yadira":
		return FallbackRimeAiVoiceIdEnumYadira, nil
	case "marsh":
		return FallbackRimeAiVoiceIdEnumMarsh, nil
	case "bayou":
		return FallbackRimeAiVoiceIdEnumBayou, nil
	case "creek":
		return FallbackRimeAiVoiceIdEnumCreek, nil
	case "brook":
		return FallbackRimeAiVoiceIdEnumBrook, nil
	case "flower":
		return FallbackRimeAiVoiceIdEnumFlower, nil
	case "spore":
		return FallbackRimeAiVoiceIdEnumSpore, nil
	case "glacier":
		return FallbackRimeAiVoiceIdEnumGlacier, nil
	case "gulch":
		return FallbackRimeAiVoiceIdEnumGulch, nil
	case "alpine":
		return FallbackRimeAiVoiceIdEnumAlpine, nil
	case "cove":
		return FallbackRimeAiVoiceIdEnumCove, nil
	case "lagoon":
		return FallbackRimeAiVoiceIdEnumLagoon, nil
	case "tundra":
		return FallbackRimeAiVoiceIdEnumTundra, nil
	case "steppe":
		return FallbackRimeAiVoiceIdEnumSteppe, nil
	case "mesa":
		return FallbackRimeAiVoiceIdEnumMesa, nil
	case "grove":
		return FallbackRimeAiVoiceIdEnumGrove, nil
	case "rainforest":
		return FallbackRimeAiVoiceIdEnumRainforest, nil
	case "moraine":
		return FallbackRimeAiVoiceIdEnumMoraine, nil
	case "wildflower":
		return FallbackRimeAiVoiceIdEnumWildflower, nil
	case "peak":
		return FallbackRimeAiVoiceIdEnumPeak, nil
	case "boulder":
		return FallbackRimeAiVoiceIdEnumBoulder, nil
	case "gypsum":
		return FallbackRimeAiVoiceIdEnumGypsum, nil
	case "zest":
		return FallbackRimeAiVoiceIdEnumZest, nil
	}
	var t FallbackRimeAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackRimeAiVoiceIdEnum) Ptr() *FallbackRimeAiVoiceIdEnum {
	return &f
}

type FallbackRimeAiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackRimeAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the model that will be used. Defaults to 'v1' when not specified.
	Model *FallbackRimeAiVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is a flag that controls whether to add slight pauses using angle brackets. Example: "Hi. <200> I'd love to have a conversation with you." adds a 200ms pause between the first and second sentences.
	PauseBetweenBrackets *bool `json:"pauseBetweenBrackets,omitempty" url:"pauseBetweenBrackets,omitempty"`
	// This is a flag that controls whether text inside brackets should be phonemized (converted to phonetic pronunciation) - Example: "{h'El.o} World" will pronounce "Hello" as expected.
	PhonemizeBetweenBrackets *bool `json:"phonemizeBetweenBrackets,omitempty" url:"phonemizeBetweenBrackets,omitempty"`
	// This is a flag that controls whether to optimize for reduced latency in streaming. https://docs.rime.ai/api-reference/endpoint/websockets#param-reduce-latency
	ReduceLatency *bool `json:"reduceLatency,omitempty" url:"reduceLatency,omitempty"`
	// This is a string that allows inline speed control using alpha notation. https://docs.rime.ai/api-reference/endpoint/websockets#param-inline-speed-alpha
	InlineSpeedAlpha *string `json:"inlineSpeedAlpha,omitempty" url:"inlineSpeedAlpha,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackRimeAiVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackRimeAiVoice) GetVoiceId() *FallbackRimeAiVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackRimeAiVoice) GetModel() *FallbackRimeAiVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackRimeAiVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackRimeAiVoice) GetPauseBetweenBrackets() *bool {
	if f == nil {
		return nil
	}
	return f.PauseBetweenBrackets
}

func (f *FallbackRimeAiVoice) GetPhonemizeBetweenBrackets() *bool {
	if f == nil {
		return nil
	}
	return f.PhonemizeBetweenBrackets
}

func (f *FallbackRimeAiVoice) GetReduceLatency() *bool {
	if f == nil {
		return nil
	}
	return f.ReduceLatency
}

func (f *FallbackRimeAiVoice) GetInlineSpeedAlpha() *string {
	if f == nil {
		return nil
	}
	return f.InlineSpeedAlpha
}

func (f *FallbackRimeAiVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackRimeAiVoice) Provider() string {
	return f.provider
}

func (f *FallbackRimeAiVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackRimeAiVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackRimeAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackRimeAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "rime-ai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackRimeAiVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackRimeAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackRimeAiVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the model that will be used. Defaults to 'v1' when not specified.
type FallbackRimeAiVoiceModel string

const (
	FallbackRimeAiVoiceModelV1     FallbackRimeAiVoiceModel = "v1"
	FallbackRimeAiVoiceModelMist   FallbackRimeAiVoiceModel = "mist"
	FallbackRimeAiVoiceModelMistv2 FallbackRimeAiVoiceModel = "mistv2"
)

func NewFallbackRimeAiVoiceModelFromString(s string) (FallbackRimeAiVoiceModel, error) {
	switch s {
	case "v1":
		return FallbackRimeAiVoiceModelV1, nil
	case "mist":
		return FallbackRimeAiVoiceModelMist, nil
	case "mistv2":
		return FallbackRimeAiVoiceModelMistv2, nil
	}
	var t FallbackRimeAiVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackRimeAiVoiceModel) Ptr() *FallbackRimeAiVoiceModel {
	return &f
}

type FallbackSesameVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the model that will be used.
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string
	model     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackSesameVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackSesameVoice) GetVoiceId() string {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackSesameVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackSesameVoice) Provider() string {
	return f.provider
}

func (f *FallbackSesameVoice) Model() string {
	return f.model
}

func (f *FallbackSesameVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackSesameVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackSesameVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
		Model    string `json:"model"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackSesameVoice(unmarshaler.embed)
	if unmarshaler.Provider != "sesame" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "sesame", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	if unmarshaler.Model != "csm-1b" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "csm-1b", unmarshaler.Model)
	}
	f.model = unmarshaler.Model
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider", "model")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackSesameVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackSesameVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
		Model    string `json:"model"`
	}{
		embed:    embed(*f),
		Provider: "sesame",
		Model:    "csm-1b",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackSesameVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackSmallestAiVoiceId struct {
	FallbackSmallestAiVoiceIdEnum FallbackSmallestAiVoiceIdEnum
	String                        string

	typ string
}

func (f *FallbackSmallestAiVoiceId) GetFallbackSmallestAiVoiceIdEnum() FallbackSmallestAiVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackSmallestAiVoiceIdEnum
}

func (f *FallbackSmallestAiVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackSmallestAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackSmallestAiVoiceIdEnum FallbackSmallestAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackSmallestAiVoiceIdEnum); err == nil {
		f.typ = "FallbackSmallestAiVoiceIdEnum"
		f.FallbackSmallestAiVoiceIdEnum = valueFallbackSmallestAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackSmallestAiVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackSmallestAiVoiceIdEnum" || f.FallbackSmallestAiVoiceIdEnum != "" {
		return json.Marshal(f.FallbackSmallestAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackSmallestAiVoiceIdVisitor interface {
	VisitFallbackSmallestAiVoiceIdEnum(FallbackSmallestAiVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackSmallestAiVoiceId) Accept(visitor FallbackSmallestAiVoiceIdVisitor) error {
	if f.typ == "FallbackSmallestAiVoiceIdEnum" || f.FallbackSmallestAiVoiceIdEnum != "" {
		return visitor.VisitFallbackSmallestAiVoiceIdEnum(f.FallbackSmallestAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackSmallestAiVoiceIdEnum string

const (
	FallbackSmallestAiVoiceIdEnumEmily    FallbackSmallestAiVoiceIdEnum = "emily"
	FallbackSmallestAiVoiceIdEnumJasmine  FallbackSmallestAiVoiceIdEnum = "jasmine"
	FallbackSmallestAiVoiceIdEnumArman    FallbackSmallestAiVoiceIdEnum = "arman"
	FallbackSmallestAiVoiceIdEnumJames    FallbackSmallestAiVoiceIdEnum = "james"
	FallbackSmallestAiVoiceIdEnumMithali  FallbackSmallestAiVoiceIdEnum = "mithali"
	FallbackSmallestAiVoiceIdEnumAravind  FallbackSmallestAiVoiceIdEnum = "aravind"
	FallbackSmallestAiVoiceIdEnumRaj      FallbackSmallestAiVoiceIdEnum = "raj"
	FallbackSmallestAiVoiceIdEnumDiya     FallbackSmallestAiVoiceIdEnum = "diya"
	FallbackSmallestAiVoiceIdEnumRaman    FallbackSmallestAiVoiceIdEnum = "raman"
	FallbackSmallestAiVoiceIdEnumAnanya   FallbackSmallestAiVoiceIdEnum = "ananya"
	FallbackSmallestAiVoiceIdEnumIsha     FallbackSmallestAiVoiceIdEnum = "isha"
	FallbackSmallestAiVoiceIdEnumWilliam  FallbackSmallestAiVoiceIdEnum = "william"
	FallbackSmallestAiVoiceIdEnumAarav    FallbackSmallestAiVoiceIdEnum = "aarav"
	FallbackSmallestAiVoiceIdEnumMonika   FallbackSmallestAiVoiceIdEnum = "monika"
	FallbackSmallestAiVoiceIdEnumNiharika FallbackSmallestAiVoiceIdEnum = "niharika"
	FallbackSmallestAiVoiceIdEnumDeepika  FallbackSmallestAiVoiceIdEnum = "deepika"
	FallbackSmallestAiVoiceIdEnumRaghav   FallbackSmallestAiVoiceIdEnum = "raghav"
	FallbackSmallestAiVoiceIdEnumKajal    FallbackSmallestAiVoiceIdEnum = "kajal"
	FallbackSmallestAiVoiceIdEnumRadhika  FallbackSmallestAiVoiceIdEnum = "radhika"
	FallbackSmallestAiVoiceIdEnumMansi    FallbackSmallestAiVoiceIdEnum = "mansi"
	FallbackSmallestAiVoiceIdEnumNisha    FallbackSmallestAiVoiceIdEnum = "nisha"
	FallbackSmallestAiVoiceIdEnumSaurabh  FallbackSmallestAiVoiceIdEnum = "saurabh"
	FallbackSmallestAiVoiceIdEnumPooja    FallbackSmallestAiVoiceIdEnum = "pooja"
	FallbackSmallestAiVoiceIdEnumSaina    FallbackSmallestAiVoiceIdEnum = "saina"
	FallbackSmallestAiVoiceIdEnumSanya    FallbackSmallestAiVoiceIdEnum = "sanya"
)

func NewFallbackSmallestAiVoiceIdEnumFromString(s string) (FallbackSmallestAiVoiceIdEnum, error) {
	switch s {
	case "emily":
		return FallbackSmallestAiVoiceIdEnumEmily, nil
	case "jasmine":
		return FallbackSmallestAiVoiceIdEnumJasmine, nil
	case "arman":
		return FallbackSmallestAiVoiceIdEnumArman, nil
	case "james":
		return FallbackSmallestAiVoiceIdEnumJames, nil
	case "mithali":
		return FallbackSmallestAiVoiceIdEnumMithali, nil
	case "aravind":
		return FallbackSmallestAiVoiceIdEnumAravind, nil
	case "raj":
		return FallbackSmallestAiVoiceIdEnumRaj, nil
	case "diya":
		return FallbackSmallestAiVoiceIdEnumDiya, nil
	case "raman":
		return FallbackSmallestAiVoiceIdEnumRaman, nil
	case "ananya":
		return FallbackSmallestAiVoiceIdEnumAnanya, nil
	case "isha":
		return FallbackSmallestAiVoiceIdEnumIsha, nil
	case "william":
		return FallbackSmallestAiVoiceIdEnumWilliam, nil
	case "aarav":
		return FallbackSmallestAiVoiceIdEnumAarav, nil
	case "monika":
		return FallbackSmallestAiVoiceIdEnumMonika, nil
	case "niharika":
		return FallbackSmallestAiVoiceIdEnumNiharika, nil
	case "deepika":
		return FallbackSmallestAiVoiceIdEnumDeepika, nil
	case "raghav":
		return FallbackSmallestAiVoiceIdEnumRaghav, nil
	case "kajal":
		return FallbackSmallestAiVoiceIdEnumKajal, nil
	case "radhika":
		return FallbackSmallestAiVoiceIdEnumRadhika, nil
	case "mansi":
		return FallbackSmallestAiVoiceIdEnumMansi, nil
	case "nisha":
		return FallbackSmallestAiVoiceIdEnumNisha, nil
	case "saurabh":
		return FallbackSmallestAiVoiceIdEnumSaurabh, nil
	case "pooja":
		return FallbackSmallestAiVoiceIdEnumPooja, nil
	case "saina":
		return FallbackSmallestAiVoiceIdEnumSaina, nil
	case "sanya":
		return FallbackSmallestAiVoiceIdEnumSanya, nil
	}
	var t FallbackSmallestAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackSmallestAiVoiceIdEnum) Ptr() *FallbackSmallestAiVoiceIdEnum {
	return &f
}

type FallbackSmallestAiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackSmallestAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Smallest AI voice model to use. Defaults to 'lightning' when not specified.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackSmallestAiVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackSmallestAiVoice) GetVoiceId() *FallbackSmallestAiVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackSmallestAiVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackSmallestAiVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackSmallestAiVoice) Provider() string {
	return f.provider
}

func (f *FallbackSmallestAiVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackSmallestAiVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackSmallestAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackSmallestAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "smallest-ai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackSmallestAiVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackSmallestAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackSmallestAiVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackSpeechmaticsTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model    *string                                  `json:"model,omitempty" url:"model,omitempty"`
	Language *FallbackSpeechmaticsTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackSpeechmaticsTranscriber) GetLanguage() *FallbackSpeechmaticsTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackSpeechmaticsTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackSpeechmaticsTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackSpeechmaticsTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackSpeechmaticsTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackSpeechmaticsTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "speechmatics" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "speechmatics", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackSpeechmaticsTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackSpeechmaticsTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "speechmatics",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackSpeechmaticsTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackSpeechmaticsTranscriberLanguage string

const (
	FallbackSpeechmaticsTranscriberLanguageAuto FallbackSpeechmaticsTranscriberLanguage = "auto"
	FallbackSpeechmaticsTranscriberLanguageAr   FallbackSpeechmaticsTranscriberLanguage = "ar"
	FallbackSpeechmaticsTranscriberLanguageBa   FallbackSpeechmaticsTranscriberLanguage = "ba"
	FallbackSpeechmaticsTranscriberLanguageEu   FallbackSpeechmaticsTranscriberLanguage = "eu"
	FallbackSpeechmaticsTranscriberLanguageBe   FallbackSpeechmaticsTranscriberLanguage = "be"
	FallbackSpeechmaticsTranscriberLanguageBn   FallbackSpeechmaticsTranscriberLanguage = "bn"
	FallbackSpeechmaticsTranscriberLanguageBg   FallbackSpeechmaticsTranscriberLanguage = "bg"
	FallbackSpeechmaticsTranscriberLanguageYue  FallbackSpeechmaticsTranscriberLanguage = "yue"
	FallbackSpeechmaticsTranscriberLanguageCa   FallbackSpeechmaticsTranscriberLanguage = "ca"
	FallbackSpeechmaticsTranscriberLanguageHr   FallbackSpeechmaticsTranscriberLanguage = "hr"
	FallbackSpeechmaticsTranscriberLanguageCs   FallbackSpeechmaticsTranscriberLanguage = "cs"
	FallbackSpeechmaticsTranscriberLanguageDa   FallbackSpeechmaticsTranscriberLanguage = "da"
	FallbackSpeechmaticsTranscriberLanguageNl   FallbackSpeechmaticsTranscriberLanguage = "nl"
	FallbackSpeechmaticsTranscriberLanguageEn   FallbackSpeechmaticsTranscriberLanguage = "en"
	FallbackSpeechmaticsTranscriberLanguageEo   FallbackSpeechmaticsTranscriberLanguage = "eo"
	FallbackSpeechmaticsTranscriberLanguageEt   FallbackSpeechmaticsTranscriberLanguage = "et"
	FallbackSpeechmaticsTranscriberLanguageFi   FallbackSpeechmaticsTranscriberLanguage = "fi"
	FallbackSpeechmaticsTranscriberLanguageFr   FallbackSpeechmaticsTranscriberLanguage = "fr"
	FallbackSpeechmaticsTranscriberLanguageGl   FallbackSpeechmaticsTranscriberLanguage = "gl"
	FallbackSpeechmaticsTranscriberLanguageDe   FallbackSpeechmaticsTranscriberLanguage = "de"
	FallbackSpeechmaticsTranscriberLanguageEl   FallbackSpeechmaticsTranscriberLanguage = "el"
	FallbackSpeechmaticsTranscriberLanguageHe   FallbackSpeechmaticsTranscriberLanguage = "he"
	FallbackSpeechmaticsTranscriberLanguageHi   FallbackSpeechmaticsTranscriberLanguage = "hi"
	FallbackSpeechmaticsTranscriberLanguageHu   FallbackSpeechmaticsTranscriberLanguage = "hu"
	FallbackSpeechmaticsTranscriberLanguageId   FallbackSpeechmaticsTranscriberLanguage = "id"
	FallbackSpeechmaticsTranscriberLanguageIa   FallbackSpeechmaticsTranscriberLanguage = "ia"
	FallbackSpeechmaticsTranscriberLanguageGa   FallbackSpeechmaticsTranscriberLanguage = "ga"
	FallbackSpeechmaticsTranscriberLanguageIt   FallbackSpeechmaticsTranscriberLanguage = "it"
	FallbackSpeechmaticsTranscriberLanguageJa   FallbackSpeechmaticsTranscriberLanguage = "ja"
	FallbackSpeechmaticsTranscriberLanguageKo   FallbackSpeechmaticsTranscriberLanguage = "ko"
	FallbackSpeechmaticsTranscriberLanguageLv   FallbackSpeechmaticsTranscriberLanguage = "lv"
	FallbackSpeechmaticsTranscriberLanguageLt   FallbackSpeechmaticsTranscriberLanguage = "lt"
	FallbackSpeechmaticsTranscriberLanguageMs   FallbackSpeechmaticsTranscriberLanguage = "ms"
	FallbackSpeechmaticsTranscriberLanguageMt   FallbackSpeechmaticsTranscriberLanguage = "mt"
	FallbackSpeechmaticsTranscriberLanguageCmn  FallbackSpeechmaticsTranscriberLanguage = "cmn"
	FallbackSpeechmaticsTranscriberLanguageMr   FallbackSpeechmaticsTranscriberLanguage = "mr"
	FallbackSpeechmaticsTranscriberLanguageMn   FallbackSpeechmaticsTranscriberLanguage = "mn"
	FallbackSpeechmaticsTranscriberLanguageNo   FallbackSpeechmaticsTranscriberLanguage = "no"
	FallbackSpeechmaticsTranscriberLanguageFa   FallbackSpeechmaticsTranscriberLanguage = "fa"
	FallbackSpeechmaticsTranscriberLanguagePl   FallbackSpeechmaticsTranscriberLanguage = "pl"
	FallbackSpeechmaticsTranscriberLanguagePt   FallbackSpeechmaticsTranscriberLanguage = "pt"
	FallbackSpeechmaticsTranscriberLanguageRo   FallbackSpeechmaticsTranscriberLanguage = "ro"
	FallbackSpeechmaticsTranscriberLanguageRu   FallbackSpeechmaticsTranscriberLanguage = "ru"
	FallbackSpeechmaticsTranscriberLanguageSk   FallbackSpeechmaticsTranscriberLanguage = "sk"
	FallbackSpeechmaticsTranscriberLanguageSl   FallbackSpeechmaticsTranscriberLanguage = "sl"
	FallbackSpeechmaticsTranscriberLanguageEs   FallbackSpeechmaticsTranscriberLanguage = "es"
	FallbackSpeechmaticsTranscriberLanguageSw   FallbackSpeechmaticsTranscriberLanguage = "sw"
	FallbackSpeechmaticsTranscriberLanguageSv   FallbackSpeechmaticsTranscriberLanguage = "sv"
	FallbackSpeechmaticsTranscriberLanguageTa   FallbackSpeechmaticsTranscriberLanguage = "ta"
	FallbackSpeechmaticsTranscriberLanguageTh   FallbackSpeechmaticsTranscriberLanguage = "th"
	FallbackSpeechmaticsTranscriberLanguageTr   FallbackSpeechmaticsTranscriberLanguage = "tr"
	FallbackSpeechmaticsTranscriberLanguageUk   FallbackSpeechmaticsTranscriberLanguage = "uk"
	FallbackSpeechmaticsTranscriberLanguageUr   FallbackSpeechmaticsTranscriberLanguage = "ur"
	FallbackSpeechmaticsTranscriberLanguageUg   FallbackSpeechmaticsTranscriberLanguage = "ug"
	FallbackSpeechmaticsTranscriberLanguageVi   FallbackSpeechmaticsTranscriberLanguage = "vi"
	FallbackSpeechmaticsTranscriberLanguageCy   FallbackSpeechmaticsTranscriberLanguage = "cy"
)

func NewFallbackSpeechmaticsTranscriberLanguageFromString(s string) (FallbackSpeechmaticsTranscriberLanguage, error) {
	switch s {
	case "auto":
		return FallbackSpeechmaticsTranscriberLanguageAuto, nil
	case "ar":
		return FallbackSpeechmaticsTranscriberLanguageAr, nil
	case "ba":
		return FallbackSpeechmaticsTranscriberLanguageBa, nil
	case "eu":
		return FallbackSpeechmaticsTranscriberLanguageEu, nil
	case "be":
		return FallbackSpeechmaticsTranscriberLanguageBe, nil
	case "bn":
		return FallbackSpeechmaticsTranscriberLanguageBn, nil
	case "bg":
		return FallbackSpeechmaticsTranscriberLanguageBg, nil
	case "yue":
		return FallbackSpeechmaticsTranscriberLanguageYue, nil
	case "ca":
		return FallbackSpeechmaticsTranscriberLanguageCa, nil
	case "hr":
		return FallbackSpeechmaticsTranscriberLanguageHr, nil
	case "cs":
		return FallbackSpeechmaticsTranscriberLanguageCs, nil
	case "da":
		return FallbackSpeechmaticsTranscriberLanguageDa, nil
	case "nl":
		return FallbackSpeechmaticsTranscriberLanguageNl, nil
	case "en":
		return FallbackSpeechmaticsTranscriberLanguageEn, nil
	case "eo":
		return FallbackSpeechmaticsTranscriberLanguageEo, nil
	case "et":
		return FallbackSpeechmaticsTranscriberLanguageEt, nil
	case "fi":
		return FallbackSpeechmaticsTranscriberLanguageFi, nil
	case "fr":
		return FallbackSpeechmaticsTranscriberLanguageFr, nil
	case "gl":
		return FallbackSpeechmaticsTranscriberLanguageGl, nil
	case "de":
		return FallbackSpeechmaticsTranscriberLanguageDe, nil
	case "el":
		return FallbackSpeechmaticsTranscriberLanguageEl, nil
	case "he":
		return FallbackSpeechmaticsTranscriberLanguageHe, nil
	case "hi":
		return FallbackSpeechmaticsTranscriberLanguageHi, nil
	case "hu":
		return FallbackSpeechmaticsTranscriberLanguageHu, nil
	case "id":
		return FallbackSpeechmaticsTranscriberLanguageId, nil
	case "ia":
		return FallbackSpeechmaticsTranscriberLanguageIa, nil
	case "ga":
		return FallbackSpeechmaticsTranscriberLanguageGa, nil
	case "it":
		return FallbackSpeechmaticsTranscriberLanguageIt, nil
	case "ja":
		return FallbackSpeechmaticsTranscriberLanguageJa, nil
	case "ko":
		return FallbackSpeechmaticsTranscriberLanguageKo, nil
	case "lv":
		return FallbackSpeechmaticsTranscriberLanguageLv, nil
	case "lt":
		return FallbackSpeechmaticsTranscriberLanguageLt, nil
	case "ms":
		return FallbackSpeechmaticsTranscriberLanguageMs, nil
	case "mt":
		return FallbackSpeechmaticsTranscriberLanguageMt, nil
	case "cmn":
		return FallbackSpeechmaticsTranscriberLanguageCmn, nil
	case "mr":
		return FallbackSpeechmaticsTranscriberLanguageMr, nil
	case "mn":
		return FallbackSpeechmaticsTranscriberLanguageMn, nil
	case "no":
		return FallbackSpeechmaticsTranscriberLanguageNo, nil
	case "fa":
		return FallbackSpeechmaticsTranscriberLanguageFa, nil
	case "pl":
		return FallbackSpeechmaticsTranscriberLanguagePl, nil
	case "pt":
		return FallbackSpeechmaticsTranscriberLanguagePt, nil
	case "ro":
		return FallbackSpeechmaticsTranscriberLanguageRo, nil
	case "ru":
		return FallbackSpeechmaticsTranscriberLanguageRu, nil
	case "sk":
		return FallbackSpeechmaticsTranscriberLanguageSk, nil
	case "sl":
		return FallbackSpeechmaticsTranscriberLanguageSl, nil
	case "es":
		return FallbackSpeechmaticsTranscriberLanguageEs, nil
	case "sw":
		return FallbackSpeechmaticsTranscriberLanguageSw, nil
	case "sv":
		return FallbackSpeechmaticsTranscriberLanguageSv, nil
	case "ta":
		return FallbackSpeechmaticsTranscriberLanguageTa, nil
	case "th":
		return FallbackSpeechmaticsTranscriberLanguageTh, nil
	case "tr":
		return FallbackSpeechmaticsTranscriberLanguageTr, nil
	case "uk":
		return FallbackSpeechmaticsTranscriberLanguageUk, nil
	case "ur":
		return FallbackSpeechmaticsTranscriberLanguageUr, nil
	case "ug":
		return FallbackSpeechmaticsTranscriberLanguageUg, nil
	case "vi":
		return FallbackSpeechmaticsTranscriberLanguageVi, nil
	case "cy":
		return FallbackSpeechmaticsTranscriberLanguageCy, nil
	}
	var t FallbackSpeechmaticsTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackSpeechmaticsTranscriberLanguage) Ptr() *FallbackSpeechmaticsTranscriberLanguage {
	return &f
}

type FallbackTalkscriberTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
	Language *FallbackTalkscriberTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackTalkscriberTranscriber) GetLanguage() *FallbackTalkscriberTranscriberLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackTalkscriberTranscriber) Provider() string {
	return f.provider
}

func (f *FallbackTalkscriberTranscriber) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackTalkscriberTranscriber) UnmarshalJSON(data []byte) error {
	type embed FallbackTalkscriberTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackTalkscriberTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "talkscriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "talkscriber", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTalkscriberTranscriber) MarshalJSON() ([]byte, error) {
	type embed FallbackTalkscriberTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "talkscriber",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackTalkscriberTranscriber) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
type FallbackTalkscriberTranscriberLanguage string

const (
	FallbackTalkscriberTranscriberLanguageEn  FallbackTalkscriberTranscriberLanguage = "en"
	FallbackTalkscriberTranscriberLanguageZh  FallbackTalkscriberTranscriberLanguage = "zh"
	FallbackTalkscriberTranscriberLanguageDe  FallbackTalkscriberTranscriberLanguage = "de"
	FallbackTalkscriberTranscriberLanguageEs  FallbackTalkscriberTranscriberLanguage = "es"
	FallbackTalkscriberTranscriberLanguageRu  FallbackTalkscriberTranscriberLanguage = "ru"
	FallbackTalkscriberTranscriberLanguageKo  FallbackTalkscriberTranscriberLanguage = "ko"
	FallbackTalkscriberTranscriberLanguageFr  FallbackTalkscriberTranscriberLanguage = "fr"
	FallbackTalkscriberTranscriberLanguageJa  FallbackTalkscriberTranscriberLanguage = "ja"
	FallbackTalkscriberTranscriberLanguagePt  FallbackTalkscriberTranscriberLanguage = "pt"
	FallbackTalkscriberTranscriberLanguageTr  FallbackTalkscriberTranscriberLanguage = "tr"
	FallbackTalkscriberTranscriberLanguagePl  FallbackTalkscriberTranscriberLanguage = "pl"
	FallbackTalkscriberTranscriberLanguageCa  FallbackTalkscriberTranscriberLanguage = "ca"
	FallbackTalkscriberTranscriberLanguageNl  FallbackTalkscriberTranscriberLanguage = "nl"
	FallbackTalkscriberTranscriberLanguageAr  FallbackTalkscriberTranscriberLanguage = "ar"
	FallbackTalkscriberTranscriberLanguageSv  FallbackTalkscriberTranscriberLanguage = "sv"
	FallbackTalkscriberTranscriberLanguageIt  FallbackTalkscriberTranscriberLanguage = "it"
	FallbackTalkscriberTranscriberLanguageId  FallbackTalkscriberTranscriberLanguage = "id"
	FallbackTalkscriberTranscriberLanguageHi  FallbackTalkscriberTranscriberLanguage = "hi"
	FallbackTalkscriberTranscriberLanguageFi  FallbackTalkscriberTranscriberLanguage = "fi"
	FallbackTalkscriberTranscriberLanguageVi  FallbackTalkscriberTranscriberLanguage = "vi"
	FallbackTalkscriberTranscriberLanguageHe  FallbackTalkscriberTranscriberLanguage = "he"
	FallbackTalkscriberTranscriberLanguageUk  FallbackTalkscriberTranscriberLanguage = "uk"
	FallbackTalkscriberTranscriberLanguageEl  FallbackTalkscriberTranscriberLanguage = "el"
	FallbackTalkscriberTranscriberLanguageMs  FallbackTalkscriberTranscriberLanguage = "ms"
	FallbackTalkscriberTranscriberLanguageCs  FallbackTalkscriberTranscriberLanguage = "cs"
	FallbackTalkscriberTranscriberLanguageRo  FallbackTalkscriberTranscriberLanguage = "ro"
	FallbackTalkscriberTranscriberLanguageDa  FallbackTalkscriberTranscriberLanguage = "da"
	FallbackTalkscriberTranscriberLanguageHu  FallbackTalkscriberTranscriberLanguage = "hu"
	FallbackTalkscriberTranscriberLanguageTa  FallbackTalkscriberTranscriberLanguage = "ta"
	FallbackTalkscriberTranscriberLanguageNo  FallbackTalkscriberTranscriberLanguage = "no"
	FallbackTalkscriberTranscriberLanguageTh  FallbackTalkscriberTranscriberLanguage = "th"
	FallbackTalkscriberTranscriberLanguageUr  FallbackTalkscriberTranscriberLanguage = "ur"
	FallbackTalkscriberTranscriberLanguageHr  FallbackTalkscriberTranscriberLanguage = "hr"
	FallbackTalkscriberTranscriberLanguageBg  FallbackTalkscriberTranscriberLanguage = "bg"
	FallbackTalkscriberTranscriberLanguageLt  FallbackTalkscriberTranscriberLanguage = "lt"
	FallbackTalkscriberTranscriberLanguageLa  FallbackTalkscriberTranscriberLanguage = "la"
	FallbackTalkscriberTranscriberLanguageMi  FallbackTalkscriberTranscriberLanguage = "mi"
	FallbackTalkscriberTranscriberLanguageMl  FallbackTalkscriberTranscriberLanguage = "ml"
	FallbackTalkscriberTranscriberLanguageCy  FallbackTalkscriberTranscriberLanguage = "cy"
	FallbackTalkscriberTranscriberLanguageSk  FallbackTalkscriberTranscriberLanguage = "sk"
	FallbackTalkscriberTranscriberLanguageTe  FallbackTalkscriberTranscriberLanguage = "te"
	FallbackTalkscriberTranscriberLanguageFa  FallbackTalkscriberTranscriberLanguage = "fa"
	FallbackTalkscriberTranscriberLanguageLv  FallbackTalkscriberTranscriberLanguage = "lv"
	FallbackTalkscriberTranscriberLanguageBn  FallbackTalkscriberTranscriberLanguage = "bn"
	FallbackTalkscriberTranscriberLanguageSr  FallbackTalkscriberTranscriberLanguage = "sr"
	FallbackTalkscriberTranscriberLanguageAz  FallbackTalkscriberTranscriberLanguage = "az"
	FallbackTalkscriberTranscriberLanguageSl  FallbackTalkscriberTranscriberLanguage = "sl"
	FallbackTalkscriberTranscriberLanguageKn  FallbackTalkscriberTranscriberLanguage = "kn"
	FallbackTalkscriberTranscriberLanguageEt  FallbackTalkscriberTranscriberLanguage = "et"
	FallbackTalkscriberTranscriberLanguageMk  FallbackTalkscriberTranscriberLanguage = "mk"
	FallbackTalkscriberTranscriberLanguageBr  FallbackTalkscriberTranscriberLanguage = "br"
	FallbackTalkscriberTranscriberLanguageEu  FallbackTalkscriberTranscriberLanguage = "eu"
	FallbackTalkscriberTranscriberLanguageIs  FallbackTalkscriberTranscriberLanguage = "is"
	FallbackTalkscriberTranscriberLanguageHy  FallbackTalkscriberTranscriberLanguage = "hy"
	FallbackTalkscriberTranscriberLanguageNe  FallbackTalkscriberTranscriberLanguage = "ne"
	FallbackTalkscriberTranscriberLanguageMn  FallbackTalkscriberTranscriberLanguage = "mn"
	FallbackTalkscriberTranscriberLanguageBs  FallbackTalkscriberTranscriberLanguage = "bs"
	FallbackTalkscriberTranscriberLanguageKk  FallbackTalkscriberTranscriberLanguage = "kk"
	FallbackTalkscriberTranscriberLanguageSq  FallbackTalkscriberTranscriberLanguage = "sq"
	FallbackTalkscriberTranscriberLanguageSw  FallbackTalkscriberTranscriberLanguage = "sw"
	FallbackTalkscriberTranscriberLanguageGl  FallbackTalkscriberTranscriberLanguage = "gl"
	FallbackTalkscriberTranscriberLanguageMr  FallbackTalkscriberTranscriberLanguage = "mr"
	FallbackTalkscriberTranscriberLanguagePa  FallbackTalkscriberTranscriberLanguage = "pa"
	FallbackTalkscriberTranscriberLanguageSi  FallbackTalkscriberTranscriberLanguage = "si"
	FallbackTalkscriberTranscriberLanguageKm  FallbackTalkscriberTranscriberLanguage = "km"
	FallbackTalkscriberTranscriberLanguageSn  FallbackTalkscriberTranscriberLanguage = "sn"
	FallbackTalkscriberTranscriberLanguageYo  FallbackTalkscriberTranscriberLanguage = "yo"
	FallbackTalkscriberTranscriberLanguageSo  FallbackTalkscriberTranscriberLanguage = "so"
	FallbackTalkscriberTranscriberLanguageAf  FallbackTalkscriberTranscriberLanguage = "af"
	FallbackTalkscriberTranscriberLanguageOc  FallbackTalkscriberTranscriberLanguage = "oc"
	FallbackTalkscriberTranscriberLanguageKa  FallbackTalkscriberTranscriberLanguage = "ka"
	FallbackTalkscriberTranscriberLanguageBe  FallbackTalkscriberTranscriberLanguage = "be"
	FallbackTalkscriberTranscriberLanguageTg  FallbackTalkscriberTranscriberLanguage = "tg"
	FallbackTalkscriberTranscriberLanguageSd  FallbackTalkscriberTranscriberLanguage = "sd"
	FallbackTalkscriberTranscriberLanguageGu  FallbackTalkscriberTranscriberLanguage = "gu"
	FallbackTalkscriberTranscriberLanguageAm  FallbackTalkscriberTranscriberLanguage = "am"
	FallbackTalkscriberTranscriberLanguageYi  FallbackTalkscriberTranscriberLanguage = "yi"
	FallbackTalkscriberTranscriberLanguageLo  FallbackTalkscriberTranscriberLanguage = "lo"
	FallbackTalkscriberTranscriberLanguageUz  FallbackTalkscriberTranscriberLanguage = "uz"
	FallbackTalkscriberTranscriberLanguageFo  FallbackTalkscriberTranscriberLanguage = "fo"
	FallbackTalkscriberTranscriberLanguageHt  FallbackTalkscriberTranscriberLanguage = "ht"
	FallbackTalkscriberTranscriberLanguagePs  FallbackTalkscriberTranscriberLanguage = "ps"
	FallbackTalkscriberTranscriberLanguageTk  FallbackTalkscriberTranscriberLanguage = "tk"
	FallbackTalkscriberTranscriberLanguageNn  FallbackTalkscriberTranscriberLanguage = "nn"
	FallbackTalkscriberTranscriberLanguageMt  FallbackTalkscriberTranscriberLanguage = "mt"
	FallbackTalkscriberTranscriberLanguageSa  FallbackTalkscriberTranscriberLanguage = "sa"
	FallbackTalkscriberTranscriberLanguageLb  FallbackTalkscriberTranscriberLanguage = "lb"
	FallbackTalkscriberTranscriberLanguageMy  FallbackTalkscriberTranscriberLanguage = "my"
	FallbackTalkscriberTranscriberLanguageBo  FallbackTalkscriberTranscriberLanguage = "bo"
	FallbackTalkscriberTranscriberLanguageTl  FallbackTalkscriberTranscriberLanguage = "tl"
	FallbackTalkscriberTranscriberLanguageMg  FallbackTalkscriberTranscriberLanguage = "mg"
	FallbackTalkscriberTranscriberLanguageAs  FallbackTalkscriberTranscriberLanguage = "as"
	FallbackTalkscriberTranscriberLanguageTt  FallbackTalkscriberTranscriberLanguage = "tt"
	FallbackTalkscriberTranscriberLanguageHaw FallbackTalkscriberTranscriberLanguage = "haw"
	FallbackTalkscriberTranscriberLanguageLn  FallbackTalkscriberTranscriberLanguage = "ln"
	FallbackTalkscriberTranscriberLanguageHa  FallbackTalkscriberTranscriberLanguage = "ha"
	FallbackTalkscriberTranscriberLanguageBa  FallbackTalkscriberTranscriberLanguage = "ba"
	FallbackTalkscriberTranscriberLanguageJw  FallbackTalkscriberTranscriberLanguage = "jw"
	FallbackTalkscriberTranscriberLanguageSu  FallbackTalkscriberTranscriberLanguage = "su"
	FallbackTalkscriberTranscriberLanguageYue FallbackTalkscriberTranscriberLanguage = "yue"
)

func NewFallbackTalkscriberTranscriberLanguageFromString(s string) (FallbackTalkscriberTranscriberLanguage, error) {
	switch s {
	case "en":
		return FallbackTalkscriberTranscriberLanguageEn, nil
	case "zh":
		return FallbackTalkscriberTranscriberLanguageZh, nil
	case "de":
		return FallbackTalkscriberTranscriberLanguageDe, nil
	case "es":
		return FallbackTalkscriberTranscriberLanguageEs, nil
	case "ru":
		return FallbackTalkscriberTranscriberLanguageRu, nil
	case "ko":
		return FallbackTalkscriberTranscriberLanguageKo, nil
	case "fr":
		return FallbackTalkscriberTranscriberLanguageFr, nil
	case "ja":
		return FallbackTalkscriberTranscriberLanguageJa, nil
	case "pt":
		return FallbackTalkscriberTranscriberLanguagePt, nil
	case "tr":
		return FallbackTalkscriberTranscriberLanguageTr, nil
	case "pl":
		return FallbackTalkscriberTranscriberLanguagePl, nil
	case "ca":
		return FallbackTalkscriberTranscriberLanguageCa, nil
	case "nl":
		return FallbackTalkscriberTranscriberLanguageNl, nil
	case "ar":
		return FallbackTalkscriberTranscriberLanguageAr, nil
	case "sv":
		return FallbackTalkscriberTranscriberLanguageSv, nil
	case "it":
		return FallbackTalkscriberTranscriberLanguageIt, nil
	case "id":
		return FallbackTalkscriberTranscriberLanguageId, nil
	case "hi":
		return FallbackTalkscriberTranscriberLanguageHi, nil
	case "fi":
		return FallbackTalkscriberTranscriberLanguageFi, nil
	case "vi":
		return FallbackTalkscriberTranscriberLanguageVi, nil
	case "he":
		return FallbackTalkscriberTranscriberLanguageHe, nil
	case "uk":
		return FallbackTalkscriberTranscriberLanguageUk, nil
	case "el":
		return FallbackTalkscriberTranscriberLanguageEl, nil
	case "ms":
		return FallbackTalkscriberTranscriberLanguageMs, nil
	case "cs":
		return FallbackTalkscriberTranscriberLanguageCs, nil
	case "ro":
		return FallbackTalkscriberTranscriberLanguageRo, nil
	case "da":
		return FallbackTalkscriberTranscriberLanguageDa, nil
	case "hu":
		return FallbackTalkscriberTranscriberLanguageHu, nil
	case "ta":
		return FallbackTalkscriberTranscriberLanguageTa, nil
	case "no":
		return FallbackTalkscriberTranscriberLanguageNo, nil
	case "th":
		return FallbackTalkscriberTranscriberLanguageTh, nil
	case "ur":
		return FallbackTalkscriberTranscriberLanguageUr, nil
	case "hr":
		return FallbackTalkscriberTranscriberLanguageHr, nil
	case "bg":
		return FallbackTalkscriberTranscriberLanguageBg, nil
	case "lt":
		return FallbackTalkscriberTranscriberLanguageLt, nil
	case "la":
		return FallbackTalkscriberTranscriberLanguageLa, nil
	case "mi":
		return FallbackTalkscriberTranscriberLanguageMi, nil
	case "ml":
		return FallbackTalkscriberTranscriberLanguageMl, nil
	case "cy":
		return FallbackTalkscriberTranscriberLanguageCy, nil
	case "sk":
		return FallbackTalkscriberTranscriberLanguageSk, nil
	case "te":
		return FallbackTalkscriberTranscriberLanguageTe, nil
	case "fa":
		return FallbackTalkscriberTranscriberLanguageFa, nil
	case "lv":
		return FallbackTalkscriberTranscriberLanguageLv, nil
	case "bn":
		return FallbackTalkscriberTranscriberLanguageBn, nil
	case "sr":
		return FallbackTalkscriberTranscriberLanguageSr, nil
	case "az":
		return FallbackTalkscriberTranscriberLanguageAz, nil
	case "sl":
		return FallbackTalkscriberTranscriberLanguageSl, nil
	case "kn":
		return FallbackTalkscriberTranscriberLanguageKn, nil
	case "et":
		return FallbackTalkscriberTranscriberLanguageEt, nil
	case "mk":
		return FallbackTalkscriberTranscriberLanguageMk, nil
	case "br":
		return FallbackTalkscriberTranscriberLanguageBr, nil
	case "eu":
		return FallbackTalkscriberTranscriberLanguageEu, nil
	case "is":
		return FallbackTalkscriberTranscriberLanguageIs, nil
	case "hy":
		return FallbackTalkscriberTranscriberLanguageHy, nil
	case "ne":
		return FallbackTalkscriberTranscriberLanguageNe, nil
	case "mn":
		return FallbackTalkscriberTranscriberLanguageMn, nil
	case "bs":
		return FallbackTalkscriberTranscriberLanguageBs, nil
	case "kk":
		return FallbackTalkscriberTranscriberLanguageKk, nil
	case "sq":
		return FallbackTalkscriberTranscriberLanguageSq, nil
	case "sw":
		return FallbackTalkscriberTranscriberLanguageSw, nil
	case "gl":
		return FallbackTalkscriberTranscriberLanguageGl, nil
	case "mr":
		return FallbackTalkscriberTranscriberLanguageMr, nil
	case "pa":
		return FallbackTalkscriberTranscriberLanguagePa, nil
	case "si":
		return FallbackTalkscriberTranscriberLanguageSi, nil
	case "km":
		return FallbackTalkscriberTranscriberLanguageKm, nil
	case "sn":
		return FallbackTalkscriberTranscriberLanguageSn, nil
	case "yo":
		return FallbackTalkscriberTranscriberLanguageYo, nil
	case "so":
		return FallbackTalkscriberTranscriberLanguageSo, nil
	case "af":
		return FallbackTalkscriberTranscriberLanguageAf, nil
	case "oc":
		return FallbackTalkscriberTranscriberLanguageOc, nil
	case "ka":
		return FallbackTalkscriberTranscriberLanguageKa, nil
	case "be":
		return FallbackTalkscriberTranscriberLanguageBe, nil
	case "tg":
		return FallbackTalkscriberTranscriberLanguageTg, nil
	case "sd":
		return FallbackTalkscriberTranscriberLanguageSd, nil
	case "gu":
		return FallbackTalkscriberTranscriberLanguageGu, nil
	case "am":
		return FallbackTalkscriberTranscriberLanguageAm, nil
	case "yi":
		return FallbackTalkscriberTranscriberLanguageYi, nil
	case "lo":
		return FallbackTalkscriberTranscriberLanguageLo, nil
	case "uz":
		return FallbackTalkscriberTranscriberLanguageUz, nil
	case "fo":
		return FallbackTalkscriberTranscriberLanguageFo, nil
	case "ht":
		return FallbackTalkscriberTranscriberLanguageHt, nil
	case "ps":
		return FallbackTalkscriberTranscriberLanguagePs, nil
	case "tk":
		return FallbackTalkscriberTranscriberLanguageTk, nil
	case "nn":
		return FallbackTalkscriberTranscriberLanguageNn, nil
	case "mt":
		return FallbackTalkscriberTranscriberLanguageMt, nil
	case "sa":
		return FallbackTalkscriberTranscriberLanguageSa, nil
	case "lb":
		return FallbackTalkscriberTranscriberLanguageLb, nil
	case "my":
		return FallbackTalkscriberTranscriberLanguageMy, nil
	case "bo":
		return FallbackTalkscriberTranscriberLanguageBo, nil
	case "tl":
		return FallbackTalkscriberTranscriberLanguageTl, nil
	case "mg":
		return FallbackTalkscriberTranscriberLanguageMg, nil
	case "as":
		return FallbackTalkscriberTranscriberLanguageAs, nil
	case "tt":
		return FallbackTalkscriberTranscriberLanguageTt, nil
	case "haw":
		return FallbackTalkscriberTranscriberLanguageHaw, nil
	case "ln":
		return FallbackTalkscriberTranscriberLanguageLn, nil
	case "ha":
		return FallbackTalkscriberTranscriberLanguageHa, nil
	case "ba":
		return FallbackTalkscriberTranscriberLanguageBa, nil
	case "jw":
		return FallbackTalkscriberTranscriberLanguageJw, nil
	case "su":
		return FallbackTalkscriberTranscriberLanguageSu, nil
	case "yue":
		return FallbackTalkscriberTranscriberLanguageYue, nil
	}
	var t FallbackTalkscriberTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackTalkscriberTranscriberLanguage) Ptr() *FallbackTalkscriberTranscriberLanguage {
	return &f
}

type FallbackTavusVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackTavusVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the unique identifier for the persona that the replica will use in the conversation.
	PersonaId *string `json:"personaId,omitempty" url:"personaId,omitempty"`
	// This is the url that will receive webhooks with updates regarding the conversation state.
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// This is the name for the conversation.
	ConversationName *string `json:"conversationName,omitempty" url:"conversationName,omitempty"`
	// This is the context that will be appended to any context provided in the persona, if one is provided.
	ConversationalContext *string `json:"conversationalContext,omitempty" url:"conversationalContext,omitempty"`
	// This is the custom greeting that the replica will give once a participant joines the conversation.
	CustomGreeting *string `json:"customGreeting,omitempty" url:"customGreeting,omitempty"`
	// These are optional properties used to customize the conversation.
	Properties *TavusConversationProperties `json:"properties,omitempty" url:"properties,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackTavusVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackTavusVoice) GetVoiceId() *FallbackTavusVoiceVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackTavusVoice) GetPersonaId() *string {
	if f == nil {
		return nil
	}
	return f.PersonaId
}

func (f *FallbackTavusVoice) GetCallbackUrl() *string {
	if f == nil {
		return nil
	}
	return f.CallbackUrl
}

func (f *FallbackTavusVoice) GetConversationName() *string {
	if f == nil {
		return nil
	}
	return f.ConversationName
}

func (f *FallbackTavusVoice) GetConversationalContext() *string {
	if f == nil {
		return nil
	}
	return f.ConversationalContext
}

func (f *FallbackTavusVoice) GetCustomGreeting() *string {
	if f == nil {
		return nil
	}
	return f.CustomGreeting
}

func (f *FallbackTavusVoice) GetProperties() *TavusConversationProperties {
	if f == nil {
		return nil
	}
	return f.Properties
}

func (f *FallbackTavusVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackTavusVoice) Provider() string {
	return f.provider
}

func (f *FallbackTavusVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackTavusVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackTavusVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackTavusVoice(unmarshaler.embed)
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "tavus", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTavusVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackTavusVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "tavus",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackTavusVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackTavusVoiceVoiceId struct {
	R52da2535aStringLiteral string
	String                  string

	typ string
}

func NewFallbackTavusVoiceVoiceIdWithR52da2535aStringLiteral() *FallbackTavusVoiceVoiceId {
	return &FallbackTavusVoiceVoiceId{typ: "R52da2535aStringLiteral", R52da2535aStringLiteral: "r52da2535a"}
}

func (f *FallbackTavusVoiceVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackTavusVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueR52da2535aStringLiteral string
	if err := json.Unmarshal(data, &valueR52da2535aStringLiteral); err == nil {
		f.typ = "R52da2535aStringLiteral"
		f.R52da2535aStringLiteral = valueR52da2535aStringLiteral
		if f.R52da2535aStringLiteral != "r52da2535a" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "r52da2535a", valueR52da2535aStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackTavusVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "R52da2535aStringLiteral" || f.R52da2535aStringLiteral != "" {
		return json.Marshal("r52da2535a")
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackTavusVoiceVoiceIdVisitor interface {
	VisitR52da2535aStringLiteral(string) error
	VisitString(string) error
}

func (f *FallbackTavusVoiceVoiceId) Accept(visitor FallbackTavusVoiceVoiceIdVisitor) error {
	if f.typ == "R52da2535aStringLiteral" || f.R52da2535aStringLiteral != "" {
		return visitor.VisitR52da2535aStringLiteral(f.R52da2535aStringLiteral)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackTranscriberPlan struct {
	Transcribers []*FallbackTranscriberPlanTranscribersItem `json:"transcribers,omitempty" url:"transcribers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackTranscriberPlan) GetTranscribers() []*FallbackTranscriberPlanTranscribersItem {
	if f == nil {
		return nil
	}
	return f.Transcribers
}

func (f *FallbackTranscriberPlan) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackTranscriberPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackTranscriberPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackTranscriberPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTranscriberPlan) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackTranscriberPlanTranscribersItem struct {
	FallbackAssemblyAiTranscriber   *FallbackAssemblyAiTranscriber
	FallbackAzureSpeechTranscriber  *FallbackAzureSpeechTranscriber
	FallbackCustomTranscriber       *FallbackCustomTranscriber
	FallbackDeepgramTranscriber     *FallbackDeepgramTranscriber
	FallbackElevenLabsTranscriber   *FallbackElevenLabsTranscriber
	FallbackGladiaTranscriber       *FallbackGladiaTranscriber
	FallbackGoogleTranscriber       *FallbackGoogleTranscriber
	FallbackTalkscriberTranscriber  *FallbackTalkscriberTranscriber
	FallbackSpeechmaticsTranscriber *FallbackSpeechmaticsTranscriber
	FallbackOpenAiTranscriber       *FallbackOpenAiTranscriber

	typ string
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackAssemblyAiTranscriber() *FallbackAssemblyAiTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackAssemblyAiTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackAzureSpeechTranscriber() *FallbackAzureSpeechTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackAzureSpeechTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackCustomTranscriber() *FallbackCustomTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackCustomTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackDeepgramTranscriber() *FallbackDeepgramTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackDeepgramTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackElevenLabsTranscriber() *FallbackElevenLabsTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackElevenLabsTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackGladiaTranscriber() *FallbackGladiaTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackGladiaTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackGoogleTranscriber() *FallbackGoogleTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackGoogleTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackTalkscriberTranscriber() *FallbackTalkscriberTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackTalkscriberTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackSpeechmaticsTranscriber() *FallbackSpeechmaticsTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackSpeechmaticsTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) GetFallbackOpenAiTranscriber() *FallbackOpenAiTranscriber {
	if f == nil {
		return nil
	}
	return f.FallbackOpenAiTranscriber
}

func (f *FallbackTranscriberPlanTranscribersItem) UnmarshalJSON(data []byte) error {
	valueFallbackAssemblyAiTranscriber := new(FallbackAssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueFallbackAssemblyAiTranscriber); err == nil {
		f.typ = "FallbackAssemblyAiTranscriber"
		f.FallbackAssemblyAiTranscriber = valueFallbackAssemblyAiTranscriber
		return nil
	}
	valueFallbackAzureSpeechTranscriber := new(FallbackAzureSpeechTranscriber)
	if err := json.Unmarshal(data, &valueFallbackAzureSpeechTranscriber); err == nil {
		f.typ = "FallbackAzureSpeechTranscriber"
		f.FallbackAzureSpeechTranscriber = valueFallbackAzureSpeechTranscriber
		return nil
	}
	valueFallbackCustomTranscriber := new(FallbackCustomTranscriber)
	if err := json.Unmarshal(data, &valueFallbackCustomTranscriber); err == nil {
		f.typ = "FallbackCustomTranscriber"
		f.FallbackCustomTranscriber = valueFallbackCustomTranscriber
		return nil
	}
	valueFallbackDeepgramTranscriber := new(FallbackDeepgramTranscriber)
	if err := json.Unmarshal(data, &valueFallbackDeepgramTranscriber); err == nil {
		f.typ = "FallbackDeepgramTranscriber"
		f.FallbackDeepgramTranscriber = valueFallbackDeepgramTranscriber
		return nil
	}
	valueFallbackElevenLabsTranscriber := new(FallbackElevenLabsTranscriber)
	if err := json.Unmarshal(data, &valueFallbackElevenLabsTranscriber); err == nil {
		f.typ = "FallbackElevenLabsTranscriber"
		f.FallbackElevenLabsTranscriber = valueFallbackElevenLabsTranscriber
		return nil
	}
	valueFallbackGladiaTranscriber := new(FallbackGladiaTranscriber)
	if err := json.Unmarshal(data, &valueFallbackGladiaTranscriber); err == nil {
		f.typ = "FallbackGladiaTranscriber"
		f.FallbackGladiaTranscriber = valueFallbackGladiaTranscriber
		return nil
	}
	valueFallbackGoogleTranscriber := new(FallbackGoogleTranscriber)
	if err := json.Unmarshal(data, &valueFallbackGoogleTranscriber); err == nil {
		f.typ = "FallbackGoogleTranscriber"
		f.FallbackGoogleTranscriber = valueFallbackGoogleTranscriber
		return nil
	}
	valueFallbackTalkscriberTranscriber := new(FallbackTalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueFallbackTalkscriberTranscriber); err == nil {
		f.typ = "FallbackTalkscriberTranscriber"
		f.FallbackTalkscriberTranscriber = valueFallbackTalkscriberTranscriber
		return nil
	}
	valueFallbackSpeechmaticsTranscriber := new(FallbackSpeechmaticsTranscriber)
	if err := json.Unmarshal(data, &valueFallbackSpeechmaticsTranscriber); err == nil {
		f.typ = "FallbackSpeechmaticsTranscriber"
		f.FallbackSpeechmaticsTranscriber = valueFallbackSpeechmaticsTranscriber
		return nil
	}
	valueFallbackOpenAiTranscriber := new(FallbackOpenAiTranscriber)
	if err := json.Unmarshal(data, &valueFallbackOpenAiTranscriber); err == nil {
		f.typ = "FallbackOpenAiTranscriber"
		f.FallbackOpenAiTranscriber = valueFallbackOpenAiTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackTranscriberPlanTranscribersItem) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackAssemblyAiTranscriber" || f.FallbackAssemblyAiTranscriber != nil {
		return json.Marshal(f.FallbackAssemblyAiTranscriber)
	}
	if f.typ == "FallbackAzureSpeechTranscriber" || f.FallbackAzureSpeechTranscriber != nil {
		return json.Marshal(f.FallbackAzureSpeechTranscriber)
	}
	if f.typ == "FallbackCustomTranscriber" || f.FallbackCustomTranscriber != nil {
		return json.Marshal(f.FallbackCustomTranscriber)
	}
	if f.typ == "FallbackDeepgramTranscriber" || f.FallbackDeepgramTranscriber != nil {
		return json.Marshal(f.FallbackDeepgramTranscriber)
	}
	if f.typ == "FallbackElevenLabsTranscriber" || f.FallbackElevenLabsTranscriber != nil {
		return json.Marshal(f.FallbackElevenLabsTranscriber)
	}
	if f.typ == "FallbackGladiaTranscriber" || f.FallbackGladiaTranscriber != nil {
		return json.Marshal(f.FallbackGladiaTranscriber)
	}
	if f.typ == "FallbackGoogleTranscriber" || f.FallbackGoogleTranscriber != nil {
		return json.Marshal(f.FallbackGoogleTranscriber)
	}
	if f.typ == "FallbackTalkscriberTranscriber" || f.FallbackTalkscriberTranscriber != nil {
		return json.Marshal(f.FallbackTalkscriberTranscriber)
	}
	if f.typ == "FallbackSpeechmaticsTranscriber" || f.FallbackSpeechmaticsTranscriber != nil {
		return json.Marshal(f.FallbackSpeechmaticsTranscriber)
	}
	if f.typ == "FallbackOpenAiTranscriber" || f.FallbackOpenAiTranscriber != nil {
		return json.Marshal(f.FallbackOpenAiTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackTranscriberPlanTranscribersItemVisitor interface {
	VisitFallbackAssemblyAiTranscriber(*FallbackAssemblyAiTranscriber) error
	VisitFallbackAzureSpeechTranscriber(*FallbackAzureSpeechTranscriber) error
	VisitFallbackCustomTranscriber(*FallbackCustomTranscriber) error
	VisitFallbackDeepgramTranscriber(*FallbackDeepgramTranscriber) error
	VisitFallbackElevenLabsTranscriber(*FallbackElevenLabsTranscriber) error
	VisitFallbackGladiaTranscriber(*FallbackGladiaTranscriber) error
	VisitFallbackGoogleTranscriber(*FallbackGoogleTranscriber) error
	VisitFallbackTalkscriberTranscriber(*FallbackTalkscriberTranscriber) error
	VisitFallbackSpeechmaticsTranscriber(*FallbackSpeechmaticsTranscriber) error
	VisitFallbackOpenAiTranscriber(*FallbackOpenAiTranscriber) error
}

func (f *FallbackTranscriberPlanTranscribersItem) Accept(visitor FallbackTranscriberPlanTranscribersItemVisitor) error {
	if f.typ == "FallbackAssemblyAiTranscriber" || f.FallbackAssemblyAiTranscriber != nil {
		return visitor.VisitFallbackAssemblyAiTranscriber(f.FallbackAssemblyAiTranscriber)
	}
	if f.typ == "FallbackAzureSpeechTranscriber" || f.FallbackAzureSpeechTranscriber != nil {
		return visitor.VisitFallbackAzureSpeechTranscriber(f.FallbackAzureSpeechTranscriber)
	}
	if f.typ == "FallbackCustomTranscriber" || f.FallbackCustomTranscriber != nil {
		return visitor.VisitFallbackCustomTranscriber(f.FallbackCustomTranscriber)
	}
	if f.typ == "FallbackDeepgramTranscriber" || f.FallbackDeepgramTranscriber != nil {
		return visitor.VisitFallbackDeepgramTranscriber(f.FallbackDeepgramTranscriber)
	}
	if f.typ == "FallbackElevenLabsTranscriber" || f.FallbackElevenLabsTranscriber != nil {
		return visitor.VisitFallbackElevenLabsTranscriber(f.FallbackElevenLabsTranscriber)
	}
	if f.typ == "FallbackGladiaTranscriber" || f.FallbackGladiaTranscriber != nil {
		return visitor.VisitFallbackGladiaTranscriber(f.FallbackGladiaTranscriber)
	}
	if f.typ == "FallbackGoogleTranscriber" || f.FallbackGoogleTranscriber != nil {
		return visitor.VisitFallbackGoogleTranscriber(f.FallbackGoogleTranscriber)
	}
	if f.typ == "FallbackTalkscriberTranscriber" || f.FallbackTalkscriberTranscriber != nil {
		return visitor.VisitFallbackTalkscriberTranscriber(f.FallbackTalkscriberTranscriber)
	}
	if f.typ == "FallbackSpeechmaticsTranscriber" || f.FallbackSpeechmaticsTranscriber != nil {
		return visitor.VisitFallbackSpeechmaticsTranscriber(f.FallbackSpeechmaticsTranscriber)
	}
	if f.typ == "FallbackOpenAiTranscriber" || f.FallbackOpenAiTranscriber != nil {
		return visitor.VisitFallbackOpenAiTranscriber(f.FallbackOpenAiTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackVapiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// The voices provided by Vapi
	VoiceId FallbackVapiVoiceVoiceId `json:"voiceId" url:"voiceId"`
	// This is the speed multiplier that will be used.
	//
	// @default 1
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the language code (ISO 639-1) that will be used.
	//
	// @default 'en-US'
	Language *FallbackVapiVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackVapiVoice) GetCachingEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.CachingEnabled
}

func (f *FallbackVapiVoice) GetVoiceId() FallbackVapiVoiceVoiceId {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackVapiVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackVapiVoice) GetLanguage() *FallbackVapiVoiceLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackVapiVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackVapiVoice) Provider() string {
	return f.provider
}

func (f *FallbackVapiVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackVapiVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackVapiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackVapiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "vapi", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackVapiVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackVapiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "vapi",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackVapiVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the language code (ISO 639-1) that will be used.
//
// @default 'en-US'
type FallbackVapiVoiceLanguage string

const (
	FallbackVapiVoiceLanguageEnUs FallbackVapiVoiceLanguage = "en-US"
	FallbackVapiVoiceLanguageEnGb FallbackVapiVoiceLanguage = "en-GB"
	FallbackVapiVoiceLanguageEnAu FallbackVapiVoiceLanguage = "en-AU"
	FallbackVapiVoiceLanguageEnCa FallbackVapiVoiceLanguage = "en-CA"
	FallbackVapiVoiceLanguageJa   FallbackVapiVoiceLanguage = "ja"
	FallbackVapiVoiceLanguageZh   FallbackVapiVoiceLanguage = "zh"
	FallbackVapiVoiceLanguageDe   FallbackVapiVoiceLanguage = "de"
	FallbackVapiVoiceLanguageHi   FallbackVapiVoiceLanguage = "hi"
	FallbackVapiVoiceLanguageFrFr FallbackVapiVoiceLanguage = "fr-FR"
	FallbackVapiVoiceLanguageFrCa FallbackVapiVoiceLanguage = "fr-CA"
	FallbackVapiVoiceLanguageKo   FallbackVapiVoiceLanguage = "ko"
	FallbackVapiVoiceLanguagePtBr FallbackVapiVoiceLanguage = "pt-BR"
	FallbackVapiVoiceLanguagePtPt FallbackVapiVoiceLanguage = "pt-PT"
	FallbackVapiVoiceLanguageIt   FallbackVapiVoiceLanguage = "it"
	FallbackVapiVoiceLanguageEsEs FallbackVapiVoiceLanguage = "es-ES"
	FallbackVapiVoiceLanguageEsMx FallbackVapiVoiceLanguage = "es-MX"
	FallbackVapiVoiceLanguageId   FallbackVapiVoiceLanguage = "id"
	FallbackVapiVoiceLanguageNl   FallbackVapiVoiceLanguage = "nl"
	FallbackVapiVoiceLanguageTr   FallbackVapiVoiceLanguage = "tr"
	FallbackVapiVoiceLanguageFil  FallbackVapiVoiceLanguage = "fil"
	FallbackVapiVoiceLanguagePl   FallbackVapiVoiceLanguage = "pl"
	FallbackVapiVoiceLanguageSv   FallbackVapiVoiceLanguage = "sv"
	FallbackVapiVoiceLanguageBg   FallbackVapiVoiceLanguage = "bg"
	FallbackVapiVoiceLanguageRo   FallbackVapiVoiceLanguage = "ro"
	FallbackVapiVoiceLanguageArSa FallbackVapiVoiceLanguage = "ar-SA"
	FallbackVapiVoiceLanguageArAe FallbackVapiVoiceLanguage = "ar-AE"
	FallbackVapiVoiceLanguageCs   FallbackVapiVoiceLanguage = "cs"
	FallbackVapiVoiceLanguageEl   FallbackVapiVoiceLanguage = "el"
	FallbackVapiVoiceLanguageFi   FallbackVapiVoiceLanguage = "fi"
	FallbackVapiVoiceLanguageHr   FallbackVapiVoiceLanguage = "hr"
	FallbackVapiVoiceLanguageMs   FallbackVapiVoiceLanguage = "ms"
	FallbackVapiVoiceLanguageSk   FallbackVapiVoiceLanguage = "sk"
	FallbackVapiVoiceLanguageDa   FallbackVapiVoiceLanguage = "da"
	FallbackVapiVoiceLanguageTa   FallbackVapiVoiceLanguage = "ta"
	FallbackVapiVoiceLanguageUk   FallbackVapiVoiceLanguage = "uk"
	FallbackVapiVoiceLanguageRu   FallbackVapiVoiceLanguage = "ru"
	FallbackVapiVoiceLanguageHu   FallbackVapiVoiceLanguage = "hu"
	FallbackVapiVoiceLanguageNo   FallbackVapiVoiceLanguage = "no"
	FallbackVapiVoiceLanguageVi   FallbackVapiVoiceLanguage = "vi"
)

func NewFallbackVapiVoiceLanguageFromString(s string) (FallbackVapiVoiceLanguage, error) {
	switch s {
	case "en-US":
		return FallbackVapiVoiceLanguageEnUs, nil
	case "en-GB":
		return FallbackVapiVoiceLanguageEnGb, nil
	case "en-AU":
		return FallbackVapiVoiceLanguageEnAu, nil
	case "en-CA":
		return FallbackVapiVoiceLanguageEnCa, nil
	case "ja":
		return FallbackVapiVoiceLanguageJa, nil
	case "zh":
		return FallbackVapiVoiceLanguageZh, nil
	case "de":
		return FallbackVapiVoiceLanguageDe, nil
	case "hi":
		return FallbackVapiVoiceLanguageHi, nil
	case "fr-FR":
		return FallbackVapiVoiceLanguageFrFr, nil
	case "fr-CA":
		return FallbackVapiVoiceLanguageFrCa, nil
	case "ko":
		return FallbackVapiVoiceLanguageKo, nil
	case "pt-BR":
		return FallbackVapiVoiceLanguagePtBr, nil
	case "pt-PT":
		return FallbackVapiVoiceLanguagePtPt, nil
	case "it":
		return FallbackVapiVoiceLanguageIt, nil
	case "es-ES":
		return FallbackVapiVoiceLanguageEsEs, nil
	case "es-MX":
		return FallbackVapiVoiceLanguageEsMx, nil
	case "id":
		return FallbackVapiVoiceLanguageId, nil
	case "nl":
		return FallbackVapiVoiceLanguageNl, nil
	case "tr":
		return FallbackVapiVoiceLanguageTr, nil
	case "fil":
		return FallbackVapiVoiceLanguageFil, nil
	case "pl":
		return FallbackVapiVoiceLanguagePl, nil
	case "sv":
		return FallbackVapiVoiceLanguageSv, nil
	case "bg":
		return FallbackVapiVoiceLanguageBg, nil
	case "ro":
		return FallbackVapiVoiceLanguageRo, nil
	case "ar-SA":
		return FallbackVapiVoiceLanguageArSa, nil
	case "ar-AE":
		return FallbackVapiVoiceLanguageArAe, nil
	case "cs":
		return FallbackVapiVoiceLanguageCs, nil
	case "el":
		return FallbackVapiVoiceLanguageEl, nil
	case "fi":
		return FallbackVapiVoiceLanguageFi, nil
	case "hr":
		return FallbackVapiVoiceLanguageHr, nil
	case "ms":
		return FallbackVapiVoiceLanguageMs, nil
	case "sk":
		return FallbackVapiVoiceLanguageSk, nil
	case "da":
		return FallbackVapiVoiceLanguageDa, nil
	case "ta":
		return FallbackVapiVoiceLanguageTa, nil
	case "uk":
		return FallbackVapiVoiceLanguageUk, nil
	case "ru":
		return FallbackVapiVoiceLanguageRu, nil
	case "hu":
		return FallbackVapiVoiceLanguageHu, nil
	case "no":
		return FallbackVapiVoiceLanguageNo, nil
	case "vi":
		return FallbackVapiVoiceLanguageVi, nil
	}
	var t FallbackVapiVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackVapiVoiceLanguage) Ptr() *FallbackVapiVoiceLanguage {
	return &f
}

// The voices provided by Vapi
type FallbackVapiVoiceVoiceId string

const (
	FallbackVapiVoiceVoiceIdElliot   FallbackVapiVoiceVoiceId = "Elliot"
	FallbackVapiVoiceVoiceIdKylie    FallbackVapiVoiceVoiceId = "Kylie"
	FallbackVapiVoiceVoiceIdRohan    FallbackVapiVoiceVoiceId = "Rohan"
	FallbackVapiVoiceVoiceIdLily     FallbackVapiVoiceVoiceId = "Lily"
	FallbackVapiVoiceVoiceIdSavannah FallbackVapiVoiceVoiceId = "Savannah"
	FallbackVapiVoiceVoiceIdHana     FallbackVapiVoiceVoiceId = "Hana"
	FallbackVapiVoiceVoiceIdNeha     FallbackVapiVoiceVoiceId = "Neha"
	FallbackVapiVoiceVoiceIdCole     FallbackVapiVoiceVoiceId = "Cole"
	FallbackVapiVoiceVoiceIdHarry    FallbackVapiVoiceVoiceId = "Harry"
	FallbackVapiVoiceVoiceIdPaige    FallbackVapiVoiceVoiceId = "Paige"
	FallbackVapiVoiceVoiceIdSpencer  FallbackVapiVoiceVoiceId = "Spencer"
)

func NewFallbackVapiVoiceVoiceIdFromString(s string) (FallbackVapiVoiceVoiceId, error) {
	switch s {
	case "Elliot":
		return FallbackVapiVoiceVoiceIdElliot, nil
	case "Kylie":
		return FallbackVapiVoiceVoiceIdKylie, nil
	case "Rohan":
		return FallbackVapiVoiceVoiceIdRohan, nil
	case "Lily":
		return FallbackVapiVoiceVoiceIdLily, nil
	case "Savannah":
		return FallbackVapiVoiceVoiceIdSavannah, nil
	case "Hana":
		return FallbackVapiVoiceVoiceIdHana, nil
	case "Neha":
		return FallbackVapiVoiceVoiceIdNeha, nil
	case "Cole":
		return FallbackVapiVoiceVoiceIdCole, nil
	case "Harry":
		return FallbackVapiVoiceVoiceIdHarry, nil
	case "Paige":
		return FallbackVapiVoiceVoiceIdPaige, nil
	case "Spencer":
		return FallbackVapiVoiceVoiceIdSpencer, nil
	}
	var t FallbackVapiVoiceVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackVapiVoiceVoiceId) Ptr() *FallbackVapiVoiceVoiceId {
	return &f
}

type FormatPlan struct {
	// This determines whether the chunk is formatted before being sent to the voice provider. This helps with enunciation. This includes phone numbers, emails and addresses. Default `true`.
	//
	// Usage:
	// - To rely on the voice provider's formatting logic, set this to `false`.
	//
	// If `voice.chunkPlan.enabled` is `false`, this is automatically `false` since there's no chunk to format.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the cutoff after which a number is converted to individual digits instead of being spoken as words.
	//
	// Example:
	// - If cutoff 2025, "12345" is converted to "1 2 3 4 5" while "1200" is converted to "twelve hundred".
	//
	// Usage:
	// - If your use case doesn't involve IDs like zip codes, set this to a high value.
	// - If your use case involves IDs that are shorter than 5 digits, set this to a lower value.
	//
	// @default 2025
	NumberToDigitsCutoff *float64 `json:"numberToDigitsCutoff,omitempty" url:"numberToDigitsCutoff,omitempty"`
	// These are the custom replacements you can make to the chunk before it is sent to the voice provider.
	//
	// Usage:
	// - To replace a specific word or phrase with a different word or phrase, use the `ExactReplacement` type. Eg. `{ type: 'exact', key: 'hello', value: 'hi' }`
	// - To replace a word or phrase that matches a pattern, use the `RegexReplacement` type. Eg. `{ type: 'regex', regex: '\\b[a-zA-Z]{5}\\b', value: 'hi' }`
	//
	// @default []
	Replacements []*FormatPlanReplacementsItem `json:"replacements,omitempty" url:"replacements,omitempty"`
	// List of formatters to apply. If not provided, all default formatters will be applied.
	// If provided, only the specified formatters will be applied.
	// Note: Some essential formatters like angle bracket removal will always be applied.
	// @default undefined
	FormattersEnabled []FormatPlanFormattersEnabledItem `json:"formattersEnabled,omitempty" url:"formattersEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FormatPlan) GetEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.Enabled
}

func (f *FormatPlan) GetNumberToDigitsCutoff() *float64 {
	if f == nil {
		return nil
	}
	return f.NumberToDigitsCutoff
}

func (f *FormatPlan) GetReplacements() []*FormatPlanReplacementsItem {
	if f == nil {
		return nil
	}
	return f.Replacements
}

func (f *FormatPlan) GetFormattersEnabled() []FormatPlanFormattersEnabledItem {
	if f == nil {
		return nil
	}
	return f.FormattersEnabled
}

func (f *FormatPlan) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FormatPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler FormatPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FormatPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FormatPlan) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FormatPlanFormattersEnabledItem string

const (
	FormatPlanFormattersEnabledItemMarkdown      FormatPlanFormattersEnabledItem = "markdown"
	FormatPlanFormattersEnabledItemAsterisk      FormatPlanFormattersEnabledItem = "asterisk"
	FormatPlanFormattersEnabledItemQuote         FormatPlanFormattersEnabledItem = "quote"
	FormatPlanFormattersEnabledItemDash          FormatPlanFormattersEnabledItem = "dash"
	FormatPlanFormattersEnabledItemNewline       FormatPlanFormattersEnabledItem = "newline"
	FormatPlanFormattersEnabledItemColon         FormatPlanFormattersEnabledItem = "colon"
	FormatPlanFormattersEnabledItemAcronym       FormatPlanFormattersEnabledItem = "acronym"
	FormatPlanFormattersEnabledItemDollarAmount  FormatPlanFormattersEnabledItem = "dollarAmount"
	FormatPlanFormattersEnabledItemEmail         FormatPlanFormattersEnabledItem = "email"
	FormatPlanFormattersEnabledItemDate          FormatPlanFormattersEnabledItem = "date"
	FormatPlanFormattersEnabledItemTime          FormatPlanFormattersEnabledItem = "time"
	FormatPlanFormattersEnabledItemDistance      FormatPlanFormattersEnabledItem = "distance"
	FormatPlanFormattersEnabledItemUnit          FormatPlanFormattersEnabledItem = "unit"
	FormatPlanFormattersEnabledItemPercentage    FormatPlanFormattersEnabledItem = "percentage"
	FormatPlanFormattersEnabledItemPhoneNumber   FormatPlanFormattersEnabledItem = "phoneNumber"
	FormatPlanFormattersEnabledItemNumber        FormatPlanFormattersEnabledItem = "number"
	FormatPlanFormattersEnabledItemStripAsterisk FormatPlanFormattersEnabledItem = "stripAsterisk"
)

func NewFormatPlanFormattersEnabledItemFromString(s string) (FormatPlanFormattersEnabledItem, error) {
	switch s {
	case "markdown":
		return FormatPlanFormattersEnabledItemMarkdown, nil
	case "asterisk":
		return FormatPlanFormattersEnabledItemAsterisk, nil
	case "quote":
		return FormatPlanFormattersEnabledItemQuote, nil
	case "dash":
		return FormatPlanFormattersEnabledItemDash, nil
	case "newline":
		return FormatPlanFormattersEnabledItemNewline, nil
	case "colon":
		return FormatPlanFormattersEnabledItemColon, nil
	case "acronym":
		return FormatPlanFormattersEnabledItemAcronym, nil
	case "dollarAmount":
		return FormatPlanFormattersEnabledItemDollarAmount, nil
	case "email":
		return FormatPlanFormattersEnabledItemEmail, nil
	case "date":
		return FormatPlanFormattersEnabledItemDate, nil
	case "time":
		return FormatPlanFormattersEnabledItemTime, nil
	case "distance":
		return FormatPlanFormattersEnabledItemDistance, nil
	case "unit":
		return FormatPlanFormattersEnabledItemUnit, nil
	case "percentage":
		return FormatPlanFormattersEnabledItemPercentage, nil
	case "phoneNumber":
		return FormatPlanFormattersEnabledItemPhoneNumber, nil
	case "number":
		return FormatPlanFormattersEnabledItemNumber, nil
	case "stripAsterisk":
		return FormatPlanFormattersEnabledItemStripAsterisk, nil
	}
	var t FormatPlanFormattersEnabledItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FormatPlanFormattersEnabledItem) Ptr() *FormatPlanFormattersEnabledItem {
	return &f
}

type FormatPlanReplacementsItem struct {
	ExactReplacement *ExactReplacement
	RegexReplacement *RegexReplacement

	typ string
}

func (f *FormatPlanReplacementsItem) GetExactReplacement() *ExactReplacement {
	if f == nil {
		return nil
	}
	return f.ExactReplacement
}

func (f *FormatPlanReplacementsItem) GetRegexReplacement() *RegexReplacement {
	if f == nil {
		return nil
	}
	return f.RegexReplacement
}

func (f *FormatPlanReplacementsItem) UnmarshalJSON(data []byte) error {
	valueExactReplacement := new(ExactReplacement)
	if err := json.Unmarshal(data, &valueExactReplacement); err == nil {
		f.typ = "ExactReplacement"
		f.ExactReplacement = valueExactReplacement
		return nil
	}
	valueRegexReplacement := new(RegexReplacement)
	if err := json.Unmarshal(data, &valueRegexReplacement); err == nil {
		f.typ = "RegexReplacement"
		f.RegexReplacement = valueRegexReplacement
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FormatPlanReplacementsItem) MarshalJSON() ([]byte, error) {
	if f.typ == "ExactReplacement" || f.ExactReplacement != nil {
		return json.Marshal(f.ExactReplacement)
	}
	if f.typ == "RegexReplacement" || f.RegexReplacement != nil {
		return json.Marshal(f.RegexReplacement)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FormatPlanReplacementsItemVisitor interface {
	VisitExactReplacement(*ExactReplacement) error
	VisitRegexReplacement(*RegexReplacement) error
}

func (f *FormatPlanReplacementsItem) Accept(visitor FormatPlanReplacementsItemVisitor) error {
	if f.typ == "ExactReplacement" || f.ExactReplacement != nil {
		return visitor.VisitExactReplacement(f.ExactReplacement)
	}
	if f.typ == "RegexReplacement" || f.RegexReplacement != nil {
		return visitor.VisitRegexReplacement(f.RegexReplacement)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionCallAssistantHookAction struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*FunctionCallAssistantHookActionMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "function" for Function tool.
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FunctionCallAssistantHookAction) GetAsync() *bool {
	if f == nil {
		return nil
	}
	return f.Async
}

func (f *FunctionCallAssistantHookAction) GetMessages() []*FunctionCallAssistantHookActionMessagesItem {
	if f == nil {
		return nil
	}
	return f.Messages
}

func (f *FunctionCallAssistantHookAction) GetFunction() *OpenAiFunction {
	if f == nil {
		return nil
	}
	return f.Function
}

func (f *FunctionCallAssistantHookAction) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FunctionCallAssistantHookAction) Type() string {
	return f.type_
}

func (f *FunctionCallAssistantHookAction) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionCallAssistantHookAction) UnmarshalJSON(data []byte) error {
	type embed FunctionCallAssistantHookAction
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionCallAssistantHookAction(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionCallAssistantHookAction) MarshalJSON() ([]byte, error) {
	type embed FunctionCallAssistantHookAction
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionCallAssistantHookAction) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionCallAssistantHookActionMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (f *FunctionCallAssistantHookActionMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if f == nil {
		return nil
	}
	return f.ToolMessageStart
}

func (f *FunctionCallAssistantHookActionMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if f == nil {
		return nil
	}
	return f.ToolMessageComplete
}

func (f *FunctionCallAssistantHookActionMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if f == nil {
		return nil
	}
	return f.ToolMessageFailed
}

func (f *FunctionCallAssistantHookActionMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if f == nil {
		return nil
	}
	return f.ToolMessageDelayed
}

func (f *FunctionCallAssistantHookActionMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		f.typ = "ToolMessageStart"
		f.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		f.typ = "ToolMessageComplete"
		f.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		f.typ = "ToolMessageFailed"
		f.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		f.typ = "ToolMessageDelayed"
		f.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FunctionCallAssistantHookActionMessagesItem) MarshalJSON() ([]byte, error) {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return json.Marshal(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return json.Marshal(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return json.Marshal(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return json.Marshal(f.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionCallAssistantHookActionMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (f *FunctionCallAssistantHookActionMessagesItem) Accept(visitor FunctionCallAssistantHookActionMessagesItemVisitor) error {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(f.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "function" for Function tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FunctionToolProviderDetails) GetTemplateUrl() *string {
	if f == nil {
		return nil
	}
	return f.TemplateUrl
}

func (f *FunctionToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if f == nil {
		return nil
	}
	return f.SetupInstructions
}

func (f *FunctionToolProviderDetails) Type() string {
	return f.type_
}

func (f *FunctionToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed FunctionToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed FunctionToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionToolProviderDetails) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*FunctionToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "function" for Function tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FunctionToolWithToolCall) GetAsync() *bool {
	if f == nil {
		return nil
	}
	return f.Async
}

func (f *FunctionToolWithToolCall) GetMessages() []*FunctionToolWithToolCallMessagesItem {
	if f == nil {
		return nil
	}
	return f.Messages
}

func (f *FunctionToolWithToolCall) GetToolCall() *ToolCall {
	if f == nil {
		return nil
	}
	return f.ToolCall
}

func (f *FunctionToolWithToolCall) GetFunction() *OpenAiFunction {
	if f == nil {
		return nil
	}
	return f.Function
}

func (f *FunctionToolWithToolCall) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FunctionToolWithToolCall) Type() string {
	return f.type_
}

func (f *FunctionToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed FunctionToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed FunctionToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionToolWithToolCall) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if f == nil {
		return nil
	}
	return f.ToolMessageStart
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if f == nil {
		return nil
	}
	return f.ToolMessageComplete
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if f == nil {
		return nil
	}
	return f.ToolMessageFailed
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if f == nil {
		return nil
	}
	return f.ToolMessageDelayed
}

func (f *FunctionToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		f.typ = "ToolMessageStart"
		f.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		f.typ = "ToolMessageComplete"
		f.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		f.typ = "ToolMessageFailed"
		f.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		f.typ = "ToolMessageDelayed"
		f.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FunctionToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return json.Marshal(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return json.Marshal(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return json.Marshal(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return json.Marshal(f.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (f *FunctionToolWithToolCallMessagesItem) Accept(visitor FunctionToolWithToolCallMessagesItemVisitor) error {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(f.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type GcpCredential struct {
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GcpCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GcpCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GcpCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GcpCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GcpCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GcpCredential) GetGcpKey() *GcpKey {
	if g == nil {
		return nil
	}
	return g.GcpKey
}

func (g *GcpCredential) GetBucketPlan() *BucketPlan {
	if g == nil {
		return nil
	}
	return g.BucketPlan
}

func (g *GcpCredential) Provider() string {
	return g.provider
}

func (g *GcpCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GcpCredential) UnmarshalJSON(data []byte) error {
	type embed GcpCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GcpCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gcp", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GcpCredential) MarshalJSON() ([]byte, error) {
	type embed GcpCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "gcp",
	}
	return json.Marshal(marshaler)
}

func (g *GcpCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GcpKey struct {
	// This is the type of the key. Most likely, this is "service_account".
	Type string `json:"type" url:"type"`
	// This is the ID of the Google Cloud project associated with this key.
	ProjectId string `json:"projectId" url:"projectId"`
	// This is the unique identifier for the private key.
	PrivateKeyId string `json:"privateKeyId" url:"privateKeyId"`
	// This is the private key in PEM format.
	//
	// Note: This is not returned in the API.
	PrivateKey string `json:"privateKey" url:"privateKey"`
	// This is the email address associated with the service account.
	ClientEmail string `json:"clientEmail" url:"clientEmail"`
	// This is the unique identifier for the client.
	ClientId string `json:"clientId" url:"clientId"`
	// This is the URI for the auth provider's authorization endpoint.
	AuthUri string `json:"authUri" url:"authUri"`
	// This is the URI for the auth provider's token endpoint.
	TokenUri string `json:"tokenUri" url:"tokenUri"`
	// This is the URL of the public x509 certificate for the auth provider.
	AuthProviderX509CertUrl string `json:"authProviderX509CertUrl" url:"authProviderX509CertUrl"`
	// This is the URL of the public x509 certificate for the client.
	ClientX509CertUrl string `json:"clientX509CertUrl" url:"clientX509CertUrl"`
	// This is the domain associated with the universe this service account belongs to.
	UniverseDomain string `json:"universeDomain" url:"universeDomain"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GcpKey) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GcpKey) GetProjectId() string {
	if g == nil {
		return ""
	}
	return g.ProjectId
}

func (g *GcpKey) GetPrivateKeyId() string {
	if g == nil {
		return ""
	}
	return g.PrivateKeyId
}

func (g *GcpKey) GetPrivateKey() string {
	if g == nil {
		return ""
	}
	return g.PrivateKey
}

func (g *GcpKey) GetClientEmail() string {
	if g == nil {
		return ""
	}
	return g.ClientEmail
}

func (g *GcpKey) GetClientId() string {
	if g == nil {
		return ""
	}
	return g.ClientId
}

func (g *GcpKey) GetAuthUri() string {
	if g == nil {
		return ""
	}
	return g.AuthUri
}

func (g *GcpKey) GetTokenUri() string {
	if g == nil {
		return ""
	}
	return g.TokenUri
}

func (g *GcpKey) GetAuthProviderX509CertUrl() string {
	if g == nil {
		return ""
	}
	return g.AuthProviderX509CertUrl
}

func (g *GcpKey) GetClientX509CertUrl() string {
	if g == nil {
		return ""
	}
	return g.ClientX509CertUrl
}

func (g *GcpKey) GetUniverseDomain() string {
	if g == nil {
		return ""
	}
	return g.UniverseDomain
}

func (g *GcpKey) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GcpKey) UnmarshalJSON(data []byte) error {
	type unmarshaler GcpKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GcpKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GcpKey) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeminiMultimodalLivePrebuiltVoiceConfig struct {
	VoiceName GeminiMultimodalLivePrebuiltVoiceConfigVoiceName `json:"voiceName" url:"voiceName"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) GetVoiceName() GeminiMultimodalLivePrebuiltVoiceConfigVoiceName {
	if g == nil {
		return ""
	}
	return g.VoiceName
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeminiMultimodalLivePrebuiltVoiceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeminiMultimodalLivePrebuiltVoiceConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeminiMultimodalLivePrebuiltVoiceConfigVoiceName string

const (
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNamePuck   GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Puck"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameCharon GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Charon"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameKore   GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Kore"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameFenrir GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Fenrir"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameAoede  GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Aoede"
)

func NewGeminiMultimodalLivePrebuiltVoiceConfigVoiceNameFromString(s string) (GeminiMultimodalLivePrebuiltVoiceConfigVoiceName, error) {
	switch s {
	case "Puck":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNamePuck, nil
	case "Charon":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameCharon, nil
	case "Kore":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameKore, nil
	case "Fenrir":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameFenrir, nil
	case "Aoede":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameAoede, nil
	}
	var t GeminiMultimodalLivePrebuiltVoiceConfigVoiceName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GeminiMultimodalLivePrebuiltVoiceConfigVoiceName) Ptr() *GeminiMultimodalLivePrebuiltVoiceConfigVoiceName {
	return &g
}

type GeminiMultimodalLiveSpeechConfig struct {
	VoiceConfig *GeminiMultimodalLiveVoiceConfig `json:"voiceConfig,omitempty" url:"voiceConfig,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeminiMultimodalLiveSpeechConfig) GetVoiceConfig() *GeminiMultimodalLiveVoiceConfig {
	if g == nil {
		return nil
	}
	return g.VoiceConfig
}

func (g *GeminiMultimodalLiveSpeechConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeminiMultimodalLiveSpeechConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeminiMultimodalLiveSpeechConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeminiMultimodalLiveSpeechConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeminiMultimodalLiveSpeechConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeminiMultimodalLiveVoiceConfig struct {
	PrebuiltVoiceConfig *GeminiMultimodalLivePrebuiltVoiceConfig `json:"prebuiltVoiceConfig,omitempty" url:"prebuiltVoiceConfig,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeminiMultimodalLiveVoiceConfig) GetPrebuiltVoiceConfig() *GeminiMultimodalLivePrebuiltVoiceConfig {
	if g == nil {
		return nil
	}
	return g.PrebuiltVoiceConfig
}

func (g *GeminiMultimodalLiveVoiceConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeminiMultimodalLiveVoiceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeminiMultimodalLiveVoiceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeminiMultimodalLiveVoiceConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeminiMultimodalLiveVoiceConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "ghl" for GHL tool.
	WorkflowId      *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	WorkflowName    *string `json:"workflowName,omitempty" url:"workflowName,omitempty"`
	WebhookHookId   *string `json:"webhookHookId,omitempty" url:"webhookHookId,omitempty"`
	WebhookHookName *string `json:"webhookHookName,omitempty" url:"webhookHookName,omitempty"`
	LocationId      *string `json:"locationId,omitempty" url:"locationId,omitempty"`
	type_           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GhlToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GhlToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GhlToolProviderDetails) GetWorkflowId() *string {
	if g == nil {
		return nil
	}
	return g.WorkflowId
}

func (g *GhlToolProviderDetails) GetWorkflowName() *string {
	if g == nil {
		return nil
	}
	return g.WorkflowName
}

func (g *GhlToolProviderDetails) GetWebhookHookId() *string {
	if g == nil {
		return nil
	}
	return g.WebhookHookId
}

func (g *GhlToolProviderDetails) GetWebhookHookName() *string {
	if g == nil {
		return nil
	}
	return g.WebhookHookName
}

func (g *GhlToolProviderDetails) GetLocationId() *string {
	if g == nil {
		return nil
	}
	return g.LocationId
}

func (g *GhlToolProviderDetails) Type() string {
	return g.type_
}

func (g *GhlToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GhlToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GhlToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GhlToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "ghl" for GHL tool.
	ToolCall *ToolCall        `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	Metadata *GhlToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GhlToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GhlToolWithToolCall) GetMessages() []*GhlToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GhlToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GhlToolWithToolCall) GetMetadata() *GhlToolMetadata {
	if g == nil {
		return nil
	}
	return g.Metadata
}

func (g *GhlToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GhlToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GhlToolWithToolCall) Type() string {
	return g.type_
}

func (g *GhlToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GhlToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GhlToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GhlToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GhlToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GhlToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GhlToolWithToolCallMessagesItem) Accept(visitor GhlToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GladiaCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GladiaCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GladiaCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GladiaCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GladiaCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GladiaCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GladiaCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GladiaCredential) Provider() string {
	return g.provider
}

func (g *GladiaCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GladiaCredential) UnmarshalJSON(data []byte) error {
	type embed GladiaCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GladiaCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gladia", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GladiaCredential) MarshalJSON() ([]byte, error) {
	type embed GladiaCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "gladia",
	}
	return json.Marshal(marshaler)
}

func (g *GladiaCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GladiaTranscriber struct {
	// This is the transcription provider that will be used.
	Model             *GladiaTranscriberModel             `json:"model,omitempty" url:"model,omitempty"`
	LanguageBehaviour *GladiaTranscriberLanguageBehaviour `json:"languageBehaviour,omitempty" url:"languageBehaviour,omitempty"`
	// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
	Language *GladiaTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// Provides a custom vocabulary to the model to improve accuracy of transcribing context specific words, technical terms, names, etc. If empty, this argument is ignored.
	// ⚠️ Warning ⚠️: Please be aware that the transcription_hint field has a character limit of 600. If you provide a transcription_hint longer than 600 characters, it will be automatically truncated to meet this limit.
	TranscriptionHint *string `json:"transcriptionHint,omitempty" url:"transcriptionHint,omitempty"`
	// If prosody is true, you will get a transcription that can contain prosodies i.e. (laugh) (giggles) (malefic laugh) (toss) (music)… Default value is false.
	Prosody *bool `json:"prosody,omitempty" url:"prosody,omitempty"`
	// If true, audio will be pre-processed to improve accuracy but latency will increase. Default value is false.
	AudioEnhancer *bool `json:"audioEnhancer,omitempty" url:"audioEnhancer,omitempty"`
	// Transcripts below this confidence threshold will be discarded.
	//
	// @default 0.4
	ConfidenceThreshold *float64 `json:"confidenceThreshold,omitempty" url:"confidenceThreshold,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GladiaTranscriber) GetModel() *GladiaTranscriberModel {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GladiaTranscriber) GetLanguageBehaviour() *GladiaTranscriberLanguageBehaviour {
	if g == nil {
		return nil
	}
	return g.LanguageBehaviour
}

func (g *GladiaTranscriber) GetLanguage() *GladiaTranscriberLanguage {
	if g == nil {
		return nil
	}
	return g.Language
}

func (g *GladiaTranscriber) GetTranscriptionHint() *string {
	if g == nil {
		return nil
	}
	return g.TranscriptionHint
}

func (g *GladiaTranscriber) GetProsody() *bool {
	if g == nil {
		return nil
	}
	return g.Prosody
}

func (g *GladiaTranscriber) GetAudioEnhancer() *bool {
	if g == nil {
		return nil
	}
	return g.AudioEnhancer
}

func (g *GladiaTranscriber) GetConfidenceThreshold() *float64 {
	if g == nil {
		return nil
	}
	return g.ConfidenceThreshold
}

func (g *GladiaTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if g == nil {
		return nil
	}
	return g.FallbackPlan
}

func (g *GladiaTranscriber) Provider() string {
	return g.provider
}

func (g *GladiaTranscriber) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GladiaTranscriber) UnmarshalJSON(data []byte) error {
	type embed GladiaTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GladiaTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gladia", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GladiaTranscriber) MarshalJSON() ([]byte, error) {
	type embed GladiaTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (g *GladiaTranscriber) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
type GladiaTranscriberLanguage string

const (
	GladiaTranscriberLanguageAf  GladiaTranscriberLanguage = "af"
	GladiaTranscriberLanguageSq  GladiaTranscriberLanguage = "sq"
	GladiaTranscriberLanguageAm  GladiaTranscriberLanguage = "am"
	GladiaTranscriberLanguageAr  GladiaTranscriberLanguage = "ar"
	GladiaTranscriberLanguageHy  GladiaTranscriberLanguage = "hy"
	GladiaTranscriberLanguageAs  GladiaTranscriberLanguage = "as"
	GladiaTranscriberLanguageAz  GladiaTranscriberLanguage = "az"
	GladiaTranscriberLanguageBa  GladiaTranscriberLanguage = "ba"
	GladiaTranscriberLanguageEu  GladiaTranscriberLanguage = "eu"
	GladiaTranscriberLanguageBe  GladiaTranscriberLanguage = "be"
	GladiaTranscriberLanguageBn  GladiaTranscriberLanguage = "bn"
	GladiaTranscriberLanguageBs  GladiaTranscriberLanguage = "bs"
	GladiaTranscriberLanguageBr  GladiaTranscriberLanguage = "br"
	GladiaTranscriberLanguageBg  GladiaTranscriberLanguage = "bg"
	GladiaTranscriberLanguageCa  GladiaTranscriberLanguage = "ca"
	GladiaTranscriberLanguageZh  GladiaTranscriberLanguage = "zh"
	GladiaTranscriberLanguageHr  GladiaTranscriberLanguage = "hr"
	GladiaTranscriberLanguageCs  GladiaTranscriberLanguage = "cs"
	GladiaTranscriberLanguageDa  GladiaTranscriberLanguage = "da"
	GladiaTranscriberLanguageNl  GladiaTranscriberLanguage = "nl"
	GladiaTranscriberLanguageEn  GladiaTranscriberLanguage = "en"
	GladiaTranscriberLanguageEt  GladiaTranscriberLanguage = "et"
	GladiaTranscriberLanguageFo  GladiaTranscriberLanguage = "fo"
	GladiaTranscriberLanguageFi  GladiaTranscriberLanguage = "fi"
	GladiaTranscriberLanguageFr  GladiaTranscriberLanguage = "fr"
	GladiaTranscriberLanguageGl  GladiaTranscriberLanguage = "gl"
	GladiaTranscriberLanguageKa  GladiaTranscriberLanguage = "ka"
	GladiaTranscriberLanguageDe  GladiaTranscriberLanguage = "de"
	GladiaTranscriberLanguageEl  GladiaTranscriberLanguage = "el"
	GladiaTranscriberLanguageGu  GladiaTranscriberLanguage = "gu"
	GladiaTranscriberLanguageHt  GladiaTranscriberLanguage = "ht"
	GladiaTranscriberLanguageHa  GladiaTranscriberLanguage = "ha"
	GladiaTranscriberLanguageHaw GladiaTranscriberLanguage = "haw"
	GladiaTranscriberLanguageHe  GladiaTranscriberLanguage = "he"
	GladiaTranscriberLanguageHi  GladiaTranscriberLanguage = "hi"
	GladiaTranscriberLanguageHu  GladiaTranscriberLanguage = "hu"
	GladiaTranscriberLanguageIs  GladiaTranscriberLanguage = "is"
	GladiaTranscriberLanguageId  GladiaTranscriberLanguage = "id"
	GladiaTranscriberLanguageIt  GladiaTranscriberLanguage = "it"
	GladiaTranscriberLanguageJa  GladiaTranscriberLanguage = "ja"
	GladiaTranscriberLanguageJv  GladiaTranscriberLanguage = "jv"
	GladiaTranscriberLanguageKn  GladiaTranscriberLanguage = "kn"
	GladiaTranscriberLanguageKk  GladiaTranscriberLanguage = "kk"
	GladiaTranscriberLanguageKm  GladiaTranscriberLanguage = "km"
	GladiaTranscriberLanguageKo  GladiaTranscriberLanguage = "ko"
	GladiaTranscriberLanguageLo  GladiaTranscriberLanguage = "lo"
	GladiaTranscriberLanguageLa  GladiaTranscriberLanguage = "la"
	GladiaTranscriberLanguageLv  GladiaTranscriberLanguage = "lv"
	GladiaTranscriberLanguageLn  GladiaTranscriberLanguage = "ln"
	GladiaTranscriberLanguageLt  GladiaTranscriberLanguage = "lt"
	GladiaTranscriberLanguageLb  GladiaTranscriberLanguage = "lb"
	GladiaTranscriberLanguageMk  GladiaTranscriberLanguage = "mk"
	GladiaTranscriberLanguageMg  GladiaTranscriberLanguage = "mg"
	GladiaTranscriberLanguageMs  GladiaTranscriberLanguage = "ms"
	GladiaTranscriberLanguageMl  GladiaTranscriberLanguage = "ml"
	GladiaTranscriberLanguageMt  GladiaTranscriberLanguage = "mt"
	GladiaTranscriberLanguageMi  GladiaTranscriberLanguage = "mi"
	GladiaTranscriberLanguageMr  GladiaTranscriberLanguage = "mr"
	GladiaTranscriberLanguageMn  GladiaTranscriberLanguage = "mn"
	GladiaTranscriberLanguageMy  GladiaTranscriberLanguage = "my"
	GladiaTranscriberLanguageNe  GladiaTranscriberLanguage = "ne"
	GladiaTranscriberLanguageNo  GladiaTranscriberLanguage = "no"
	GladiaTranscriberLanguageNn  GladiaTranscriberLanguage = "nn"
	GladiaTranscriberLanguageOc  GladiaTranscriberLanguage = "oc"
	GladiaTranscriberLanguagePs  GladiaTranscriberLanguage = "ps"
	GladiaTranscriberLanguageFa  GladiaTranscriberLanguage = "fa"
	GladiaTranscriberLanguagePl  GladiaTranscriberLanguage = "pl"
	GladiaTranscriberLanguagePt  GladiaTranscriberLanguage = "pt"
	GladiaTranscriberLanguagePa  GladiaTranscriberLanguage = "pa"
	GladiaTranscriberLanguageRo  GladiaTranscriberLanguage = "ro"
	GladiaTranscriberLanguageRu  GladiaTranscriberLanguage = "ru"
	GladiaTranscriberLanguageSa  GladiaTranscriberLanguage = "sa"
	GladiaTranscriberLanguageSr  GladiaTranscriberLanguage = "sr"
	GladiaTranscriberLanguageSn  GladiaTranscriberLanguage = "sn"
	GladiaTranscriberLanguageSd  GladiaTranscriberLanguage = "sd"
	GladiaTranscriberLanguageSi  GladiaTranscriberLanguage = "si"
	GladiaTranscriberLanguageSk  GladiaTranscriberLanguage = "sk"
	GladiaTranscriberLanguageSl  GladiaTranscriberLanguage = "sl"
	GladiaTranscriberLanguageSo  GladiaTranscriberLanguage = "so"
	GladiaTranscriberLanguageEs  GladiaTranscriberLanguage = "es"
	GladiaTranscriberLanguageSu  GladiaTranscriberLanguage = "su"
	GladiaTranscriberLanguageSw  GladiaTranscriberLanguage = "sw"
	GladiaTranscriberLanguageSv  GladiaTranscriberLanguage = "sv"
	GladiaTranscriberLanguageTl  GladiaTranscriberLanguage = "tl"
	GladiaTranscriberLanguageTg  GladiaTranscriberLanguage = "tg"
	GladiaTranscriberLanguageTa  GladiaTranscriberLanguage = "ta"
	GladiaTranscriberLanguageTt  GladiaTranscriberLanguage = "tt"
	GladiaTranscriberLanguageTe  GladiaTranscriberLanguage = "te"
	GladiaTranscriberLanguageTh  GladiaTranscriberLanguage = "th"
	GladiaTranscriberLanguageBo  GladiaTranscriberLanguage = "bo"
	GladiaTranscriberLanguageTr  GladiaTranscriberLanguage = "tr"
	GladiaTranscriberLanguageTk  GladiaTranscriberLanguage = "tk"
	GladiaTranscriberLanguageUk  GladiaTranscriberLanguage = "uk"
	GladiaTranscriberLanguageUr  GladiaTranscriberLanguage = "ur"
	GladiaTranscriberLanguageUz  GladiaTranscriberLanguage = "uz"
	GladiaTranscriberLanguageVi  GladiaTranscriberLanguage = "vi"
	GladiaTranscriberLanguageCy  GladiaTranscriberLanguage = "cy"
	GladiaTranscriberLanguageYi  GladiaTranscriberLanguage = "yi"
	GladiaTranscriberLanguageYo  GladiaTranscriberLanguage = "yo"
)

func NewGladiaTranscriberLanguageFromString(s string) (GladiaTranscriberLanguage, error) {
	switch s {
	case "af":
		return GladiaTranscriberLanguageAf, nil
	case "sq":
		return GladiaTranscriberLanguageSq, nil
	case "am":
		return GladiaTranscriberLanguageAm, nil
	case "ar":
		return GladiaTranscriberLanguageAr, nil
	case "hy":
		return GladiaTranscriberLanguageHy, nil
	case "as":
		return GladiaTranscriberLanguageAs, nil
	case "az":
		return GladiaTranscriberLanguageAz, nil
	case "ba":
		return GladiaTranscriberLanguageBa, nil
	case "eu":
		return GladiaTranscriberLanguageEu, nil
	case "be":
		return GladiaTranscriberLanguageBe, nil
	case "bn":
		return GladiaTranscriberLanguageBn, nil
	case "bs":
		return GladiaTranscriberLanguageBs, nil
	case "br":
		return GladiaTranscriberLanguageBr, nil
	case "bg":
		return GladiaTranscriberLanguageBg, nil
	case "ca":
		return GladiaTranscriberLanguageCa, nil
	case "zh":
		return GladiaTranscriberLanguageZh, nil
	case "hr":
		return GladiaTranscriberLanguageHr, nil
	case "cs":
		return GladiaTranscriberLanguageCs, nil
	case "da":
		return GladiaTranscriberLanguageDa, nil
	case "nl":
		return GladiaTranscriberLanguageNl, nil
	case "en":
		return GladiaTranscriberLanguageEn, nil
	case "et":
		return GladiaTranscriberLanguageEt, nil
	case "fo":
		return GladiaTranscriberLanguageFo, nil
	case "fi":
		return GladiaTranscriberLanguageFi, nil
	case "fr":
		return GladiaTranscriberLanguageFr, nil
	case "gl":
		return GladiaTranscriberLanguageGl, nil
	case "ka":
		return GladiaTranscriberLanguageKa, nil
	case "de":
		return GladiaTranscriberLanguageDe, nil
	case "el":
		return GladiaTranscriberLanguageEl, nil
	case "gu":
		return GladiaTranscriberLanguageGu, nil
	case "ht":
		return GladiaTranscriberLanguageHt, nil
	case "ha":
		return GladiaTranscriberLanguageHa, nil
	case "haw":
		return GladiaTranscriberLanguageHaw, nil
	case "he":
		return GladiaTranscriberLanguageHe, nil
	case "hi":
		return GladiaTranscriberLanguageHi, nil
	case "hu":
		return GladiaTranscriberLanguageHu, nil
	case "is":
		return GladiaTranscriberLanguageIs, nil
	case "id":
		return GladiaTranscriberLanguageId, nil
	case "it":
		return GladiaTranscriberLanguageIt, nil
	case "ja":
		return GladiaTranscriberLanguageJa, nil
	case "jv":
		return GladiaTranscriberLanguageJv, nil
	case "kn":
		return GladiaTranscriberLanguageKn, nil
	case "kk":
		return GladiaTranscriberLanguageKk, nil
	case "km":
		return GladiaTranscriberLanguageKm, nil
	case "ko":
		return GladiaTranscriberLanguageKo, nil
	case "lo":
		return GladiaTranscriberLanguageLo, nil
	case "la":
		return GladiaTranscriberLanguageLa, nil
	case "lv":
		return GladiaTranscriberLanguageLv, nil
	case "ln":
		return GladiaTranscriberLanguageLn, nil
	case "lt":
		return GladiaTranscriberLanguageLt, nil
	case "lb":
		return GladiaTranscriberLanguageLb, nil
	case "mk":
		return GladiaTranscriberLanguageMk, nil
	case "mg":
		return GladiaTranscriberLanguageMg, nil
	case "ms":
		return GladiaTranscriberLanguageMs, nil
	case "ml":
		return GladiaTranscriberLanguageMl, nil
	case "mt":
		return GladiaTranscriberLanguageMt, nil
	case "mi":
		return GladiaTranscriberLanguageMi, nil
	case "mr":
		return GladiaTranscriberLanguageMr, nil
	case "mn":
		return GladiaTranscriberLanguageMn, nil
	case "my":
		return GladiaTranscriberLanguageMy, nil
	case "ne":
		return GladiaTranscriberLanguageNe, nil
	case "no":
		return GladiaTranscriberLanguageNo, nil
	case "nn":
		return GladiaTranscriberLanguageNn, nil
	case "oc":
		return GladiaTranscriberLanguageOc, nil
	case "ps":
		return GladiaTranscriberLanguagePs, nil
	case "fa":
		return GladiaTranscriberLanguageFa, nil
	case "pl":
		return GladiaTranscriberLanguagePl, nil
	case "pt":
		return GladiaTranscriberLanguagePt, nil
	case "pa":
		return GladiaTranscriberLanguagePa, nil
	case "ro":
		return GladiaTranscriberLanguageRo, nil
	case "ru":
		return GladiaTranscriberLanguageRu, nil
	case "sa":
		return GladiaTranscriberLanguageSa, nil
	case "sr":
		return GladiaTranscriberLanguageSr, nil
	case "sn":
		return GladiaTranscriberLanguageSn, nil
	case "sd":
		return GladiaTranscriberLanguageSd, nil
	case "si":
		return GladiaTranscriberLanguageSi, nil
	case "sk":
		return GladiaTranscriberLanguageSk, nil
	case "sl":
		return GladiaTranscriberLanguageSl, nil
	case "so":
		return GladiaTranscriberLanguageSo, nil
	case "es":
		return GladiaTranscriberLanguageEs, nil
	case "su":
		return GladiaTranscriberLanguageSu, nil
	case "sw":
		return GladiaTranscriberLanguageSw, nil
	case "sv":
		return GladiaTranscriberLanguageSv, nil
	case "tl":
		return GladiaTranscriberLanguageTl, nil
	case "tg":
		return GladiaTranscriberLanguageTg, nil
	case "ta":
		return GladiaTranscriberLanguageTa, nil
	case "tt":
		return GladiaTranscriberLanguageTt, nil
	case "te":
		return GladiaTranscriberLanguageTe, nil
	case "th":
		return GladiaTranscriberLanguageTh, nil
	case "bo":
		return GladiaTranscriberLanguageBo, nil
	case "tr":
		return GladiaTranscriberLanguageTr, nil
	case "tk":
		return GladiaTranscriberLanguageTk, nil
	case "uk":
		return GladiaTranscriberLanguageUk, nil
	case "ur":
		return GladiaTranscriberLanguageUr, nil
	case "uz":
		return GladiaTranscriberLanguageUz, nil
	case "vi":
		return GladiaTranscriberLanguageVi, nil
	case "cy":
		return GladiaTranscriberLanguageCy, nil
	case "yi":
		return GladiaTranscriberLanguageYi, nil
	case "yo":
		return GladiaTranscriberLanguageYo, nil
	}
	var t GladiaTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberLanguage) Ptr() *GladiaTranscriberLanguage {
	return &g
}

type GladiaTranscriberLanguageBehaviour string

const (
	GladiaTranscriberLanguageBehaviourManual                     GladiaTranscriberLanguageBehaviour = "manual"
	GladiaTranscriberLanguageBehaviourAutomaticSingleLanguage    GladiaTranscriberLanguageBehaviour = "automatic single language"
	GladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages GladiaTranscriberLanguageBehaviour = "automatic multiple languages"
)

func NewGladiaTranscriberLanguageBehaviourFromString(s string) (GladiaTranscriberLanguageBehaviour, error) {
	switch s {
	case "manual":
		return GladiaTranscriberLanguageBehaviourManual, nil
	case "automatic single language":
		return GladiaTranscriberLanguageBehaviourAutomaticSingleLanguage, nil
	case "automatic multiple languages":
		return GladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages, nil
	}
	var t GladiaTranscriberLanguageBehaviour
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberLanguageBehaviour) Ptr() *GladiaTranscriberLanguageBehaviour {
	return &g
}

type GladiaTranscriberModel string

const (
	GladiaTranscriberModelFast     GladiaTranscriberModel = "fast"
	GladiaTranscriberModelAccurate GladiaTranscriberModel = "accurate"
)

func NewGladiaTranscriberModelFromString(s string) (GladiaTranscriberModel, error) {
	switch s {
	case "fast":
		return GladiaTranscriberModelFast, nil
	case "accurate":
		return GladiaTranscriberModelAccurate, nil
	}
	var t GladiaTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberModel) Ptr() *GladiaTranscriberModel {
	return &g
}

type GlobalNodePlan struct {
	// This is the flag to determine if this node is a global node
	//
	// @default false
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the condition that will be checked to determine if the global node should be executed.
	//
	// @default ”
	EnterCondition *string `json:"enterCondition,omitempty" url:"enterCondition,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GlobalNodePlan) GetEnabled() *bool {
	if g == nil {
		return nil
	}
	return g.Enabled
}

func (g *GlobalNodePlan) GetEnterCondition() *string {
	if g == nil {
		return nil
	}
	return g.EnterCondition
}

func (g *GlobalNodePlan) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GlobalNodePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler GlobalNodePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GlobalNodePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GlobalNodePlan) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarAvailabilityToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "gohighlevel.calendar.availability.check" for GoHighLevel Calendar availability check tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarAvailabilityToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GoHighLevelCalendarAvailabilityToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GoHighLevelCalendarAvailabilityToolProviderDetails) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarAvailabilityToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarAvailabilityToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarAvailabilityToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarAvailabilityToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.availability.check", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarAvailabilityToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarAvailabilityToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.calendar.availability.check",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCalendarAvailabilityToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarAvailabilityToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "gohighlevel.calendar.availability.check" for GoHighLevel Calendar availability check tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) GetMessages() []*GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarAvailabilityToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarAvailabilityToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.availability.check", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarAvailabilityToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.calendar.availability.check",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItem) Accept(visitor GoHighLevelCalendarAvailabilityToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarEventCreateToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "gohighlevel.calendar.event.create" for GoHighLevel Calendar event create tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarEventCreateToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GoHighLevelCalendarEventCreateToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GoHighLevelCalendarEventCreateToolProviderDetails) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarEventCreateToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarEventCreateToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarEventCreateToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarEventCreateToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarEventCreateToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarEventCreateToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCalendarEventCreateToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarEventCreateToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "gohighlevel.calendar.event.create" for GoHighLevel Calendar event create tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) GetMessages() []*GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarEventCreateToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarEventCreateToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarEventCreateToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarEventCreateToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelCalendarEventCreateToolWithToolCallMessagesItem) Accept(visitor GoHighLevelCalendarEventCreateToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactCreateToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "gohighlevel.contact.create" for GoHighLevel contact create tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactCreateToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GoHighLevelContactCreateToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GoHighLevelContactCreateToolProviderDetails) Type() string {
	return g.type_
}

func (g *GoHighLevelContactCreateToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactCreateToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactCreateToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactCreateToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.contact.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactCreateToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactCreateToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.contact.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelContactCreateToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactCreateToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelContactCreateToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "gohighlevel.contact.create" for GoHighLevel contact create tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactCreateToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelContactCreateToolWithToolCall) GetMessages() []*GoHighLevelContactCreateToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelContactCreateToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GoHighLevelContactCreateToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelContactCreateToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelContactCreateToolWithToolCall) Type() string {
	return g.type_
}

func (g *GoHighLevelContactCreateToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactCreateToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactCreateToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactCreateToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.contact.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactCreateToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactCreateToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.contact.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelContactCreateToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactCreateToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelContactCreateToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelContactCreateToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelContactCreateToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelContactCreateToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelContactCreateToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelContactCreateToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactCreateToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelContactCreateToolWithToolCallMessagesItem) Accept(visitor GoHighLevelContactCreateToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactGetToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "gohighlevel.contact.get" for GoHighLevel contact get tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactGetToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GoHighLevelContactGetToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GoHighLevelContactGetToolProviderDetails) Type() string {
	return g.type_
}

func (g *GoHighLevelContactGetToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactGetToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactGetToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactGetToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.contact.get" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.get", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactGetToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactGetToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.contact.get",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelContactGetToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactGetToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelContactGetToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "gohighlevel.contact.get" for GoHighLevel contact get tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactGetToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelContactGetToolWithToolCall) GetMessages() []*GoHighLevelContactGetToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelContactGetToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GoHighLevelContactGetToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelContactGetToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelContactGetToolWithToolCall) Type() string {
	return g.type_
}

func (g *GoHighLevelContactGetToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactGetToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactGetToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactGetToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "gohighlevel.contact.get" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.get", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactGetToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactGetToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gohighlevel.contact.get",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelContactGetToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactGetToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelContactGetToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelContactGetToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelContactGetToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelContactGetToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelContactGetToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelContactGetToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactGetToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelContactGetToolWithToolCallMessagesItem) Accept(visitor GoHighLevelContactGetToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GoHighLevelCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoHighLevelCredential) Provider() string {
	return g.provider
}

func (g *GoHighLevelCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCredential) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gohighlevel" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCredential) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "gohighlevel",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelMcpCredential struct {
	// This is the authentication session for the credential.
	AuthenticationSession *Oauth2AuthenticationSession `json:"authenticationSession,omitempty" url:"authenticationSession,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelMcpCredential) GetAuthenticationSession() *Oauth2AuthenticationSession {
	if g == nil {
		return nil
	}
	return g.AuthenticationSession
}

func (g *GoHighLevelMcpCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelMcpCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelMcpCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelMcpCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelMcpCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoHighLevelMcpCredential) Provider() string {
	return g.provider
}

func (g *GoHighLevelMcpCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelMcpCredential) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelMcpCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelMcpCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "ghl.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl.oauth2-authorization", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelMcpCredential) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelMcpCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "ghl.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelMcpCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarCreateEventToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "google.calendar.event.create" for Google Calendar tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarCreateEventToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GoogleCalendarCreateEventToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GoogleCalendarCreateEventToolProviderDetails) Type() string {
	return g.type_
}

func (g *GoogleCalendarCreateEventToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarCreateEventToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarCreateEventToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarCreateEventToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "google.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarCreateEventToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarCreateEventToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "google.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCalendarCreateEventToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarCreateEventToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleCalendarCreateEventToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "google.calendar.event.create" for Google Calendar tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarCreateEventToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoogleCalendarCreateEventToolWithToolCall) GetMessages() []*GoogleCalendarCreateEventToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleCalendarCreateEventToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GoogleCalendarCreateEventToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoogleCalendarCreateEventToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoogleCalendarCreateEventToolWithToolCall) Type() string {
	return g.type_
}

func (g *GoogleCalendarCreateEventToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarCreateEventToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarCreateEventToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarCreateEventToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "google.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarCreateEventToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarCreateEventToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "google.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCalendarCreateEventToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarCreateEventToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleCalendarCreateEventToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleCalendarCreateEventToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleCalendarCreateEventToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleCalendarCreateEventToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleCalendarCreateEventToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleCalendarCreateEventToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarCreateEventToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleCalendarCreateEventToolWithToolCallMessagesItem) Accept(visitor GoogleCalendarCreateEventToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarOAuth2AuthorizationCredential struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId string `json:"authorizationId" url:"authorizationId"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) GetAuthorizationId() string {
	if g == nil {
		return ""
	}
	return g.AuthorizationId
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) Provider() string {
	return g.provider
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarOAuth2AuthorizationCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarOAuth2AuthorizationCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "google.calendar.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.oauth2-authorization", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarOAuth2AuthorizationCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "google.calendar.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCalendarOAuth2AuthorizationCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarOAuth2ClientCredential struct {
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarOAuth2ClientCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCalendarOAuth2ClientCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCalendarOAuth2ClientCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCalendarOAuth2ClientCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCalendarOAuth2ClientCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoogleCalendarOAuth2ClientCredential) Provider() string {
	return g.provider
}

func (g *GoogleCalendarOAuth2ClientCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarOAuth2ClientCredential) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarOAuth2ClientCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarOAuth2ClientCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "google.calendar.oauth2-client" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.oauth2-client", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarOAuth2ClientCredential) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarOAuth2ClientCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "google.calendar.oauth2-client",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCalendarOAuth2ClientCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCredential struct {
	// This is the key for Gemini in Google AI Studio. Get it from here: https://aistudio.google.com/app/apikey
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GoogleCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoogleCredential) Provider() string {
	return g.provider
}

func (g *GoogleCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCredential) UnmarshalJSON(data []byte) error {
	type embed GoogleCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCredential) MarshalJSON() ([]byte, error) {
	type embed GoogleCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "google",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*GoogleModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the Google model that will be used.
	Model GoogleModelModel `json:"model" url:"model"`
	// This is the session configuration for the Gemini Flash 2.0 Multimodal Live API.
	// Only applicable if the model `gemini-2.0-flash-realtime-exp` is selected.
	RealtimeConfig *GoogleRealtimeConfig `json:"realtimeConfig,omitempty" url:"realtimeConfig,omitempty"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleModel) GetMessages() []*OpenAiMessage {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleModel) GetTools() []*GoogleModelToolsItem {
	if g == nil {
		return nil
	}
	return g.Tools
}

func (g *GoogleModel) GetToolIds() []string {
	if g == nil {
		return nil
	}
	return g.ToolIds
}

func (g *GoogleModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if g == nil {
		return nil
	}
	return g.KnowledgeBase
}

func (g *GoogleModel) GetKnowledgeBaseId() *string {
	if g == nil {
		return nil
	}
	return g.KnowledgeBaseId
}

func (g *GoogleModel) GetModel() GoogleModelModel {
	if g == nil {
		return ""
	}
	return g.Model
}

func (g *GoogleModel) GetRealtimeConfig() *GoogleRealtimeConfig {
	if g == nil {
		return nil
	}
	return g.RealtimeConfig
}

func (g *GoogleModel) GetTemperature() *float64 {
	if g == nil {
		return nil
	}
	return g.Temperature
}

func (g *GoogleModel) GetMaxTokens() *float64 {
	if g == nil {
		return nil
	}
	return g.MaxTokens
}

func (g *GoogleModel) GetEmotionRecognitionEnabled() *bool {
	if g == nil {
		return nil
	}
	return g.EmotionRecognitionEnabled
}

func (g *GoogleModel) GetNumFastTurns() *float64 {
	if g == nil {
		return nil
	}
	return g.NumFastTurns
}

func (g *GoogleModel) Provider() string {
	return g.provider
}

func (g *GoogleModel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleModel) UnmarshalJSON(data []byte) error {
	type embed GoogleModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleModel(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleModel) MarshalJSON() ([]byte, error) {
	type embed GoogleModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleModel) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// This is the Google model that will be used.
type GoogleModelModel string

const (
	GoogleModelModelGemini25ProPreview0506       GoogleModelModel = "gemini-2.5-pro-preview-05-06"
	GoogleModelModelGemini25FlashPreview0417     GoogleModelModel = "gemini-2.5-flash-preview-04-17"
	GoogleModelModelGemini20FlashThinkingExp     GoogleModelModel = "gemini-2.0-flash-thinking-exp"
	GoogleModelModelGemini20ProExp0205           GoogleModelModel = "gemini-2.0-pro-exp-02-05"
	GoogleModelModelGemini20Flash                GoogleModelModel = "gemini-2.0-flash"
	GoogleModelModelGemini20FlashLite            GoogleModelModel = "gemini-2.0-flash-lite"
	GoogleModelModelGemini20FlashLitePreview0205 GoogleModelModel = "gemini-2.0-flash-lite-preview-02-05"
	GoogleModelModelGemini20FlashExp             GoogleModelModel = "gemini-2.0-flash-exp"
	GoogleModelModelGemini20FlashRealtimeExp     GoogleModelModel = "gemini-2.0-flash-realtime-exp"
	GoogleModelModelGemini15Flash                GoogleModelModel = "gemini-1.5-flash"
	GoogleModelModelGemini15Flash002             GoogleModelModel = "gemini-1.5-flash-002"
	GoogleModelModelGemini15Pro                  GoogleModelModel = "gemini-1.5-pro"
	GoogleModelModelGemini15Pro002               GoogleModelModel = "gemini-1.5-pro-002"
	GoogleModelModelGemini10Pro                  GoogleModelModel = "gemini-1.0-pro"
)

func NewGoogleModelModelFromString(s string) (GoogleModelModel, error) {
	switch s {
	case "gemini-2.5-pro-preview-05-06":
		return GoogleModelModelGemini25ProPreview0506, nil
	case "gemini-2.5-flash-preview-04-17":
		return GoogleModelModelGemini25FlashPreview0417, nil
	case "gemini-2.0-flash-thinking-exp":
		return GoogleModelModelGemini20FlashThinkingExp, nil
	case "gemini-2.0-pro-exp-02-05":
		return GoogleModelModelGemini20ProExp0205, nil
	case "gemini-2.0-flash":
		return GoogleModelModelGemini20Flash, nil
	case "gemini-2.0-flash-lite":
		return GoogleModelModelGemini20FlashLite, nil
	case "gemini-2.0-flash-lite-preview-02-05":
		return GoogleModelModelGemini20FlashLitePreview0205, nil
	case "gemini-2.0-flash-exp":
		return GoogleModelModelGemini20FlashExp, nil
	case "gemini-2.0-flash-realtime-exp":
		return GoogleModelModelGemini20FlashRealtimeExp, nil
	case "gemini-1.5-flash":
		return GoogleModelModelGemini15Flash, nil
	case "gemini-1.5-flash-002":
		return GoogleModelModelGemini15Flash002, nil
	case "gemini-1.5-pro":
		return GoogleModelModelGemini15Pro, nil
	case "gemini-1.5-pro-002":
		return GoogleModelModelGemini15Pro002, nil
	case "gemini-1.0-pro":
		return GoogleModelModelGemini10Pro, nil
	}
	var t GoogleModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GoogleModelModel) Ptr() *GoogleModelModel {
	return &g
}

type GoogleModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (g *GoogleModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if g == nil {
		return nil
	}
	return g.CreateApiRequestToolDto
}

func (g *GoogleModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if g == nil {
		return nil
	}
	return g.CreateBashToolDto
}

func (g *GoogleModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if g == nil {
		return nil
	}
	return g.CreateComputerToolDto
}

func (g *GoogleModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if g == nil {
		return nil
	}
	return g.CreateDtmfToolDto
}

func (g *GoogleModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateEndCallToolDto
}

func (g *GoogleModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if g == nil {
		return nil
	}
	return g.CreateFunctionToolDto
}

func (g *GoogleModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (g *GoogleModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelCalendarEventCreateToolDto
}

func (g *GoogleModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelContactCreateToolDto
}

func (g *GoogleModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelContactGetToolDto
}

func (g *GoogleModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (g *GoogleModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoogleCalendarCreateEventToolDto
}

func (g *GoogleModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoogleSheetsRowAppendToolDto
}

func (g *GoogleModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if g == nil {
		return nil
	}
	return g.CreateMcpToolDto
}

func (g *GoogleModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if g == nil {
		return nil
	}
	return g.CreateQueryToolDto
}

func (g *GoogleModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if g == nil {
		return nil
	}
	return g.CreateSlackSendMessageToolDto
}

func (g *GoogleModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if g == nil {
		return nil
	}
	return g.CreateSmsToolDto
}

func (g *GoogleModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if g == nil {
		return nil
	}
	return g.CreateTextEditorToolDto
}

func (g *GoogleModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateTransferCallToolDto
}

func (g *GoogleModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		g.typ = "CreateApiRequestToolDto"
		g.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		g.typ = "CreateBashToolDto"
		g.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		g.typ = "CreateComputerToolDto"
		g.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		g.typ = "CreateDtmfToolDto"
		g.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		g.typ = "CreateEndCallToolDto"
		g.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		g.typ = "CreateFunctionToolDto"
		g.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		g.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		g.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		g.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		g.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		g.typ = "CreateGoHighLevelContactCreateToolDto"
		g.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		g.typ = "CreateGoHighLevelContactGetToolDto"
		g.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		g.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		g.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		g.typ = "CreateGoogleCalendarCreateEventToolDto"
		g.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		g.typ = "CreateGoogleSheetsRowAppendToolDto"
		g.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		g.typ = "CreateMcpToolDto"
		g.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		g.typ = "CreateQueryToolDto"
		g.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		g.typ = "CreateSlackSendMessageToolDto"
		g.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		g.typ = "CreateSmsToolDto"
		g.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		g.typ = "CreateTextEditorToolDto"
		g.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		g.typ = "CreateTransferCallToolDto"
		g.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleModelToolsItem) MarshalJSON() ([]byte, error) {
	if g.typ == "CreateApiRequestToolDto" || g.CreateApiRequestToolDto != nil {
		return json.Marshal(g.CreateApiRequestToolDto)
	}
	if g.typ == "CreateBashToolDto" || g.CreateBashToolDto != nil {
		return json.Marshal(g.CreateBashToolDto)
	}
	if g.typ == "CreateComputerToolDto" || g.CreateComputerToolDto != nil {
		return json.Marshal(g.CreateComputerToolDto)
	}
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return json.Marshal(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return json.Marshal(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return json.Marshal(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || g.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || g.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactCreateToolDto" || g.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelContactCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactGetToolDto" || g.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelContactGetToolDto)
	}
	if g.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || g.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(g.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if g.typ == "CreateGoogleCalendarCreateEventToolDto" || g.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(g.CreateGoogleCalendarCreateEventToolDto)
	}
	if g.typ == "CreateGoogleSheetsRowAppendToolDto" || g.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(g.CreateGoogleSheetsRowAppendToolDto)
	}
	if g.typ == "CreateMcpToolDto" || g.CreateMcpToolDto != nil {
		return json.Marshal(g.CreateMcpToolDto)
	}
	if g.typ == "CreateQueryToolDto" || g.CreateQueryToolDto != nil {
		return json.Marshal(g.CreateQueryToolDto)
	}
	if g.typ == "CreateSlackSendMessageToolDto" || g.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(g.CreateSlackSendMessageToolDto)
	}
	if g.typ == "CreateSmsToolDto" || g.CreateSmsToolDto != nil {
		return json.Marshal(g.CreateSmsToolDto)
	}
	if g.typ == "CreateTextEditorToolDto" || g.CreateTextEditorToolDto != nil {
		return json.Marshal(g.CreateTextEditorToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return json.Marshal(g.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (g *GoogleModelToolsItem) Accept(visitor GoogleModelToolsItemVisitor) error {
	if g.typ == "CreateApiRequestToolDto" || g.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(g.CreateApiRequestToolDto)
	}
	if g.typ == "CreateBashToolDto" || g.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(g.CreateBashToolDto)
	}
	if g.typ == "CreateComputerToolDto" || g.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(g.CreateComputerToolDto)
	}
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || g.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(g.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || g.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(g.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactCreateToolDto" || g.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(g.CreateGoHighLevelContactCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactGetToolDto" || g.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(g.CreateGoHighLevelContactGetToolDto)
	}
	if g.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || g.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(g.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if g.typ == "CreateGoogleCalendarCreateEventToolDto" || g.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(g.CreateGoogleCalendarCreateEventToolDto)
	}
	if g.typ == "CreateGoogleSheetsRowAppendToolDto" || g.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(g.CreateGoogleSheetsRowAppendToolDto)
	}
	if g.typ == "CreateMcpToolDto" || g.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(g.CreateMcpToolDto)
	}
	if g.typ == "CreateQueryToolDto" || g.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(g.CreateQueryToolDto)
	}
	if g.typ == "CreateSlackSendMessageToolDto" || g.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(g.CreateSlackSendMessageToolDto)
	}
	if g.typ == "CreateSmsToolDto" || g.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(g.CreateSmsToolDto)
	}
	if g.typ == "CreateTextEditorToolDto" || g.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(g.CreateTextEditorToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(g.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleRealtimeConfig struct {
	// This is the nucleus sampling parameter that controls the cumulative probability of tokens considered during text generation.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	TopP *float64 `json:"topP,omitempty" url:"topP,omitempty"`
	// This is the top-k sampling parameter that limits the number of highest probability tokens considered during text generation.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	TopK *float64 `json:"topK,omitempty" url:"topK,omitempty"`
	// This is the presence penalty parameter that influences the model's likelihood to repeat information by penalizing tokens based on their presence in the text.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	PresencePenalty *float64 `json:"presencePenalty,omitempty" url:"presencePenalty,omitempty"`
	// This is the frequency penalty parameter that influences the model's likelihood to repeat tokens by penalizing them based on their frequency in the text.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	FrequencyPenalty *float64 `json:"frequencyPenalty,omitempty" url:"frequencyPenalty,omitempty"`
	// This is the speech configuration object that defines the voice settings to be used for the model's speech output.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	SpeechConfig *GeminiMultimodalLiveSpeechConfig `json:"speechConfig,omitempty" url:"speechConfig,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleRealtimeConfig) GetTopP() *float64 {
	if g == nil {
		return nil
	}
	return g.TopP
}

func (g *GoogleRealtimeConfig) GetTopK() *float64 {
	if g == nil {
		return nil
	}
	return g.TopK
}

func (g *GoogleRealtimeConfig) GetPresencePenalty() *float64 {
	if g == nil {
		return nil
	}
	return g.PresencePenalty
}

func (g *GoogleRealtimeConfig) GetFrequencyPenalty() *float64 {
	if g == nil {
		return nil
	}
	return g.FrequencyPenalty
}

func (g *GoogleRealtimeConfig) GetSpeechConfig() *GeminiMultimodalLiveSpeechConfig {
	if g == nil {
		return nil
	}
	return g.SpeechConfig
}

func (g *GoogleRealtimeConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleRealtimeConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GoogleRealtimeConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoogleRealtimeConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleRealtimeConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleSheetsOAuth2AuthorizationCredential struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId string `json:"authorizationId" url:"authorizationId"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) GetAuthorizationId() string {
	if g == nil {
		return ""
	}
	return g.AuthorizationId
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) Provider() string {
	return g.provider
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) UnmarshalJSON(data []byte) error {
	type embed GoogleSheetsOAuth2AuthorizationCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleSheetsOAuth2AuthorizationCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "google.sheets.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.sheets.oauth2-authorization", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) MarshalJSON() ([]byte, error) {
	type embed GoogleSheetsOAuth2AuthorizationCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "google.sheets.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleSheetsOAuth2AuthorizationCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleSheetsRowAppendToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "google.sheets.row.append" for Google Sheets tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleSheetsRowAppendToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GoogleSheetsRowAppendToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GoogleSheetsRowAppendToolProviderDetails) Type() string {
	return g.type_
}

func (g *GoogleSheetsRowAppendToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleSheetsRowAppendToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GoogleSheetsRowAppendToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleSheetsRowAppendToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "google.sheets.row.append" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.sheets.row.append", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleSheetsRowAppendToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GoogleSheetsRowAppendToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "google.sheets.row.append",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleSheetsRowAppendToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleSheetsRowAppendToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleSheetsRowAppendToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "google.sheets.row.append" for Google Sheets tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleSheetsRowAppendToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoogleSheetsRowAppendToolWithToolCall) GetMessages() []*GoogleSheetsRowAppendToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleSheetsRowAppendToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GoogleSheetsRowAppendToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoogleSheetsRowAppendToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoogleSheetsRowAppendToolWithToolCall) Type() string {
	return g.type_
}

func (g *GoogleSheetsRowAppendToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleSheetsRowAppendToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GoogleSheetsRowAppendToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleSheetsRowAppendToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "google.sheets.row.append" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.sheets.row.append", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleSheetsRowAppendToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GoogleSheetsRowAppendToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "google.sheets.row.append",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleSheetsRowAppendToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleSheetsRowAppendToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleSheetsRowAppendToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleSheetsRowAppendToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleSheetsRowAppendToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleSheetsRowAppendToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleSheetsRowAppendToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleSheetsRowAppendToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleSheetsRowAppendToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleSheetsRowAppendToolWithToolCallMessagesItem) Accept(visitor GoogleSheetsRowAppendToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model *GoogleTranscriberModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription.
	Language *GoogleTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleTranscriber) GetModel() *GoogleTranscriberModel {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GoogleTranscriber) GetLanguage() *GoogleTranscriberLanguage {
	if g == nil {
		return nil
	}
	return g.Language
}

func (g *GoogleTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if g == nil {
		return nil
	}
	return g.FallbackPlan
}

func (g *GoogleTranscriber) Provider() string {
	return g.provider
}

func (g *GoogleTranscriber) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleTranscriber) UnmarshalJSON(data []byte) error {
	type embed GoogleTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleTranscriber) MarshalJSON() ([]byte, error) {
	type embed GoogleTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleTranscriber) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// This is the language that will be set for the transcription.
type GoogleTranscriberLanguage string

const (
	GoogleTranscriberLanguageMultilingual GoogleTranscriberLanguage = "Multilingual"
	GoogleTranscriberLanguageArabic       GoogleTranscriberLanguage = "Arabic"
	GoogleTranscriberLanguageBengali      GoogleTranscriberLanguage = "Bengali"
	GoogleTranscriberLanguageBulgarian    GoogleTranscriberLanguage = "Bulgarian"
	GoogleTranscriberLanguageChinese      GoogleTranscriberLanguage = "Chinese"
	GoogleTranscriberLanguageCroatian     GoogleTranscriberLanguage = "Croatian"
	GoogleTranscriberLanguageCzech        GoogleTranscriberLanguage = "Czech"
	GoogleTranscriberLanguageDanish       GoogleTranscriberLanguage = "Danish"
	GoogleTranscriberLanguageDutch        GoogleTranscriberLanguage = "Dutch"
	GoogleTranscriberLanguageEnglish      GoogleTranscriberLanguage = "English"
	GoogleTranscriberLanguageEstonian     GoogleTranscriberLanguage = "Estonian"
	GoogleTranscriberLanguageFinnish      GoogleTranscriberLanguage = "Finnish"
	GoogleTranscriberLanguageFrench       GoogleTranscriberLanguage = "French"
	GoogleTranscriberLanguageGerman       GoogleTranscriberLanguage = "German"
	GoogleTranscriberLanguageGreek        GoogleTranscriberLanguage = "Greek"
	GoogleTranscriberLanguageHebrew       GoogleTranscriberLanguage = "Hebrew"
	GoogleTranscriberLanguageHindi        GoogleTranscriberLanguage = "Hindi"
	GoogleTranscriberLanguageHungarian    GoogleTranscriberLanguage = "Hungarian"
	GoogleTranscriberLanguageIndonesian   GoogleTranscriberLanguage = "Indonesian"
	GoogleTranscriberLanguageItalian      GoogleTranscriberLanguage = "Italian"
	GoogleTranscriberLanguageJapanese     GoogleTranscriberLanguage = "Japanese"
	GoogleTranscriberLanguageKorean       GoogleTranscriberLanguage = "Korean"
	GoogleTranscriberLanguageLatvian      GoogleTranscriberLanguage = "Latvian"
	GoogleTranscriberLanguageLithuanian   GoogleTranscriberLanguage = "Lithuanian"
	GoogleTranscriberLanguageNorwegian    GoogleTranscriberLanguage = "Norwegian"
	GoogleTranscriberLanguagePolish       GoogleTranscriberLanguage = "Polish"
	GoogleTranscriberLanguagePortuguese   GoogleTranscriberLanguage = "Portuguese"
	GoogleTranscriberLanguageRomanian     GoogleTranscriberLanguage = "Romanian"
	GoogleTranscriberLanguageRussian      GoogleTranscriberLanguage = "Russian"
	GoogleTranscriberLanguageSerbian      GoogleTranscriberLanguage = "Serbian"
	GoogleTranscriberLanguageSlovak       GoogleTranscriberLanguage = "Slovak"
	GoogleTranscriberLanguageSlovenian    GoogleTranscriberLanguage = "Slovenian"
	GoogleTranscriberLanguageSpanish      GoogleTranscriberLanguage = "Spanish"
	GoogleTranscriberLanguageSwahili      GoogleTranscriberLanguage = "Swahili"
	GoogleTranscriberLanguageSwedish      GoogleTranscriberLanguage = "Swedish"
	GoogleTranscriberLanguageThai         GoogleTranscriberLanguage = "Thai"
	GoogleTranscriberLanguageTurkish      GoogleTranscriberLanguage = "Turkish"
	GoogleTranscriberLanguageUkrainian    GoogleTranscriberLanguage = "Ukrainian"
	GoogleTranscriberLanguageVietnamese   GoogleTranscriberLanguage = "Vietnamese"
)

func NewGoogleTranscriberLanguageFromString(s string) (GoogleTranscriberLanguage, error) {
	switch s {
	case "Multilingual":
		return GoogleTranscriberLanguageMultilingual, nil
	case "Arabic":
		return GoogleTranscriberLanguageArabic, nil
	case "Bengali":
		return GoogleTranscriberLanguageBengali, nil
	case "Bulgarian":
		return GoogleTranscriberLanguageBulgarian, nil
	case "Chinese":
		return GoogleTranscriberLanguageChinese, nil
	case "Croatian":
		return GoogleTranscriberLanguageCroatian, nil
	case "Czech":
		return GoogleTranscriberLanguageCzech, nil
	case "Danish":
		return GoogleTranscriberLanguageDanish, nil
	case "Dutch":
		return GoogleTranscriberLanguageDutch, nil
	case "English":
		return GoogleTranscriberLanguageEnglish, nil
	case "Estonian":
		return GoogleTranscriberLanguageEstonian, nil
	case "Finnish":
		return GoogleTranscriberLanguageFinnish, nil
	case "French":
		return GoogleTranscriberLanguageFrench, nil
	case "German":
		return GoogleTranscriberLanguageGerman, nil
	case "Greek":
		return GoogleTranscriberLanguageGreek, nil
	case "Hebrew":
		return GoogleTranscriberLanguageHebrew, nil
	case "Hindi":
		return GoogleTranscriberLanguageHindi, nil
	case "Hungarian":
		return GoogleTranscriberLanguageHungarian, nil
	case "Indonesian":
		return GoogleTranscriberLanguageIndonesian, nil
	case "Italian":
		return GoogleTranscriberLanguageItalian, nil
	case "Japanese":
		return GoogleTranscriberLanguageJapanese, nil
	case "Korean":
		return GoogleTranscriberLanguageKorean, nil
	case "Latvian":
		return GoogleTranscriberLanguageLatvian, nil
	case "Lithuanian":
		return GoogleTranscriberLanguageLithuanian, nil
	case "Norwegian":
		return GoogleTranscriberLanguageNorwegian, nil
	case "Polish":
		return GoogleTranscriberLanguagePolish, nil
	case "Portuguese":
		return GoogleTranscriberLanguagePortuguese, nil
	case "Romanian":
		return GoogleTranscriberLanguageRomanian, nil
	case "Russian":
		return GoogleTranscriberLanguageRussian, nil
	case "Serbian":
		return GoogleTranscriberLanguageSerbian, nil
	case "Slovak":
		return GoogleTranscriberLanguageSlovak, nil
	case "Slovenian":
		return GoogleTranscriberLanguageSlovenian, nil
	case "Spanish":
		return GoogleTranscriberLanguageSpanish, nil
	case "Swahili":
		return GoogleTranscriberLanguageSwahili, nil
	case "Swedish":
		return GoogleTranscriberLanguageSwedish, nil
	case "Thai":
		return GoogleTranscriberLanguageThai, nil
	case "Turkish":
		return GoogleTranscriberLanguageTurkish, nil
	case "Ukrainian":
		return GoogleTranscriberLanguageUkrainian, nil
	case "Vietnamese":
		return GoogleTranscriberLanguageVietnamese, nil
	}
	var t GoogleTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GoogleTranscriberLanguage) Ptr() *GoogleTranscriberLanguage {
	return &g
}

// This is the model that will be used for the transcription.
type GoogleTranscriberModel string

const (
	GoogleTranscriberModelGemini25ProPreview0506       GoogleTranscriberModel = "gemini-2.5-pro-preview-05-06"
	GoogleTranscriberModelGemini25FlashPreview0417     GoogleTranscriberModel = "gemini-2.5-flash-preview-04-17"
	GoogleTranscriberModelGemini20FlashThinkingExp     GoogleTranscriberModel = "gemini-2.0-flash-thinking-exp"
	GoogleTranscriberModelGemini20ProExp0205           GoogleTranscriberModel = "gemini-2.0-pro-exp-02-05"
	GoogleTranscriberModelGemini20Flash                GoogleTranscriberModel = "gemini-2.0-flash"
	GoogleTranscriberModelGemini20FlashLite            GoogleTranscriberModel = "gemini-2.0-flash-lite"
	GoogleTranscriberModelGemini20FlashLitePreview0205 GoogleTranscriberModel = "gemini-2.0-flash-lite-preview-02-05"
	GoogleTranscriberModelGemini20FlashExp             GoogleTranscriberModel = "gemini-2.0-flash-exp"
	GoogleTranscriberModelGemini20FlashRealtimeExp     GoogleTranscriberModel = "gemini-2.0-flash-realtime-exp"
	GoogleTranscriberModelGemini15Flash                GoogleTranscriberModel = "gemini-1.5-flash"
	GoogleTranscriberModelGemini15Flash002             GoogleTranscriberModel = "gemini-1.5-flash-002"
	GoogleTranscriberModelGemini15Pro                  GoogleTranscriberModel = "gemini-1.5-pro"
	GoogleTranscriberModelGemini15Pro002               GoogleTranscriberModel = "gemini-1.5-pro-002"
	GoogleTranscriberModelGemini10Pro                  GoogleTranscriberModel = "gemini-1.0-pro"
)

func NewGoogleTranscriberModelFromString(s string) (GoogleTranscriberModel, error) {
	switch s {
	case "gemini-2.5-pro-preview-05-06":
		return GoogleTranscriberModelGemini25ProPreview0506, nil
	case "gemini-2.5-flash-preview-04-17":
		return GoogleTranscriberModelGemini25FlashPreview0417, nil
	case "gemini-2.0-flash-thinking-exp":
		return GoogleTranscriberModelGemini20FlashThinkingExp, nil
	case "gemini-2.0-pro-exp-02-05":
		return GoogleTranscriberModelGemini20ProExp0205, nil
	case "gemini-2.0-flash":
		return GoogleTranscriberModelGemini20Flash, nil
	case "gemini-2.0-flash-lite":
		return GoogleTranscriberModelGemini20FlashLite, nil
	case "gemini-2.0-flash-lite-preview-02-05":
		return GoogleTranscriberModelGemini20FlashLitePreview0205, nil
	case "gemini-2.0-flash-exp":
		return GoogleTranscriberModelGemini20FlashExp, nil
	case "gemini-2.0-flash-realtime-exp":
		return GoogleTranscriberModelGemini20FlashRealtimeExp, nil
	case "gemini-1.5-flash":
		return GoogleTranscriberModelGemini15Flash, nil
	case "gemini-1.5-flash-002":
		return GoogleTranscriberModelGemini15Flash002, nil
	case "gemini-1.5-pro":
		return GoogleTranscriberModelGemini15Pro, nil
	case "gemini-1.5-pro-002":
		return GoogleTranscriberModelGemini15Pro002, nil
	case "gemini-1.0-pro":
		return GoogleTranscriberModelGemini10Pro, nil
	}
	var t GoogleTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GoogleTranscriberModel) Ptr() *GoogleTranscriberModel {
	return &g
}

type GoogleVoicemailDetectionPlan struct {
	// This is the maximum duration from the start of the call that we will wait for a voicemail beep, before speaking our message
	//
	// - If we detect a voicemail beep before this, we will speak the message at that point.
	//
	// - Setting too low a value means that the bot will start speaking its voicemail message too early. If it does so before the actual beep, it will get cut off. You should definitely tune this to your use case.
	//
	// @default 30
	// @min 0
	// @max 60
	BeepMaxAwaitSeconds *float64 `json:"beepMaxAwaitSeconds,omitempty" url:"beepMaxAwaitSeconds,omitempty"`
	// This is the provider to use for voicemail detection.
	// This is the backoff plan for the voicemail detection.
	BackoffPlan *VoicemailDetectionBackoffPlan `json:"backoffPlan,omitempty" url:"backoffPlan,omitempty"`
	provider    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleVoicemailDetectionPlan) GetBeepMaxAwaitSeconds() *float64 {
	if g == nil {
		return nil
	}
	return g.BeepMaxAwaitSeconds
}

func (g *GoogleVoicemailDetectionPlan) GetBackoffPlan() *VoicemailDetectionBackoffPlan {
	if g == nil {
		return nil
	}
	return g.BackoffPlan
}

func (g *GoogleVoicemailDetectionPlan) Provider() string {
	return g.provider
}

func (g *GoogleVoicemailDetectionPlan) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleVoicemailDetectionPlan) UnmarshalJSON(data []byte) error {
	type embed GoogleVoicemailDetectionPlan
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleVoicemailDetectionPlan(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleVoicemailDetectionPlan) MarshalJSON() ([]byte, error) {
	type embed GoogleVoicemailDetectionPlan
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleVoicemailDetectionPlan) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroqCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroqCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GroqCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GroqCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GroqCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GroqCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GroqCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GroqCredential) Provider() string {
	return g.provider
}

func (g *GroqCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroqCredential) UnmarshalJSON(data []byte) error {
	type embed GroqCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GroqCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "groq", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroqCredential) MarshalJSON() ([]byte, error) {
	type embed GroqCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "groq",
	}
	return json.Marshal(marshaler)
}

func (g *GroqCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroqModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*GroqModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model GroqModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroqModel) GetMessages() []*OpenAiMessage {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GroqModel) GetTools() []*GroqModelToolsItem {
	if g == nil {
		return nil
	}
	return g.Tools
}

func (g *GroqModel) GetToolIds() []string {
	if g == nil {
		return nil
	}
	return g.ToolIds
}

func (g *GroqModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if g == nil {
		return nil
	}
	return g.KnowledgeBase
}

func (g *GroqModel) GetKnowledgeBaseId() *string {
	if g == nil {
		return nil
	}
	return g.KnowledgeBaseId
}

func (g *GroqModel) GetModel() GroqModelModel {
	if g == nil {
		return ""
	}
	return g.Model
}

func (g *GroqModel) GetTemperature() *float64 {
	if g == nil {
		return nil
	}
	return g.Temperature
}

func (g *GroqModel) GetMaxTokens() *float64 {
	if g == nil {
		return nil
	}
	return g.MaxTokens
}

func (g *GroqModel) GetEmotionRecognitionEnabled() *bool {
	if g == nil {
		return nil
	}
	return g.EmotionRecognitionEnabled
}

func (g *GroqModel) GetNumFastTurns() *float64 {
	if g == nil {
		return nil
	}
	return g.NumFastTurns
}

func (g *GroqModel) Provider() string {
	return g.provider
}

func (g *GroqModel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroqModel) UnmarshalJSON(data []byte) error {
	type embed GroqModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GroqModel(unmarshaler.embed)
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "groq", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroqModel) MarshalJSON() ([]byte, error) {
	type embed GroqModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "groq",
	}
	return json.Marshal(marshaler)
}

func (g *GroqModel) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
type GroqModelModel string

const (
	GroqModelModelDeepseekR1DistillLlama70B              GroqModelModel = "deepseek-r1-distill-llama-70b"
	GroqModelModelLlama3370BVersatile                    GroqModelModel = "llama-3.3-70b-versatile"
	GroqModelModelLlama31405BReasoning                   GroqModelModel = "llama-3.1-405b-reasoning"
	GroqModelModelLlama318BInstant                       GroqModelModel = "llama-3.1-8b-instant"
	GroqModelModelLlama38B8192                           GroqModelModel = "llama3-8b-8192"
	GroqModelModelLlama370B8192                          GroqModelModel = "llama3-70b-8192"
	GroqModelModelGemma29BIt                             GroqModelModel = "gemma2-9b-it"
	GroqModelModelMetaLlamaLlama4Maverick17B128EInstruct GroqModelModel = "meta-llama/llama-4-maverick-17b-128e-instruct"
	GroqModelModelMetaLlamaLlama4Scout17B16EInstruct     GroqModelModel = "meta-llama/llama-4-scout-17b-16e-instruct"
	GroqModelModelMistralSaba24B                         GroqModelModel = "mistral-saba-24b"
	GroqModelModelCompoundBeta                           GroqModelModel = "compound-beta"
	GroqModelModelCompoundBetaMini                       GroqModelModel = "compound-beta-mini"
)

func NewGroqModelModelFromString(s string) (GroqModelModel, error) {
	switch s {
	case "deepseek-r1-distill-llama-70b":
		return GroqModelModelDeepseekR1DistillLlama70B, nil
	case "llama-3.3-70b-versatile":
		return GroqModelModelLlama3370BVersatile, nil
	case "llama-3.1-405b-reasoning":
		return GroqModelModelLlama31405BReasoning, nil
	case "llama-3.1-8b-instant":
		return GroqModelModelLlama318BInstant, nil
	case "llama3-8b-8192":
		return GroqModelModelLlama38B8192, nil
	case "llama3-70b-8192":
		return GroqModelModelLlama370B8192, nil
	case "gemma2-9b-it":
		return GroqModelModelGemma29BIt, nil
	case "meta-llama/llama-4-maverick-17b-128e-instruct":
		return GroqModelModelMetaLlamaLlama4Maverick17B128EInstruct, nil
	case "meta-llama/llama-4-scout-17b-16e-instruct":
		return GroqModelModelMetaLlamaLlama4Scout17B16EInstruct, nil
	case "mistral-saba-24b":
		return GroqModelModelMistralSaba24B, nil
	case "compound-beta":
		return GroqModelModelCompoundBeta, nil
	case "compound-beta-mini":
		return GroqModelModelCompoundBetaMini, nil
	}
	var t GroqModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GroqModelModel) Ptr() *GroqModelModel {
	return &g
}

type GroqModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (g *GroqModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if g == nil {
		return nil
	}
	return g.CreateApiRequestToolDto
}

func (g *GroqModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if g == nil {
		return nil
	}
	return g.CreateBashToolDto
}

func (g *GroqModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if g == nil {
		return nil
	}
	return g.CreateComputerToolDto
}

func (g *GroqModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if g == nil {
		return nil
	}
	return g.CreateDtmfToolDto
}

func (g *GroqModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateEndCallToolDto
}

func (g *GroqModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if g == nil {
		return nil
	}
	return g.CreateFunctionToolDto
}

func (g *GroqModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (g *GroqModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelCalendarEventCreateToolDto
}

func (g *GroqModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelContactCreateToolDto
}

func (g *GroqModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoHighLevelContactGetToolDto
}

func (g *GroqModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (g *GroqModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoogleCalendarCreateEventToolDto
}

func (g *GroqModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGoogleSheetsRowAppendToolDto
}

func (g *GroqModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if g == nil {
		return nil
	}
	return g.CreateMcpToolDto
}

func (g *GroqModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if g == nil {
		return nil
	}
	return g.CreateQueryToolDto
}

func (g *GroqModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if g == nil {
		return nil
	}
	return g.CreateSlackSendMessageToolDto
}

func (g *GroqModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if g == nil {
		return nil
	}
	return g.CreateSmsToolDto
}

func (g *GroqModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if g == nil {
		return nil
	}
	return g.CreateTextEditorToolDto
}

func (g *GroqModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateTransferCallToolDto
}

func (g *GroqModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		g.typ = "CreateApiRequestToolDto"
		g.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		g.typ = "CreateBashToolDto"
		g.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		g.typ = "CreateComputerToolDto"
		g.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		g.typ = "CreateDtmfToolDto"
		g.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		g.typ = "CreateEndCallToolDto"
		g.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		g.typ = "CreateFunctionToolDto"
		g.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		g.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		g.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		g.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		g.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		g.typ = "CreateGoHighLevelContactCreateToolDto"
		g.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		g.typ = "CreateGoHighLevelContactGetToolDto"
		g.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		g.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		g.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		g.typ = "CreateGoogleCalendarCreateEventToolDto"
		g.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		g.typ = "CreateGoogleSheetsRowAppendToolDto"
		g.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		g.typ = "CreateMcpToolDto"
		g.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		g.typ = "CreateQueryToolDto"
		g.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		g.typ = "CreateSlackSendMessageToolDto"
		g.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		g.typ = "CreateSmsToolDto"
		g.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		g.typ = "CreateTextEditorToolDto"
		g.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		g.typ = "CreateTransferCallToolDto"
		g.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroqModelToolsItem) MarshalJSON() ([]byte, error) {
	if g.typ == "CreateApiRequestToolDto" || g.CreateApiRequestToolDto != nil {
		return json.Marshal(g.CreateApiRequestToolDto)
	}
	if g.typ == "CreateBashToolDto" || g.CreateBashToolDto != nil {
		return json.Marshal(g.CreateBashToolDto)
	}
	if g.typ == "CreateComputerToolDto" || g.CreateComputerToolDto != nil {
		return json.Marshal(g.CreateComputerToolDto)
	}
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return json.Marshal(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return json.Marshal(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return json.Marshal(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || g.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || g.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactCreateToolDto" || g.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelContactCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactGetToolDto" || g.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(g.CreateGoHighLevelContactGetToolDto)
	}
	if g.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || g.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(g.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if g.typ == "CreateGoogleCalendarCreateEventToolDto" || g.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(g.CreateGoogleCalendarCreateEventToolDto)
	}
	if g.typ == "CreateGoogleSheetsRowAppendToolDto" || g.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(g.CreateGoogleSheetsRowAppendToolDto)
	}
	if g.typ == "CreateMcpToolDto" || g.CreateMcpToolDto != nil {
		return json.Marshal(g.CreateMcpToolDto)
	}
	if g.typ == "CreateQueryToolDto" || g.CreateQueryToolDto != nil {
		return json.Marshal(g.CreateQueryToolDto)
	}
	if g.typ == "CreateSlackSendMessageToolDto" || g.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(g.CreateSlackSendMessageToolDto)
	}
	if g.typ == "CreateSmsToolDto" || g.CreateSmsToolDto != nil {
		return json.Marshal(g.CreateSmsToolDto)
	}
	if g.typ == "CreateTextEditorToolDto" || g.CreateTextEditorToolDto != nil {
		return json.Marshal(g.CreateTextEditorToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return json.Marshal(g.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroqModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (g *GroqModelToolsItem) Accept(visitor GroqModelToolsItemVisitor) error {
	if g.typ == "CreateApiRequestToolDto" || g.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(g.CreateApiRequestToolDto)
	}
	if g.typ == "CreateBashToolDto" || g.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(g.CreateBashToolDto)
	}
	if g.typ == "CreateComputerToolDto" || g.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(g.CreateComputerToolDto)
	}
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || g.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(g.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if g.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || g.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(g.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactCreateToolDto" || g.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(g.CreateGoHighLevelContactCreateToolDto)
	}
	if g.typ == "CreateGoHighLevelContactGetToolDto" || g.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(g.CreateGoHighLevelContactGetToolDto)
	}
	if g.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || g.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(g.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if g.typ == "CreateGoogleCalendarCreateEventToolDto" || g.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(g.CreateGoogleCalendarCreateEventToolDto)
	}
	if g.typ == "CreateGoogleSheetsRowAppendToolDto" || g.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(g.CreateGoogleSheetsRowAppendToolDto)
	}
	if g.typ == "CreateMcpToolDto" || g.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(g.CreateMcpToolDto)
	}
	if g.typ == "CreateQueryToolDto" || g.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(g.CreateQueryToolDto)
	}
	if g.typ == "CreateSlackSendMessageToolDto" || g.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(g.CreateSlackSendMessageToolDto)
	}
	if g.typ == "CreateSmsToolDto" || g.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(g.CreateSmsToolDto)
	}
	if g.typ == "CreateTextEditorToolDto" || g.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(g.CreateTextEditorToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(g.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type HangupNode struct {
	Name string `json:"name" url:"name"`
	// This is whether or not the node is the start of the workflow.
	IsStart *bool `json:"isStart,omitempty" url:"isStart,omitempty"`
	// This is for metadata you want to store on the task.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HangupNode) GetName() string {
	if h == nil {
		return ""
	}
	return h.Name
}

func (h *HangupNode) GetIsStart() *bool {
	if h == nil {
		return nil
	}
	return h.IsStart
}

func (h *HangupNode) GetMetadata() map[string]interface{} {
	if h == nil {
		return nil
	}
	return h.Metadata
}

func (h *HangupNode) Type() string {
	return h.type_
}

func (h *HangupNode) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HangupNode) UnmarshalJSON(data []byte) error {
	type embed HangupNode
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HangupNode(unmarshaler.embed)
	if unmarshaler.Type != "hangup" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", h, "hangup", unmarshaler.Type)
	}
	h.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *h, "type")
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HangupNode) MarshalJSON() ([]byte, error) {
	type embed HangupNode
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
		Type:  "hangup",
	}
	return json.Marshal(marshaler)
}

func (h *HangupNode) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HumeCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HumeCredential) GetApiKey() string {
	if h == nil {
		return ""
	}
	return h.ApiKey
}

func (h *HumeCredential) GetId() string {
	if h == nil {
		return ""
	}
	return h.Id
}

func (h *HumeCredential) GetOrgId() string {
	if h == nil {
		return ""
	}
	return h.OrgId
}

func (h *HumeCredential) GetCreatedAt() time.Time {
	if h == nil {
		return time.Time{}
	}
	return h.CreatedAt
}

func (h *HumeCredential) GetUpdatedAt() time.Time {
	if h == nil {
		return time.Time{}
	}
	return h.UpdatedAt
}

func (h *HumeCredential) GetName() *string {
	if h == nil {
		return nil
	}
	return h.Name
}

func (h *HumeCredential) Provider() string {
	return h.provider
}

func (h *HumeCredential) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HumeCredential) UnmarshalJSON(data []byte) error {
	type embed HumeCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HumeCredential(unmarshaler.embed)
	h.CreatedAt = unmarshaler.CreatedAt.Time()
	h.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "hume" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", h, "hume", unmarshaler.Provider)
	}
	h.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *h, "provider")
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HumeCredential) MarshalJSON() ([]byte, error) {
	type embed HumeCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*h),
		CreatedAt: internal.NewDateTime(h.CreatedAt),
		UpdatedAt: internal.NewDateTime(h.UpdatedAt),
		Provider:  "hume",
	}
	return json.Marshal(marshaler)
}

func (h *HumeCredential) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HumeVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the model that will be used.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The ID of the particular voice you want to use.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// Indicates whether the chosen voice is a preset Hume AI voice or a custom voice.
	IsCustomHumeVoice *bool `json:"isCustomHumeVoice,omitempty" url:"isCustomHumeVoice,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent (e.g., 'a soft, gentle voice with a strong British accent').
	//
	// If a Voice is specified in the request, this description serves as acting instructions.
	// If no Voice is specified, a new voice is generated based on this description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HumeVoice) GetCachingEnabled() *bool {
	if h == nil {
		return nil
	}
	return h.CachingEnabled
}

func (h *HumeVoice) GetVoiceId() string {
	if h == nil {
		return ""
	}
	return h.VoiceId
}

func (h *HumeVoice) GetIsCustomHumeVoice() *bool {
	if h == nil {
		return nil
	}
	return h.IsCustomHumeVoice
}

func (h *HumeVoice) GetChunkPlan() *ChunkPlan {
	if h == nil {
		return nil
	}
	return h.ChunkPlan
}

func (h *HumeVoice) GetDescription() *string {
	if h == nil {
		return nil
	}
	return h.Description
}

func (h *HumeVoice) GetFallbackPlan() *FallbackPlan {
	if h == nil {
		return nil
	}
	return h.FallbackPlan
}

func (h *HumeVoice) Provider() string {
	return h.provider
}

func (h *HumeVoice) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HumeVoice) UnmarshalJSON(data []byte) error {
	type embed HumeVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HumeVoice(unmarshaler.embed)
	if unmarshaler.Provider != "hume" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", h, "hume", unmarshaler.Provider)
	}
	h.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *h, "provider")
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HumeVoice) MarshalJSON() ([]byte, error) {
	type embed HumeVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*h),
		Provider: "hume",
	}
	return json.Marshal(marshaler)
}

func (h *HumeVoice) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type ImportVonagePhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *ImportVonagePhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the hooks that will be used for incoming calls to this phone number.
	Hooks []*PhoneNumberHookCallRinging `json:"hooks,omitempty" url:"hooks,omitempty"`
	// These are the digits of the phone number you own on your Vonage.
	VonagePhoneNumber string `json:"vonagePhoneNumber" url:"vonagePhoneNumber"`
	// This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups.
	CredentialId string `json:"credentialId" url:"credentialId"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the workflow that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ImportVonagePhoneNumberDto) GetFallbackDestination() *ImportVonagePhoneNumberDtoFallbackDestination {
	if i == nil {
		return nil
	}
	return i.FallbackDestination
}

func (i *ImportVonagePhoneNumberDto) GetHooks() []*PhoneNumberHookCallRinging {
	if i == nil {
		return nil
	}
	return i.Hooks
}

func (i *ImportVonagePhoneNumberDto) GetVonagePhoneNumber() string {
	if i == nil {
		return ""
	}
	return i.VonagePhoneNumber
}

func (i *ImportVonagePhoneNumberDto) GetCredentialId() string {
	if i == nil {
		return ""
	}
	return i.CredentialId
}

func (i *ImportVonagePhoneNumberDto) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *ImportVonagePhoneNumberDto) GetAssistantId() *string {
	if i == nil {
		return nil
	}
	return i.AssistantId
}

func (i *ImportVonagePhoneNumberDto) GetWorkflowId() *string {
	if i == nil {
		return nil
	}
	return i.WorkflowId
}

func (i *ImportVonagePhoneNumberDto) GetSquadId() *string {
	if i == nil {
		return nil
	}
	return i.SquadId
}

func (i *ImportVonagePhoneNumberDto) GetServer() *Server {
	if i == nil {
		return nil
	}
	return i.Server
}

func (i *ImportVonagePhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImportVonagePhoneNumberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler ImportVonagePhoneNumberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImportVonagePhoneNumberDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImportVonagePhoneNumberDto) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// This is the fallback destination an inbound call will be transferred to if:
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type ImportVonagePhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if i == nil {
		return nil
	}
	return i.TransferDestinationNumber
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if i == nil {
		return nil
	}
	return i.TransferDestinationSip
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		i.typ = "TransferDestinationNumber"
		i.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		i.typ = "TransferDestinationSip"
		i.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ImportVonagePhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if i.typ == "TransferDestinationNumber" || i.TransferDestinationNumber != nil {
		return json.Marshal(i.TransferDestinationNumber)
	}
	if i.typ == "TransferDestinationSip" || i.TransferDestinationSip != nil {
		return json.Marshal(i.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ImportVonagePhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) Accept(visitor ImportVonagePhoneNumberDtoFallbackDestinationVisitor) error {
	if i.typ == "TransferDestinationNumber" || i.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(i.TransferDestinationNumber)
	}
	if i.typ == "TransferDestinationSip" || i.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(i.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InflectionAiCredential struct {
	// This is the api key for Pi in InflectionAI's console. Get it from here: https://developers.inflection.ai/keys, billing will need to be setup
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InflectionAiCredential) GetApiKey() string {
	if i == nil {
		return ""
	}
	return i.ApiKey
}

func (i *InflectionAiCredential) GetId() string {
	if i == nil {
		return ""
	}
	return i.Id
}

func (i *InflectionAiCredential) GetOrgId() string {
	if i == nil {
		return ""
	}
	return i.OrgId
}

func (i *InflectionAiCredential) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InflectionAiCredential) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InflectionAiCredential) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InflectionAiCredential) Provider() string {
	return i.provider
}

func (i *InflectionAiCredential) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InflectionAiCredential) UnmarshalJSON(data []byte) error {
	type embed InflectionAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InflectionAiCredential(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "inflection-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", i, "inflection-ai", unmarshaler.Provider)
	}
	i.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *i, "provider")
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InflectionAiCredential) MarshalJSON() ([]byte, error) {
	type embed InflectionAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
		Provider:  "inflection-ai",
	}
	return json.Marshal(marshaler)
}

func (i *InflectionAiCredential) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InflectionAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*InflectionAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	model        string
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InflectionAiModel) GetMessages() []*OpenAiMessage {
	if i == nil {
		return nil
	}
	return i.Messages
}

func (i *InflectionAiModel) GetTools() []*InflectionAiModelToolsItem {
	if i == nil {
		return nil
	}
	return i.Tools
}

func (i *InflectionAiModel) GetToolIds() []string {
	if i == nil {
		return nil
	}
	return i.ToolIds
}

func (i *InflectionAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if i == nil {
		return nil
	}
	return i.KnowledgeBase
}

func (i *InflectionAiModel) GetKnowledgeBaseId() *string {
	if i == nil {
		return nil
	}
	return i.KnowledgeBaseId
}

func (i *InflectionAiModel) GetTemperature() *float64 {
	if i == nil {
		return nil
	}
	return i.Temperature
}

func (i *InflectionAiModel) GetMaxTokens() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxTokens
}

func (i *InflectionAiModel) GetEmotionRecognitionEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.EmotionRecognitionEnabled
}

func (i *InflectionAiModel) GetNumFastTurns() *float64 {
	if i == nil {
		return nil
	}
	return i.NumFastTurns
}

func (i *InflectionAiModel) Model() string {
	return i.model
}

func (i *InflectionAiModel) Provider() string {
	return i.provider
}

func (i *InflectionAiModel) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InflectionAiModel) UnmarshalJSON(data []byte) error {
	type embed InflectionAiModel
	var unmarshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InflectionAiModel(unmarshaler.embed)
	if unmarshaler.Model != "inflection_3_pi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", i, "inflection_3_pi", unmarshaler.Model)
	}
	i.model = unmarshaler.Model
	if unmarshaler.Provider != "inflection-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", i, "inflection-ai", unmarshaler.Provider)
	}
	i.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *i, "model", "provider")
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InflectionAiModel) MarshalJSON() ([]byte, error) {
	type embed InflectionAiModel
	var marshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed:    embed(*i),
		Model:    "inflection_3_pi",
		Provider: "inflection-ai",
	}
	return json.Marshal(marshaler)
}

func (i *InflectionAiModel) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InflectionAiModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (i *InflectionAiModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if i == nil {
		return nil
	}
	return i.CreateApiRequestToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if i == nil {
		return nil
	}
	return i.CreateBashToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if i == nil {
		return nil
	}
	return i.CreateComputerToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if i == nil {
		return nil
	}
	return i.CreateDtmfToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if i == nil {
		return nil
	}
	return i.CreateEndCallToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if i == nil {
		return nil
	}
	return i.CreateFunctionToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGoHighLevelCalendarEventCreateToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGoHighLevelContactCreateToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGoHighLevelContactGetToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGoogleCalendarCreateEventToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGoogleSheetsRowAppendToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if i == nil {
		return nil
	}
	return i.CreateMcpToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if i == nil {
		return nil
	}
	return i.CreateQueryToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if i == nil {
		return nil
	}
	return i.CreateSlackSendMessageToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if i == nil {
		return nil
	}
	return i.CreateSmsToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if i == nil {
		return nil
	}
	return i.CreateTextEditorToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if i == nil {
		return nil
	}
	return i.CreateTransferCallToolDto
}

func (i *InflectionAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		i.typ = "CreateApiRequestToolDto"
		i.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		i.typ = "CreateBashToolDto"
		i.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		i.typ = "CreateComputerToolDto"
		i.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		i.typ = "CreateDtmfToolDto"
		i.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		i.typ = "CreateEndCallToolDto"
		i.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		i.typ = "CreateFunctionToolDto"
		i.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		i.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		i.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		i.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		i.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		i.typ = "CreateGoHighLevelContactCreateToolDto"
		i.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		i.typ = "CreateGoHighLevelContactGetToolDto"
		i.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		i.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		i.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		i.typ = "CreateGoogleCalendarCreateEventToolDto"
		i.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		i.typ = "CreateGoogleSheetsRowAppendToolDto"
		i.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		i.typ = "CreateMcpToolDto"
		i.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		i.typ = "CreateQueryToolDto"
		i.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		i.typ = "CreateSlackSendMessageToolDto"
		i.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		i.typ = "CreateSmsToolDto"
		i.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		i.typ = "CreateTextEditorToolDto"
		i.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		i.typ = "CreateTransferCallToolDto"
		i.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InflectionAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if i.typ == "CreateApiRequestToolDto" || i.CreateApiRequestToolDto != nil {
		return json.Marshal(i.CreateApiRequestToolDto)
	}
	if i.typ == "CreateBashToolDto" || i.CreateBashToolDto != nil {
		return json.Marshal(i.CreateBashToolDto)
	}
	if i.typ == "CreateComputerToolDto" || i.CreateComputerToolDto != nil {
		return json.Marshal(i.CreateComputerToolDto)
	}
	if i.typ == "CreateDtmfToolDto" || i.CreateDtmfToolDto != nil {
		return json.Marshal(i.CreateDtmfToolDto)
	}
	if i.typ == "CreateEndCallToolDto" || i.CreateEndCallToolDto != nil {
		return json.Marshal(i.CreateEndCallToolDto)
	}
	if i.typ == "CreateFunctionToolDto" || i.CreateFunctionToolDto != nil {
		return json.Marshal(i.CreateFunctionToolDto)
	}
	if i.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || i.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(i.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if i.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || i.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(i.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if i.typ == "CreateGoHighLevelContactCreateToolDto" || i.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(i.CreateGoHighLevelContactCreateToolDto)
	}
	if i.typ == "CreateGoHighLevelContactGetToolDto" || i.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(i.CreateGoHighLevelContactGetToolDto)
	}
	if i.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || i.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(i.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if i.typ == "CreateGoogleCalendarCreateEventToolDto" || i.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(i.CreateGoogleCalendarCreateEventToolDto)
	}
	if i.typ == "CreateGoogleSheetsRowAppendToolDto" || i.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(i.CreateGoogleSheetsRowAppendToolDto)
	}
	if i.typ == "CreateMcpToolDto" || i.CreateMcpToolDto != nil {
		return json.Marshal(i.CreateMcpToolDto)
	}
	if i.typ == "CreateQueryToolDto" || i.CreateQueryToolDto != nil {
		return json.Marshal(i.CreateQueryToolDto)
	}
	if i.typ == "CreateSlackSendMessageToolDto" || i.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(i.CreateSlackSendMessageToolDto)
	}
	if i.typ == "CreateSmsToolDto" || i.CreateSmsToolDto != nil {
		return json.Marshal(i.CreateSmsToolDto)
	}
	if i.typ == "CreateTextEditorToolDto" || i.CreateTextEditorToolDto != nil {
		return json.Marshal(i.CreateTextEditorToolDto)
	}
	if i.typ == "CreateTransferCallToolDto" || i.CreateTransferCallToolDto != nil {
		return json.Marshal(i.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InflectionAiModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (i *InflectionAiModelToolsItem) Accept(visitor InflectionAiModelToolsItemVisitor) error {
	if i.typ == "CreateApiRequestToolDto" || i.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(i.CreateApiRequestToolDto)
	}
	if i.typ == "CreateBashToolDto" || i.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(i.CreateBashToolDto)
	}
	if i.typ == "CreateComputerToolDto" || i.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(i.CreateComputerToolDto)
	}
	if i.typ == "CreateDtmfToolDto" || i.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(i.CreateDtmfToolDto)
	}
	if i.typ == "CreateEndCallToolDto" || i.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(i.CreateEndCallToolDto)
	}
	if i.typ == "CreateFunctionToolDto" || i.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(i.CreateFunctionToolDto)
	}
	if i.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || i.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(i.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if i.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || i.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(i.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if i.typ == "CreateGoHighLevelContactCreateToolDto" || i.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(i.CreateGoHighLevelContactCreateToolDto)
	}
	if i.typ == "CreateGoHighLevelContactGetToolDto" || i.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(i.CreateGoHighLevelContactGetToolDto)
	}
	if i.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || i.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(i.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if i.typ == "CreateGoogleCalendarCreateEventToolDto" || i.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(i.CreateGoogleCalendarCreateEventToolDto)
	}
	if i.typ == "CreateGoogleSheetsRowAppendToolDto" || i.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(i.CreateGoogleSheetsRowAppendToolDto)
	}
	if i.typ == "CreateMcpToolDto" || i.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(i.CreateMcpToolDto)
	}
	if i.typ == "CreateQueryToolDto" || i.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(i.CreateQueryToolDto)
	}
	if i.typ == "CreateSlackSendMessageToolDto" || i.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(i.CreateSlackSendMessageToolDto)
	}
	if i.typ == "CreateSmsToolDto" || i.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(i.CreateSmsToolDto)
	}
	if i.typ == "CreateTextEditorToolDto" || i.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(i.CreateTextEditorToolDto)
	}
	if i.typ == "CreateTransferCallToolDto" || i.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(i.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InviteUserDto struct {
	Emails     []string          `json:"emails,omitempty" url:"emails,omitempty"`
	Role       InviteUserDtoRole `json:"role" url:"role"`
	RedirectTo *string           `json:"redirectTo,omitempty" url:"redirectTo,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InviteUserDto) GetEmails() []string {
	if i == nil {
		return nil
	}
	return i.Emails
}

func (i *InviteUserDto) GetRole() InviteUserDtoRole {
	if i == nil {
		return ""
	}
	return i.Role
}

func (i *InviteUserDto) GetRedirectTo() *string {
	if i == nil {
		return nil
	}
	return i.RedirectTo
}

func (i *InviteUserDto) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InviteUserDto) UnmarshalJSON(data []byte) error {
	type unmarshaler InviteUserDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InviteUserDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InviteUserDto) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InviteUserDtoRole string

const (
	InviteUserDtoRoleAdmin  InviteUserDtoRole = "admin"
	InviteUserDtoRoleEditor InviteUserDtoRole = "editor"
	InviteUserDtoRoleViewer InviteUserDtoRole = "viewer"
)

func NewInviteUserDtoRoleFromString(s string) (InviteUserDtoRole, error) {
	switch s {
	case "admin":
		return InviteUserDtoRoleAdmin, nil
	case "editor":
		return InviteUserDtoRoleEditor, nil
	case "viewer":
		return InviteUserDtoRoleViewer, nil
	}
	var t InviteUserDtoRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InviteUserDtoRole) Ptr() *InviteUserDtoRole {
	return &i
}

type InvoicePlan struct {
	// This is the name of the company.
	CompanyName *string `json:"companyName,omitempty" url:"companyName,omitempty"`
	// This is the address of the company.
	CompanyAddress *string `json:"companyAddress,omitempty" url:"companyAddress,omitempty"`
	// This is the tax ID of the company.
	CompanyTaxId *string `json:"companyTaxId,omitempty" url:"companyTaxId,omitempty"`
	// This is the preferred invoicing email of the company. If not specified, defaults to the subscription's email.
	CompanyEmail *string `json:"companyEmail,omitempty" url:"companyEmail,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoicePlan) GetCompanyName() *string {
	if i == nil {
		return nil
	}
	return i.CompanyName
}

func (i *InvoicePlan) GetCompanyAddress() *string {
	if i == nil {
		return nil
	}
	return i.CompanyAddress
}

func (i *InvoicePlan) GetCompanyTaxId() *string {
	if i == nil {
		return nil
	}
	return i.CompanyTaxId
}

func (i *InvoicePlan) GetCompanyEmail() *string {
	if i == nil {
		return nil
	}
	return i.CompanyEmail
}

func (i *InvoicePlan) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePlan) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonSchema struct {
	// This is the type of output you'd like.
	//
	// `string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.
	//
	// `array` and `object` are more interesting and quite powerful. They allow you to define nested structures.
	//
	// For `array`, you can define the schema of the items in the array using the `items` property.
	//
	// For `object`, you can define the properties of the object using the `properties` property.
	Type JsonSchemaType `json:"type" url:"type"`
	// This is required if the type is "array". This is the schema of the items in the array.
	//
	// This is of type JsonSchema. However, Swagger doesn't support circular references.
	Items map[string]interface{} `json:"items,omitempty" url:"items,omitempty"`
	// This is required if the type is "object". This specifies the properties of the object.
	//
	// This is a map of string to JsonSchema. However, Swagger doesn't support circular references.
	Properties map[string]interface{} `json:"properties,omitempty" url:"properties,omitempty"`
	// This is the description to help the model understand what it needs to output.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is a list of properties that are required.
	//
	// This only makes sense if the type is "object".
	Required []string `json:"required,omitempty" url:"required,omitempty"`
	// This is a regex that will be used to validate data in question.
	Regex *string `json:"regex,omitempty" url:"regex,omitempty"`
	// This the value that will be used in filling the property.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// This the target variable that will be filled with the value of this property.
	Target *string `json:"target,omitempty" url:"target,omitempty"`
	// This array specifies the allowed values that can be used to restrict the output of the model.
	Enum []string `json:"enum,omitempty" url:"enum,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JsonSchema) GetType() JsonSchemaType {
	if j == nil {
		return ""
	}
	return j.Type
}

func (j *JsonSchema) GetItems() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.Items
}

func (j *JsonSchema) GetProperties() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.Properties
}

func (j *JsonSchema) GetDescription() *string {
	if j == nil {
		return nil
	}
	return j.Description
}

func (j *JsonSchema) GetRequired() []string {
	if j == nil {
		return nil
	}
	return j.Required
}

func (j *JsonSchema) GetRegex() *string {
	if j == nil {
		return nil
	}
	return j.Regex
}

func (j *JsonSchema) GetValue() *string {
	if j == nil {
		return nil
	}
	return j.Value
}

func (j *JsonSchema) GetTarget() *string {
	if j == nil {
		return nil
	}
	return j.Target
}

func (j *JsonSchema) GetEnum() []string {
	if j == nil {
		return nil
	}
	return j.Enum
}

func (j *JsonSchema) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonSchema) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// This is the type of output you'd like.
//
// `string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.
//
// `array` and `object` are more interesting and quite powerful. They allow you to define nested structures.
//
// For `array`, you can define the schema of the items in the array using the `items` property.
//
// For `object`, you can define the properties of the object using the `properties` property.
type JsonSchemaType string

const (
	JsonSchemaTypeString  JsonSchemaType = "string"
	JsonSchemaTypeNumber  JsonSchemaType = "number"
	JsonSchemaTypeInteger JsonSchemaType = "integer"
	JsonSchemaTypeBoolean JsonSchemaType = "boolean"
	JsonSchemaTypeArray   JsonSchemaType = "array"
	JsonSchemaTypeObject  JsonSchemaType = "object"
)

func NewJsonSchemaTypeFromString(s string) (JsonSchemaType, error) {
	switch s {
	case "string":
		return JsonSchemaTypeString, nil
	case "number":
		return JsonSchemaTypeNumber, nil
	case "integer":
		return JsonSchemaTypeInteger, nil
	case "boolean":
		return JsonSchemaTypeBoolean, nil
	case "array":
		return JsonSchemaTypeArray, nil
	case "object":
		return JsonSchemaTypeObject, nil
	}
	var t JsonSchemaType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonSchemaType) Ptr() *JsonSchemaType {
	return &j
}

type JwtResponse struct {
	AccessToken string                 `json:"accessToken" url:"accessToken"`
	Aud         map[string]interface{} `json:"aud,omitempty" url:"aud,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JwtResponse) GetAccessToken() string {
	if j == nil {
		return ""
	}
	return j.AccessToken
}

func (j *JwtResponse) GetAud() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.Aud
}

func (j *JwtResponse) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JwtResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler JwtResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JwtResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JwtResponse) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type KeypadInputPlan struct {
	// This keeps track of whether the user has enabled keypad input.
	// By default, it is off.
	//
	// @default false
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the time in seconds to wait before processing the input.
	// If the input is not received within this time, the input will be ignored.
	// If set to "off", the input will be processed when the user enters a delimiter or immediately if no delimiter is used.
	//
	// @default 2
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// This is the delimiter(s) that will be used to process the input.
	// Can be '#', '*', or an empty array.
	Delimiters *KeypadInputPlanDelimiters `json:"delimiters,omitempty" url:"delimiters,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeypadInputPlan) GetEnabled() *bool {
	if k == nil {
		return nil
	}
	return k.Enabled
}

func (k *KeypadInputPlan) GetTimeoutSeconds() *float64 {
	if k == nil {
		return nil
	}
	return k.TimeoutSeconds
}

func (k *KeypadInputPlan) GetDelimiters() *KeypadInputPlanDelimiters {
	if k == nil {
		return nil
	}
	return k.Delimiters
}

func (k *KeypadInputPlan) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeypadInputPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler KeypadInputPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeypadInputPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeypadInputPlan) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// This is the delimiter(s) that will be used to process the input.
// Can be '#', '*', or an empty array.
type KeypadInputPlanDelimiters string

const (
	KeypadInputPlanDelimitersHash     KeypadInputPlanDelimiters = "#"
	KeypadInputPlanDelimitersAsterisk KeypadInputPlanDelimiters = "*"
	KeypadInputPlanDelimitersEmpty    KeypadInputPlanDelimiters = ""
)

func NewKeypadInputPlanDelimitersFromString(s string) (KeypadInputPlanDelimiters, error) {
	switch s {
	case "#":
		return KeypadInputPlanDelimitersHash, nil
	case "*":
		return KeypadInputPlanDelimitersAsterisk, nil
	case "":
		return KeypadInputPlanDelimitersEmpty, nil
	}
	var t KeypadInputPlanDelimiters
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KeypadInputPlanDelimiters) Ptr() *KeypadInputPlanDelimiters {
	return &k
}

type KnowledgeBase struct {
	// The name of the knowledge base
	Name string `json:"name" url:"name"`
	// The provider of the knowledge base
	// The model to use for the knowledge base
	Model *KnowledgeBaseModel `json:"model,omitempty" url:"model,omitempty"`
	// A description of the knowledge base
	Description string `json:"description" url:"description"`
	// The file IDs associated with this knowledge base
	FileIds  []string `json:"fileIds,omitempty" url:"fileIds,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBase) GetName() string {
	if k == nil {
		return ""
	}
	return k.Name
}

func (k *KnowledgeBase) GetModel() *KnowledgeBaseModel {
	if k == nil {
		return nil
	}
	return k.Model
}

func (k *KnowledgeBase) GetDescription() string {
	if k == nil {
		return ""
	}
	return k.Description
}

func (k *KnowledgeBase) GetFileIds() []string {
	if k == nil {
		return nil
	}
	return k.FileIds
}

func (k *KnowledgeBase) Provider() string {
	return k.provider
}

func (k *KnowledgeBase) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBase) UnmarshalJSON(data []byte) error {
	type embed KnowledgeBase
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeBase(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", k, "google", unmarshaler.Provider)
	}
	k.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *k, "provider")
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBase) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBase
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*k),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (k *KnowledgeBase) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// The model to use for the knowledge base
type KnowledgeBaseModel string

const (
	KnowledgeBaseModelGemini25ProPreview0506       KnowledgeBaseModel = "gemini-2.5-pro-preview-05-06"
	KnowledgeBaseModelGemini25FlashPreview0417     KnowledgeBaseModel = "gemini-2.5-flash-preview-04-17"
	KnowledgeBaseModelGemini20FlashThinkingExp     KnowledgeBaseModel = "gemini-2.0-flash-thinking-exp"
	KnowledgeBaseModelGemini20ProExp0205           KnowledgeBaseModel = "gemini-2.0-pro-exp-02-05"
	KnowledgeBaseModelGemini20Flash                KnowledgeBaseModel = "gemini-2.0-flash"
	KnowledgeBaseModelGemini20FlashLite            KnowledgeBaseModel = "gemini-2.0-flash-lite"
	KnowledgeBaseModelGemini20FlashLitePreview0205 KnowledgeBaseModel = "gemini-2.0-flash-lite-preview-02-05"
	KnowledgeBaseModelGemini20FlashExp             KnowledgeBaseModel = "gemini-2.0-flash-exp"
	KnowledgeBaseModelGemini20FlashRealtimeExp     KnowledgeBaseModel = "gemini-2.0-flash-realtime-exp"
	KnowledgeBaseModelGemini15Flash                KnowledgeBaseModel = "gemini-1.5-flash"
	KnowledgeBaseModelGemini15Flash002             KnowledgeBaseModel = "gemini-1.5-flash-002"
	KnowledgeBaseModelGemini15Pro                  KnowledgeBaseModel = "gemini-1.5-pro"
	KnowledgeBaseModelGemini15Pro002               KnowledgeBaseModel = "gemini-1.5-pro-002"
	KnowledgeBaseModelGemini10Pro                  KnowledgeBaseModel = "gemini-1.0-pro"
)

func NewKnowledgeBaseModelFromString(s string) (KnowledgeBaseModel, error) {
	switch s {
	case "gemini-2.5-pro-preview-05-06":
		return KnowledgeBaseModelGemini25ProPreview0506, nil
	case "gemini-2.5-flash-preview-04-17":
		return KnowledgeBaseModelGemini25FlashPreview0417, nil
	case "gemini-2.0-flash-thinking-exp":
		return KnowledgeBaseModelGemini20FlashThinkingExp, nil
	case "gemini-2.0-pro-exp-02-05":
		return KnowledgeBaseModelGemini20ProExp0205, nil
	case "gemini-2.0-flash":
		return KnowledgeBaseModelGemini20Flash, nil
	case "gemini-2.0-flash-lite":
		return KnowledgeBaseModelGemini20FlashLite, nil
	case "gemini-2.0-flash-lite-preview-02-05":
		return KnowledgeBaseModelGemini20FlashLitePreview0205, nil
	case "gemini-2.0-flash-exp":
		return KnowledgeBaseModelGemini20FlashExp, nil
	case "gemini-2.0-flash-realtime-exp":
		return KnowledgeBaseModelGemini20FlashRealtimeExp, nil
	case "gemini-1.5-flash":
		return KnowledgeBaseModelGemini15Flash, nil
	case "gemini-1.5-flash-002":
		return KnowledgeBaseModelGemini15Flash002, nil
	case "gemini-1.5-pro":
		return KnowledgeBaseModelGemini15Pro, nil
	case "gemini-1.5-pro-002":
		return KnowledgeBaseModelGemini15Pro002, nil
	case "gemini-1.0-pro":
		return KnowledgeBaseModelGemini10Pro, nil
	}
	var t KnowledgeBaseModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeBaseModel) Ptr() *KnowledgeBaseModel {
	return &k
}

type KnowledgeBaseResponseDocument struct {
	// This is the content of the document.
	Content string `json:"content" url:"content"`
	// This is the similarity score of the document.
	Similarity float64 `json:"similarity" url:"similarity"`
	// This is the uuid of the document.
	Uuid *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseResponseDocument) GetContent() string {
	if k == nil {
		return ""
	}
	return k.Content
}

func (k *KnowledgeBaseResponseDocument) GetSimilarity() float64 {
	if k == nil {
		return 0
	}
	return k.Similarity
}

func (k *KnowledgeBaseResponseDocument) GetUuid() *string {
	if k == nil {
		return nil
	}
	return k.Uuid
}

func (k *KnowledgeBaseResponseDocument) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseResponseDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseResponseDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseResponseDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseResponseDocument) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// This is the provider-specific ID that will be used.
type LmntVoiceId struct {
	LmntVoiceIdEnum LmntVoiceIdEnum
	String          string

	typ string
}

func (l *LmntVoiceId) GetLmntVoiceIdEnum() LmntVoiceIdEnum {
	if l == nil {
		return ""
	}
	return l.LmntVoiceIdEnum
}

func (l *LmntVoiceId) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LmntVoiceId) UnmarshalJSON(data []byte) error {
	var valueLmntVoiceIdEnum LmntVoiceIdEnum
	if err := json.Unmarshal(data, &valueLmntVoiceIdEnum); err == nil {
		l.typ = "LmntVoiceIdEnum"
		l.LmntVoiceIdEnum = valueLmntVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LmntVoiceId) MarshalJSON() ([]byte, error) {
	if l.typ == "LmntVoiceIdEnum" || l.LmntVoiceIdEnum != "" {
		return json.Marshal(l.LmntVoiceIdEnum)
	}
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LmntVoiceIdVisitor interface {
	VisitLmntVoiceIdEnum(LmntVoiceIdEnum) error
	VisitString(string) error
}

func (l *LmntVoiceId) Accept(visitor LmntVoiceIdVisitor) error {
	if l.typ == "LmntVoiceIdEnum" || l.LmntVoiceIdEnum != "" {
		return visitor.VisitLmntVoiceIdEnum(l.LmntVoiceIdEnum)
	}
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LmntVoiceIdEnum string

const (
	LmntVoiceIdEnumLily   LmntVoiceIdEnum = "lily"
	LmntVoiceIdEnumDaniel LmntVoiceIdEnum = "daniel"
)

func NewLmntVoiceIdEnumFromString(s string) (LmntVoiceIdEnum, error) {
	switch s {
	case "lily":
		return LmntVoiceIdEnumLily, nil
	case "daniel":
		return LmntVoiceIdEnumDaniel, nil
	}
	var t LmntVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LmntVoiceIdEnum) Ptr() *LmntVoiceIdEnum {
	return &l
}

type LangfuseCredential struct {
	// The public key for Langfuse project. Eg: pk-lf-...
	PublicKey string `json:"publicKey" url:"publicKey"`
	// The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// The host URL for Langfuse project. Eg: https://cloud.langfuse.com
	ApiUrl string `json:"apiUrl" url:"apiUrl"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LangfuseCredential) GetPublicKey() string {
	if l == nil {
		return ""
	}
	return l.PublicKey
}

func (l *LangfuseCredential) GetApiKey() string {
	if l == nil {
		return ""
	}
	return l.ApiKey
}

func (l *LangfuseCredential) GetApiUrl() string {
	if l == nil {
		return ""
	}
	return l.ApiUrl
}

func (l *LangfuseCredential) GetId() string {
	if l == nil {
		return ""
	}
	return l.Id
}

func (l *LangfuseCredential) GetOrgId() string {
	if l == nil {
		return ""
	}
	return l.OrgId
}

func (l *LangfuseCredential) GetCreatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.CreatedAt
}

func (l *LangfuseCredential) GetUpdatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.UpdatedAt
}

func (l *LangfuseCredential) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LangfuseCredential) Provider() string {
	return l.provider
}

func (l *LangfuseCredential) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LangfuseCredential) UnmarshalJSON(data []byte) error {
	type embed LangfuseCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LangfuseCredential(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.Time()
	l.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "langfuse" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "langfuse", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LangfuseCredential) MarshalJSON() ([]byte, error) {
	type embed LangfuseCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*l),
		CreatedAt: internal.NewDateTime(l.CreatedAt),
		UpdatedAt: internal.NewDateTime(l.UpdatedAt),
		Provider:  "langfuse",
	}
	return json.Marshal(marshaler)
}

func (l *LangfuseCredential) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LangfuseObservabilityPlan struct {
	// This is an array of tags to be added to the Langfuse trace. Tags allow you to categorize and filter traces. https://langfuse.com/docs/tracing-features/tags
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// This is a JSON object that will be added to the Langfuse trace. Traces can be enriched with metadata to better understand your users, application, and experiments. https://langfuse.com/docs/tracing-features/metadata
	// By default it includes the call metadata, assistant metadata, and assistant overrides.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LangfuseObservabilityPlan) GetTags() []string {
	if l == nil {
		return nil
	}
	return l.Tags
}

func (l *LangfuseObservabilityPlan) GetMetadata() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.Metadata
}

func (l *LangfuseObservabilityPlan) Provider() string {
	return l.provider
}

func (l *LangfuseObservabilityPlan) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LangfuseObservabilityPlan) UnmarshalJSON(data []byte) error {
	type embed LangfuseObservabilityPlan
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LangfuseObservabilityPlan(unmarshaler.embed)
	if unmarshaler.Provider != "langfuse" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "langfuse", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LangfuseObservabilityPlan) MarshalJSON() ([]byte, error) {
	type embed LangfuseObservabilityPlan
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*l),
		Provider: "langfuse",
	}
	return json.Marshal(marshaler)
}

func (l *LangfuseObservabilityPlan) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LivekitSmartEndpointingPlan struct {
	// This is the provider for the smart endpointing plan.
	Provider LivekitSmartEndpointingPlanProvider `json:"provider" url:"provider"`
	// This expression describes how long the bot will wait to start speaking based on the likelihood that the user has reached an endpoint.
	//
	// This is a millisecond valued function. It maps probabilities (real numbers on [0,1]) to milliseconds that the bot should wait before speaking ([0, \infty]). Any negative values that are returned are set to zero (the bot can't start talking in the past).
	//
	// A probability of zero represents very high confidence that the caller has stopped speaking, and would like the bot to speak to them. A probability of one represents very high confidence that the caller is still speaking.
	//
	// Under the hood, this is parsed into a mathjs expression. Whatever you use to write your expression needs to be valid with respect to mathjs
	//
	// @default "20 + 500 * sqrt(x) + 2500 * x^3"
	WaitFunction *string `json:"waitFunction,omitempty" url:"waitFunction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LivekitSmartEndpointingPlan) GetProvider() LivekitSmartEndpointingPlanProvider {
	if l == nil {
		return ""
	}
	return l.Provider
}

func (l *LivekitSmartEndpointingPlan) GetWaitFunction() *string {
	if l == nil {
		return nil
	}
	return l.WaitFunction
}

func (l *LivekitSmartEndpointingPlan) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LivekitSmartEndpointingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler LivekitSmartEndpointingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LivekitSmartEndpointingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LivekitSmartEndpointingPlan) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// This is the provider for the smart endpointing plan.
type LivekitSmartEndpointingPlanProvider string

const (
	LivekitSmartEndpointingPlanProviderVapi    LivekitSmartEndpointingPlanProvider = "vapi"
	LivekitSmartEndpointingPlanProviderLivekit LivekitSmartEndpointingPlanProvider = "livekit"
)

func NewLivekitSmartEndpointingPlanProviderFromString(s string) (LivekitSmartEndpointingPlanProvider, error) {
	switch s {
	case "vapi":
		return LivekitSmartEndpointingPlanProviderVapi, nil
	case "livekit":
		return LivekitSmartEndpointingPlanProviderLivekit, nil
	}
	var t LivekitSmartEndpointingPlanProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LivekitSmartEndpointingPlanProvider) Ptr() *LivekitSmartEndpointingPlanProvider {
	return &l
}

type LmntCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LmntCredential) GetApiKey() string {
	if l == nil {
		return ""
	}
	return l.ApiKey
}

func (l *LmntCredential) GetId() string {
	if l == nil {
		return ""
	}
	return l.Id
}

func (l *LmntCredential) GetOrgId() string {
	if l == nil {
		return ""
	}
	return l.OrgId
}

func (l *LmntCredential) GetCreatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.CreatedAt
}

func (l *LmntCredential) GetUpdatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.UpdatedAt
}

func (l *LmntCredential) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LmntCredential) Provider() string {
	return l.provider
}

func (l *LmntCredential) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LmntCredential) UnmarshalJSON(data []byte) error {
	type embed LmntCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LmntCredential(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.Time()
	l.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "lmnt", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LmntCredential) MarshalJSON() ([]byte, error) {
	type embed LmntCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*l),
		CreatedAt: internal.NewDateTime(l.CreatedAt),
		UpdatedAt: internal.NewDateTime(l.UpdatedAt),
		Provider:  "lmnt",
	}
	return json.Marshal(marshaler)
}

func (l *LmntCredential) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LmntVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *LmntVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LmntVoice) GetCachingEnabled() *bool {
	if l == nil {
		return nil
	}
	return l.CachingEnabled
}

func (l *LmntVoice) GetVoiceId() *LmntVoiceId {
	if l == nil {
		return nil
	}
	return l.VoiceId
}

func (l *LmntVoice) GetSpeed() *float64 {
	if l == nil {
		return nil
	}
	return l.Speed
}

func (l *LmntVoice) GetChunkPlan() *ChunkPlan {
	if l == nil {
		return nil
	}
	return l.ChunkPlan
}

func (l *LmntVoice) GetFallbackPlan() *FallbackPlan {
	if l == nil {
		return nil
	}
	return l.FallbackPlan
}

func (l *LmntVoice) Provider() string {
	return l.provider
}

func (l *LmntVoice) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LmntVoice) UnmarshalJSON(data []byte) error {
	type embed LmntVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LmntVoice(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "lmnt", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LmntVoice) MarshalJSON() ([]byte, error) {
	type embed LmntVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*l),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (l *LmntVoice) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LogicEdgeCondition struct {
	Liquid string `json:"liquid" url:"liquid"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogicEdgeCondition) GetLiquid() string {
	if l == nil {
		return ""
	}
	return l.Liquid
}

func (l *LogicEdgeCondition) Type() string {
	return l.type_
}

func (l *LogicEdgeCondition) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogicEdgeCondition) UnmarshalJSON(data []byte) error {
	type embed LogicEdgeCondition
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LogicEdgeCondition(unmarshaler.embed)
	if unmarshaler.Type != "logic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "logic", unmarshaler.Type)
	}
	l.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "type")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogicEdgeCondition) MarshalJSON() ([]byte, error) {
	type embed LogicEdgeCondition
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*l),
		Type:  "logic",
	}
	return json.Marshal(marshaler)
}

func (l *LogicEdgeCondition) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MakeCredential struct {
	// Team ID
	TeamId string `json:"teamId" url:"teamId"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region string `json:"region" url:"region"`
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeCredential) GetTeamId() string {
	if m == nil {
		return ""
	}
	return m.TeamId
}

func (m *MakeCredential) GetRegion() string {
	if m == nil {
		return ""
	}
	return m.Region
}

func (m *MakeCredential) GetApiKey() string {
	if m == nil {
		return ""
	}
	return m.ApiKey
}

func (m *MakeCredential) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *MakeCredential) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *MakeCredential) GetCreatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.CreatedAt
}

func (m *MakeCredential) GetUpdatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.UpdatedAt
}

func (m *MakeCredential) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MakeCredential) Provider() string {
	return m.provider
}

func (m *MakeCredential) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeCredential) UnmarshalJSON(data []byte) error {
	type embed MakeCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeCredential(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Provider)
	}
	m.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "provider")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeCredential) MarshalJSON() ([]byte, error) {
	type embed MakeCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*m),
		CreatedAt: internal.NewDateTime(m.CreatedAt),
		UpdatedAt: internal.NewDateTime(m.UpdatedAt),
		Provider:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeCredential) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "make" for Make tool.
	ScenarioId      *float64 `json:"scenarioId,omitempty" url:"scenarioId,omitempty"`
	ScenarioName    *string  `json:"scenarioName,omitempty" url:"scenarioName,omitempty"`
	TriggerHookId   *float64 `json:"triggerHookId,omitempty" url:"triggerHookId,omitempty"`
	TriggerHookName *string  `json:"triggerHookName,omitempty" url:"triggerHookName,omitempty"`
	type_           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeToolProviderDetails) GetTemplateUrl() *string {
	if m == nil {
		return nil
	}
	return m.TemplateUrl
}

func (m *MakeToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if m == nil {
		return nil
	}
	return m.SetupInstructions
}

func (m *MakeToolProviderDetails) GetScenarioId() *float64 {
	if m == nil {
		return nil
	}
	return m.ScenarioId
}

func (m *MakeToolProviderDetails) GetScenarioName() *string {
	if m == nil {
		return nil
	}
	return m.ScenarioName
}

func (m *MakeToolProviderDetails) GetTriggerHookId() *float64 {
	if m == nil {
		return nil
	}
	return m.TriggerHookId
}

func (m *MakeToolProviderDetails) GetTriggerHookName() *string {
	if m == nil {
		return nil
	}
	return m.TriggerHookName
}

func (m *MakeToolProviderDetails) Type() string {
	return m.type_
}

func (m *MakeToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed MakeToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed MakeToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeToolProviderDetails) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*MakeToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "make" for Make tool.
	ToolCall *ToolCall         `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	Metadata *MakeToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeToolWithToolCall) GetAsync() *bool {
	if m == nil {
		return nil
	}
	return m.Async
}

func (m *MakeToolWithToolCall) GetMessages() []*MakeToolWithToolCallMessagesItem {
	if m == nil {
		return nil
	}
	return m.Messages
}

func (m *MakeToolWithToolCall) GetToolCall() *ToolCall {
	if m == nil {
		return nil
	}
	return m.ToolCall
}

func (m *MakeToolWithToolCall) GetMetadata() *MakeToolMetadata {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *MakeToolWithToolCall) GetFunction() *OpenAiFunction {
	if m == nil {
		return nil
	}
	return m.Function
}

func (m *MakeToolWithToolCall) GetServer() *Server {
	if m == nil {
		return nil
	}
	return m.Server
}

func (m *MakeToolWithToolCall) Type() string {
	return m.type_
}

func (m *MakeToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed MakeToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed MakeToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeToolWithToolCall) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if m == nil {
		return nil
	}
	return m.ToolMessageStart
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if m == nil {
		return nil
	}
	return m.ToolMessageComplete
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if m == nil {
		return nil
	}
	return m.ToolMessageFailed
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if m == nil {
		return nil
	}
	return m.ToolMessageDelayed
}

func (m *MakeToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		m.typ = "ToolMessageStart"
		m.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		m.typ = "ToolMessageComplete"
		m.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		m.typ = "ToolMessageFailed"
		m.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		m.typ = "ToolMessageDelayed"
		m.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MakeToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return json.Marshal(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return json.Marshal(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return json.Marshal(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return json.Marshal(m.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MakeToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (m *MakeToolWithToolCallMessagesItem) Accept(visitor MakeToolWithToolCallMessagesItemVisitor) error {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(m.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessagePlan struct {
	// This are the messages that the assistant will speak when the user hasn't responded for `idleTimeoutSeconds`. Each time the timeout is triggered, a random message will be chosen from this array.
	//
	// Usage:
	// - If user gets distracted and doesn't respond for a while, this can be used to grab their attention.
	// - If the transcriber doesn't pick up what the user said, this can be used to ask the user to repeat themselves. (From the perspective of the assistant, the conversation is idle since it didn't "hear" any user messages.)
	//
	// @default null (no idle message is spoken)
	IdleMessages []string `json:"idleMessages,omitempty" url:"idleMessages,omitempty"`
	// This determines the maximum number of times `idleMessages` can be spoken during the call.
	//
	// @default 3
	IdleMessageMaxSpokenCount *float64 `json:"idleMessageMaxSpokenCount,omitempty" url:"idleMessageMaxSpokenCount,omitempty"`
	// This determines whether the idle message count is reset whenever the user speaks.
	//
	// @default false
	IdleMessageResetCountOnUserSpeechEnabled *bool `json:"idleMessageResetCountOnUserSpeechEnabled,omitempty" url:"idleMessageResetCountOnUserSpeechEnabled,omitempty"`
	// This is the timeout in seconds before a message from `idleMessages` is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks.
	//
	// @default 10
	IdleTimeoutSeconds *float64 `json:"idleTimeoutSeconds,omitempty" url:"idleTimeoutSeconds,omitempty"`
	// This is the message that the assistant will say if the call ends due to silence.
	//
	// If unspecified, it will hang up without saying anything.
	SilenceTimeoutMessage *string `json:"silenceTimeoutMessage,omitempty" url:"silenceTimeoutMessage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MessagePlan) GetIdleMessages() []string {
	if m == nil {
		return nil
	}
	return m.IdleMessages
}

func (m *MessagePlan) GetIdleMessageMaxSpokenCount() *float64 {
	if m == nil {
		return nil
	}
	return m.IdleMessageMaxSpokenCount
}

func (m *MessagePlan) GetIdleMessageResetCountOnUserSpeechEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.IdleMessageResetCountOnUserSpeechEnabled
}

func (m *MessagePlan) GetIdleTimeoutSeconds() *float64 {
	if m == nil {
		return nil
	}
	return m.IdleTimeoutSeconds
}

func (m *MessagePlan) GetSilenceTimeoutMessage() *string {
	if m == nil {
		return nil
	}
	return m.SilenceTimeoutMessage
}

func (m *MessagePlan) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MessagePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler MessagePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessagePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessagePlan) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Metrics struct {
	OrgId                            string                 `json:"orgId" url:"orgId"`
	RangeStart                       string                 `json:"rangeStart" url:"rangeStart"`
	RangeEnd                         string                 `json:"rangeEnd" url:"rangeEnd"`
	Bill                             float64                `json:"bill" url:"bill"`
	BillWithinBillingLimit           bool                   `json:"billWithinBillingLimit" url:"billWithinBillingLimit"`
	BillDailyBreakdown               map[string]interface{} `json:"billDailyBreakdown,omitempty" url:"billDailyBreakdown,omitempty"`
	CallActive                       float64                `json:"callActive" url:"callActive"`
	CallActiveWithinConcurrencyLimit bool                   `json:"callActiveWithinConcurrencyLimit" url:"callActiveWithinConcurrencyLimit"`
	CallMinutes                      float64                `json:"callMinutes" url:"callMinutes"`
	CallMinutesDailyBreakdown        map[string]interface{} `json:"callMinutesDailyBreakdown,omitempty" url:"callMinutesDailyBreakdown,omitempty"`
	CallMinutesAverage               float64                `json:"callMinutesAverage" url:"callMinutesAverage"`
	CallMinutesAverageDailyBreakdown map[string]interface{} `json:"callMinutesAverageDailyBreakdown,omitempty" url:"callMinutesAverageDailyBreakdown,omitempty"`
	CallCount                        float64                `json:"callCount" url:"callCount"`
	CallCountDailyBreakdown          map[string]interface{} `json:"callCountDailyBreakdown,omitempty" url:"callCountDailyBreakdown,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Metrics) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *Metrics) GetRangeStart() string {
	if m == nil {
		return ""
	}
	return m.RangeStart
}

func (m *Metrics) GetRangeEnd() string {
	if m == nil {
		return ""
	}
	return m.RangeEnd
}

func (m *Metrics) GetBill() float64 {
	if m == nil {
		return 0
	}
	return m.Bill
}

func (m *Metrics) GetBillWithinBillingLimit() bool {
	if m == nil {
		return false
	}
	return m.BillWithinBillingLimit
}

func (m *Metrics) GetBillDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.BillDailyBreakdown
}

func (m *Metrics) GetCallActive() float64 {
	if m == nil {
		return 0
	}
	return m.CallActive
}

func (m *Metrics) GetCallActiveWithinConcurrencyLimit() bool {
	if m == nil {
		return false
	}
	return m.CallActiveWithinConcurrencyLimit
}

func (m *Metrics) GetCallMinutes() float64 {
	if m == nil {
		return 0
	}
	return m.CallMinutes
}

func (m *Metrics) GetCallMinutesDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.CallMinutesDailyBreakdown
}

func (m *Metrics) GetCallMinutesAverage() float64 {
	if m == nil {
		return 0
	}
	return m.CallMinutesAverage
}

func (m *Metrics) GetCallMinutesAverageDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.CallMinutesAverageDailyBreakdown
}

func (m *Metrics) GetCallCount() float64 {
	if m == nil {
		return 0
	}
	return m.CallCount
}

func (m *Metrics) GetCallCountDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.CallCountDailyBreakdown
}

func (m *Metrics) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metrics) UnmarshalJSON(data []byte) error {
	type unmarshaler Metrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metrics(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metrics) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MistralCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MistralCredential) GetApiKey() string {
	if m == nil {
		return ""
	}
	return m.ApiKey
}

func (m *MistralCredential) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *MistralCredential) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *MistralCredential) GetCreatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.CreatedAt
}

func (m *MistralCredential) GetUpdatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.UpdatedAt
}

func (m *MistralCredential) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MistralCredential) Provider() string {
	return m.provider
}

func (m *MistralCredential) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MistralCredential) UnmarshalJSON(data []byte) error {
	type embed MistralCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MistralCredential(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "mistral" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "mistral", unmarshaler.Provider)
	}
	m.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "provider")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MistralCredential) MarshalJSON() ([]byte, error) {
	type embed MistralCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*m),
		CreatedAt: internal.NewDateTime(m.CreatedAt),
		UpdatedAt: internal.NewDateTime(m.UpdatedAt),
		Provider:  "mistral",
	}
	return json.Marshal(marshaler)
}

func (m *MistralCredential) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MonitorPlan struct {
	// This determines whether the assistant's calls allow live listening. Defaults to true.
	//
	// Fetch `call.monitor.listenUrl` to get the live listening URL.
	//
	// @default true
	ListenEnabled *bool `json:"listenEnabled,omitempty" url:"listenEnabled,omitempty"`
	// This enables authentication on the `call.monitor.listenUrl`.
	//
	// If `listenAuthenticationEnabled` is `true`, the `call.monitor.listenUrl` will require an `Authorization: Bearer <vapi-public-api-key>` header.
	//
	// @default false
	ListenAuthenticationEnabled *bool `json:"listenAuthenticationEnabled,omitempty" url:"listenAuthenticationEnabled,omitempty"`
	// This determines whether the assistant's calls allow live control. Defaults to true.
	//
	// Fetch `call.monitor.controlUrl` to get the live control URL.
	//
	// To use, send any control message via a POST request to `call.monitor.controlUrl`. Here are the types of controls supported: https://docs.vapi.ai/api-reference/messages/client-inbound-message
	//
	// @default true
	ControlEnabled *bool `json:"controlEnabled,omitempty" url:"controlEnabled,omitempty"`
	// This enables authentication on the `call.monitor.controlUrl`.
	//
	// If `controlAuthenticationEnabled` is `true`, the `call.monitor.controlUrl` will require an `Authorization: Bearer <vapi-public-api-key>` header.
	//
	// @default false
	ControlAuthenticationEnabled *bool `json:"controlAuthenticationEnabled,omitempty" url:"controlAuthenticationEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MonitorPlan) GetListenEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.ListenEnabled
}

func (m *MonitorPlan) GetListenAuthenticationEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.ListenAuthenticationEnabled
}

func (m *MonitorPlan) GetControlEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.ControlEnabled
}

func (m *MonitorPlan) GetControlAuthenticationEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.ControlAuthenticationEnabled
}

func (m *MonitorPlan) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MonitorPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler MonitorPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MonitorPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MonitorPlan) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Mono struct {
	// This is the combined recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	CombinedUrl *string `json:"combinedUrl,omitempty" url:"combinedUrl,omitempty"`
	// This is the mono recording url for the assistant. To enable, set `assistant.artifactPlan.recordingEnabled`.
	AssistantUrl *string `json:"assistantUrl,omitempty" url:"assistantUrl,omitempty"`
	// This is the mono recording url for the customer. To enable, set `assistant.artifactPlan.recordingEnabled`.
	CustomerUrl *string `json:"customerUrl,omitempty" url:"customerUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Mono) GetCombinedUrl() *string {
	if m == nil {
		return nil
	}
	return m.CombinedUrl
}

func (m *Mono) GetAssistantUrl() *string {
	if m == nil {
		return nil
	}
	return m.AssistantUrl
}

func (m *Mono) GetCustomerUrl() *string {
	if m == nil {
		return nil
	}
	return m.CustomerUrl
}

func (m *Mono) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Mono) UnmarshalJSON(data []byte) error {
	type unmarshaler Mono
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Mono(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Mono) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NeetsVoice struct {
	VoiceId interface{} `json:"voiceId,omitempty" url:"voiceId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NeetsVoice) GetVoiceId() interface{} {
	if n == nil {
		return nil
	}
	return n.VoiceId
}

func (n *NeetsVoice) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NeetsVoice) UnmarshalJSON(data []byte) error {
	type unmarshaler NeetsVoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NeetsVoice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NeetsVoice) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NeuphonicCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NeuphonicCredential) GetApiKey() string {
	if n == nil {
		return ""
	}
	return n.ApiKey
}

func (n *NeuphonicCredential) GetId() string {
	if n == nil {
		return ""
	}
	return n.Id
}

func (n *NeuphonicCredential) GetOrgId() string {
	if n == nil {
		return ""
	}
	return n.OrgId
}

func (n *NeuphonicCredential) GetCreatedAt() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.CreatedAt
}

func (n *NeuphonicCredential) GetUpdatedAt() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.UpdatedAt
}

func (n *NeuphonicCredential) GetName() *string {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NeuphonicCredential) Provider() string {
	return n.provider
}

func (n *NeuphonicCredential) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NeuphonicCredential) UnmarshalJSON(data []byte) error {
	type embed NeuphonicCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NeuphonicCredential(unmarshaler.embed)
	n.CreatedAt = unmarshaler.CreatedAt.Time()
	n.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "neuphonic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "neuphonic", unmarshaler.Provider)
	}
	n.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *n, "provider")
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NeuphonicCredential) MarshalJSON() ([]byte, error) {
	type embed NeuphonicCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*n),
		CreatedAt: internal.NewDateTime(n.CreatedAt),
		UpdatedAt: internal.NewDateTime(n.UpdatedAt),
		Provider:  "neuphonic",
	}
	return json.Marshal(marshaler)
}

func (n *NeuphonicCredential) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NeuphonicVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the model that will be used. Defaults to 'neu_fast' if not specified.
	Model *NeuphonicVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language (ISO 639-1) that is enforced for the model.
	Language map[string]interface{} `json:"language,omitempty" url:"language,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NeuphonicVoice) GetCachingEnabled() *bool {
	if n == nil {
		return nil
	}
	return n.CachingEnabled
}

func (n *NeuphonicVoice) GetVoiceId() string {
	if n == nil {
		return ""
	}
	return n.VoiceId
}

func (n *NeuphonicVoice) GetModel() *NeuphonicVoiceModel {
	if n == nil {
		return nil
	}
	return n.Model
}

func (n *NeuphonicVoice) GetLanguage() map[string]interface{} {
	if n == nil {
		return nil
	}
	return n.Language
}

func (n *NeuphonicVoice) GetSpeed() *float64 {
	if n == nil {
		return nil
	}
	return n.Speed
}

func (n *NeuphonicVoice) GetChunkPlan() *ChunkPlan {
	if n == nil {
		return nil
	}
	return n.ChunkPlan
}

func (n *NeuphonicVoice) GetFallbackPlan() *FallbackPlan {
	if n == nil {
		return nil
	}
	return n.FallbackPlan
}

func (n *NeuphonicVoice) Provider() string {
	return n.provider
}

func (n *NeuphonicVoice) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NeuphonicVoice) UnmarshalJSON(data []byte) error {
	type embed NeuphonicVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NeuphonicVoice(unmarshaler.embed)
	if unmarshaler.Provider != "neuphonic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "neuphonic", unmarshaler.Provider)
	}
	n.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *n, "provider")
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NeuphonicVoice) MarshalJSON() ([]byte, error) {
	type embed NeuphonicVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*n),
		Provider: "neuphonic",
	}
	return json.Marshal(marshaler)
}

func (n *NeuphonicVoice) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// This is the model that will be used. Defaults to 'neu_fast' if not specified.
type NeuphonicVoiceModel string

const (
	NeuphonicVoiceModelNeuHq   NeuphonicVoiceModel = "neu_hq"
	NeuphonicVoiceModelNeuFast NeuphonicVoiceModel = "neu_fast"
)

func NewNeuphonicVoiceModelFromString(s string) (NeuphonicVoiceModel, error) {
	switch s {
	case "neu_hq":
		return NeuphonicVoiceModelNeuHq, nil
	case "neu_fast":
		return NeuphonicVoiceModelNeuFast, nil
	}
	var t NeuphonicVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NeuphonicVoiceModel) Ptr() *NeuphonicVoiceModel {
	return &n
}

type OAuth2AuthenticationPlan struct {
	Type OAuth2AuthenticationPlanType `json:"type" url:"type"`
	// This is the OAuth2 URL.
	Url string `json:"url" url:"url"`
	// This is the OAuth2 client ID.
	ClientId string `json:"clientId" url:"clientId"`
	// This is the OAuth2 client secret.
	ClientSecret string `json:"clientSecret" url:"clientSecret"`
	// This is the scope of the OAuth2 token.
	Scope *string `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OAuth2AuthenticationPlan) GetType() OAuth2AuthenticationPlanType {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *OAuth2AuthenticationPlan) GetUrl() string {
	if o == nil {
		return ""
	}
	return o.Url
}

func (o *OAuth2AuthenticationPlan) GetClientId() string {
	if o == nil {
		return ""
	}
	return o.ClientId
}

func (o *OAuth2AuthenticationPlan) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *OAuth2AuthenticationPlan) GetScope() *string {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OAuth2AuthenticationPlan) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuth2AuthenticationPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuth2AuthenticationPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuth2AuthenticationPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuth2AuthenticationPlan) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OAuth2AuthenticationPlanType string

const (
	OAuth2AuthenticationPlanTypeOauth2 OAuth2AuthenticationPlanType = "oauth2"
	OAuth2AuthenticationPlanTypeAwsSts OAuth2AuthenticationPlanType = "aws-sts"
)

func NewOAuth2AuthenticationPlanTypeFromString(s string) (OAuth2AuthenticationPlanType, error) {
	switch s {
	case "oauth2":
		return OAuth2AuthenticationPlanTypeOauth2, nil
	case "aws-sts":
		return OAuth2AuthenticationPlanTypeAwsSts, nil
	}
	var t OAuth2AuthenticationPlanType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OAuth2AuthenticationPlanType) Ptr() *OAuth2AuthenticationPlanType {
	return &o
}

type Oauth2AuthenticationSession struct {
	// This is the OAuth2 access token.
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`
	// This is the OAuth2 access token expiration.
	ExpiresAt *time.Time `json:"expiresAt,omitempty" url:"expiresAt,omitempty"`
	// This is the OAuth2 refresh token.
	RefreshToken *string `json:"refreshToken,omitempty" url:"refreshToken,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Oauth2AuthenticationSession) GetAccessToken() *string {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *Oauth2AuthenticationSession) GetExpiresAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

func (o *Oauth2AuthenticationSession) GetRefreshToken() *string {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

func (o *Oauth2AuthenticationSession) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Oauth2AuthenticationSession) UnmarshalJSON(data []byte) error {
	type embed Oauth2AuthenticationSession
	var unmarshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Oauth2AuthenticationSession(unmarshaler.embed)
	o.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Oauth2AuthenticationSession) MarshalJSON() ([]byte, error) {
	type embed Oauth2AuthenticationSession
	var marshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed:     embed(*o),
		ExpiresAt: internal.NewOptionalDateTime(o.ExpiresAt),
	}
	return json.Marshal(marshaler)
}

func (o *Oauth2AuthenticationSession) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the provider-specific ID that will be used.
// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
type OpenAiVoiceId struct {
	OpenAiVoiceIdEnum OpenAiVoiceIdEnum
	String            string

	typ string
}

func (o *OpenAiVoiceId) GetOpenAiVoiceIdEnum() OpenAiVoiceIdEnum {
	if o == nil {
		return ""
	}
	return o.OpenAiVoiceIdEnum
}

func (o *OpenAiVoiceId) GetString() string {
	if o == nil {
		return ""
	}
	return o.String
}

func (o *OpenAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueOpenAiVoiceIdEnum OpenAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueOpenAiVoiceIdEnum); err == nil {
		o.typ = "OpenAiVoiceIdEnum"
		o.OpenAiVoiceIdEnum = valueOpenAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		o.typ = "String"
		o.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiVoiceId) MarshalJSON() ([]byte, error) {
	if o.typ == "OpenAiVoiceIdEnum" || o.OpenAiVoiceIdEnum != "" {
		return json.Marshal(o.OpenAiVoiceIdEnum)
	}
	if o.typ == "String" || o.String != "" {
		return json.Marshal(o.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiVoiceIdVisitor interface {
	VisitOpenAiVoiceIdEnum(OpenAiVoiceIdEnum) error
	VisitString(string) error
}

func (o *OpenAiVoiceId) Accept(visitor OpenAiVoiceIdVisitor) error {
	if o.typ == "OpenAiVoiceIdEnum" || o.OpenAiVoiceIdEnum != "" {
		return visitor.VisitOpenAiVoiceIdEnum(o.OpenAiVoiceIdEnum)
	}
	if o.typ == "String" || o.String != "" {
		return visitor.VisitString(o.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiVoiceIdEnum string

const (
	OpenAiVoiceIdEnumAlloy   OpenAiVoiceIdEnum = "alloy"
	OpenAiVoiceIdEnumEcho    OpenAiVoiceIdEnum = "echo"
	OpenAiVoiceIdEnumFable   OpenAiVoiceIdEnum = "fable"
	OpenAiVoiceIdEnumOnyx    OpenAiVoiceIdEnum = "onyx"
	OpenAiVoiceIdEnumNova    OpenAiVoiceIdEnum = "nova"
	OpenAiVoiceIdEnumShimmer OpenAiVoiceIdEnum = "shimmer"
)

func NewOpenAiVoiceIdEnumFromString(s string) (OpenAiVoiceIdEnum, error) {
	switch s {
	case "alloy":
		return OpenAiVoiceIdEnumAlloy, nil
	case "echo":
		return OpenAiVoiceIdEnumEcho, nil
	case "fable":
		return OpenAiVoiceIdEnumFable, nil
	case "onyx":
		return OpenAiVoiceIdEnumOnyx, nil
	case "nova":
		return OpenAiVoiceIdEnumNova, nil
	case "shimmer":
		return OpenAiVoiceIdEnumShimmer, nil
	}
	var t OpenAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiVoiceIdEnum) Ptr() *OpenAiVoiceIdEnum {
	return &o
}

type OpenAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiCredential) GetApiKey() string {
	if o == nil {
		return ""
	}
	return o.ApiKey
}

func (o *OpenAiCredential) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *OpenAiCredential) GetOrgId() string {
	if o == nil {
		return ""
	}
	return o.OrgId
}

func (o *OpenAiCredential) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *OpenAiCredential) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *OpenAiCredential) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OpenAiCredential) Provider() string {
	return o.provider
}

func (o *OpenAiCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiCredential) UnmarshalJSON(data []byte) error {
	type embed OpenAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiCredential(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiCredential) MarshalJSON() ([]byte, error) {
	type embed OpenAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*o),
		CreatedAt: internal.NewDateTime(o.CreatedAt),
		UpdatedAt: internal.NewDateTime(o.UpdatedAt),
		Provider:  "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiCredential) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiFunction struct {
	// This is a boolean that controls whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the parameters field. Only a subset of JSON Schema is supported when strict is true. Learn more about Structured Outputs in the [OpenAI guide](https://openai.com/index/introducing-structured-outputs-in-the-api/).
	//
	// @default false
	Strict *bool `json:"strict,omitempty" url:"strict,omitempty"`
	// This is the the name of the function to be called.
	//
	// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name" url:"name"`
	// This is the description of what the function does, used by the AI to choose when and how to call the function.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// These are the parameters the functions accepts, described as a JSON Schema object.
	//
	// See the [OpenAI guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema) for documentation about the format.
	//
	// Omitting parameters defines a function with an empty parameter list.
	Parameters *OpenAiFunctionParameters `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiFunction) GetStrict() *bool {
	if o == nil {
		return nil
	}
	return o.Strict
}

func (o *OpenAiFunction) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *OpenAiFunction) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OpenAiFunction) GetParameters() *OpenAiFunctionParameters {
	if o == nil {
		return nil
	}
	return o.Parameters
}

func (o *OpenAiFunction) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiFunction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiFunction) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiFunctionParameters struct {
	// This must be set to 'object'. It instructs the model to return a JSON object containing the function call properties.
	// This provides a description of the properties required by the function.
	// JSON Schema can be used to specify expectations for each property.
	// Refer to [this doc](https://ajv.js.org/json-schema.html#json-data-type) for a comprehensive guide on JSON Schema.
	Properties map[string]*JsonSchema `json:"properties,omitempty" url:"properties,omitempty"`
	// This specifies the properties that are required by the function.
	Required []string `json:"required,omitempty" url:"required,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiFunctionParameters) GetProperties() map[string]*JsonSchema {
	if o == nil {
		return nil
	}
	return o.Properties
}

func (o *OpenAiFunctionParameters) GetRequired() []string {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *OpenAiFunctionParameters) Type() string {
	return o.type_
}

func (o *OpenAiFunctionParameters) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiFunctionParameters) UnmarshalJSON(data []byte) error {
	type embed OpenAiFunctionParameters
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiFunctionParameters(unmarshaler.embed)
	if unmarshaler.Type != "object" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "object", unmarshaler.Type)
	}
	o.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "type")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiFunctionParameters) MarshalJSON() ([]byte, error) {
	type embed OpenAiFunctionParameters
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
		Type:  "object",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiFunctionParameters) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiMessage struct {
	Content *string           `json:"content,omitempty" url:"content,omitempty"`
	Role    OpenAiMessageRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiMessage) GetContent() *string {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *OpenAiMessage) GetRole() OpenAiMessageRole {
	if o == nil {
		return ""
	}
	return o.Role
}

func (o *OpenAiMessage) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiMessage) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiMessageRole string

const (
	OpenAiMessageRoleAssistant OpenAiMessageRole = "assistant"
	OpenAiMessageRoleFunction  OpenAiMessageRole = "function"
	OpenAiMessageRoleUser      OpenAiMessageRole = "user"
	OpenAiMessageRoleSystem    OpenAiMessageRole = "system"
	OpenAiMessageRoleTool      OpenAiMessageRole = "tool"
)

func NewOpenAiMessageRoleFromString(s string) (OpenAiMessageRole, error) {
	switch s {
	case "assistant":
		return OpenAiMessageRoleAssistant, nil
	case "function":
		return OpenAiMessageRoleFunction, nil
	case "user":
		return OpenAiMessageRoleUser, nil
	case "system":
		return OpenAiMessageRoleSystem, nil
	case "tool":
		return OpenAiMessageRoleTool, nil
	}
	var t OpenAiMessageRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiMessageRole) Ptr() *OpenAiMessageRole {
	return &o
}

type OpenAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*OpenAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the provider that will be used for the model.
	// This is the OpenAI model that will be used.
	Model OpenAiModelModel `json:"model" url:"model"`
	// These are the fallback models that will be used if the primary model fails. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest fallbacks that make sense.
	FallbackModels []OpenAiModelFallbackModelsItem `json:"fallbackModels,omitempty" url:"fallbackModels,omitempty"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiModel) GetMessages() []*OpenAiMessage {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *OpenAiModel) GetTools() []*OpenAiModelToolsItem {
	if o == nil {
		return nil
	}
	return o.Tools
}

func (o *OpenAiModel) GetToolIds() []string {
	if o == nil {
		return nil
	}
	return o.ToolIds
}

func (o *OpenAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if o == nil {
		return nil
	}
	return o.KnowledgeBase
}

func (o *OpenAiModel) GetKnowledgeBaseId() *string {
	if o == nil {
		return nil
	}
	return o.KnowledgeBaseId
}

func (o *OpenAiModel) GetModel() OpenAiModelModel {
	if o == nil {
		return ""
	}
	return o.Model
}

func (o *OpenAiModel) GetFallbackModels() []OpenAiModelFallbackModelsItem {
	if o == nil {
		return nil
	}
	return o.FallbackModels
}

func (o *OpenAiModel) GetTemperature() *float64 {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *OpenAiModel) GetMaxTokens() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxTokens
}

func (o *OpenAiModel) GetEmotionRecognitionEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.EmotionRecognitionEnabled
}

func (o *OpenAiModel) GetNumFastTurns() *float64 {
	if o == nil {
		return nil
	}
	return o.NumFastTurns
}

func (o *OpenAiModel) Provider() string {
	return o.provider
}

func (o *OpenAiModel) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiModel) UnmarshalJSON(data []byte) error {
	type embed OpenAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiModel) MarshalJSON() ([]byte, error) {
	type embed OpenAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiModel) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiModelFallbackModelsItem string

const (
	OpenAiModelFallbackModelsItemGpt41                            OpenAiModelFallbackModelsItem = "gpt-4.1"
	OpenAiModelFallbackModelsItemGpt41Mini                        OpenAiModelFallbackModelsItem = "gpt-4.1-mini"
	OpenAiModelFallbackModelsItemGpt41Nano                        OpenAiModelFallbackModelsItem = "gpt-4.1-nano"
	OpenAiModelFallbackModelsItemGpt45Preview                     OpenAiModelFallbackModelsItem = "gpt-4.5-preview"
	OpenAiModelFallbackModelsItemChatgpt4OLatest                  OpenAiModelFallbackModelsItem = "chatgpt-4o-latest"
	OpenAiModelFallbackModelsItemO3                               OpenAiModelFallbackModelsItem = "o3"
	OpenAiModelFallbackModelsItemO3Mini                           OpenAiModelFallbackModelsItem = "o3-mini"
	OpenAiModelFallbackModelsItemO4Mini                           OpenAiModelFallbackModelsItem = "o4-mini"
	OpenAiModelFallbackModelsItemO1Preview                        OpenAiModelFallbackModelsItem = "o1-preview"
	OpenAiModelFallbackModelsItemO1Preview20240912                OpenAiModelFallbackModelsItem = "o1-preview-2024-09-12"
	OpenAiModelFallbackModelsItemO1Mini                           OpenAiModelFallbackModelsItem = "o1-mini"
	OpenAiModelFallbackModelsItemO1Mini20240912                   OpenAiModelFallbackModelsItem = "o1-mini-2024-09-12"
	OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241001     OpenAiModelFallbackModelsItem = "gpt-4o-realtime-preview-2024-10-01"
	OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241217     OpenAiModelFallbackModelsItem = "gpt-4o-realtime-preview-2024-12-17"
	OpenAiModelFallbackModelsItemGpt4OMiniRealtimePreview20241217 OpenAiModelFallbackModelsItem = "gpt-4o-mini-realtime-preview-2024-12-17"
	OpenAiModelFallbackModelsItemGpt4OMini20240718                OpenAiModelFallbackModelsItem = "gpt-4o-mini-2024-07-18"
	OpenAiModelFallbackModelsItemGpt4OMini                        OpenAiModelFallbackModelsItem = "gpt-4o-mini"
	OpenAiModelFallbackModelsItemGpt4O                            OpenAiModelFallbackModelsItem = "gpt-4o"
	OpenAiModelFallbackModelsItemGpt4O20240513                    OpenAiModelFallbackModelsItem = "gpt-4o-2024-05-13"
	OpenAiModelFallbackModelsItemGpt4O20240806                    OpenAiModelFallbackModelsItem = "gpt-4o-2024-08-06"
	OpenAiModelFallbackModelsItemGpt4O20241120                    OpenAiModelFallbackModelsItem = "gpt-4o-2024-11-20"
	OpenAiModelFallbackModelsItemGpt4Turbo                        OpenAiModelFallbackModelsItem = "gpt-4-turbo"
	OpenAiModelFallbackModelsItemGpt4Turbo20240409                OpenAiModelFallbackModelsItem = "gpt-4-turbo-2024-04-09"
	OpenAiModelFallbackModelsItemGpt4TurboPreview                 OpenAiModelFallbackModelsItem = "gpt-4-turbo-preview"
	OpenAiModelFallbackModelsItemGpt40125Preview                  OpenAiModelFallbackModelsItem = "gpt-4-0125-preview"
	OpenAiModelFallbackModelsItemGpt41106Preview                  OpenAiModelFallbackModelsItem = "gpt-4-1106-preview"
	OpenAiModelFallbackModelsItemGpt4                             OpenAiModelFallbackModelsItem = "gpt-4"
	OpenAiModelFallbackModelsItemGpt40613                         OpenAiModelFallbackModelsItem = "gpt-4-0613"
	OpenAiModelFallbackModelsItemGpt35Turbo                       OpenAiModelFallbackModelsItem = "gpt-3.5-turbo"
	OpenAiModelFallbackModelsItemGpt35Turbo0125                   OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-0125"
	OpenAiModelFallbackModelsItemGpt35Turbo1106                   OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-1106"
	OpenAiModelFallbackModelsItemGpt35Turbo16K                    OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-16k"
	OpenAiModelFallbackModelsItemGpt35Turbo0613                   OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-0613"
)

func NewOpenAiModelFallbackModelsItemFromString(s string) (OpenAiModelFallbackModelsItem, error) {
	switch s {
	case "gpt-4.1":
		return OpenAiModelFallbackModelsItemGpt41, nil
	case "gpt-4.1-mini":
		return OpenAiModelFallbackModelsItemGpt41Mini, nil
	case "gpt-4.1-nano":
		return OpenAiModelFallbackModelsItemGpt41Nano, nil
	case "gpt-4.5-preview":
		return OpenAiModelFallbackModelsItemGpt45Preview, nil
	case "chatgpt-4o-latest":
		return OpenAiModelFallbackModelsItemChatgpt4OLatest, nil
	case "o3":
		return OpenAiModelFallbackModelsItemO3, nil
	case "o3-mini":
		return OpenAiModelFallbackModelsItemO3Mini, nil
	case "o4-mini":
		return OpenAiModelFallbackModelsItemO4Mini, nil
	case "o1-preview":
		return OpenAiModelFallbackModelsItemO1Preview, nil
	case "o1-preview-2024-09-12":
		return OpenAiModelFallbackModelsItemO1Preview20240912, nil
	case "o1-mini":
		return OpenAiModelFallbackModelsItemO1Mini, nil
	case "o1-mini-2024-09-12":
		return OpenAiModelFallbackModelsItemO1Mini20240912, nil
	case "gpt-4o-realtime-preview-2024-10-01":
		return OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241001, nil
	case "gpt-4o-realtime-preview-2024-12-17":
		return OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241217, nil
	case "gpt-4o-mini-realtime-preview-2024-12-17":
		return OpenAiModelFallbackModelsItemGpt4OMiniRealtimePreview20241217, nil
	case "gpt-4o-mini-2024-07-18":
		return OpenAiModelFallbackModelsItemGpt4OMini20240718, nil
	case "gpt-4o-mini":
		return OpenAiModelFallbackModelsItemGpt4OMini, nil
	case "gpt-4o":
		return OpenAiModelFallbackModelsItemGpt4O, nil
	case "gpt-4o-2024-05-13":
		return OpenAiModelFallbackModelsItemGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return OpenAiModelFallbackModelsItemGpt4O20240806, nil
	case "gpt-4o-2024-11-20":
		return OpenAiModelFallbackModelsItemGpt4O20241120, nil
	case "gpt-4-turbo":
		return OpenAiModelFallbackModelsItemGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return OpenAiModelFallbackModelsItemGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return OpenAiModelFallbackModelsItemGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return OpenAiModelFallbackModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return OpenAiModelFallbackModelsItemGpt41106Preview, nil
	case "gpt-4":
		return OpenAiModelFallbackModelsItemGpt4, nil
	case "gpt-4-0613":
		return OpenAiModelFallbackModelsItemGpt40613, nil
	case "gpt-3.5-turbo":
		return OpenAiModelFallbackModelsItemGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return OpenAiModelFallbackModelsItemGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return OpenAiModelFallbackModelsItemGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return OpenAiModelFallbackModelsItemGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return OpenAiModelFallbackModelsItemGpt35Turbo0613, nil
	}
	var t OpenAiModelFallbackModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiModelFallbackModelsItem) Ptr() *OpenAiModelFallbackModelsItem {
	return &o
}

// This is the OpenAI model that will be used.
type OpenAiModelModel string

const (
	OpenAiModelModelGpt41                            OpenAiModelModel = "gpt-4.1"
	OpenAiModelModelGpt41Mini                        OpenAiModelModel = "gpt-4.1-mini"
	OpenAiModelModelGpt41Nano                        OpenAiModelModel = "gpt-4.1-nano"
	OpenAiModelModelGpt45Preview                     OpenAiModelModel = "gpt-4.5-preview"
	OpenAiModelModelChatgpt4OLatest                  OpenAiModelModel = "chatgpt-4o-latest"
	OpenAiModelModelO3                               OpenAiModelModel = "o3"
	OpenAiModelModelO3Mini                           OpenAiModelModel = "o3-mini"
	OpenAiModelModelO4Mini                           OpenAiModelModel = "o4-mini"
	OpenAiModelModelO1Preview                        OpenAiModelModel = "o1-preview"
	OpenAiModelModelO1Preview20240912                OpenAiModelModel = "o1-preview-2024-09-12"
	OpenAiModelModelO1Mini                           OpenAiModelModel = "o1-mini"
	OpenAiModelModelO1Mini20240912                   OpenAiModelModel = "o1-mini-2024-09-12"
	OpenAiModelModelGpt4ORealtimePreview20241001     OpenAiModelModel = "gpt-4o-realtime-preview-2024-10-01"
	OpenAiModelModelGpt4ORealtimePreview20241217     OpenAiModelModel = "gpt-4o-realtime-preview-2024-12-17"
	OpenAiModelModelGpt4OMiniRealtimePreview20241217 OpenAiModelModel = "gpt-4o-mini-realtime-preview-2024-12-17"
	OpenAiModelModelGpt4OMini20240718                OpenAiModelModel = "gpt-4o-mini-2024-07-18"
	OpenAiModelModelGpt4OMini                        OpenAiModelModel = "gpt-4o-mini"
	OpenAiModelModelGpt4O                            OpenAiModelModel = "gpt-4o"
	OpenAiModelModelGpt4O20240513                    OpenAiModelModel = "gpt-4o-2024-05-13"
	OpenAiModelModelGpt4O20240806                    OpenAiModelModel = "gpt-4o-2024-08-06"
	OpenAiModelModelGpt4O20241120                    OpenAiModelModel = "gpt-4o-2024-11-20"
	OpenAiModelModelGpt4Turbo                        OpenAiModelModel = "gpt-4-turbo"
	OpenAiModelModelGpt4Turbo20240409                OpenAiModelModel = "gpt-4-turbo-2024-04-09"
	OpenAiModelModelGpt4TurboPreview                 OpenAiModelModel = "gpt-4-turbo-preview"
	OpenAiModelModelGpt40125Preview                  OpenAiModelModel = "gpt-4-0125-preview"
	OpenAiModelModelGpt41106Preview                  OpenAiModelModel = "gpt-4-1106-preview"
	OpenAiModelModelGpt4                             OpenAiModelModel = "gpt-4"
	OpenAiModelModelGpt40613                         OpenAiModelModel = "gpt-4-0613"
	OpenAiModelModelGpt35Turbo                       OpenAiModelModel = "gpt-3.5-turbo"
	OpenAiModelModelGpt35Turbo0125                   OpenAiModelModel = "gpt-3.5-turbo-0125"
	OpenAiModelModelGpt35Turbo1106                   OpenAiModelModel = "gpt-3.5-turbo-1106"
	OpenAiModelModelGpt35Turbo16K                    OpenAiModelModel = "gpt-3.5-turbo-16k"
	OpenAiModelModelGpt35Turbo0613                   OpenAiModelModel = "gpt-3.5-turbo-0613"
)

func NewOpenAiModelModelFromString(s string) (OpenAiModelModel, error) {
	switch s {
	case "gpt-4.1":
		return OpenAiModelModelGpt41, nil
	case "gpt-4.1-mini":
		return OpenAiModelModelGpt41Mini, nil
	case "gpt-4.1-nano":
		return OpenAiModelModelGpt41Nano, nil
	case "gpt-4.5-preview":
		return OpenAiModelModelGpt45Preview, nil
	case "chatgpt-4o-latest":
		return OpenAiModelModelChatgpt4OLatest, nil
	case "o3":
		return OpenAiModelModelO3, nil
	case "o3-mini":
		return OpenAiModelModelO3Mini, nil
	case "o4-mini":
		return OpenAiModelModelO4Mini, nil
	case "o1-preview":
		return OpenAiModelModelO1Preview, nil
	case "o1-preview-2024-09-12":
		return OpenAiModelModelO1Preview20240912, nil
	case "o1-mini":
		return OpenAiModelModelO1Mini, nil
	case "o1-mini-2024-09-12":
		return OpenAiModelModelO1Mini20240912, nil
	case "gpt-4o-realtime-preview-2024-10-01":
		return OpenAiModelModelGpt4ORealtimePreview20241001, nil
	case "gpt-4o-realtime-preview-2024-12-17":
		return OpenAiModelModelGpt4ORealtimePreview20241217, nil
	case "gpt-4o-mini-realtime-preview-2024-12-17":
		return OpenAiModelModelGpt4OMiniRealtimePreview20241217, nil
	case "gpt-4o-mini-2024-07-18":
		return OpenAiModelModelGpt4OMini20240718, nil
	case "gpt-4o-mini":
		return OpenAiModelModelGpt4OMini, nil
	case "gpt-4o":
		return OpenAiModelModelGpt4O, nil
	case "gpt-4o-2024-05-13":
		return OpenAiModelModelGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return OpenAiModelModelGpt4O20240806, nil
	case "gpt-4o-2024-11-20":
		return OpenAiModelModelGpt4O20241120, nil
	case "gpt-4-turbo":
		return OpenAiModelModelGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return OpenAiModelModelGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return OpenAiModelModelGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return OpenAiModelModelGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return OpenAiModelModelGpt41106Preview, nil
	case "gpt-4":
		return OpenAiModelModelGpt4, nil
	case "gpt-4-0613":
		return OpenAiModelModelGpt40613, nil
	case "gpt-3.5-turbo":
		return OpenAiModelModelGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return OpenAiModelModelGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return OpenAiModelModelGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return OpenAiModelModelGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return OpenAiModelModelGpt35Turbo0613, nil
	}
	var t OpenAiModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiModelModel) Ptr() *OpenAiModelModel {
	return &o
}

type OpenAiModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (o *OpenAiModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if o == nil {
		return nil
	}
	return o.CreateApiRequestToolDto
}

func (o *OpenAiModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if o == nil {
		return nil
	}
	return o.CreateBashToolDto
}

func (o *OpenAiModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if o == nil {
		return nil
	}
	return o.CreateComputerToolDto
}

func (o *OpenAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if o == nil {
		return nil
	}
	return o.CreateDtmfToolDto
}

func (o *OpenAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateEndCallToolDto
}

func (o *OpenAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if o == nil {
		return nil
	}
	return o.CreateFunctionToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelCalendarEventCreateToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelContactCreateToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelContactGetToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoogleCalendarCreateEventToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoogleSheetsRowAppendToolDto
}

func (o *OpenAiModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if o == nil {
		return nil
	}
	return o.CreateMcpToolDto
}

func (o *OpenAiModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if o == nil {
		return nil
	}
	return o.CreateQueryToolDto
}

func (o *OpenAiModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if o == nil {
		return nil
	}
	return o.CreateSlackSendMessageToolDto
}

func (o *OpenAiModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if o == nil {
		return nil
	}
	return o.CreateSmsToolDto
}

func (o *OpenAiModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if o == nil {
		return nil
	}
	return o.CreateTextEditorToolDto
}

func (o *OpenAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateTransferCallToolDto
}

func (o *OpenAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		o.typ = "CreateApiRequestToolDto"
		o.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		o.typ = "CreateBashToolDto"
		o.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		o.typ = "CreateComputerToolDto"
		o.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		o.typ = "CreateDtmfToolDto"
		o.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		o.typ = "CreateEndCallToolDto"
		o.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		o.typ = "CreateFunctionToolDto"
		o.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		o.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		o.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		o.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		o.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		o.typ = "CreateGoHighLevelContactCreateToolDto"
		o.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		o.typ = "CreateGoHighLevelContactGetToolDto"
		o.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		o.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		o.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		o.typ = "CreateGoogleCalendarCreateEventToolDto"
		o.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		o.typ = "CreateGoogleSheetsRowAppendToolDto"
		o.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		o.typ = "CreateMcpToolDto"
		o.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		o.typ = "CreateQueryToolDto"
		o.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		o.typ = "CreateSlackSendMessageToolDto"
		o.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		o.typ = "CreateSmsToolDto"
		o.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		o.typ = "CreateTextEditorToolDto"
		o.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		o.typ = "CreateTransferCallToolDto"
		o.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if o.typ == "CreateApiRequestToolDto" || o.CreateApiRequestToolDto != nil {
		return json.Marshal(o.CreateApiRequestToolDto)
	}
	if o.typ == "CreateBashToolDto" || o.CreateBashToolDto != nil {
		return json.Marshal(o.CreateBashToolDto)
	}
	if o.typ == "CreateComputerToolDto" || o.CreateComputerToolDto != nil {
		return json.Marshal(o.CreateComputerToolDto)
	}
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return json.Marshal(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return json.Marshal(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return json.Marshal(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || o.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || o.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactCreateToolDto" || o.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelContactCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactGetToolDto" || o.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelContactGetToolDto)
	}
	if o.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || o.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(o.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if o.typ == "CreateGoogleCalendarCreateEventToolDto" || o.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(o.CreateGoogleCalendarCreateEventToolDto)
	}
	if o.typ == "CreateGoogleSheetsRowAppendToolDto" || o.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(o.CreateGoogleSheetsRowAppendToolDto)
	}
	if o.typ == "CreateMcpToolDto" || o.CreateMcpToolDto != nil {
		return json.Marshal(o.CreateMcpToolDto)
	}
	if o.typ == "CreateQueryToolDto" || o.CreateQueryToolDto != nil {
		return json.Marshal(o.CreateQueryToolDto)
	}
	if o.typ == "CreateSlackSendMessageToolDto" || o.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(o.CreateSlackSendMessageToolDto)
	}
	if o.typ == "CreateSmsToolDto" || o.CreateSmsToolDto != nil {
		return json.Marshal(o.CreateSmsToolDto)
	}
	if o.typ == "CreateTextEditorToolDto" || o.CreateTextEditorToolDto != nil {
		return json.Marshal(o.CreateTextEditorToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return json.Marshal(o.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (o *OpenAiModelToolsItem) Accept(visitor OpenAiModelToolsItemVisitor) error {
	if o.typ == "CreateApiRequestToolDto" || o.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(o.CreateApiRequestToolDto)
	}
	if o.typ == "CreateBashToolDto" || o.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(o.CreateBashToolDto)
	}
	if o.typ == "CreateComputerToolDto" || o.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(o.CreateComputerToolDto)
	}
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || o.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(o.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || o.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(o.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactCreateToolDto" || o.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(o.CreateGoHighLevelContactCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactGetToolDto" || o.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(o.CreateGoHighLevelContactGetToolDto)
	}
	if o.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || o.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(o.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if o.typ == "CreateGoogleCalendarCreateEventToolDto" || o.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(o.CreateGoogleCalendarCreateEventToolDto)
	}
	if o.typ == "CreateGoogleSheetsRowAppendToolDto" || o.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(o.CreateGoogleSheetsRowAppendToolDto)
	}
	if o.typ == "CreateMcpToolDto" || o.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(o.CreateMcpToolDto)
	}
	if o.typ == "CreateQueryToolDto" || o.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(o.CreateQueryToolDto)
	}
	if o.typ == "CreateSlackSendMessageToolDto" || o.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(o.CreateSlackSendMessageToolDto)
	}
	if o.typ == "CreateSmsToolDto" || o.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(o.CreateSmsToolDto)
	}
	if o.typ == "CreateTextEditorToolDto" || o.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(o.CreateTextEditorToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(o.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model OpenAiTranscriberModel `json:"model" url:"model"`
	// This is the language that will be set for the transcription.
	Language *OpenAiTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiTranscriber) GetModel() OpenAiTranscriberModel {
	if o == nil {
		return ""
	}
	return o.Model
}

func (o *OpenAiTranscriber) GetLanguage() *OpenAiTranscriberLanguage {
	if o == nil {
		return nil
	}
	return o.Language
}

func (o *OpenAiTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if o == nil {
		return nil
	}
	return o.FallbackPlan
}

func (o *OpenAiTranscriber) Provider() string {
	return o.provider
}

func (o *OpenAiTranscriber) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiTranscriber) UnmarshalJSON(data []byte) error {
	type embed OpenAiTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiTranscriber) MarshalJSON() ([]byte, error) {
	type embed OpenAiTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiTranscriber) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the language that will be set for the transcription.
type OpenAiTranscriberLanguage string

const (
	OpenAiTranscriberLanguageAf OpenAiTranscriberLanguage = "af"
	OpenAiTranscriberLanguageAr OpenAiTranscriberLanguage = "ar"
	OpenAiTranscriberLanguageHy OpenAiTranscriberLanguage = "hy"
	OpenAiTranscriberLanguageAz OpenAiTranscriberLanguage = "az"
	OpenAiTranscriberLanguageBe OpenAiTranscriberLanguage = "be"
	OpenAiTranscriberLanguageBs OpenAiTranscriberLanguage = "bs"
	OpenAiTranscriberLanguageBg OpenAiTranscriberLanguage = "bg"
	OpenAiTranscriberLanguageCa OpenAiTranscriberLanguage = "ca"
	OpenAiTranscriberLanguageZh OpenAiTranscriberLanguage = "zh"
	OpenAiTranscriberLanguageHr OpenAiTranscriberLanguage = "hr"
	OpenAiTranscriberLanguageCs OpenAiTranscriberLanguage = "cs"
	OpenAiTranscriberLanguageDa OpenAiTranscriberLanguage = "da"
	OpenAiTranscriberLanguageNl OpenAiTranscriberLanguage = "nl"
	OpenAiTranscriberLanguageEn OpenAiTranscriberLanguage = "en"
	OpenAiTranscriberLanguageEt OpenAiTranscriberLanguage = "et"
	OpenAiTranscriberLanguageFi OpenAiTranscriberLanguage = "fi"
	OpenAiTranscriberLanguageFr OpenAiTranscriberLanguage = "fr"
	OpenAiTranscriberLanguageGl OpenAiTranscriberLanguage = "gl"
	OpenAiTranscriberLanguageDe OpenAiTranscriberLanguage = "de"
	OpenAiTranscriberLanguageEl OpenAiTranscriberLanguage = "el"
	OpenAiTranscriberLanguageHe OpenAiTranscriberLanguage = "he"
	OpenAiTranscriberLanguageHi OpenAiTranscriberLanguage = "hi"
	OpenAiTranscriberLanguageHu OpenAiTranscriberLanguage = "hu"
	OpenAiTranscriberLanguageIs OpenAiTranscriberLanguage = "is"
	OpenAiTranscriberLanguageId OpenAiTranscriberLanguage = "id"
	OpenAiTranscriberLanguageIt OpenAiTranscriberLanguage = "it"
	OpenAiTranscriberLanguageJa OpenAiTranscriberLanguage = "ja"
	OpenAiTranscriberLanguageKn OpenAiTranscriberLanguage = "kn"
	OpenAiTranscriberLanguageKk OpenAiTranscriberLanguage = "kk"
	OpenAiTranscriberLanguageKo OpenAiTranscriberLanguage = "ko"
	OpenAiTranscriberLanguageLv OpenAiTranscriberLanguage = "lv"
	OpenAiTranscriberLanguageLt OpenAiTranscriberLanguage = "lt"
	OpenAiTranscriberLanguageMk OpenAiTranscriberLanguage = "mk"
	OpenAiTranscriberLanguageMs OpenAiTranscriberLanguage = "ms"
	OpenAiTranscriberLanguageMr OpenAiTranscriberLanguage = "mr"
	OpenAiTranscriberLanguageMi OpenAiTranscriberLanguage = "mi"
	OpenAiTranscriberLanguageNe OpenAiTranscriberLanguage = "ne"
	OpenAiTranscriberLanguageNo OpenAiTranscriberLanguage = "no"
	OpenAiTranscriberLanguageFa OpenAiTranscriberLanguage = "fa"
	OpenAiTranscriberLanguagePl OpenAiTranscriberLanguage = "pl"
	OpenAiTranscriberLanguagePt OpenAiTranscriberLanguage = "pt"
	OpenAiTranscriberLanguageRo OpenAiTranscriberLanguage = "ro"
	OpenAiTranscriberLanguageRu OpenAiTranscriberLanguage = "ru"
	OpenAiTranscriberLanguageSr OpenAiTranscriberLanguage = "sr"
	OpenAiTranscriberLanguageSk OpenAiTranscriberLanguage = "sk"
	OpenAiTranscriberLanguageSl OpenAiTranscriberLanguage = "sl"
	OpenAiTranscriberLanguageEs OpenAiTranscriberLanguage = "es"
	OpenAiTranscriberLanguageSw OpenAiTranscriberLanguage = "sw"
	OpenAiTranscriberLanguageSv OpenAiTranscriberLanguage = "sv"
	OpenAiTranscriberLanguageTl OpenAiTranscriberLanguage = "tl"
	OpenAiTranscriberLanguageTa OpenAiTranscriberLanguage = "ta"
	OpenAiTranscriberLanguageTh OpenAiTranscriberLanguage = "th"
	OpenAiTranscriberLanguageTr OpenAiTranscriberLanguage = "tr"
	OpenAiTranscriberLanguageUk OpenAiTranscriberLanguage = "uk"
	OpenAiTranscriberLanguageUr OpenAiTranscriberLanguage = "ur"
	OpenAiTranscriberLanguageVi OpenAiTranscriberLanguage = "vi"
	OpenAiTranscriberLanguageCy OpenAiTranscriberLanguage = "cy"
)

func NewOpenAiTranscriberLanguageFromString(s string) (OpenAiTranscriberLanguage, error) {
	switch s {
	case "af":
		return OpenAiTranscriberLanguageAf, nil
	case "ar":
		return OpenAiTranscriberLanguageAr, nil
	case "hy":
		return OpenAiTranscriberLanguageHy, nil
	case "az":
		return OpenAiTranscriberLanguageAz, nil
	case "be":
		return OpenAiTranscriberLanguageBe, nil
	case "bs":
		return OpenAiTranscriberLanguageBs, nil
	case "bg":
		return OpenAiTranscriberLanguageBg, nil
	case "ca":
		return OpenAiTranscriberLanguageCa, nil
	case "zh":
		return OpenAiTranscriberLanguageZh, nil
	case "hr":
		return OpenAiTranscriberLanguageHr, nil
	case "cs":
		return OpenAiTranscriberLanguageCs, nil
	case "da":
		return OpenAiTranscriberLanguageDa, nil
	case "nl":
		return OpenAiTranscriberLanguageNl, nil
	case "en":
		return OpenAiTranscriberLanguageEn, nil
	case "et":
		return OpenAiTranscriberLanguageEt, nil
	case "fi":
		return OpenAiTranscriberLanguageFi, nil
	case "fr":
		return OpenAiTranscriberLanguageFr, nil
	case "gl":
		return OpenAiTranscriberLanguageGl, nil
	case "de":
		return OpenAiTranscriberLanguageDe, nil
	case "el":
		return OpenAiTranscriberLanguageEl, nil
	case "he":
		return OpenAiTranscriberLanguageHe, nil
	case "hi":
		return OpenAiTranscriberLanguageHi, nil
	case "hu":
		return OpenAiTranscriberLanguageHu, nil
	case "is":
		return OpenAiTranscriberLanguageIs, nil
	case "id":
		return OpenAiTranscriberLanguageId, nil
	case "it":
		return OpenAiTranscriberLanguageIt, nil
	case "ja":
		return OpenAiTranscriberLanguageJa, nil
	case "kn":
		return OpenAiTranscriberLanguageKn, nil
	case "kk":
		return OpenAiTranscriberLanguageKk, nil
	case "ko":
		return OpenAiTranscriberLanguageKo, nil
	case "lv":
		return OpenAiTranscriberLanguageLv, nil
	case "lt":
		return OpenAiTranscriberLanguageLt, nil
	case "mk":
		return OpenAiTranscriberLanguageMk, nil
	case "ms":
		return OpenAiTranscriberLanguageMs, nil
	case "mr":
		return OpenAiTranscriberLanguageMr, nil
	case "mi":
		return OpenAiTranscriberLanguageMi, nil
	case "ne":
		return OpenAiTranscriberLanguageNe, nil
	case "no":
		return OpenAiTranscriberLanguageNo, nil
	case "fa":
		return OpenAiTranscriberLanguageFa, nil
	case "pl":
		return OpenAiTranscriberLanguagePl, nil
	case "pt":
		return OpenAiTranscriberLanguagePt, nil
	case "ro":
		return OpenAiTranscriberLanguageRo, nil
	case "ru":
		return OpenAiTranscriberLanguageRu, nil
	case "sr":
		return OpenAiTranscriberLanguageSr, nil
	case "sk":
		return OpenAiTranscriberLanguageSk, nil
	case "sl":
		return OpenAiTranscriberLanguageSl, nil
	case "es":
		return OpenAiTranscriberLanguageEs, nil
	case "sw":
		return OpenAiTranscriberLanguageSw, nil
	case "sv":
		return OpenAiTranscriberLanguageSv, nil
	case "tl":
		return OpenAiTranscriberLanguageTl, nil
	case "ta":
		return OpenAiTranscriberLanguageTa, nil
	case "th":
		return OpenAiTranscriberLanguageTh, nil
	case "tr":
		return OpenAiTranscriberLanguageTr, nil
	case "uk":
		return OpenAiTranscriberLanguageUk, nil
	case "ur":
		return OpenAiTranscriberLanguageUr, nil
	case "vi":
		return OpenAiTranscriberLanguageVi, nil
	case "cy":
		return OpenAiTranscriberLanguageCy, nil
	}
	var t OpenAiTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiTranscriberLanguage) Ptr() *OpenAiTranscriberLanguage {
	return &o
}

// This is the model that will be used for the transcription.
type OpenAiTranscriberModel string

const (
	OpenAiTranscriberModelGpt4OTranscribe     OpenAiTranscriberModel = "gpt-4o-transcribe"
	OpenAiTranscriberModelGpt4OMiniTranscribe OpenAiTranscriberModel = "gpt-4o-mini-transcribe"
)

func NewOpenAiTranscriberModelFromString(s string) (OpenAiTranscriberModel, error) {
	switch s {
	case "gpt-4o-transcribe":
		return OpenAiTranscriberModelGpt4OTranscribe, nil
	case "gpt-4o-mini-transcribe":
		return OpenAiTranscriberModelGpt4OMiniTranscribe, nil
	}
	var t OpenAiTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiTranscriberModel) Ptr() *OpenAiTranscriberModel {
	return &o
}

type OpenAiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
	VoiceId *OpenAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the model that will be used for text-to-speech.
	Model *OpenAiVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is a prompt that allows you to control the voice of your generated audio.
	// Does not work with 'tts-1' or 'tts-1-hd' models.
	Instructions *string `json:"instructions,omitempty" url:"instructions,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiVoice) GetCachingEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.CachingEnabled
}

func (o *OpenAiVoice) GetVoiceId() *OpenAiVoiceId {
	if o == nil {
		return nil
	}
	return o.VoiceId
}

func (o *OpenAiVoice) GetModel() *OpenAiVoiceModel {
	if o == nil {
		return nil
	}
	return o.Model
}

func (o *OpenAiVoice) GetInstructions() *string {
	if o == nil {
		return nil
	}
	return o.Instructions
}

func (o *OpenAiVoice) GetSpeed() *float64 {
	if o == nil {
		return nil
	}
	return o.Speed
}

func (o *OpenAiVoice) GetChunkPlan() *ChunkPlan {
	if o == nil {
		return nil
	}
	return o.ChunkPlan
}

func (o *OpenAiVoice) GetFallbackPlan() *FallbackPlan {
	if o == nil {
		return nil
	}
	return o.FallbackPlan
}

func (o *OpenAiVoice) Provider() string {
	return o.provider
}

func (o *OpenAiVoice) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVoice) UnmarshalJSON(data []byte) error {
	type embed OpenAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVoice) MarshalJSON() ([]byte, error) {
	type embed OpenAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiVoice) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the model that will be used for text-to-speech.
type OpenAiVoiceModel string

const (
	OpenAiVoiceModelTts1         OpenAiVoiceModel = "tts-1"
	OpenAiVoiceModelTts1Hd       OpenAiVoiceModel = "tts-1-hd"
	OpenAiVoiceModelGpt4OMiniTts OpenAiVoiceModel = "gpt-4o-mini-tts"
)

func NewOpenAiVoiceModelFromString(s string) (OpenAiVoiceModel, error) {
	switch s {
	case "tts-1":
		return OpenAiVoiceModelTts1, nil
	case "tts-1-hd":
		return OpenAiVoiceModelTts1Hd, nil
	case "gpt-4o-mini-tts":
		return OpenAiVoiceModelGpt4OMiniTts, nil
	}
	var t OpenAiVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiVoiceModel) Ptr() *OpenAiVoiceModel {
	return &o
}

type OpenAiVoicemailDetectionPlan struct {
	// This is the maximum duration from the start of the call that we will wait for a voicemail beep, before speaking our message
	//
	// - If we detect a voicemail beep before this, we will speak the message at that point.
	//
	// - Setting too low a value means that the bot will start speaking its voicemail message too early. If it does so before the actual beep, it will get cut off. You should definitely tune this to your use case.
	//
	// @default 30
	// @min 0
	// @max 60
	BeepMaxAwaitSeconds *float64 `json:"beepMaxAwaitSeconds,omitempty" url:"beepMaxAwaitSeconds,omitempty"`
	// This is the provider to use for voicemail detection.
	// This is the backoff plan for the voicemail detection.
	BackoffPlan *VoicemailDetectionBackoffPlan `json:"backoffPlan,omitempty" url:"backoffPlan,omitempty"`
	provider    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiVoicemailDetectionPlan) GetBeepMaxAwaitSeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.BeepMaxAwaitSeconds
}

func (o *OpenAiVoicemailDetectionPlan) GetBackoffPlan() *VoicemailDetectionBackoffPlan {
	if o == nil {
		return nil
	}
	return o.BackoffPlan
}

func (o *OpenAiVoicemailDetectionPlan) Provider() string {
	return o.provider
}

func (o *OpenAiVoicemailDetectionPlan) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVoicemailDetectionPlan) UnmarshalJSON(data []byte) error {
	type embed OpenAiVoicemailDetectionPlan
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiVoicemailDetectionPlan(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVoicemailDetectionPlan) MarshalJSON() ([]byte, error) {
	type embed OpenAiVoicemailDetectionPlan
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiVoicemailDetectionPlan) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenRouterCredential) GetApiKey() string {
	if o == nil {
		return ""
	}
	return o.ApiKey
}

func (o *OpenRouterCredential) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *OpenRouterCredential) GetOrgId() string {
	if o == nil {
		return ""
	}
	return o.OrgId
}

func (o *OpenRouterCredential) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *OpenRouterCredential) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *OpenRouterCredential) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OpenRouterCredential) Provider() string {
	return o.provider
}

func (o *OpenRouterCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenRouterCredential) UnmarshalJSON(data []byte) error {
	type embed OpenRouterCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenRouterCredential(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openrouter", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenRouterCredential) MarshalJSON() ([]byte, error) {
	type embed OpenRouterCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*o),
		CreatedAt: internal.NewDateTime(o.CreatedAt),
		UpdatedAt: internal.NewDateTime(o.UpdatedAt),
		Provider:  "openrouter",
	}
	return json.Marshal(marshaler)
}

func (o *OpenRouterCredential) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*OpenRouterModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenRouterModel) GetMessages() []*OpenAiMessage {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *OpenRouterModel) GetTools() []*OpenRouterModelToolsItem {
	if o == nil {
		return nil
	}
	return o.Tools
}

func (o *OpenRouterModel) GetToolIds() []string {
	if o == nil {
		return nil
	}
	return o.ToolIds
}

func (o *OpenRouterModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if o == nil {
		return nil
	}
	return o.KnowledgeBase
}

func (o *OpenRouterModel) GetKnowledgeBaseId() *string {
	if o == nil {
		return nil
	}
	return o.KnowledgeBaseId
}

func (o *OpenRouterModel) GetModel() string {
	if o == nil {
		return ""
	}
	return o.Model
}

func (o *OpenRouterModel) GetTemperature() *float64 {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *OpenRouterModel) GetMaxTokens() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxTokens
}

func (o *OpenRouterModel) GetEmotionRecognitionEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.EmotionRecognitionEnabled
}

func (o *OpenRouterModel) GetNumFastTurns() *float64 {
	if o == nil {
		return nil
	}
	return o.NumFastTurns
}

func (o *OpenRouterModel) Provider() string {
	return o.provider
}

func (o *OpenRouterModel) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenRouterModel) UnmarshalJSON(data []byte) error {
	type embed OpenRouterModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenRouterModel(unmarshaler.embed)
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openrouter", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenRouterModel) MarshalJSON() ([]byte, error) {
	type embed OpenRouterModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openrouter",
	}
	return json.Marshal(marshaler)
}

func (o *OpenRouterModel) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (o *OpenRouterModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if o == nil {
		return nil
	}
	return o.CreateApiRequestToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if o == nil {
		return nil
	}
	return o.CreateBashToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if o == nil {
		return nil
	}
	return o.CreateComputerToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if o == nil {
		return nil
	}
	return o.CreateDtmfToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateEndCallToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if o == nil {
		return nil
	}
	return o.CreateFunctionToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelCalendarEventCreateToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelContactCreateToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoHighLevelContactGetToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoogleCalendarCreateEventToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGoogleSheetsRowAppendToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if o == nil {
		return nil
	}
	return o.CreateMcpToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if o == nil {
		return nil
	}
	return o.CreateQueryToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if o == nil {
		return nil
	}
	return o.CreateSlackSendMessageToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if o == nil {
		return nil
	}
	return o.CreateSmsToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if o == nil {
		return nil
	}
	return o.CreateTextEditorToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateTransferCallToolDto
}

func (o *OpenRouterModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		o.typ = "CreateApiRequestToolDto"
		o.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		o.typ = "CreateBashToolDto"
		o.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		o.typ = "CreateComputerToolDto"
		o.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		o.typ = "CreateDtmfToolDto"
		o.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		o.typ = "CreateEndCallToolDto"
		o.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		o.typ = "CreateFunctionToolDto"
		o.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		o.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		o.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		o.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		o.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		o.typ = "CreateGoHighLevelContactCreateToolDto"
		o.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		o.typ = "CreateGoHighLevelContactGetToolDto"
		o.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		o.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		o.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		o.typ = "CreateGoogleCalendarCreateEventToolDto"
		o.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		o.typ = "CreateGoogleSheetsRowAppendToolDto"
		o.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		o.typ = "CreateMcpToolDto"
		o.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		o.typ = "CreateQueryToolDto"
		o.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		o.typ = "CreateSlackSendMessageToolDto"
		o.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		o.typ = "CreateSmsToolDto"
		o.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		o.typ = "CreateTextEditorToolDto"
		o.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		o.typ = "CreateTransferCallToolDto"
		o.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenRouterModelToolsItem) MarshalJSON() ([]byte, error) {
	if o.typ == "CreateApiRequestToolDto" || o.CreateApiRequestToolDto != nil {
		return json.Marshal(o.CreateApiRequestToolDto)
	}
	if o.typ == "CreateBashToolDto" || o.CreateBashToolDto != nil {
		return json.Marshal(o.CreateBashToolDto)
	}
	if o.typ == "CreateComputerToolDto" || o.CreateComputerToolDto != nil {
		return json.Marshal(o.CreateComputerToolDto)
	}
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return json.Marshal(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return json.Marshal(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return json.Marshal(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || o.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || o.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactCreateToolDto" || o.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelContactCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactGetToolDto" || o.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(o.CreateGoHighLevelContactGetToolDto)
	}
	if o.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || o.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(o.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if o.typ == "CreateGoogleCalendarCreateEventToolDto" || o.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(o.CreateGoogleCalendarCreateEventToolDto)
	}
	if o.typ == "CreateGoogleSheetsRowAppendToolDto" || o.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(o.CreateGoogleSheetsRowAppendToolDto)
	}
	if o.typ == "CreateMcpToolDto" || o.CreateMcpToolDto != nil {
		return json.Marshal(o.CreateMcpToolDto)
	}
	if o.typ == "CreateQueryToolDto" || o.CreateQueryToolDto != nil {
		return json.Marshal(o.CreateQueryToolDto)
	}
	if o.typ == "CreateSlackSendMessageToolDto" || o.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(o.CreateSlackSendMessageToolDto)
	}
	if o.typ == "CreateSmsToolDto" || o.CreateSmsToolDto != nil {
		return json.Marshal(o.CreateSmsToolDto)
	}
	if o.typ == "CreateTextEditorToolDto" || o.CreateTextEditorToolDto != nil {
		return json.Marshal(o.CreateTextEditorToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return json.Marshal(o.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenRouterModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (o *OpenRouterModelToolsItem) Accept(visitor OpenRouterModelToolsItemVisitor) error {
	if o.typ == "CreateApiRequestToolDto" || o.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(o.CreateApiRequestToolDto)
	}
	if o.typ == "CreateBashToolDto" || o.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(o.CreateBashToolDto)
	}
	if o.typ == "CreateComputerToolDto" || o.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(o.CreateComputerToolDto)
	}
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || o.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(o.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if o.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || o.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(o.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactCreateToolDto" || o.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(o.CreateGoHighLevelContactCreateToolDto)
	}
	if o.typ == "CreateGoHighLevelContactGetToolDto" || o.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(o.CreateGoHighLevelContactGetToolDto)
	}
	if o.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || o.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(o.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if o.typ == "CreateGoogleCalendarCreateEventToolDto" || o.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(o.CreateGoogleCalendarCreateEventToolDto)
	}
	if o.typ == "CreateGoogleSheetsRowAppendToolDto" || o.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(o.CreateGoogleSheetsRowAppendToolDto)
	}
	if o.typ == "CreateMcpToolDto" || o.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(o.CreateMcpToolDto)
	}
	if o.typ == "CreateQueryToolDto" || o.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(o.CreateQueryToolDto)
	}
	if o.typ == "CreateSlackSendMessageToolDto" || o.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(o.CreateSlackSendMessageToolDto)
	}
	if o.typ == "CreateSmsToolDto" || o.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(o.CreateSmsToolDto)
	}
	if o.typ == "CreateTextEditorToolDto" || o.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(o.CreateTextEditorToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(o.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type Org struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool         `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// This is the ID of the subscription the org belongs to.
	SubscriptionId *string `json:"subscriptionId,omitempty" url:"subscriptionId,omitempty"`
	// This is the unique identifier for the org.
	Id string `json:"id" url:"id"`
	// This is the ISO 8601 date-time string of when the org was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the org was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the Stripe customer for the org.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	// This is the subscription for the org.
	StripeSubscriptionId *string `json:"stripeSubscriptionId,omitempty" url:"stripeSubscriptionId,omitempty"`
	// This is the subscription's subscription item.
	StripeSubscriptionItemId *string `json:"stripeSubscriptionItemId,omitempty" url:"stripeSubscriptionItemId,omitempty"`
	// This is the subscription's current period start.
	StripeSubscriptionCurrentPeriodStart *time.Time `json:"stripeSubscriptionCurrentPeriodStart,omitempty" url:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	// This is the subscription's status.
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty" url:"stripeSubscriptionStatus,omitempty"`
	// This is the plan for the org.
	Plan *OrgPlan `json:"plan,omitempty" url:"plan,omitempty"`
	// This is the secret key used for signing JWT tokens for the org.
	JwtSecret *string `json:"jwtSecret,omitempty" url:"jwtSecret,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
	Channel *OrgChannel `json:"channel,omitempty" url:"channel,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`
	// Stores the information about the compliance plan enforced at the organization level. Currently pciEnabled is supported through this field.
	// When this is enabled, any logs, recordings, or transcriptions will be shipped to the customer endpoints if provided else lost.
	// At the end of the call, you will receive an end-of-call-report message to store on your server, if webhook is provided.
	// Defaults to false.
	// When PCI is enabled, only PCI-compliant Providers will be available for LLM, Voice and transcribers.
	// This is due to the compliance requirements of PCI. Other providers may not meet these requirements.
	CompliancePlan *CompliancePlan `json:"compliancePlan,omitempty" url:"compliancePlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Org) GetHipaaEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.HipaaEnabled
}

func (o *Org) GetSubscription() *Subscription {
	if o == nil {
		return nil
	}
	return o.Subscription
}

func (o *Org) GetSubscriptionId() *string {
	if o == nil {
		return nil
	}
	return o.SubscriptionId
}

func (o *Org) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *Org) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *Org) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *Org) GetStripeCustomerId() *string {
	if o == nil {
		return nil
	}
	return o.StripeCustomerId
}

func (o *Org) GetStripeSubscriptionId() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionId
}

func (o *Org) GetStripeSubscriptionItemId() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionItemId
}

func (o *Org) GetStripeSubscriptionCurrentPeriodStart() *time.Time {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionCurrentPeriodStart
}

func (o *Org) GetStripeSubscriptionStatus() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionStatus
}

func (o *Org) GetPlan() *OrgPlan {
	if o == nil {
		return nil
	}
	return o.Plan
}

func (o *Org) GetJwtSecret() *string {
	if o == nil {
		return nil
	}
	return o.JwtSecret
}

func (o *Org) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Org) GetChannel() *OrgChannel {
	if o == nil {
		return nil
	}
	return o.Channel
}

func (o *Org) GetBillingLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.BillingLimit
}

func (o *Org) GetServer() *Server {
	if o == nil {
		return nil
	}
	return o.Server
}

func (o *Org) GetConcurrencyLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.ConcurrencyLimit
}

func (o *Org) GetCompliancePlan() *CompliancePlan {
	if o == nil {
		return nil
	}
	return o.CompliancePlan
}

func (o *Org) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Org) UnmarshalJSON(data []byte) error {
	type embed Org
	var unmarshaler = struct {
		embed
		CreatedAt                            *internal.DateTime `json:"createdAt"`
		UpdatedAt                            *internal.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *internal.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Org(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	o.StripeSubscriptionCurrentPeriodStart = unmarshaler.StripeSubscriptionCurrentPeriodStart.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Org) MarshalJSON() ([]byte, error) {
	type embed Org
	var marshaler = struct {
		embed
		CreatedAt                            *internal.DateTime `json:"createdAt"`
		UpdatedAt                            *internal.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *internal.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed:                                embed(*o),
		CreatedAt:                            internal.NewDateTime(o.CreatedAt),
		UpdatedAt:                            internal.NewDateTime(o.UpdatedAt),
		StripeSubscriptionCurrentPeriodStart: internal.NewOptionalDateTime(o.StripeSubscriptionCurrentPeriodStart),
	}
	return json.Marshal(marshaler)
}

func (o *Org) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
type OrgChannel string

const (
	OrgChannelDefault OrgChannel = "default"
	OrgChannelWeekly  OrgChannel = "weekly"
)

func NewOrgChannelFromString(s string) (OrgChannel, error) {
	switch s {
	case "default":
		return OrgChannelDefault, nil
	case "weekly":
		return OrgChannelWeekly, nil
	}
	var t OrgChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrgChannel) Ptr() *OrgChannel {
	return &o
}

type OrgPlan struct {
	IncludedProviders    []map[string]interface{} `json:"includedProviders,omitempty" url:"includedProviders,omitempty"`
	IncludedMinutes      *float64                 `json:"includedMinutes,omitempty" url:"includedMinutes,omitempty"`
	CostPerOverageMinute *float64                 `json:"costPerOverageMinute,omitempty" url:"costPerOverageMinute,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrgPlan) GetIncludedProviders() []map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.IncludedProviders
}

func (o *OrgPlan) GetIncludedMinutes() *float64 {
	if o == nil {
		return nil
	}
	return o.IncludedMinutes
}

func (o *OrgPlan) GetCostPerOverageMinute() *float64 {
	if o == nil {
		return nil
	}
	return o.CostPerOverageMinute
}

func (o *OrgPlan) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrgPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler OrgPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrgPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrgPlan) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PaginationMeta struct {
	ItemsPerPage float64 `json:"itemsPerPage" url:"itemsPerPage"`
	TotalItems   float64 `json:"totalItems" url:"totalItems"`
	CurrentPage  float64 `json:"currentPage" url:"currentPage"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginationMeta) GetItemsPerPage() float64 {
	if p == nil {
		return 0
	}
	return p.ItemsPerPage
}

func (p *PaginationMeta) GetTotalItems() float64 {
	if p == nil {
		return 0
	}
	return p.TotalItems
}

func (p *PaginationMeta) GetCurrentPage() float64 {
	if p == nil {
		return 0
	}
	return p.CurrentPage
}

func (p *PaginationMeta) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginationMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginationMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginationMeta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginationMeta) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PerplexityAiCredential) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PerplexityAiCredential) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PerplexityAiCredential) GetOrgId() string {
	if p == nil {
		return ""
	}
	return p.OrgId
}

func (p *PerplexityAiCredential) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PerplexityAiCredential) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PerplexityAiCredential) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PerplexityAiCredential) Provider() string {
	return p.provider
}

func (p *PerplexityAiCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PerplexityAiCredential) UnmarshalJSON(data []byte) error {
	type embed PerplexityAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PerplexityAiCredential(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "perplexity-ai", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PerplexityAiCredential) MarshalJSON() ([]byte, error) {
	type embed PerplexityAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
		Provider:  "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (p *PerplexityAiCredential) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*PerplexityAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PerplexityAiModel) GetMessages() []*OpenAiMessage {
	if p == nil {
		return nil
	}
	return p.Messages
}

func (p *PerplexityAiModel) GetTools() []*PerplexityAiModelToolsItem {
	if p == nil {
		return nil
	}
	return p.Tools
}

func (p *PerplexityAiModel) GetToolIds() []string {
	if p == nil {
		return nil
	}
	return p.ToolIds
}

func (p *PerplexityAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if p == nil {
		return nil
	}
	return p.KnowledgeBase
}

func (p *PerplexityAiModel) GetKnowledgeBaseId() *string {
	if p == nil {
		return nil
	}
	return p.KnowledgeBaseId
}

func (p *PerplexityAiModel) GetModel() string {
	if p == nil {
		return ""
	}
	return p.Model
}

func (p *PerplexityAiModel) GetTemperature() *float64 {
	if p == nil {
		return nil
	}
	return p.Temperature
}

func (p *PerplexityAiModel) GetMaxTokens() *float64 {
	if p == nil {
		return nil
	}
	return p.MaxTokens
}

func (p *PerplexityAiModel) GetEmotionRecognitionEnabled() *bool {
	if p == nil {
		return nil
	}
	return p.EmotionRecognitionEnabled
}

func (p *PerplexityAiModel) GetNumFastTurns() *float64 {
	if p == nil {
		return nil
	}
	return p.NumFastTurns
}

func (p *PerplexityAiModel) Provider() string {
	return p.provider
}

func (p *PerplexityAiModel) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PerplexityAiModel) UnmarshalJSON(data []byte) error {
	type embed PerplexityAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PerplexityAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "perplexity-ai", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PerplexityAiModel) MarshalJSON() ([]byte, error) {
	type embed PerplexityAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*p),
		Provider: "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (p *PerplexityAiModel) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (p *PerplexityAiModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if p == nil {
		return nil
	}
	return p.CreateApiRequestToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if p == nil {
		return nil
	}
	return p.CreateBashToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if p == nil {
		return nil
	}
	return p.CreateComputerToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if p == nil {
		return nil
	}
	return p.CreateDtmfToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if p == nil {
		return nil
	}
	return p.CreateEndCallToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if p == nil {
		return nil
	}
	return p.CreateFunctionToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGoHighLevelCalendarEventCreateToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGoHighLevelContactCreateToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGoHighLevelContactGetToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGoogleCalendarCreateEventToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGoogleSheetsRowAppendToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if p == nil {
		return nil
	}
	return p.CreateMcpToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if p == nil {
		return nil
	}
	return p.CreateQueryToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if p == nil {
		return nil
	}
	return p.CreateSlackSendMessageToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if p == nil {
		return nil
	}
	return p.CreateSmsToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if p == nil {
		return nil
	}
	return p.CreateTextEditorToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if p == nil {
		return nil
	}
	return p.CreateTransferCallToolDto
}

func (p *PerplexityAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		p.typ = "CreateApiRequestToolDto"
		p.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		p.typ = "CreateBashToolDto"
		p.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		p.typ = "CreateComputerToolDto"
		p.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		p.typ = "CreateDtmfToolDto"
		p.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		p.typ = "CreateEndCallToolDto"
		p.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		p.typ = "CreateFunctionToolDto"
		p.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		p.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		p.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		p.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		p.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		p.typ = "CreateGoHighLevelContactCreateToolDto"
		p.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		p.typ = "CreateGoHighLevelContactGetToolDto"
		p.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		p.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		p.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		p.typ = "CreateGoogleCalendarCreateEventToolDto"
		p.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		p.typ = "CreateGoogleSheetsRowAppendToolDto"
		p.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		p.typ = "CreateMcpToolDto"
		p.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		p.typ = "CreateQueryToolDto"
		p.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		p.typ = "CreateSlackSendMessageToolDto"
		p.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		p.typ = "CreateSmsToolDto"
		p.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		p.typ = "CreateTextEditorToolDto"
		p.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		p.typ = "CreateTransferCallToolDto"
		p.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PerplexityAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if p.typ == "CreateApiRequestToolDto" || p.CreateApiRequestToolDto != nil {
		return json.Marshal(p.CreateApiRequestToolDto)
	}
	if p.typ == "CreateBashToolDto" || p.CreateBashToolDto != nil {
		return json.Marshal(p.CreateBashToolDto)
	}
	if p.typ == "CreateComputerToolDto" || p.CreateComputerToolDto != nil {
		return json.Marshal(p.CreateComputerToolDto)
	}
	if p.typ == "CreateDtmfToolDto" || p.CreateDtmfToolDto != nil {
		return json.Marshal(p.CreateDtmfToolDto)
	}
	if p.typ == "CreateEndCallToolDto" || p.CreateEndCallToolDto != nil {
		return json.Marshal(p.CreateEndCallToolDto)
	}
	if p.typ == "CreateFunctionToolDto" || p.CreateFunctionToolDto != nil {
		return json.Marshal(p.CreateFunctionToolDto)
	}
	if p.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || p.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(p.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if p.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || p.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(p.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if p.typ == "CreateGoHighLevelContactCreateToolDto" || p.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(p.CreateGoHighLevelContactCreateToolDto)
	}
	if p.typ == "CreateGoHighLevelContactGetToolDto" || p.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(p.CreateGoHighLevelContactGetToolDto)
	}
	if p.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || p.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(p.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if p.typ == "CreateGoogleCalendarCreateEventToolDto" || p.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(p.CreateGoogleCalendarCreateEventToolDto)
	}
	if p.typ == "CreateGoogleSheetsRowAppendToolDto" || p.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(p.CreateGoogleSheetsRowAppendToolDto)
	}
	if p.typ == "CreateMcpToolDto" || p.CreateMcpToolDto != nil {
		return json.Marshal(p.CreateMcpToolDto)
	}
	if p.typ == "CreateQueryToolDto" || p.CreateQueryToolDto != nil {
		return json.Marshal(p.CreateQueryToolDto)
	}
	if p.typ == "CreateSlackSendMessageToolDto" || p.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(p.CreateSlackSendMessageToolDto)
	}
	if p.typ == "CreateSmsToolDto" || p.CreateSmsToolDto != nil {
		return json.Marshal(p.CreateSmsToolDto)
	}
	if p.typ == "CreateTextEditorToolDto" || p.CreateTextEditorToolDto != nil {
		return json.Marshal(p.CreateTextEditorToolDto)
	}
	if p.typ == "CreateTransferCallToolDto" || p.CreateTransferCallToolDto != nil {
		return json.Marshal(p.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PerplexityAiModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (p *PerplexityAiModelToolsItem) Accept(visitor PerplexityAiModelToolsItemVisitor) error {
	if p.typ == "CreateApiRequestToolDto" || p.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(p.CreateApiRequestToolDto)
	}
	if p.typ == "CreateBashToolDto" || p.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(p.CreateBashToolDto)
	}
	if p.typ == "CreateComputerToolDto" || p.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(p.CreateComputerToolDto)
	}
	if p.typ == "CreateDtmfToolDto" || p.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(p.CreateDtmfToolDto)
	}
	if p.typ == "CreateEndCallToolDto" || p.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(p.CreateEndCallToolDto)
	}
	if p.typ == "CreateFunctionToolDto" || p.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(p.CreateFunctionToolDto)
	}
	if p.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || p.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(p.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if p.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || p.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(p.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if p.typ == "CreateGoHighLevelContactCreateToolDto" || p.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(p.CreateGoHighLevelContactCreateToolDto)
	}
	if p.typ == "CreateGoHighLevelContactGetToolDto" || p.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(p.CreateGoHighLevelContactGetToolDto)
	}
	if p.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || p.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(p.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if p.typ == "CreateGoogleCalendarCreateEventToolDto" || p.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(p.CreateGoogleCalendarCreateEventToolDto)
	}
	if p.typ == "CreateGoogleSheetsRowAppendToolDto" || p.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(p.CreateGoogleSheetsRowAppendToolDto)
	}
	if p.typ == "CreateMcpToolDto" || p.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(p.CreateMcpToolDto)
	}
	if p.typ == "CreateQueryToolDto" || p.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(p.CreateQueryToolDto)
	}
	if p.typ == "CreateSlackSendMessageToolDto" || p.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(p.CreateSlackSendMessageToolDto)
	}
	if p.typ == "CreateSmsToolDto" || p.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(p.CreateSmsToolDto)
	}
	if p.typ == "CreateTextEditorToolDto" || p.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(p.CreateTextEditorToolDto)
	}
	if p.typ == "CreateTransferCallToolDto" || p.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(p.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhoneNumberHookCallRinging struct {
	// This is the event to trigger the hook on
	// This is the set of actions to perform when the hook triggers
	Do []*PhoneNumberHookCallRingingDoItem `json:"do,omitempty" url:"do,omitempty"`
	on string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhoneNumberHookCallRinging) GetDo() []*PhoneNumberHookCallRingingDoItem {
	if p == nil {
		return nil
	}
	return p.Do
}

func (p *PhoneNumberHookCallRinging) On() string {
	return p.on
}

func (p *PhoneNumberHookCallRinging) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhoneNumberHookCallRinging) UnmarshalJSON(data []byte) error {
	type embed PhoneNumberHookCallRinging
	var unmarshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PhoneNumberHookCallRinging(unmarshaler.embed)
	if unmarshaler.On != "call.ringing" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "call.ringing", unmarshaler.On)
	}
	p.on = unmarshaler.On
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "on")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneNumberHookCallRinging) MarshalJSON() ([]byte, error) {
	type embed PhoneNumberHookCallRinging
	var marshaler = struct {
		embed
		On string `json:"on"`
	}{
		embed: embed(*p),
		On:    "call.ringing",
	}
	return json.Marshal(marshaler)
}

func (p *PhoneNumberHookCallRinging) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhoneNumberHookCallRingingDoItem struct {
	TransferPhoneNumberHookAction *TransferPhoneNumberHookAction
	SayPhoneNumberHookAction      *SayPhoneNumberHookAction

	typ string
}

func (p *PhoneNumberHookCallRingingDoItem) GetTransferPhoneNumberHookAction() *TransferPhoneNumberHookAction {
	if p == nil {
		return nil
	}
	return p.TransferPhoneNumberHookAction
}

func (p *PhoneNumberHookCallRingingDoItem) GetSayPhoneNumberHookAction() *SayPhoneNumberHookAction {
	if p == nil {
		return nil
	}
	return p.SayPhoneNumberHookAction
}

func (p *PhoneNumberHookCallRingingDoItem) UnmarshalJSON(data []byte) error {
	valueTransferPhoneNumberHookAction := new(TransferPhoneNumberHookAction)
	if err := json.Unmarshal(data, &valueTransferPhoneNumberHookAction); err == nil {
		p.typ = "TransferPhoneNumberHookAction"
		p.TransferPhoneNumberHookAction = valueTransferPhoneNumberHookAction
		return nil
	}
	valueSayPhoneNumberHookAction := new(SayPhoneNumberHookAction)
	if err := json.Unmarshal(data, &valueSayPhoneNumberHookAction); err == nil {
		p.typ = "SayPhoneNumberHookAction"
		p.SayPhoneNumberHookAction = valueSayPhoneNumberHookAction
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhoneNumberHookCallRingingDoItem) MarshalJSON() ([]byte, error) {
	if p.typ == "TransferPhoneNumberHookAction" || p.TransferPhoneNumberHookAction != nil {
		return json.Marshal(p.TransferPhoneNumberHookAction)
	}
	if p.typ == "SayPhoneNumberHookAction" || p.SayPhoneNumberHookAction != nil {
		return json.Marshal(p.SayPhoneNumberHookAction)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhoneNumberHookCallRingingDoItemVisitor interface {
	VisitTransferPhoneNumberHookAction(*TransferPhoneNumberHookAction) error
	VisitSayPhoneNumberHookAction(*SayPhoneNumberHookAction) error
}

func (p *PhoneNumberHookCallRingingDoItem) Accept(visitor PhoneNumberHookCallRingingDoItemVisitor) error {
	if p.typ == "TransferPhoneNumberHookAction" || p.TransferPhoneNumberHookAction != nil {
		return visitor.VisitTransferPhoneNumberHookAction(p.TransferPhoneNumberHookAction)
	}
	if p.typ == "SayPhoneNumberHookAction" || p.SayPhoneNumberHookAction != nil {
		return visitor.VisitSayPhoneNumberHookAction(p.SayPhoneNumberHookAction)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhoneNumberPaginatedResponse struct {
	// A list of phone numbers, which can be of any provider type.
	Results []*PhoneNumberPaginatedResponseResultsItem `json:"results,omitempty" url:"results,omitempty"`
	// Metadata about the pagination.
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhoneNumberPaginatedResponse) GetResults() []*PhoneNumberPaginatedResponseResultsItem {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PhoneNumberPaginatedResponse) GetMetadata() *PaginationMeta {
	if p == nil {
		return nil
	}
	return p.Metadata
}

func (p *PhoneNumberPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhoneNumberPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PhoneNumberPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhoneNumberPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneNumberPaginatedResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhoneNumberPaginatedResponseResultsItem struct {
	ByoPhoneNumber    *ByoPhoneNumber
	TwilioPhoneNumber *TwilioPhoneNumber
	VonagePhoneNumber *VonagePhoneNumber
	VapiPhoneNumber   *VapiPhoneNumber
	TelnyxPhoneNumber *TelnyxPhoneNumber

	typ string
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetByoPhoneNumber() *ByoPhoneNumber {
	if p == nil {
		return nil
	}
	return p.ByoPhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetTwilioPhoneNumber() *TwilioPhoneNumber {
	if p == nil {
		return nil
	}
	return p.TwilioPhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetVonagePhoneNumber() *VonagePhoneNumber {
	if p == nil {
		return nil
	}
	return p.VonagePhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetVapiPhoneNumber() *VapiPhoneNumber {
	if p == nil {
		return nil
	}
	return p.VapiPhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetTelnyxPhoneNumber() *TelnyxPhoneNumber {
	if p == nil {
		return nil
	}
	return p.TelnyxPhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) UnmarshalJSON(data []byte) error {
	valueByoPhoneNumber := new(ByoPhoneNumber)
	if err := json.Unmarshal(data, &valueByoPhoneNumber); err == nil {
		p.typ = "ByoPhoneNumber"
		p.ByoPhoneNumber = valueByoPhoneNumber
		return nil
	}
	valueTwilioPhoneNumber := new(TwilioPhoneNumber)
	if err := json.Unmarshal(data, &valueTwilioPhoneNumber); err == nil {
		p.typ = "TwilioPhoneNumber"
		p.TwilioPhoneNumber = valueTwilioPhoneNumber
		return nil
	}
	valueVonagePhoneNumber := new(VonagePhoneNumber)
	if err := json.Unmarshal(data, &valueVonagePhoneNumber); err == nil {
		p.typ = "VonagePhoneNumber"
		p.VonagePhoneNumber = valueVonagePhoneNumber
		return nil
	}
	valueVapiPhoneNumber := new(VapiPhoneNumber)
	if err := json.Unmarshal(data, &valueVapiPhoneNumber); err == nil {
		p.typ = "VapiPhoneNumber"
		p.VapiPhoneNumber = valueVapiPhoneNumber
		return nil
	}
	valueTelnyxPhoneNumber := new(TelnyxPhoneNumber)
	if err := json.Unmarshal(data, &valueTelnyxPhoneNumber); err == nil {
		p.typ = "TelnyxPhoneNumber"
		p.TelnyxPhoneNumber = valueTelnyxPhoneNumber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhoneNumberPaginatedResponseResultsItem) MarshalJSON() ([]byte, error) {
	if p.typ == "ByoPhoneNumber" || p.ByoPhoneNumber != nil {
		return json.Marshal(p.ByoPhoneNumber)
	}
	if p.typ == "TwilioPhoneNumber" || p.TwilioPhoneNumber != nil {
		return json.Marshal(p.TwilioPhoneNumber)
	}
	if p.typ == "VonagePhoneNumber" || p.VonagePhoneNumber != nil {
		return json.Marshal(p.VonagePhoneNumber)
	}
	if p.typ == "VapiPhoneNumber" || p.VapiPhoneNumber != nil {
		return json.Marshal(p.VapiPhoneNumber)
	}
	if p.typ == "TelnyxPhoneNumber" || p.TelnyxPhoneNumber != nil {
		return json.Marshal(p.TelnyxPhoneNumber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhoneNumberPaginatedResponseResultsItemVisitor interface {
	VisitByoPhoneNumber(*ByoPhoneNumber) error
	VisitTwilioPhoneNumber(*TwilioPhoneNumber) error
	VisitVonagePhoneNumber(*VonagePhoneNumber) error
	VisitVapiPhoneNumber(*VapiPhoneNumber) error
	VisitTelnyxPhoneNumber(*TelnyxPhoneNumber) error
}

func (p *PhoneNumberPaginatedResponseResultsItem) Accept(visitor PhoneNumberPaginatedResponseResultsItemVisitor) error {
	if p.typ == "ByoPhoneNumber" || p.ByoPhoneNumber != nil {
		return visitor.VisitByoPhoneNumber(p.ByoPhoneNumber)
	}
	if p.typ == "TwilioPhoneNumber" || p.TwilioPhoneNumber != nil {
		return visitor.VisitTwilioPhoneNumber(p.TwilioPhoneNumber)
	}
	if p.typ == "VonagePhoneNumber" || p.VonagePhoneNumber != nil {
		return visitor.VisitVonagePhoneNumber(p.VonagePhoneNumber)
	}
	if p.typ == "VapiPhoneNumber" || p.VapiPhoneNumber != nil {
		return visitor.VisitVapiPhoneNumber(p.VapiPhoneNumber)
	}
	if p.typ == "TelnyxPhoneNumber" || p.TelnyxPhoneNumber != nil {
		return visitor.VisitTelnyxPhoneNumber(p.TelnyxPhoneNumber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// This is the provider-specific ID that will be used.
type PlayHtVoiceId struct {
	PlayHtVoiceIdEnum PlayHtVoiceIdEnum
	String            string

	typ string
}

func (p *PlayHtVoiceId) GetPlayHtVoiceIdEnum() PlayHtVoiceIdEnum {
	if p == nil {
		return ""
	}
	return p.PlayHtVoiceIdEnum
}

func (p *PlayHtVoiceId) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PlayHtVoiceId) UnmarshalJSON(data []byte) error {
	var valuePlayHtVoiceIdEnum PlayHtVoiceIdEnum
	if err := json.Unmarshal(data, &valuePlayHtVoiceIdEnum); err == nil {
		p.typ = "PlayHtVoiceIdEnum"
		p.PlayHtVoiceIdEnum = valuePlayHtVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PlayHtVoiceId) MarshalJSON() ([]byte, error) {
	if p.typ == "PlayHtVoiceIdEnum" || p.PlayHtVoiceIdEnum != "" {
		return json.Marshal(p.PlayHtVoiceIdEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlayHtVoiceIdVisitor interface {
	VisitPlayHtVoiceIdEnum(PlayHtVoiceIdEnum) error
	VisitString(string) error
}

func (p *PlayHtVoiceId) Accept(visitor PlayHtVoiceIdVisitor) error {
	if p.typ == "PlayHtVoiceIdEnum" || p.PlayHtVoiceIdEnum != "" {
		return visitor.VisitPlayHtVoiceIdEnum(p.PlayHtVoiceIdEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlayHtVoiceIdEnum string

const (
	PlayHtVoiceIdEnumJennifer PlayHtVoiceIdEnum = "jennifer"
	PlayHtVoiceIdEnumMelissa  PlayHtVoiceIdEnum = "melissa"
	PlayHtVoiceIdEnumWill     PlayHtVoiceIdEnum = "will"
	PlayHtVoiceIdEnumChris    PlayHtVoiceIdEnum = "chris"
	PlayHtVoiceIdEnumMatt     PlayHtVoiceIdEnum = "matt"
	PlayHtVoiceIdEnumJack     PlayHtVoiceIdEnum = "jack"
	PlayHtVoiceIdEnumRuby     PlayHtVoiceIdEnum = "ruby"
	PlayHtVoiceIdEnumDavis    PlayHtVoiceIdEnum = "davis"
	PlayHtVoiceIdEnumDonna    PlayHtVoiceIdEnum = "donna"
	PlayHtVoiceIdEnumMichael  PlayHtVoiceIdEnum = "michael"
)

func NewPlayHtVoiceIdEnumFromString(s string) (PlayHtVoiceIdEnum, error) {
	switch s {
	case "jennifer":
		return PlayHtVoiceIdEnumJennifer, nil
	case "melissa":
		return PlayHtVoiceIdEnumMelissa, nil
	case "will":
		return PlayHtVoiceIdEnumWill, nil
	case "chris":
		return PlayHtVoiceIdEnumChris, nil
	case "matt":
		return PlayHtVoiceIdEnumMatt, nil
	case "jack":
		return PlayHtVoiceIdEnumJack, nil
	case "ruby":
		return PlayHtVoiceIdEnumRuby, nil
	case "davis":
		return PlayHtVoiceIdEnumDavis, nil
	case "donna":
		return PlayHtVoiceIdEnumDonna, nil
	case "michael":
		return PlayHtVoiceIdEnumMichael, nil
	}
	var t PlayHtVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceIdEnum) Ptr() *PlayHtVoiceIdEnum {
	return &p
}

type PlayHtCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	UserId   string  `json:"userId" url:"userId"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlayHtCredential) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PlayHtCredential) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PlayHtCredential) GetOrgId() string {
	if p == nil {
		return ""
	}
	return p.OrgId
}

func (p *PlayHtCredential) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PlayHtCredential) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PlayHtCredential) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PlayHtCredential) GetUserId() string {
	if p == nil {
		return ""
	}
	return p.UserId
}

func (p *PlayHtCredential) Provider() string {
	return p.provider
}

func (p *PlayHtCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlayHtCredential) UnmarshalJSON(data []byte) error {
	type embed PlayHtCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PlayHtCredential(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "playht", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlayHtCredential) MarshalJSON() ([]byte, error) {
	type embed PlayHtCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
		Provider:  "playht",
	}
	return json.Marshal(marshaler)
}

func (p *PlayHtCredential) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlayHtVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *PlayHtVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// A floating point number between 0, exclusive, and 2, inclusive. If equal to null or not provided, the model's default temperature will be used. The temperature parameter controls variance. Lower temperatures result in more predictable results, higher temperatures allow each run to vary more, so the voice may sound less like the baseline voice.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// An emotion to be applied to the speech.
	Emotion *PlayHtVoiceEmotion `json:"emotion,omitempty" url:"emotion,omitempty"`
	// A number between 1 and 6. Use lower numbers to reduce how unique your chosen voice will be compared to other voices.
	VoiceGuidance *float64 `json:"voiceGuidance,omitempty" url:"voiceGuidance,omitempty"`
	// A number between 1 and 30. Use lower numbers to to reduce how strong your chosen emotion will be. Higher numbers will create a very emotional performance.
	StyleGuidance *float64 `json:"styleGuidance,omitempty" url:"styleGuidance,omitempty"`
	// A number between 1 and 2. This number influences how closely the generated speech adheres to the input text. Use lower values to create more fluid speech, but with a higher chance of deviating from the input text. Higher numbers will make the generated speech more accurate to the input text, ensuring that the words spoken align closely with the provided text.
	TextGuidance *float64 `json:"textGuidance,omitempty" url:"textGuidance,omitempty"`
	// Playht voice model/engine to use.
	Model *PlayHtVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// The language to use for the speech.
	Language *PlayHtVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlayHtVoice) GetCachingEnabled() *bool {
	if p == nil {
		return nil
	}
	return p.CachingEnabled
}

func (p *PlayHtVoice) GetVoiceId() *PlayHtVoiceId {
	if p == nil {
		return nil
	}
	return p.VoiceId
}

func (p *PlayHtVoice) GetSpeed() *float64 {
	if p == nil {
		return nil
	}
	return p.Speed
}

func (p *PlayHtVoice) GetTemperature() *float64 {
	if p == nil {
		return nil
	}
	return p.Temperature
}

func (p *PlayHtVoice) GetEmotion() *PlayHtVoiceEmotion {
	if p == nil {
		return nil
	}
	return p.Emotion
}

func (p *PlayHtVoice) GetVoiceGuidance() *float64 {
	if p == nil {
		return nil
	}
	return p.VoiceGuidance
}

func (p *PlayHtVoice) GetStyleGuidance() *float64 {
	if p == nil {
		return nil
	}
	return p.StyleGuidance
}

func (p *PlayHtVoice) GetTextGuidance() *float64 {
	if p == nil {
		return nil
	}
	return p.TextGuidance
}

func (p *PlayHtVoice) GetModel() *PlayHtVoiceModel {
	if p == nil {
		return nil
	}
	return p.Model
}

func (p *PlayHtVoice) GetLanguage() *PlayHtVoiceLanguage {
	if p == nil {
		return nil
	}
	return p.Language
}

func (p *PlayHtVoice) GetChunkPlan() *ChunkPlan {
	if p == nil {
		return nil
	}
	return p.ChunkPlan
}

func (p *PlayHtVoice) GetFallbackPlan() *FallbackPlan {
	if p == nil {
		return nil
	}
	return p.FallbackPlan
}

func (p *PlayHtVoice) Provider() string {
	return p.provider
}

func (p *PlayHtVoice) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlayHtVoice) UnmarshalJSON(data []byte) error {
	type embed PlayHtVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PlayHtVoice(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "playht", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlayHtVoice) MarshalJSON() ([]byte, error) {
	type embed PlayHtVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*p),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (p *PlayHtVoice) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An emotion to be applied to the speech.
type PlayHtVoiceEmotion string

const (
	PlayHtVoiceEmotionFemaleHappy     PlayHtVoiceEmotion = "female_happy"
	PlayHtVoiceEmotionFemaleSad       PlayHtVoiceEmotion = "female_sad"
	PlayHtVoiceEmotionFemaleAngry     PlayHtVoiceEmotion = "female_angry"
	PlayHtVoiceEmotionFemaleFearful   PlayHtVoiceEmotion = "female_fearful"
	PlayHtVoiceEmotionFemaleDisgust   PlayHtVoiceEmotion = "female_disgust"
	PlayHtVoiceEmotionFemaleSurprised PlayHtVoiceEmotion = "female_surprised"
	PlayHtVoiceEmotionMaleHappy       PlayHtVoiceEmotion = "male_happy"
	PlayHtVoiceEmotionMaleSad         PlayHtVoiceEmotion = "male_sad"
	PlayHtVoiceEmotionMaleAngry       PlayHtVoiceEmotion = "male_angry"
	PlayHtVoiceEmotionMaleFearful     PlayHtVoiceEmotion = "male_fearful"
	PlayHtVoiceEmotionMaleDisgust     PlayHtVoiceEmotion = "male_disgust"
	PlayHtVoiceEmotionMaleSurprised   PlayHtVoiceEmotion = "male_surprised"
)

func NewPlayHtVoiceEmotionFromString(s string) (PlayHtVoiceEmotion, error) {
	switch s {
	case "female_happy":
		return PlayHtVoiceEmotionFemaleHappy, nil
	case "female_sad":
		return PlayHtVoiceEmotionFemaleSad, nil
	case "female_angry":
		return PlayHtVoiceEmotionFemaleAngry, nil
	case "female_fearful":
		return PlayHtVoiceEmotionFemaleFearful, nil
	case "female_disgust":
		return PlayHtVoiceEmotionFemaleDisgust, nil
	case "female_surprised":
		return PlayHtVoiceEmotionFemaleSurprised, nil
	case "male_happy":
		return PlayHtVoiceEmotionMaleHappy, nil
	case "male_sad":
		return PlayHtVoiceEmotionMaleSad, nil
	case "male_angry":
		return PlayHtVoiceEmotionMaleAngry, nil
	case "male_fearful":
		return PlayHtVoiceEmotionMaleFearful, nil
	case "male_disgust":
		return PlayHtVoiceEmotionMaleDisgust, nil
	case "male_surprised":
		return PlayHtVoiceEmotionMaleSurprised, nil
	}
	var t PlayHtVoiceEmotion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceEmotion) Ptr() *PlayHtVoiceEmotion {
	return &p
}

// The language to use for the speech.
type PlayHtVoiceLanguage string

const (
	PlayHtVoiceLanguageAfrikaans  PlayHtVoiceLanguage = "afrikaans"
	PlayHtVoiceLanguageAlbanian   PlayHtVoiceLanguage = "albanian"
	PlayHtVoiceLanguageAmharic    PlayHtVoiceLanguage = "amharic"
	PlayHtVoiceLanguageArabic     PlayHtVoiceLanguage = "arabic"
	PlayHtVoiceLanguageBengali    PlayHtVoiceLanguage = "bengali"
	PlayHtVoiceLanguageBulgarian  PlayHtVoiceLanguage = "bulgarian"
	PlayHtVoiceLanguageCatalan    PlayHtVoiceLanguage = "catalan"
	PlayHtVoiceLanguageCroatian   PlayHtVoiceLanguage = "croatian"
	PlayHtVoiceLanguageCzech      PlayHtVoiceLanguage = "czech"
	PlayHtVoiceLanguageDanish     PlayHtVoiceLanguage = "danish"
	PlayHtVoiceLanguageDutch      PlayHtVoiceLanguage = "dutch"
	PlayHtVoiceLanguageEnglish    PlayHtVoiceLanguage = "english"
	PlayHtVoiceLanguageFrench     PlayHtVoiceLanguage = "french"
	PlayHtVoiceLanguageGalician   PlayHtVoiceLanguage = "galician"
	PlayHtVoiceLanguageGerman     PlayHtVoiceLanguage = "german"
	PlayHtVoiceLanguageGreek      PlayHtVoiceLanguage = "greek"
	PlayHtVoiceLanguageHebrew     PlayHtVoiceLanguage = "hebrew"
	PlayHtVoiceLanguageHindi      PlayHtVoiceLanguage = "hindi"
	PlayHtVoiceLanguageHungarian  PlayHtVoiceLanguage = "hungarian"
	PlayHtVoiceLanguageIndonesian PlayHtVoiceLanguage = "indonesian"
	PlayHtVoiceLanguageItalian    PlayHtVoiceLanguage = "italian"
	PlayHtVoiceLanguageJapanese   PlayHtVoiceLanguage = "japanese"
	PlayHtVoiceLanguageKorean     PlayHtVoiceLanguage = "korean"
	PlayHtVoiceLanguageMalay      PlayHtVoiceLanguage = "malay"
	PlayHtVoiceLanguageMandarin   PlayHtVoiceLanguage = "mandarin"
	PlayHtVoiceLanguagePolish     PlayHtVoiceLanguage = "polish"
	PlayHtVoiceLanguagePortuguese PlayHtVoiceLanguage = "portuguese"
	PlayHtVoiceLanguageRussian    PlayHtVoiceLanguage = "russian"
	PlayHtVoiceLanguageSerbian    PlayHtVoiceLanguage = "serbian"
	PlayHtVoiceLanguageSpanish    PlayHtVoiceLanguage = "spanish"
	PlayHtVoiceLanguageSwedish    PlayHtVoiceLanguage = "swedish"
	PlayHtVoiceLanguageTagalog    PlayHtVoiceLanguage = "tagalog"
	PlayHtVoiceLanguageThai       PlayHtVoiceLanguage = "thai"
	PlayHtVoiceLanguageTurkish    PlayHtVoiceLanguage = "turkish"
	PlayHtVoiceLanguageUkrainian  PlayHtVoiceLanguage = "ukrainian"
	PlayHtVoiceLanguageUrdu       PlayHtVoiceLanguage = "urdu"
	PlayHtVoiceLanguageXhosa      PlayHtVoiceLanguage = "xhosa"
)

func NewPlayHtVoiceLanguageFromString(s string) (PlayHtVoiceLanguage, error) {
	switch s {
	case "afrikaans":
		return PlayHtVoiceLanguageAfrikaans, nil
	case "albanian":
		return PlayHtVoiceLanguageAlbanian, nil
	case "amharic":
		return PlayHtVoiceLanguageAmharic, nil
	case "arabic":
		return PlayHtVoiceLanguageArabic, nil
	case "bengali":
		return PlayHtVoiceLanguageBengali, nil
	case "bulgarian":
		return PlayHtVoiceLanguageBulgarian, nil
	case "catalan":
		return PlayHtVoiceLanguageCatalan, nil
	case "croatian":
		return PlayHtVoiceLanguageCroatian, nil
	case "czech":
		return PlayHtVoiceLanguageCzech, nil
	case "danish":
		return PlayHtVoiceLanguageDanish, nil
	case "dutch":
		return PlayHtVoiceLanguageDutch, nil
	case "english":
		return PlayHtVoiceLanguageEnglish, nil
	case "french":
		return PlayHtVoiceLanguageFrench, nil
	case "galician":
		return PlayHtVoiceLanguageGalician, nil
	case "german":
		return PlayHtVoiceLanguageGerman, nil
	case "greek":
		return PlayHtVoiceLanguageGreek, nil
	case "hebrew":
		return PlayHtVoiceLanguageHebrew, nil
	case "hindi":
		return PlayHtVoiceLanguageHindi, nil
	case "hungarian":
		return PlayHtVoiceLanguageHungarian, nil
	case "indonesian":
		return PlayHtVoiceLanguageIndonesian, nil
	case "italian":
		return PlayHtVoiceLanguageItalian, nil
	case "japanese":
		return PlayHtVoiceLanguageJapanese, nil
	case "korean":
		return PlayHtVoiceLanguageKorean, nil
	case "malay":
		return PlayHtVoiceLanguageMalay, nil
	case "mandarin":
		return PlayHtVoiceLanguageMandarin, nil
	case "polish":
		return PlayHtVoiceLanguagePolish, nil
	case "portuguese":
		return PlayHtVoiceLanguagePortuguese, nil
	case "russian":
		return PlayHtVoiceLanguageRussian, nil
	case "serbian":
		return PlayHtVoiceLanguageSerbian, nil
	case "spanish":
		return PlayHtVoiceLanguageSpanish, nil
	case "swedish":
		return PlayHtVoiceLanguageSwedish, nil
	case "tagalog":
		return PlayHtVoiceLanguageTagalog, nil
	case "thai":
		return PlayHtVoiceLanguageThai, nil
	case "turkish":
		return PlayHtVoiceLanguageTurkish, nil
	case "ukrainian":
		return PlayHtVoiceLanguageUkrainian, nil
	case "urdu":
		return PlayHtVoiceLanguageUrdu, nil
	case "xhosa":
		return PlayHtVoiceLanguageXhosa, nil
	}
	var t PlayHtVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceLanguage) Ptr() *PlayHtVoiceLanguage {
	return &p
}

// Playht voice model/engine to use.
type PlayHtVoiceModel string

const (
	PlayHtVoiceModelPlayHt20      PlayHtVoiceModel = "PlayHT2.0"
	PlayHtVoiceModelPlayHt20Turbo PlayHtVoiceModel = "PlayHT2.0-turbo"
	PlayHtVoiceModelPlay30Mini    PlayHtVoiceModel = "Play3.0-mini"
	PlayHtVoiceModelPlayDialog    PlayHtVoiceModel = "PlayDialog"
)

func NewPlayHtVoiceModelFromString(s string) (PlayHtVoiceModel, error) {
	switch s {
	case "PlayHT2.0":
		return PlayHtVoiceModelPlayHt20, nil
	case "PlayHT2.0-turbo":
		return PlayHtVoiceModelPlayHt20Turbo, nil
	case "Play3.0-mini":
		return PlayHtVoiceModelPlay30Mini, nil
	case "PlayDialog":
		return PlayHtVoiceModelPlayDialog, nil
	}
	var t PlayHtVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceModel) Ptr() *PlayHtVoiceModel {
	return &p
}

type PunctuationBoundary string

const (
	// 。
	PunctuationBoundaryCircle PunctuationBoundary = "。"
	// ，
	PunctuationBoundaryFullWidthComma PunctuationBoundary = "，"
	// .
	PunctuationBoundaryDot PunctuationBoundary = "."
	// !
	PunctuationBoundaryExclamation PunctuationBoundary = "!"
	// ?
	PunctuationBoundaryQuestion PunctuationBoundary = "?"
	// ;
	PunctuationBoundarySemicolon PunctuationBoundary = ";"
	// )
	PunctuationBoundaryParenthesis PunctuationBoundary = ")"
	// ،
	PunctuationBoundaryArabicComma PunctuationBoundary = "،"
	// ۔
	PunctuationBoundaryUrduFullStop PunctuationBoundary = "۔"
	// ।
	PunctuationBoundaryBengaliFullStop PunctuationBoundary = "।"
	// ॥
	PunctuationBoundaryDoubleDanda PunctuationBoundary = "॥"
	// |
	PunctuationBoundaryPipe PunctuationBoundary = "|"
	// ||
	PunctuationBoundaryDoublePipe PunctuationBoundary = "||"
	// ,
	PunctuationBoundaryHalfWidthComma PunctuationBoundary = ","
	// :
	PunctuationBoundaryColon PunctuationBoundary = ":"
)

func NewPunctuationBoundaryFromString(s string) (PunctuationBoundary, error) {
	switch s {
	case "。":
		return PunctuationBoundaryCircle, nil
	case "，":
		return PunctuationBoundaryFullWidthComma, nil
	case ".":
		return PunctuationBoundaryDot, nil
	case "!":
		return PunctuationBoundaryExclamation, nil
	case "?":
		return PunctuationBoundaryQuestion, nil
	case ";":
		return PunctuationBoundarySemicolon, nil
	case ")":
		return PunctuationBoundaryParenthesis, nil
	case "،":
		return PunctuationBoundaryArabicComma, nil
	case "۔":
		return PunctuationBoundaryUrduFullStop, nil
	case "।":
		return PunctuationBoundaryBengaliFullStop, nil
	case "॥":
		return PunctuationBoundaryDoubleDanda, nil
	case "|":
		return PunctuationBoundaryPipe, nil
	case "||":
		return PunctuationBoundaryDoublePipe, nil
	case ",":
		return PunctuationBoundaryHalfWidthComma, nil
	case ":":
		return PunctuationBoundaryColon, nil
	}
	var t PunctuationBoundary
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PunctuationBoundary) Ptr() *PunctuationBoundary {
	return &p
}

type Recording struct {
	// This is the stereo recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	StereoUrl *string `json:"stereoUrl,omitempty" url:"stereoUrl,omitempty"`
	// This is the video recording url for the call. To enable, set `assistant.artifactPlan.videoRecordingEnabled`.
	VideoUrl *string `json:"videoUrl,omitempty" url:"videoUrl,omitempty"`
	// This is video recording start delay in ms. To enable, set `assistant.artifactPlan.videoRecordingEnabled`. This can be used to align the playback of the recording with artifact.messages timestamps.
	VideoRecordingStartDelaySeconds *float64 `json:"videoRecordingStartDelaySeconds,omitempty" url:"videoRecordingStartDelaySeconds,omitempty"`
	// This is the mono recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.
	Mono *Mono `json:"mono,omitempty" url:"mono,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Recording) GetStereoUrl() *string {
	if r == nil {
		return nil
	}
	return r.StereoUrl
}

func (r *Recording) GetVideoUrl() *string {
	if r == nil {
		return nil
	}
	return r.VideoUrl
}

func (r *Recording) GetVideoRecordingStartDelaySeconds() *float64 {
	if r == nil {
		return nil
	}
	return r.VideoRecordingStartDelaySeconds
}

func (r *Recording) GetMono() *Mono {
	if r == nil {
		return nil
	}
	return r.Mono
}

func (r *Recording) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Recording) UnmarshalJSON(data []byte) error {
	type unmarshaler Recording
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Recording(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Recording) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RegexOption struct {
	// This is the type of the regex option. Options are:
	// - `ignore-case`: Ignores the case of the text being matched. Add
	// - `whole-word`: Matches whole words only.
	// - `multi-line`: Matches across multiple lines.
	Type RegexOptionType `json:"type" url:"type"`
	// This is whether to enable the option.
	//
	// @default false
	Enabled bool `json:"enabled" url:"enabled"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RegexOption) GetType() RegexOptionType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RegexOption) GetEnabled() bool {
	if r == nil {
		return false
	}
	return r.Enabled
}

func (r *RegexOption) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RegexOption) UnmarshalJSON(data []byte) error {
	type unmarshaler RegexOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegexOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegexOption) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the type of the regex option. Options are:
// - `ignore-case`: Ignores the case of the text being matched. Add
// - `whole-word`: Matches whole words only.
// - `multi-line`: Matches across multiple lines.
type RegexOptionType string

const (
	RegexOptionTypeIgnoreCase RegexOptionType = "ignore-case"
	RegexOptionTypeWholeWord  RegexOptionType = "whole-word"
	RegexOptionTypeMultiLine  RegexOptionType = "multi-line"
)

func NewRegexOptionTypeFromString(s string) (RegexOptionType, error) {
	switch s {
	case "ignore-case":
		return RegexOptionTypeIgnoreCase, nil
	case "whole-word":
		return RegexOptionTypeWholeWord, nil
	case "multi-line":
		return RegexOptionTypeMultiLine, nil
	}
	var t RegexOptionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RegexOptionType) Ptr() *RegexOptionType {
	return &r
}

type RegexReplacement struct {
	// This is the regex replacement type. You can use this to replace a word or phrase that matches a pattern.
	//
	// Usage:
	// - Replace all numbers with "some number": { type: 'regex', regex: '\\d+', value: 'some number' }
	// - Replace email addresses with "[EMAIL]": { type: 'regex', regex: '\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', value: '[EMAIL]' }
	// - Replace phone numbers with a formatted version: { type: 'regex', regex: '(\\d{3})(\\d{3})(\\d{4})', value: '($1) $2-$3' }
	// - Replace all instances of "color" or "colour" with "hue": { type: 'regex', regex: 'colou?r', value: 'hue' }
	// - Capitalize the first letter of every sentence: { type: 'regex', regex: '(?<=\\. |^)[a-z]', value: (match) => match.toUpperCase() }
	// This is the regex pattern to replace.
	//
	// Note:
	// - This works by using the `string.replace` method in Node.JS. Eg. `"hello there".replace(/hello/g, "hi")` will return `"hi there"`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	Regex string `json:"regex" url:"regex"`
	// These are the options for the regex replacement. Defaults to all disabled.
	//
	// @default []
	Options []*RegexOption `json:"options,omitempty" url:"options,omitempty"`
	// This is the value that will replace the match.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RegexReplacement) GetRegex() string {
	if r == nil {
		return ""
	}
	return r.Regex
}

func (r *RegexReplacement) GetOptions() []*RegexOption {
	if r == nil {
		return nil
	}
	return r.Options
}

func (r *RegexReplacement) GetValue() string {
	if r == nil {
		return ""
	}
	return r.Value
}

func (r *RegexReplacement) Type() string {
	return r.type_
}

func (r *RegexReplacement) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RegexReplacement) UnmarshalJSON(data []byte) error {
	type embed RegexReplacement
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RegexReplacement(unmarshaler.embed)
	if unmarshaler.Type != "regex" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "regex", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegexReplacement) MarshalJSON() ([]byte, error) {
	type embed RegexReplacement
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "regex",
	}
	return json.Marshal(marshaler)
}

func (r *RegexReplacement) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the provider-specific ID that will be used.
type RimeAiVoiceId struct {
	RimeAiVoiceIdEnum RimeAiVoiceIdEnum
	String            string

	typ string
}

func (r *RimeAiVoiceId) GetRimeAiVoiceIdEnum() RimeAiVoiceIdEnum {
	if r == nil {
		return ""
	}
	return r.RimeAiVoiceIdEnum
}

func (r *RimeAiVoiceId) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RimeAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueRimeAiVoiceIdEnum RimeAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueRimeAiVoiceIdEnum); err == nil {
		r.typ = "RimeAiVoiceIdEnum"
		r.RimeAiVoiceIdEnum = valueRimeAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RimeAiVoiceId) MarshalJSON() ([]byte, error) {
	if r.typ == "RimeAiVoiceIdEnum" || r.RimeAiVoiceIdEnum != "" {
		return json.Marshal(r.RimeAiVoiceIdEnum)
	}
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RimeAiVoiceIdVisitor interface {
	VisitRimeAiVoiceIdEnum(RimeAiVoiceIdEnum) error
	VisitString(string) error
}

func (r *RimeAiVoiceId) Accept(visitor RimeAiVoiceIdVisitor) error {
	if r.typ == "RimeAiVoiceIdEnum" || r.RimeAiVoiceIdEnum != "" {
		return visitor.VisitRimeAiVoiceIdEnum(r.RimeAiVoiceIdEnum)
	}
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RimeAiVoiceIdEnum string

const (
	RimeAiVoiceIdEnumAbbie      RimeAiVoiceIdEnum = "abbie"
	RimeAiVoiceIdEnumAllison    RimeAiVoiceIdEnum = "allison"
	RimeAiVoiceIdEnumAlly       RimeAiVoiceIdEnum = "ally"
	RimeAiVoiceIdEnumAlona      RimeAiVoiceIdEnum = "alona"
	RimeAiVoiceIdEnumAmber      RimeAiVoiceIdEnum = "amber"
	RimeAiVoiceIdEnumAna        RimeAiVoiceIdEnum = "ana"
	RimeAiVoiceIdEnumAntoine    RimeAiVoiceIdEnum = "antoine"
	RimeAiVoiceIdEnumArmon      RimeAiVoiceIdEnum = "armon"
	RimeAiVoiceIdEnumBrenda     RimeAiVoiceIdEnum = "brenda"
	RimeAiVoiceIdEnumBrittany   RimeAiVoiceIdEnum = "brittany"
	RimeAiVoiceIdEnumCarol      RimeAiVoiceIdEnum = "carol"
	RimeAiVoiceIdEnumColin      RimeAiVoiceIdEnum = "colin"
	RimeAiVoiceIdEnumCourtney   RimeAiVoiceIdEnum = "courtney"
	RimeAiVoiceIdEnumElena      RimeAiVoiceIdEnum = "elena"
	RimeAiVoiceIdEnumElliot     RimeAiVoiceIdEnum = "elliot"
	RimeAiVoiceIdEnumEva        RimeAiVoiceIdEnum = "eva"
	RimeAiVoiceIdEnumGeoff      RimeAiVoiceIdEnum = "geoff"
	RimeAiVoiceIdEnumGerald     RimeAiVoiceIdEnum = "gerald"
	RimeAiVoiceIdEnumHank       RimeAiVoiceIdEnum = "hank"
	RimeAiVoiceIdEnumHelen      RimeAiVoiceIdEnum = "helen"
	RimeAiVoiceIdEnumHera       RimeAiVoiceIdEnum = "hera"
	RimeAiVoiceIdEnumJen        RimeAiVoiceIdEnum = "jen"
	RimeAiVoiceIdEnumJoe        RimeAiVoiceIdEnum = "joe"
	RimeAiVoiceIdEnumJoy        RimeAiVoiceIdEnum = "joy"
	RimeAiVoiceIdEnumJuan       RimeAiVoiceIdEnum = "juan"
	RimeAiVoiceIdEnumKendra     RimeAiVoiceIdEnum = "kendra"
	RimeAiVoiceIdEnumKendrick   RimeAiVoiceIdEnum = "kendrick"
	RimeAiVoiceIdEnumKenneth    RimeAiVoiceIdEnum = "kenneth"
	RimeAiVoiceIdEnumKevin      RimeAiVoiceIdEnum = "kevin"
	RimeAiVoiceIdEnumKris       RimeAiVoiceIdEnum = "kris"
	RimeAiVoiceIdEnumLinda      RimeAiVoiceIdEnum = "linda"
	RimeAiVoiceIdEnumMadison    RimeAiVoiceIdEnum = "madison"
	RimeAiVoiceIdEnumMarge      RimeAiVoiceIdEnum = "marge"
	RimeAiVoiceIdEnumMarina     RimeAiVoiceIdEnum = "marina"
	RimeAiVoiceIdEnumMarissa    RimeAiVoiceIdEnum = "marissa"
	RimeAiVoiceIdEnumMarta      RimeAiVoiceIdEnum = "marta"
	RimeAiVoiceIdEnumMaya       RimeAiVoiceIdEnum = "maya"
	RimeAiVoiceIdEnumNicholas   RimeAiVoiceIdEnum = "nicholas"
	RimeAiVoiceIdEnumNyles      RimeAiVoiceIdEnum = "nyles"
	RimeAiVoiceIdEnumPhil       RimeAiVoiceIdEnum = "phil"
	RimeAiVoiceIdEnumReba       RimeAiVoiceIdEnum = "reba"
	RimeAiVoiceIdEnumRex        RimeAiVoiceIdEnum = "rex"
	RimeAiVoiceIdEnumRick       RimeAiVoiceIdEnum = "rick"
	RimeAiVoiceIdEnumRitu       RimeAiVoiceIdEnum = "ritu"
	RimeAiVoiceIdEnumRob        RimeAiVoiceIdEnum = "rob"
	RimeAiVoiceIdEnumRodney     RimeAiVoiceIdEnum = "rodney"
	RimeAiVoiceIdEnumRohan      RimeAiVoiceIdEnum = "rohan"
	RimeAiVoiceIdEnumRosco      RimeAiVoiceIdEnum = "rosco"
	RimeAiVoiceIdEnumSamantha   RimeAiVoiceIdEnum = "samantha"
	RimeAiVoiceIdEnumSandy      RimeAiVoiceIdEnum = "sandy"
	RimeAiVoiceIdEnumSelena     RimeAiVoiceIdEnum = "selena"
	RimeAiVoiceIdEnumSeth       RimeAiVoiceIdEnum = "seth"
	RimeAiVoiceIdEnumSharon     RimeAiVoiceIdEnum = "sharon"
	RimeAiVoiceIdEnumStan       RimeAiVoiceIdEnum = "stan"
	RimeAiVoiceIdEnumTamra      RimeAiVoiceIdEnum = "tamra"
	RimeAiVoiceIdEnumTanya      RimeAiVoiceIdEnum = "tanya"
	RimeAiVoiceIdEnumTibur      RimeAiVoiceIdEnum = "tibur"
	RimeAiVoiceIdEnumTj         RimeAiVoiceIdEnum = "tj"
	RimeAiVoiceIdEnumTyler      RimeAiVoiceIdEnum = "tyler"
	RimeAiVoiceIdEnumViv        RimeAiVoiceIdEnum = "viv"
	RimeAiVoiceIdEnumYadira     RimeAiVoiceIdEnum = "yadira"
	RimeAiVoiceIdEnumMarsh      RimeAiVoiceIdEnum = "marsh"
	RimeAiVoiceIdEnumBayou      RimeAiVoiceIdEnum = "bayou"
	RimeAiVoiceIdEnumCreek      RimeAiVoiceIdEnum = "creek"
	RimeAiVoiceIdEnumBrook      RimeAiVoiceIdEnum = "brook"
	RimeAiVoiceIdEnumFlower     RimeAiVoiceIdEnum = "flower"
	RimeAiVoiceIdEnumSpore      RimeAiVoiceIdEnum = "spore"
	RimeAiVoiceIdEnumGlacier    RimeAiVoiceIdEnum = "glacier"
	RimeAiVoiceIdEnumGulch      RimeAiVoiceIdEnum = "gulch"
	RimeAiVoiceIdEnumAlpine     RimeAiVoiceIdEnum = "alpine"
	RimeAiVoiceIdEnumCove       RimeAiVoiceIdEnum = "cove"
	RimeAiVoiceIdEnumLagoon     RimeAiVoiceIdEnum = "lagoon"
	RimeAiVoiceIdEnumTundra     RimeAiVoiceIdEnum = "tundra"
	RimeAiVoiceIdEnumSteppe     RimeAiVoiceIdEnum = "steppe"
	RimeAiVoiceIdEnumMesa       RimeAiVoiceIdEnum = "mesa"
	RimeAiVoiceIdEnumGrove      RimeAiVoiceIdEnum = "grove"
	RimeAiVoiceIdEnumRainforest RimeAiVoiceIdEnum = "rainforest"
	RimeAiVoiceIdEnumMoraine    RimeAiVoiceIdEnum = "moraine"
	RimeAiVoiceIdEnumWildflower RimeAiVoiceIdEnum = "wildflower"
	RimeAiVoiceIdEnumPeak       RimeAiVoiceIdEnum = "peak"
	RimeAiVoiceIdEnumBoulder    RimeAiVoiceIdEnum = "boulder"
	RimeAiVoiceIdEnumGypsum     RimeAiVoiceIdEnum = "gypsum"
	RimeAiVoiceIdEnumZest       RimeAiVoiceIdEnum = "zest"
)

func NewRimeAiVoiceIdEnumFromString(s string) (RimeAiVoiceIdEnum, error) {
	switch s {
	case "abbie":
		return RimeAiVoiceIdEnumAbbie, nil
	case "allison":
		return RimeAiVoiceIdEnumAllison, nil
	case "ally":
		return RimeAiVoiceIdEnumAlly, nil
	case "alona":
		return RimeAiVoiceIdEnumAlona, nil
	case "amber":
		return RimeAiVoiceIdEnumAmber, nil
	case "ana":
		return RimeAiVoiceIdEnumAna, nil
	case "antoine":
		return RimeAiVoiceIdEnumAntoine, nil
	case "armon":
		return RimeAiVoiceIdEnumArmon, nil
	case "brenda":
		return RimeAiVoiceIdEnumBrenda, nil
	case "brittany":
		return RimeAiVoiceIdEnumBrittany, nil
	case "carol":
		return RimeAiVoiceIdEnumCarol, nil
	case "colin":
		return RimeAiVoiceIdEnumColin, nil
	case "courtney":
		return RimeAiVoiceIdEnumCourtney, nil
	case "elena":
		return RimeAiVoiceIdEnumElena, nil
	case "elliot":
		return RimeAiVoiceIdEnumElliot, nil
	case "eva":
		return RimeAiVoiceIdEnumEva, nil
	case "geoff":
		return RimeAiVoiceIdEnumGeoff, nil
	case "gerald":
		return RimeAiVoiceIdEnumGerald, nil
	case "hank":
		return RimeAiVoiceIdEnumHank, nil
	case "helen":
		return RimeAiVoiceIdEnumHelen, nil
	case "hera":
		return RimeAiVoiceIdEnumHera, nil
	case "jen":
		return RimeAiVoiceIdEnumJen, nil
	case "joe":
		return RimeAiVoiceIdEnumJoe, nil
	case "joy":
		return RimeAiVoiceIdEnumJoy, nil
	case "juan":
		return RimeAiVoiceIdEnumJuan, nil
	case "kendra":
		return RimeAiVoiceIdEnumKendra, nil
	case "kendrick":
		return RimeAiVoiceIdEnumKendrick, nil
	case "kenneth":
		return RimeAiVoiceIdEnumKenneth, nil
	case "kevin":
		return RimeAiVoiceIdEnumKevin, nil
	case "kris":
		return RimeAiVoiceIdEnumKris, nil
	case "linda":
		return RimeAiVoiceIdEnumLinda, nil
	case "madison":
		return RimeAiVoiceIdEnumMadison, nil
	case "marge":
		return RimeAiVoiceIdEnumMarge, nil
	case "marina":
		return RimeAiVoiceIdEnumMarina, nil
	case "marissa":
		return RimeAiVoiceIdEnumMarissa, nil
	case "marta":
		return RimeAiVoiceIdEnumMarta, nil
	case "maya":
		return RimeAiVoiceIdEnumMaya, nil
	case "nicholas":
		return RimeAiVoiceIdEnumNicholas, nil
	case "nyles":
		return RimeAiVoiceIdEnumNyles, nil
	case "phil":
		return RimeAiVoiceIdEnumPhil, nil
	case "reba":
		return RimeAiVoiceIdEnumReba, nil
	case "rex":
		return RimeAiVoiceIdEnumRex, nil
	case "rick":
		return RimeAiVoiceIdEnumRick, nil
	case "ritu":
		return RimeAiVoiceIdEnumRitu, nil
	case "rob":
		return RimeAiVoiceIdEnumRob, nil
	case "rodney":
		return RimeAiVoiceIdEnumRodney, nil
	case "rohan":
		return RimeAiVoiceIdEnumRohan, nil
	case "rosco":
		return RimeAiVoiceIdEnumRosco, nil
	case "samantha":
		return RimeAiVoiceIdEnumSamantha, nil
	case "sandy":
		return RimeAiVoiceIdEnumSandy, nil
	case "selena":
		return RimeAiVoiceIdEnumSelena, nil
	case "seth":
		return RimeAiVoiceIdEnumSeth, nil
	case "sharon":
		return RimeAiVoiceIdEnumSharon, nil
	case "stan":
		return RimeAiVoiceIdEnumStan, nil
	case "tamra":
		return RimeAiVoiceIdEnumTamra, nil
	case "tanya":
		return RimeAiVoiceIdEnumTanya, nil
	case "tibur":
		return RimeAiVoiceIdEnumTibur, nil
	case "tj":
		return RimeAiVoiceIdEnumTj, nil
	case "tyler":
		return RimeAiVoiceIdEnumTyler, nil
	case "viv":
		return RimeAiVoiceIdEnumViv, nil
	case "yadira":
		return RimeAiVoiceIdEnumYadira, nil
	case "marsh":
		return RimeAiVoiceIdEnumMarsh, nil
	case "bayou":
		return RimeAiVoiceIdEnumBayou, nil
	case "creek":
		return RimeAiVoiceIdEnumCreek, nil
	case "brook":
		return RimeAiVoiceIdEnumBrook, nil
	case "flower":
		return RimeAiVoiceIdEnumFlower, nil
	case "spore":
		return RimeAiVoiceIdEnumSpore, nil
	case "glacier":
		return RimeAiVoiceIdEnumGlacier, nil
	case "gulch":
		return RimeAiVoiceIdEnumGulch, nil
	case "alpine":
		return RimeAiVoiceIdEnumAlpine, nil
	case "cove":
		return RimeAiVoiceIdEnumCove, nil
	case "lagoon":
		return RimeAiVoiceIdEnumLagoon, nil
	case "tundra":
		return RimeAiVoiceIdEnumTundra, nil
	case "steppe":
		return RimeAiVoiceIdEnumSteppe, nil
	case "mesa":
		return RimeAiVoiceIdEnumMesa, nil
	case "grove":
		return RimeAiVoiceIdEnumGrove, nil
	case "rainforest":
		return RimeAiVoiceIdEnumRainforest, nil
	case "moraine":
		return RimeAiVoiceIdEnumMoraine, nil
	case "wildflower":
		return RimeAiVoiceIdEnumWildflower, nil
	case "peak":
		return RimeAiVoiceIdEnumPeak, nil
	case "boulder":
		return RimeAiVoiceIdEnumBoulder, nil
	case "gypsum":
		return RimeAiVoiceIdEnumGypsum, nil
	case "zest":
		return RimeAiVoiceIdEnumZest, nil
	}
	var t RimeAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RimeAiVoiceIdEnum) Ptr() *RimeAiVoiceIdEnum {
	return &r
}

type RimeAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RimeAiCredential) GetApiKey() string {
	if r == nil {
		return ""
	}
	return r.ApiKey
}

func (r *RimeAiCredential) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RimeAiCredential) GetOrgId() string {
	if r == nil {
		return ""
	}
	return r.OrgId
}

func (r *RimeAiCredential) GetCreatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.CreatedAt
}

func (r *RimeAiCredential) GetUpdatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.UpdatedAt
}

func (r *RimeAiCredential) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RimeAiCredential) Provider() string {
	return r.provider
}

func (r *RimeAiCredential) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RimeAiCredential) UnmarshalJSON(data []byte) error {
	type embed RimeAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RimeAiCredential(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rime-ai", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RimeAiCredential) MarshalJSON() ([]byte, error) {
	type embed RimeAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*r),
		CreatedAt: internal.NewDateTime(r.CreatedAt),
		UpdatedAt: internal.NewDateTime(r.UpdatedAt),
		Provider:  "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (r *RimeAiCredential) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RimeAiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *RimeAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the model that will be used. Defaults to 'v1' when not specified.
	Model *RimeAiVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is a flag that controls whether to add slight pauses using angle brackets. Example: "Hi. <200> I'd love to have a conversation with you." adds a 200ms pause between the first and second sentences.
	PauseBetweenBrackets *bool `json:"pauseBetweenBrackets,omitempty" url:"pauseBetweenBrackets,omitempty"`
	// This is a flag that controls whether text inside brackets should be phonemized (converted to phonetic pronunciation) - Example: "{h'El.o} World" will pronounce "Hello" as expected.
	PhonemizeBetweenBrackets *bool `json:"phonemizeBetweenBrackets,omitempty" url:"phonemizeBetweenBrackets,omitempty"`
	// This is a flag that controls whether to optimize for reduced latency in streaming. https://docs.rime.ai/api-reference/endpoint/websockets#param-reduce-latency
	ReduceLatency *bool `json:"reduceLatency,omitempty" url:"reduceLatency,omitempty"`
	// This is a string that allows inline speed control using alpha notation. https://docs.rime.ai/api-reference/endpoint/websockets#param-inline-speed-alpha
	InlineSpeedAlpha *string `json:"inlineSpeedAlpha,omitempty" url:"inlineSpeedAlpha,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RimeAiVoice) GetCachingEnabled() *bool {
	if r == nil {
		return nil
	}
	return r.CachingEnabled
}

func (r *RimeAiVoice) GetVoiceId() *RimeAiVoiceId {
	if r == nil {
		return nil
	}
	return r.VoiceId
}

func (r *RimeAiVoice) GetModel() *RimeAiVoiceModel {
	if r == nil {
		return nil
	}
	return r.Model
}

func (r *RimeAiVoice) GetSpeed() *float64 {
	if r == nil {
		return nil
	}
	return r.Speed
}

func (r *RimeAiVoice) GetPauseBetweenBrackets() *bool {
	if r == nil {
		return nil
	}
	return r.PauseBetweenBrackets
}

func (r *RimeAiVoice) GetPhonemizeBetweenBrackets() *bool {
	if r == nil {
		return nil
	}
	return r.PhonemizeBetweenBrackets
}

func (r *RimeAiVoice) GetReduceLatency() *bool {
	if r == nil {
		return nil
	}
	return r.ReduceLatency
}

func (r *RimeAiVoice) GetInlineSpeedAlpha() *string {
	if r == nil {
		return nil
	}
	return r.InlineSpeedAlpha
}

func (r *RimeAiVoice) GetChunkPlan() *ChunkPlan {
	if r == nil {
		return nil
	}
	return r.ChunkPlan
}

func (r *RimeAiVoice) GetFallbackPlan() *FallbackPlan {
	if r == nil {
		return nil
	}
	return r.FallbackPlan
}

func (r *RimeAiVoice) Provider() string {
	return r.provider
}

func (r *RimeAiVoice) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RimeAiVoice) UnmarshalJSON(data []byte) error {
	type embed RimeAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RimeAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rime-ai", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RimeAiVoice) MarshalJSON() ([]byte, error) {
	type embed RimeAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*r),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (r *RimeAiVoice) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the model that will be used. Defaults to 'v1' when not specified.
type RimeAiVoiceModel string

const (
	RimeAiVoiceModelV1     RimeAiVoiceModel = "v1"
	RimeAiVoiceModelMist   RimeAiVoiceModel = "mist"
	RimeAiVoiceModelMistv2 RimeAiVoiceModel = "mistv2"
)

func NewRimeAiVoiceModelFromString(s string) (RimeAiVoiceModel, error) {
	switch s {
	case "v1":
		return RimeAiVoiceModelV1, nil
	case "mist":
		return RimeAiVoiceModelMist, nil
	case "mistv2":
		return RimeAiVoiceModelMistv2, nil
	}
	var t RimeAiVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RimeAiVoiceModel) Ptr() *RimeAiVoiceModel {
	return &r
}

type RunpodCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RunpodCredential) GetApiKey() string {
	if r == nil {
		return ""
	}
	return r.ApiKey
}

func (r *RunpodCredential) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RunpodCredential) GetOrgId() string {
	if r == nil {
		return ""
	}
	return r.OrgId
}

func (r *RunpodCredential) GetCreatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.CreatedAt
}

func (r *RunpodCredential) GetUpdatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.UpdatedAt
}

func (r *RunpodCredential) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RunpodCredential) Provider() string {
	return r.provider
}

func (r *RunpodCredential) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RunpodCredential) UnmarshalJSON(data []byte) error {
	type embed RunpodCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RunpodCredential(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "runpod" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "runpod", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RunpodCredential) MarshalJSON() ([]byte, error) {
	type embed RunpodCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*r),
		CreatedAt: internal.NewDateTime(r.CreatedAt),
		UpdatedAt: internal.NewDateTime(r.UpdatedAt),
		Provider:  "runpod",
	}
	return json.Marshal(marshaler)
}

func (r *RunpodCredential) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type S3Credential struct {
	// Credential provider. Only allowed value is s3
	// AWS access key ID.
	AwsAccessKeyId string `json:"awsAccessKeyId" url:"awsAccessKeyId"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey string `json:"awsSecretAccessKey" url:"awsSecretAccessKey"`
	// AWS region in which the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// AWS S3 bucket name.
	S3BucketName string `json:"s3BucketName" url:"s3BucketName"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix string `json:"s3PathPrefix" url:"s3PathPrefix"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *S3Credential) GetAwsAccessKeyId() string {
	if s == nil {
		return ""
	}
	return s.AwsAccessKeyId
}

func (s *S3Credential) GetAwsSecretAccessKey() string {
	if s == nil {
		return ""
	}
	return s.AwsSecretAccessKey
}

func (s *S3Credential) GetRegion() string {
	if s == nil {
		return ""
	}
	return s.Region
}

func (s *S3Credential) GetS3BucketName() string {
	if s == nil {
		return ""
	}
	return s.S3BucketName
}

func (s *S3Credential) GetS3PathPrefix() string {
	if s == nil {
		return ""
	}
	return s.S3PathPrefix
}

func (s *S3Credential) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *S3Credential) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *S3Credential) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *S3Credential) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *S3Credential) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *S3Credential) Provider() string {
	return s.provider
}

func (s *S3Credential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *S3Credential) UnmarshalJSON(data []byte) error {
	type embed S3Credential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = S3Credential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "s3" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "s3", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *S3Credential) MarshalJSON() ([]byte, error) {
	type embed S3Credential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Provider:  "s3",
	}
	return json.Marshal(marshaler)
}

func (s *S3Credential) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SayAssistantHookAction struct {
	// This is the type of action - must be "say"
	// This is the message to say
	Exact map[string]interface{} `json:"exact,omitempty" url:"exact,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SayAssistantHookAction) GetExact() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Exact
}

func (s *SayAssistantHookAction) Type() string {
	return s.type_
}

func (s *SayAssistantHookAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SayAssistantHookAction) UnmarshalJSON(data []byte) error {
	type embed SayAssistantHookAction
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SayAssistantHookAction(unmarshaler.embed)
	if unmarshaler.Type != "say" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "say", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SayAssistantHookAction) MarshalJSON() ([]byte, error) {
	type embed SayAssistantHookAction
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "say",
	}
	return json.Marshal(marshaler)
}

func (s *SayAssistantHookAction) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SayPhoneNumberHookAction struct {
	// This is the type of action - must be "say"
	// This is the message to say
	Exact string `json:"exact" url:"exact"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SayPhoneNumberHookAction) GetExact() string {
	if s == nil {
		return ""
	}
	return s.Exact
}

func (s *SayPhoneNumberHookAction) Type() string {
	return s.type_
}

func (s *SayPhoneNumberHookAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SayPhoneNumberHookAction) UnmarshalJSON(data []byte) error {
	type embed SayPhoneNumberHookAction
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SayPhoneNumberHookAction(unmarshaler.embed)
	if unmarshaler.Type != "say" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "say", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SayPhoneNumberHookAction) MarshalJSON() ([]byte, error) {
	type embed SayPhoneNumberHookAction
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "say",
	}
	return json.Marshal(marshaler)
}

func (s *SayPhoneNumberHookAction) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SbcConfiguration struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SbcConfiguration) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SbcConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler SbcConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SbcConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SbcConfiguration) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Server struct {
	// This is the timeout in seconds for the request. Defaults to 20 seconds.
	//
	// @default 20
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// This is where the request will be sent.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// These are the headers to include in the request.
	//
	// Each key-value pair represents a header name and its value.
	Headers map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`
	// This is the backoff plan if the request fails. Defaults to undefined (the request will not be retried).
	//
	// @default undefined (the request will not be retried)
	BackoffPlan *BackoffPlan `json:"backoffPlan,omitempty" url:"backoffPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Server) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *Server) GetUrl() *string {
	if s == nil {
		return nil
	}
	return s.Url
}

func (s *Server) GetHeaders() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Headers
}

func (s *Server) GetBackoffPlan() *BackoffPlan {
	if s == nil {
		return nil
	}
	return s.BackoffPlan
}

func (s *Server) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Server) UnmarshalJSON(data []byte) error {
	type unmarshaler Server
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Server(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Server) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessage struct {
	// These are all the messages that can be sent to your server before, after and during the call. Configure the messages you'd like to receive in `assistant.serverMessages`.
	//
	// The server where the message is sent is determined by the following precedence order:
	//
	// 1. `tool.server.url` (if configured, and only for "tool-calls" message)
	// 2. `assistant.serverUrl` (if configure)
	// 3. `phoneNumber.serverUrl` (if configured)
	// 4. `org.serverUrl` (if configured)
	Message *ServerMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessage) GetMessage() *ServerMessageMessage {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *ServerMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageAssistantRequest struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageAssistantRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "assistant-request" is sent to fetch assistant configuration for an incoming call.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageAssistantRequest) GetPhoneNumber() *ServerMessageAssistantRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageAssistantRequest) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageAssistantRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageAssistantRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageAssistantRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageAssistantRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageAssistantRequest) Type() string {
	return s.type_
}

func (s *ServerMessageAssistantRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageAssistantRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageAssistantRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageAssistantRequest(unmarshaler.embed)
	if unmarshaler.Type != "assistant-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "assistant-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageAssistantRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageAssistantRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "assistant-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageAssistantRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageAssistantRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageAssistantRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageAssistantRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageAssistantRequestPhoneNumber) Accept(visitor ServerMessageAssistantRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdate struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageConversationUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "conversation-update" is sent when an update is committed to the conversation history.
	// This is the most up-to-date conversation history at the time the message is sent.
	Messages []*ServerMessageConversationUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageConversationUpdate) GetPhoneNumber() *ServerMessageConversationUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageConversationUpdate) GetMessages() []*ServerMessageConversationUpdateMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *ServerMessageConversationUpdate) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if s == nil {
		return nil
	}
	return s.MessagesOpenAiFormatted
}

func (s *ServerMessageConversationUpdate) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageConversationUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageConversationUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageConversationUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageConversationUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageConversationUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageConversationUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageConversationUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageConversationUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageConversationUpdate(unmarshaler.embed)
	if unmarshaler.Type != "conversation-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "conversation-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageConversationUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageConversationUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "conversation-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageConversationUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageConversationUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (s *ServerMessageConversationUpdateMessagesItem) GetUserMessage() *UserMessage {
	if s == nil {
		return nil
	}
	return s.UserMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetSystemMessage() *SystemMessage {
	if s == nil {
		return nil
	}
	return s.SystemMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetBotMessage() *BotMessage {
	if s == nil {
		return nil
	}
	return s.BotMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallResultMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.typ = "UserMessage"
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.typ = "SystemMessage"
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.typ = "BotMessage"
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.typ = "ToolCallMessage"
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.typ = "ToolCallResultMessage"
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageConversationUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageConversationUpdateMessagesItem) Accept(visitor ServerMessageConversationUpdateMessagesItemVisitor) error {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number that the message is associated with.
type ServerMessageConversationUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageConversationUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageConversationUpdatePhoneNumber) Accept(visitor ServerMessageConversationUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReport struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageEndOfCallReportPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "end-of-call-report" is sent when the call ends and post-processing is complete.
	// This is the reason the call ended. This can also be found at `call.endedReason` on GET /call/:id.
	EndedReason ServerMessageEndOfCallReportEndedReason `json:"endedReason" url:"endedReason"`
	// This is the cost of the call in USD. This can also be found at `call.cost` on GET /call/:id.
	Cost *float64 `json:"cost,omitempty" url:"cost,omitempty"`
	// These are the costs of individual components of the call in USD. This can also be found at `call.costs` on GET /call/:id.
	Costs []*ServerMessageEndOfCallReportCostsItem `json:"costs,omitempty" url:"costs,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// These are the artifacts from the call. This can also be found at `call.artifact` on GET /call/:id.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the analysis of the call. This can also be found at `call.analysis` on GET /call/:id.
	Analysis *Analysis `json:"analysis,omitempty" url:"analysis,omitempty"`
	// This is the ISO 8601 date-time string of when the call started. This can also be found at `call.startedAt` on GET /call/:id.
	StartedAt *time.Time `json:"startedAt,omitempty" url:"startedAt,omitempty"`
	// This is the ISO 8601 date-time string of when the call ended. This can also be found at `call.endedAt` on GET /call/:id.
	EndedAt *time.Time `json:"endedAt,omitempty" url:"endedAt,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageEndOfCallReport) GetPhoneNumber() *ServerMessageEndOfCallReportPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageEndOfCallReport) GetEndedReason() ServerMessageEndOfCallReportEndedReason {
	if s == nil {
		return ""
	}
	return s.EndedReason
}

func (s *ServerMessageEndOfCallReport) GetCost() *float64 {
	if s == nil {
		return nil
	}
	return s.Cost
}

func (s *ServerMessageEndOfCallReport) GetCosts() []*ServerMessageEndOfCallReportCostsItem {
	if s == nil {
		return nil
	}
	return s.Costs
}

func (s *ServerMessageEndOfCallReport) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageEndOfCallReport) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageEndOfCallReport) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageEndOfCallReport) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageEndOfCallReport) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageEndOfCallReport) GetAnalysis() *Analysis {
	if s == nil {
		return nil
	}
	return s.Analysis
}

func (s *ServerMessageEndOfCallReport) GetStartedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartedAt
}

func (s *ServerMessageEndOfCallReport) GetEndedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.EndedAt
}

func (s *ServerMessageEndOfCallReport) Type() string {
	return s.type_
}

func (s *ServerMessageEndOfCallReport) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageEndOfCallReport) UnmarshalJSON(data []byte) error {
	type embed ServerMessageEndOfCallReport
	var unmarshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt,omitempty"`
		EndedAt   *internal.DateTime `json:"endedAt,omitempty"`
		Type      string             `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageEndOfCallReport(unmarshaler.embed)
	s.StartedAt = unmarshaler.StartedAt.TimePtr()
	s.EndedAt = unmarshaler.EndedAt.TimePtr()
	if unmarshaler.Type != "end-of-call-report" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "end-of-call-report", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageEndOfCallReport) MarshalJSON() ([]byte, error) {
	type embed ServerMessageEndOfCallReport
	var marshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt,omitempty"`
		EndedAt   *internal.DateTime `json:"endedAt,omitempty"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*s),
		StartedAt: internal.NewOptionalDateTime(s.StartedAt),
		EndedAt:   internal.NewOptionalDateTime(s.EndedAt),
		Type:      "end-of-call-report",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageEndOfCallReport) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageEndOfCallReportCostsItem struct {
	TransportCost          *TransportCost
	TranscriberCost        *TranscriberCost
	ModelCost              *ModelCost
	VoiceCost              *VoiceCost
	VapiCost               *VapiCost
	VoicemailDetectionCost *VoicemailDetectionCost
	AnalysisCost           *AnalysisCost
	KnowledgeBaseCost      *KnowledgeBaseCost

	typ string
}

func (s *ServerMessageEndOfCallReportCostsItem) GetTransportCost() *TransportCost {
	if s == nil {
		return nil
	}
	return s.TransportCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetTranscriberCost() *TranscriberCost {
	if s == nil {
		return nil
	}
	return s.TranscriberCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetModelCost() *ModelCost {
	if s == nil {
		return nil
	}
	return s.ModelCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetVoiceCost() *VoiceCost {
	if s == nil {
		return nil
	}
	return s.VoiceCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetVapiCost() *VapiCost {
	if s == nil {
		return nil
	}
	return s.VapiCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetVoicemailDetectionCost() *VoicemailDetectionCost {
	if s == nil {
		return nil
	}
	return s.VoicemailDetectionCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetAnalysisCost() *AnalysisCost {
	if s == nil {
		return nil
	}
	return s.AnalysisCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetKnowledgeBaseCost() *KnowledgeBaseCost {
	if s == nil {
		return nil
	}
	return s.KnowledgeBaseCost
}

func (s *ServerMessageEndOfCallReportCostsItem) UnmarshalJSON(data []byte) error {
	valueTransportCost := new(TransportCost)
	if err := json.Unmarshal(data, &valueTransportCost); err == nil {
		s.typ = "TransportCost"
		s.TransportCost = valueTransportCost
		return nil
	}
	valueTranscriberCost := new(TranscriberCost)
	if err := json.Unmarshal(data, &valueTranscriberCost); err == nil {
		s.typ = "TranscriberCost"
		s.TranscriberCost = valueTranscriberCost
		return nil
	}
	valueModelCost := new(ModelCost)
	if err := json.Unmarshal(data, &valueModelCost); err == nil {
		s.typ = "ModelCost"
		s.ModelCost = valueModelCost
		return nil
	}
	valueVoiceCost := new(VoiceCost)
	if err := json.Unmarshal(data, &valueVoiceCost); err == nil {
		s.typ = "VoiceCost"
		s.VoiceCost = valueVoiceCost
		return nil
	}
	valueVapiCost := new(VapiCost)
	if err := json.Unmarshal(data, &valueVapiCost); err == nil {
		s.typ = "VapiCost"
		s.VapiCost = valueVapiCost
		return nil
	}
	valueVoicemailDetectionCost := new(VoicemailDetectionCost)
	if err := json.Unmarshal(data, &valueVoicemailDetectionCost); err == nil {
		s.typ = "VoicemailDetectionCost"
		s.VoicemailDetectionCost = valueVoicemailDetectionCost
		return nil
	}
	valueAnalysisCost := new(AnalysisCost)
	if err := json.Unmarshal(data, &valueAnalysisCost); err == nil {
		s.typ = "AnalysisCost"
		s.AnalysisCost = valueAnalysisCost
		return nil
	}
	valueKnowledgeBaseCost := new(KnowledgeBaseCost)
	if err := json.Unmarshal(data, &valueKnowledgeBaseCost); err == nil {
		s.typ = "KnowledgeBaseCost"
		s.KnowledgeBaseCost = valueKnowledgeBaseCost
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageEndOfCallReportCostsItem) MarshalJSON() ([]byte, error) {
	if s.typ == "TransportCost" || s.TransportCost != nil {
		return json.Marshal(s.TransportCost)
	}
	if s.typ == "TranscriberCost" || s.TranscriberCost != nil {
		return json.Marshal(s.TranscriberCost)
	}
	if s.typ == "ModelCost" || s.ModelCost != nil {
		return json.Marshal(s.ModelCost)
	}
	if s.typ == "VoiceCost" || s.VoiceCost != nil {
		return json.Marshal(s.VoiceCost)
	}
	if s.typ == "VapiCost" || s.VapiCost != nil {
		return json.Marshal(s.VapiCost)
	}
	if s.typ == "VoicemailDetectionCost" || s.VoicemailDetectionCost != nil {
		return json.Marshal(s.VoicemailDetectionCost)
	}
	if s.typ == "AnalysisCost" || s.AnalysisCost != nil {
		return json.Marshal(s.AnalysisCost)
	}
	if s.typ == "KnowledgeBaseCost" || s.KnowledgeBaseCost != nil {
		return json.Marshal(s.KnowledgeBaseCost)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReportCostsItemVisitor interface {
	VisitTransportCost(*TransportCost) error
	VisitTranscriberCost(*TranscriberCost) error
	VisitModelCost(*ModelCost) error
	VisitVoiceCost(*VoiceCost) error
	VisitVapiCost(*VapiCost) error
	VisitVoicemailDetectionCost(*VoicemailDetectionCost) error
	VisitAnalysisCost(*AnalysisCost) error
	VisitKnowledgeBaseCost(*KnowledgeBaseCost) error
}

func (s *ServerMessageEndOfCallReportCostsItem) Accept(visitor ServerMessageEndOfCallReportCostsItemVisitor) error {
	if s.typ == "TransportCost" || s.TransportCost != nil {
		return visitor.VisitTransportCost(s.TransportCost)
	}
	if s.typ == "TranscriberCost" || s.TranscriberCost != nil {
		return visitor.VisitTranscriberCost(s.TranscriberCost)
	}
	if s.typ == "ModelCost" || s.ModelCost != nil {
		return visitor.VisitModelCost(s.ModelCost)
	}
	if s.typ == "VoiceCost" || s.VoiceCost != nil {
		return visitor.VisitVoiceCost(s.VoiceCost)
	}
	if s.typ == "VapiCost" || s.VapiCost != nil {
		return visitor.VisitVapiCost(s.VapiCost)
	}
	if s.typ == "VoicemailDetectionCost" || s.VoicemailDetectionCost != nil {
		return visitor.VisitVoicemailDetectionCost(s.VoicemailDetectionCost)
	}
	if s.typ == "AnalysisCost" || s.AnalysisCost != nil {
		return visitor.VisitAnalysisCost(s.AnalysisCost)
	}
	if s.typ == "KnowledgeBaseCost" || s.KnowledgeBaseCost != nil {
		return visitor.VisitKnowledgeBaseCost(s.KnowledgeBaseCost)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the reason the call ended. This can also be found at `call.endedReason` on GET /call/:id.
type ServerMessageEndOfCallReportEndedReason string

const (
	ServerMessageEndOfCallReportEndedReasonCallStartErrorNeitherAssistantNorServerSet                                                                ServerMessageEndOfCallReportEndedReason = "call-start-error-neither-assistant-nor-server-set"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestFailed                                                                                    ServerMessageEndOfCallReportEndedReason = "assistant-request-failed"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedError                                                                             ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-error"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedUnspeakableError                                                                  ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-unspeakable-error"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedInvalidAssistant                                                                  ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-invalid-assistant"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedNoAssistant                                                                       ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-no-assistant"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedForwardingPhoneNumber                                                             ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-forwarding-phone-number"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorGetOrg                                                                                      ServerMessageEndOfCallReportEndedReason = "call.start.error-get-org"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorGetSubscription                                                                             ServerMessageEndOfCallReportEndedReason = "call.start.error-get-subscription"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorGetAssistant                                                                                ServerMessageEndOfCallReportEndedReason = "call.start.error-get-assistant"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorGetPhoneNumber                                                                              ServerMessageEndOfCallReportEndedReason = "call.start.error-get-phone-number"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorGetCustomer                                                                                 ServerMessageEndOfCallReportEndedReason = "call.start.error-get-customer"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorGetResourcesValidation                                                                      ServerMessageEndOfCallReportEndedReason = "call.start.error-get-resources-validation"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorVapiNumberInternational                                                                     ServerMessageEndOfCallReportEndedReason = "call.start.error-vapi-number-international"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorVapiNumberOutboundDailyLimit                                                                ServerMessageEndOfCallReportEndedReason = "call.start.error-vapi-number-outbound-daily-limit"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorGetTransport                                                                                ServerMessageEndOfCallReportEndedReason = "call.start.error-get-transport"
	ServerMessageEndOfCallReportEndedReasonAssistantNotValid                                                                                         ServerMessageEndOfCallReportEndedReason = "assistant-not-valid"
	ServerMessageEndOfCallReportEndedReasonDatabaseError                                                                                             ServerMessageEndOfCallReportEndedReason = "database-error"
	ServerMessageEndOfCallReportEndedReasonAssistantNotFound                                                                                         ServerMessageEndOfCallReportEndedReason = "assistant-not-found"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiVoiceFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaVoiceFailed                                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramVoiceFailed                                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceFailed                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorLmntVoiceFailed                                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-lmnt-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureVoiceFailed                                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRimeAiVoiceFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-rime-ai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorSmallestAiVoiceFailed                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-smallest-ai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorNeuphonicVoiceFailed                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-neuphonic-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorHumeVoiceFailed                                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-hume-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorSesameVoiceFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-sesame-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTavusVideoFailed                                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-tavus-video-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenaiVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCartesiaVoiceFailed                                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cartesia-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramVoiceFailed                                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepgram-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceFailed                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultLmntVoiceFailed                                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-lmnt-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureVoiceFailed                                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-azure-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRimeAiVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-rime-ai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultSmallestAiVoiceFailed                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-smallest-ai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultNeuphonicVoiceFailed                                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-neuphonic-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultHumeVoiceFailed                                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-hume-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultSesameVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-sesame-voice-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTavusVideoFailed                                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-tavus-video-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapiLlmFailed                                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi400BadRequestValidationFailed                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi401Unauthorized                                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi403ModelAccessDenied                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi429ExceededQuota                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi500ServerError                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi503ServerOverloadedError                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapiLlmFailed                                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-vapi-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi400BadRequestValidationFailed                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-vapi-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi401Unauthorized                                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-vapi-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi403ModelAccessDenied                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-vapi-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi429ExceededQuota                                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-vapi-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultVapi500ServerError                                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-vapi-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultVapi503ServerOverloadedError                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-vapi-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramTranscriberFailed                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramTranscriberFailed                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepgram-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGladiaTranscriberFailed                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-gladia-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGladiaTranscriberFailed                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-gladia-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorSpeechmaticsTranscriberFailed                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-speechmatics-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultSpeechmaticsTranscriberFailed                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-speechmatics-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiTranscriberFailed                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-assembly-ai-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning400InsufficentFunds                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-assembly-ai-returning-400-insufficent-funds"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning400PaidOnlyFeature                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-assembly-ai-returning-400-paid-only-feature"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning401InvalidCredentials                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-assembly-ai-returning-401-invalid-credentials"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning500InvalidSchema                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-assembly-ai-returning-500-invalid-schema"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning500WordBoostParsingFailed                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-assembly-ai-returning-500-word-boost-parsing-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiTranscriberFailed                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-assembly-ai-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400InsufficentFunds                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-400-insufficent-funds"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400PaidOnlyFeature                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-400-paid-only-feature"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning401InvalidCredentials                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-401-invalid-credentials"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500InvalidSchema                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-500-invalid-schema"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500WordBoostParsingFailed                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-500-word-boost-parsing-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTalkscriberTranscriberFailed                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-talkscriber-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTalkscriberTranscriberFailed                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-talkscriber-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureSpeechTranscriberFailed                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-speech-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureSpeechTranscriberFailed                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-azure-speech-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorPipelineNoAvailableLlmModel                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-pipeline-no-available-llm-model"
	ServerMessageEndOfCallReportEndedReasonWorkerShutdown                                                                                            ServerMessageEndOfCallReportEndedReason = "worker-shutdown"
	ServerMessageEndOfCallReportEndedReasonUnknownError                                                                                              ServerMessageEndOfCallReportEndedReason = "unknown-error"
	ServerMessageEndOfCallReportEndedReasonVonageDisconnected                                                                                        ServerMessageEndOfCallReportEndedReason = "vonage-disconnected"
	ServerMessageEndOfCallReportEndedReasonVonageFailedToConnectCall                                                                                 ServerMessageEndOfCallReportEndedReason = "vonage-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonVonageCompleted                                                                                           ServerMessageEndOfCallReportEndedReason = "vonage-completed"
	ServerMessageEndOfCallReportEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived                                                           ServerMessageEndOfCallReportEndedReason = "phone-call-provider-bypass-enabled-but-no-call-received"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultTransportNeverConnected                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-transport-never-connected"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultWorkerNotAvailable                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-worker-not-available"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTransportNeverConnected                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-transport-never-connected"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTransportConnectedButCallNotActive                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-transport-connected-but-call-not-active"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCallStartedButConnectionToTransportMissing                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-call-started-but-connection-to-transport-missing"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenaiLlmFailed                                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenaiLlmFailed                                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-azure-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroqLlmFailed                                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-groq-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogleLlmFailed                                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-google-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXaiLlmFailed                                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-xai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistralLlmFailed                                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-mistral-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAiLlmFailed                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-inflection-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebrasLlmFailed                                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cerebras-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeekLlmFailed                                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deep-seek-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai400BadRequestValidationFailed                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401Unauthorized                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401IncorrectApiKey                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-401-incorrect-api-key"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401AccountNotInOrganization                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-401-account-not-in-organization"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai403ModelAccessDenied                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429ExceededQuota                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429RateLimitReached                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-429-rate-limit-reached"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai500ServerError                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai503ServerOverloadedError                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiLlmFailed                                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai400BadRequestValidationFailed                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai401IncorrectApiKey                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-401-incorrect-api-key"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai401AccountNotInOrganization                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-401-account-not-in-organization"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai403ModelAccessDenied                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai429RateLimitReached                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-429-rate-limit-reached"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenai500ServerError                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenai503ServerOverloadedError                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-openai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai401Unauthorized                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai429ExceededQuota                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai500ServerError                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai503ServerOverloadedError                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenaiLlmFailed                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai400BadRequestValidationFailed                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-azure-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai401Unauthorized                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-azure-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai403ModelAccessDenied                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-azure-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai429ExceededQuota                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-azure-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAzureOpenai500ServerError                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-azure-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAzureOpenai503ServerOverloadedError                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-azure-openai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle400BadRequestValidationFailed                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle401Unauthorized                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle403ModelAccessDenied                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle429ExceededQuota                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle500ServerError                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle503ServerOverloadedError                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogleLlmFailed                                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle400BadRequestValidationFailed                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-google-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-google-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle403ModelAccessDenied                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-google-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-google-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGoogle500ServerError                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-google-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGoogle503ServerOverloadedError                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-google-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai400BadRequestValidationFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai401Unauthorized                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai403ModelAccessDenied                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai429ExceededQuota                                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai500ServerError                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai503ServerOverloadedError                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXaiLlmFailed                                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai400BadRequestValidationFailed                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-xai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai401Unauthorized                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-xai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai403ModelAccessDenied                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-xai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai429ExceededQuota                                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-xai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultXai500ServerError                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-xai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultXai503ServerOverloadedError                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-xai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral400BadRequestValidationFailed                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-mistral-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral401Unauthorized                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-mistral-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral403ModelAccessDenied                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-mistral-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral429ExceededQuota                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-mistral-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral500ServerError                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-mistral-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral503ServerOverloadedError                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-mistral-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorMistralLlmFailed                                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-mistral-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral400BadRequestValidationFailed                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-mistral-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral401Unauthorized                                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-mistral-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral403ModelAccessDenied                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-mistral-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral429ExceededQuota                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-mistral-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultMistral500ServerError                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-mistral-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultMistral503ServerOverloadedError                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-mistral-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi401Unauthorized                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi403ModelAccessDenied                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi429ExceededQuota                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi500ServerError                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi503ServerOverloadedError                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAiLlmFailed                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi400BadRequestValidationFailed                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-inflection-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi401Unauthorized                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-inflection-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi403ModelAccessDenied                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-inflection-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi429ExceededQuota                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-inflection-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultInflectionAi500ServerError                                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-inflection-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultInflectionAi503ServerOverloadedError                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-inflection-ai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek401Unauthorized                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek403ModelAccessDenied                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek429ExceededQuota                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek500ServerError                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek503ServerOverloadedError                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeekLlmFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek400BadRequestValidationFailed                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deep-seek-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek401Unauthorized                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deep-seek-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek403ModelAccessDenied                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deep-seek-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek429ExceededQuota                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deep-seek-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepSeek500ServerError                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-deep-seek-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepSeek503ServerOverloadedError                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-deep-seek-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq400BadRequestValidationFailed                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq401Unauthorized                                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq403ModelAccessDenied                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq429ExceededQuota                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq500ServerError                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq503ServerOverloadedError                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroqLlmFailed                                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq400BadRequestValidationFailed                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-groq-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq401Unauthorized                                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-groq-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq403ModelAccessDenied                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-groq-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq429ExceededQuota                                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-groq-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGroq500ServerError                                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-groq-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGroq503ServerOverloadedError                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-groq-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras400BadRequestValidationFailed                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras401Unauthorized                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras403ModelAccessDenied                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras429ExceededQuota                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras500ServerError                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras503ServerOverloadedError                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebrasLlmFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras400BadRequestValidationFailed                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cerebras-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras401Unauthorized                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cerebras-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras403ModelAccessDenied                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cerebras-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras429ExceededQuota                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cerebras-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCerebras500ServerError                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-cerebras-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCerebras503ServerOverloadedError                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-cerebras-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic401Unauthorized                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic403ModelAccessDenied                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic429ExceededQuota                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic500ServerError                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic503ServerOverloadedError                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicLlmFailed                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicLlmFailed                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic400BadRequestValidationFailed                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic401Unauthorized                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic403ModelAccessDenied                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic429ExceededQuota                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropic500ServerError                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anthropic-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropic503ServerOverloadedError                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anthropic-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock400BadRequestValidationFailed                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-bedrock-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock401Unauthorized                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-bedrock-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock403ModelAccessDenied                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-bedrock-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock429ExceededQuota                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-bedrock-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock500ServerError                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-bedrock-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock503ServerOverloadedError                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-bedrock-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrockLlmFailed                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-bedrock-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrockLlmFailed                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock400BadRequestValidationFailed                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock401Unauthorized                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock403ModelAccessDenied                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock429ExceededQuota                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock500ServerError                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anthropic-bedrock-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock503ServerOverloadedError                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anthropic-bedrock-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex400BadRequestValidationFailed                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-vertex-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex401Unauthorized                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-vertex-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex403ModelAccessDenied                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-vertex-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex429ExceededQuota                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-vertex-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex500ServerError                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-vertex-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex503ServerOverloadedError                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-vertex-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertexLlmFailed                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-vertex-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertexLlmFailed                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex400BadRequestValidationFailed                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex401Unauthorized                                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex403ModelAccessDenied                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex429ExceededQuota                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicVertex500ServerError                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anthropic-vertex-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicVertex503ServerOverloadedError                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anthropic-vertex-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi401Unauthorized                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi403ModelAccessDenied                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi429ExceededQuota                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi500ServerError                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi503ServerOverloadedError                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAiLlmFailed                                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAiLlmFailed                                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-together-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi400BadRequestValidationFailed                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-together-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi401Unauthorized                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-together-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi403ModelAccessDenied                                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-together-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi429ExceededQuota                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-together-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultTogetherAi500ServerError                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-together-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultTogetherAi503ServerOverloadedError                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-together-ai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale401Unauthorized                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale403ModelAccessDenied                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale429ExceededQuota                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale500ServerError                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale503ServerOverloadedError                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscaleLlmFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscaleLlmFailed                                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anyscale-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale400BadRequestValidationFailed                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anyscale-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale401Unauthorized                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anyscale-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale403ModelAccessDenied                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anyscale-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale429ExceededQuota                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-anyscale-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnyscale500ServerError                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anyscale-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnyscale503ServerOverloadedError                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-anyscale-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter401Unauthorized                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter403ModelAccessDenied                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter429ExceededQuota                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter500ServerError                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter503ServerOverloadedError                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouterLlmFailed                                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouterLlmFailed                                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openrouter-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter400BadRequestValidationFailed                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openrouter-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter401Unauthorized                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openrouter-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter403ModelAccessDenied                                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openrouter-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter429ExceededQuota                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openrouter-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenrouter500ServerError                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-openrouter-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenrouter503ServerOverloadedError                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-openrouter-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi401Unauthorized                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi429ExceededQuota                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi500ServerError                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi503ServerOverloadedError                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAiLlmFailed                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAiLlmFailed                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-perplexity-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi400BadRequestValidationFailed                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi401Unauthorized                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-perplexity-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi403ModelAccessDenied                                              ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-perplexity-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi429ExceededQuota                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-perplexity-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPerplexityAi500ServerError                                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-perplexity-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPerplexityAi503ServerOverloadedError                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-perplexity-ai-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra401Unauthorized                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra403ModelAccessDenied                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra429ExceededQuota                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra500ServerError                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra503ServerOverloadedError                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfraLlmFailed                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfraLlmFailed                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepinfra-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra400BadRequestValidationFailed                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepinfra-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra401Unauthorized                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepinfra-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra403ModelAccessDenied                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepinfra-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra429ExceededQuota                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepinfra-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepinfra500ServerError                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-deepinfra-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepinfra503ServerOverloadedError                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-deepinfra-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod400BadRequestValidationFailed                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod401Unauthorized                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod403ModelAccessDenied                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod429ExceededQuota                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod500ServerError                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod503ServerOverloadedError                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpodLlmFailed                                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpodLlmFailed                                                               ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-runpod-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod400BadRequestValidationFailed                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-runpod-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-runpod-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod403ModelAccessDenied                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-runpod-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-runpod-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultRunpod500ServerError                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-runpod-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultRunpod503ServerOverloadedError                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-runpod-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm401Unauthorized                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm403ModelAccessDenied                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm429ExceededQuota                                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm500ServerError                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm503ServerOverloadedError                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlmLlmFailed                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlmLlmFailed                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-custom-llm-llm-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm400BadRequestValidationFailed                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-custom-llm-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm401Unauthorized                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-custom-llm-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm403ModelAccessDenied                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-custom-llm-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm429ExceededQuota                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-custom-llm-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCustomLlm500ServerError                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-custom-llm-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCustomLlm503ServerOverloadedError                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-custom-llm-503-server-overloaded-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomVoiceFailed                                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaSocketHangUp                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-socket-hang-up"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaRequestedPayment                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-requested-payment"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia500ServerError                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia503ServerError                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-503-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia522ServerError                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-522-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCartesiaSocketHangUp                                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cartesia-socket-hang-up"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCartesiaRequestedPayment                                                      ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-cartesia-requested-payment"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCartesia500ServerError                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-cartesia-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCartesia503ServerError                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-cartesia-503-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCartesia522ServerError                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-cartesia-522-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFound                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-found"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsQuotaExceeded                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-quota-exceeded"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedAccess                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-unauthorized-access"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-unauthorized-to-access-model"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidApiKey                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-invalid-api-key"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples                                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-invalid-voice-samples"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-disabled-by-owner"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-account-in-probation"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-content-against-their-policy"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-max-character-limit-exceeded"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification                ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabs500ServerError                                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-500-server-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFound                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-found"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsQuotaExceeded                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-quota-exceeded"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedAccess                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-unauthorized-access"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedToAccessModel                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-unauthorized-to-access-model"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsProfessionalVoicesOnlyForCreatorPlus                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedFreePlanAndRequestedUpgrade                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsSystemBusyAndRequestedUpgrade                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTuned                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidApiKey                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-invalid-api-key"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidVoiceSamples                                                 ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-invalid-voice-samples"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceDisabledByOwner                                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-disabled-by-owner"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedAccountInProbation                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-account-in-probation"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedContentAgainstTheirPolicy                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-content-against-their-policy"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsMissingSamplesForVoiceClone                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTunedAndCannotBeUsed                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotAllowedForFreeUsers                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsMaxCharacterLimitExceeded                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-max-character-limit-exceeded"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultElevenLabs500ServerError                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-eleven-labs-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtRequestTimedOut                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-request-timed-out"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidVoice                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-invalid-voice"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtUnexpectedError                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-unexpected-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtOutOfCredits                                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-out-of-credits"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidEmotion                                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-invalid-emotion"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht401Unauthorized                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-403-forbidden-out-of-characters"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-403-forbidden-api-access-not-available"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht429ExceededQuota                                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht502GatewayError                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-502-gateway-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht504GatewayError                                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-504-gateway-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtRequestTimedOut                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-request-timed-out"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtInvalidVoice                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-invalid-voice"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtUnexpectedError                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-unexpected-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtOutOfCredits                                                            ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-out-of-credits"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtInvalidEmotion                                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-invalid-emotion"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtVoiceMustBeAValidVoiceManifestUri                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenOutOfCharacters                                             ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-403-forbidden-out-of-characters"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenApiAccessNotAvailable                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-403-forbidden-api-access-not-available"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-playht-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPlayht502GatewayError                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-playht-502-gateway-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPlayht504GatewayError                                                     ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-playht-504-gateway-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomTranscriberFailed                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomTranscriberFailed                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-custom-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsTranscriberFailed                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsTranscriberFailed                                                   ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-eleven-labs-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-401-invalid-credentials"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning404NotFound                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-404-not-found"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning500InvalidJson                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-500-invalid-json"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502NetworkError                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-502-network-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning400NoSuchModelLanguageTierCombination                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepgram-returning-400-no-such-model-language-tier-combination"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning401InvalidCredentials                                        ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepgram-returning-401-invalid-credentials"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning404NotFound                                                  ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepgram-returning-404-not-found"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning403ModelAccessDenied                                         ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-deepgram-returning-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepgramReturning500InvalidJson                                           ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-deepgram-returning-500-invalid-json"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502NetworkError                                          ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-deepgram-returning-502-network-error"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502BadGatewayEhostunreach                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-providerfault-deepgram-returning-502-bad-gateway-ehostunreach"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogleTranscriberFailed                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogleTranscriberFailed                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-google-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiTranscriberFailed                                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenaiTranscriberFailed                                                       ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-vapifault-openai-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonAssistantEndedCall                                                                                        ServerMessageEndOfCallReportEndedReason = "assistant-ended-call"
	ServerMessageEndOfCallReportEndedReasonAssistantSaidEndCallPhrase                                                                                ServerMessageEndOfCallReportEndedReason = "assistant-said-end-call-phrase"
	ServerMessageEndOfCallReportEndedReasonAssistantEndedCallWithHangupTask                                                                          ServerMessageEndOfCallReportEndedReason = "assistant-ended-call-with-hangup-task"
	ServerMessageEndOfCallReportEndedReasonAssistantEndedCallAfterMessageSpoken                                                                      ServerMessageEndOfCallReportEndedReason = "assistant-ended-call-after-message-spoken"
	ServerMessageEndOfCallReportEndedReasonAssistantForwardedCall                                                                                    ServerMessageEndOfCallReportEndedReason = "assistant-forwarded-call"
	ServerMessageEndOfCallReportEndedReasonAssistantJoinTimedOut                                                                                     ServerMessageEndOfCallReportEndedReason = "assistant-join-timed-out"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorAssistantDidNotReceiveCustomerAudio                                                    ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-assistant-did-not-receive-customer-audio"
	ServerMessageEndOfCallReportEndedReasonCustomerBusy                                                                                              ServerMessageEndOfCallReportEndedReason = "customer-busy"
	ServerMessageEndOfCallReportEndedReasonCustomerEndedCall                                                                                         ServerMessageEndOfCallReportEndedReason = "customer-ended-call"
	ServerMessageEndOfCallReportEndedReasonCustomerDidNotAnswer                                                                                      ServerMessageEndOfCallReportEndedReason = "customer-did-not-answer"
	ServerMessageEndOfCallReportEndedReasonCustomerDidNotGiveMicrophonePermission                                                                    ServerMessageEndOfCallReportEndedReason = "customer-did-not-give-microphone-permission"
	ServerMessageEndOfCallReportEndedReasonExceededMaxDuration                                                                                       ServerMessageEndOfCallReportEndedReason = "exceeded-max-duration"
	ServerMessageEndOfCallReportEndedReasonManuallyCanceled                                                                                          ServerMessageEndOfCallReportEndedReason = "manually-canceled"
	ServerMessageEndOfCallReportEndedReasonPhoneCallProviderClosedWebsocket                                                                          ServerMessageEndOfCallReportEndedReason = "phone-call-provider-closed-websocket"
	ServerMessageEndOfCallReportEndedReasonCallForwardingOperatorBusy                                                                                ServerMessageEndOfCallReportEndedReason = "call.forwarding.operator-busy"
	ServerMessageEndOfCallReportEndedReasonSilenceTimedOut                                                                                           ServerMessageEndOfCallReportEndedReason = "silence-timed-out"
	ServerMessageEndOfCallReportEndedReasonCallInProgressErrorSipTelephonyProviderFailedToConnectCall                                                ServerMessageEndOfCallReportEndedReason = "call.in-progress.error-sip-telephony-provider-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonCallRingingHookExecutedSay                                                                                ServerMessageEndOfCallReportEndedReason = "call.ringing.hook-executed-say"
	ServerMessageEndOfCallReportEndedReasonCallRingingHookExecutedTransfer                                                                           ServerMessageEndOfCallReportEndedReason = "call.ringing.hook-executed-transfer"
	ServerMessageEndOfCallReportEndedReasonTwilioFailedToConnectCall                                                                                 ServerMessageEndOfCallReportEndedReason = "twilio-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonTwilioReportedCustomerMisdialed                                                                           ServerMessageEndOfCallReportEndedReason = "twilio-reported-customer-misdialed"
	ServerMessageEndOfCallReportEndedReasonVonageRejected                                                                                            ServerMessageEndOfCallReportEndedReason = "vonage-rejected"
	ServerMessageEndOfCallReportEndedReasonVoicemail                                                                                                 ServerMessageEndOfCallReportEndedReason = "voicemail"
)

func NewServerMessageEndOfCallReportEndedReasonFromString(s string) (ServerMessageEndOfCallReportEndedReason, error) {
	switch s {
	case "call-start-error-neither-assistant-nor-server-set":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorNeitherAssistantNorServerSet, nil
	case "assistant-request-failed":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestFailed, nil
	case "assistant-request-returned-error":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedError, nil
	case "assistant-request-returned-unspeakable-error":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedUnspeakableError, nil
	case "assistant-request-returned-invalid-assistant":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedInvalidAssistant, nil
	case "assistant-request-returned-no-assistant":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedNoAssistant, nil
	case "assistant-request-returned-forwarding-phone-number":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedForwardingPhoneNumber, nil
	case "call.start.error-get-org":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorGetOrg, nil
	case "call.start.error-get-subscription":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorGetSubscription, nil
	case "call.start.error-get-assistant":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorGetAssistant, nil
	case "call.start.error-get-phone-number":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorGetPhoneNumber, nil
	case "call.start.error-get-customer":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorGetCustomer, nil
	case "call.start.error-get-resources-validation":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorGetResourcesValidation, nil
	case "call.start.error-vapi-number-international":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorVapiNumberInternational, nil
	case "call.start.error-vapi-number-outbound-daily-limit":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorVapiNumberOutboundDailyLimit, nil
	case "call.start.error-get-transport":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorGetTransport, nil
	case "assistant-not-valid":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotValid, nil
	case "database-error":
		return ServerMessageEndOfCallReportEndedReasonDatabaseError, nil
	case "assistant-not-found":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotFound, nil
	case "pipeline-error-openai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiVoiceFailed, nil
	case "pipeline-error-cartesia-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaVoiceFailed, nil
	case "pipeline-error-deepgram-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramVoiceFailed, nil
	case "pipeline-error-eleven-labs-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceFailed, nil
	case "pipeline-error-playht-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceFailed, nil
	case "pipeline-error-lmnt-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorLmntVoiceFailed, nil
	case "pipeline-error-azure-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureVoiceFailed, nil
	case "pipeline-error-rime-ai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRimeAiVoiceFailed, nil
	case "pipeline-error-smallest-ai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorSmallestAiVoiceFailed, nil
	case "pipeline-error-neuphonic-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorNeuphonicVoiceFailed, nil
	case "pipeline-error-hume-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorHumeVoiceFailed, nil
	case "pipeline-error-sesame-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorSesameVoiceFailed, nil
	case "pipeline-error-tavus-video-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTavusVideoFailed, nil
	case "call.in-progress.error-vapifault-openai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenaiVoiceFailed, nil
	case "call.in-progress.error-vapifault-cartesia-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCartesiaVoiceFailed, nil
	case "call.in-progress.error-vapifault-deepgram-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramVoiceFailed, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceFailed, nil
	case "call.in-progress.error-vapifault-playht-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtVoiceFailed, nil
	case "call.in-progress.error-vapifault-lmnt-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultLmntVoiceFailed, nil
	case "call.in-progress.error-vapifault-azure-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureVoiceFailed, nil
	case "call.in-progress.error-vapifault-rime-ai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRimeAiVoiceFailed, nil
	case "call.in-progress.error-vapifault-smallest-ai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultSmallestAiVoiceFailed, nil
	case "call.in-progress.error-vapifault-neuphonic-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultNeuphonicVoiceFailed, nil
	case "call.in-progress.error-vapifault-hume-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultHumeVoiceFailed, nil
	case "call.in-progress.error-vapifault-sesame-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultSesameVoiceFailed, nil
	case "call.in-progress.error-vapifault-tavus-video-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTavusVideoFailed, nil
	case "pipeline-error-vapi-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapiLlmFailed, nil
	case "pipeline-error-vapi-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi400BadRequestValidationFailed, nil
	case "pipeline-error-vapi-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi401Unauthorized, nil
	case "pipeline-error-vapi-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi403ModelAccessDenied, nil
	case "pipeline-error-vapi-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi429ExceededQuota, nil
	case "pipeline-error-vapi-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi500ServerError, nil
	case "pipeline-error-vapi-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi503ServerOverloadedError, nil
	case "call.in-progress.error-vapifault-vapi-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapiLlmFailed, nil
	case "call.in-progress.error-vapifault-vapi-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-vapi-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi401Unauthorized, nil
	case "call.in-progress.error-vapifault-vapi-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-vapi-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultVapi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-vapi-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultVapi500ServerError, nil
	case "call.in-progress.error-providerfault-vapi-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultVapi503ServerOverloadedError, nil
	case "pipeline-error-deepgram-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramTranscriberFailed, nil
	case "call.in-progress.error-vapifault-deepgram-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramTranscriberFailed, nil
	case "pipeline-error-gladia-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGladiaTranscriberFailed, nil
	case "call.in-progress.error-vapifault-gladia-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGladiaTranscriberFailed, nil
	case "pipeline-error-speechmatics-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorSpeechmaticsTranscriberFailed, nil
	case "call.in-progress.error-vapifault-speechmatics-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultSpeechmaticsTranscriberFailed, nil
	case "pipeline-error-assembly-ai-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiTranscriberFailed, nil
	case "pipeline-error-assembly-ai-returning-400-insufficent-funds":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning400InsufficentFunds, nil
	case "pipeline-error-assembly-ai-returning-400-paid-only-feature":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning400PaidOnlyFeature, nil
	case "pipeline-error-assembly-ai-returning-401-invalid-credentials":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning401InvalidCredentials, nil
	case "pipeline-error-assembly-ai-returning-500-invalid-schema":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning500InvalidSchema, nil
	case "pipeline-error-assembly-ai-returning-500-word-boost-parsing-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiReturning500WordBoostParsingFailed, nil
	case "call.in-progress.error-vapifault-assembly-ai-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiTranscriberFailed, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-400-insufficent-funds":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400InsufficentFunds, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-400-paid-only-feature":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400PaidOnlyFeature, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-401-invalid-credentials":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning401InvalidCredentials, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-500-invalid-schema":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500InvalidSchema, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-500-word-boost-parsing-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500WordBoostParsingFailed, nil
	case "pipeline-error-talkscriber-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTalkscriberTranscriberFailed, nil
	case "call.in-progress.error-vapifault-talkscriber-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTalkscriberTranscriberFailed, nil
	case "pipeline-error-azure-speech-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureSpeechTranscriberFailed, nil
	case "call.in-progress.error-vapifault-azure-speech-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureSpeechTranscriberFailed, nil
	case "call.in-progress.error-pipeline-no-available-llm-model":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorPipelineNoAvailableLlmModel, nil
	case "worker-shutdown":
		return ServerMessageEndOfCallReportEndedReasonWorkerShutdown, nil
	case "unknown-error":
		return ServerMessageEndOfCallReportEndedReasonUnknownError, nil
	case "vonage-disconnected":
		return ServerMessageEndOfCallReportEndedReasonVonageDisconnected, nil
	case "vonage-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonVonageFailedToConnectCall, nil
	case "vonage-completed":
		return ServerMessageEndOfCallReportEndedReasonVonageCompleted, nil
	case "phone-call-provider-bypass-enabled-but-no-call-received":
		return ServerMessageEndOfCallReportEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived, nil
	case "call.in-progress.error-providerfault-transport-never-connected":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultTransportNeverConnected, nil
	case "call.in-progress.error-vapifault-worker-not-available":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultWorkerNotAvailable, nil
	case "call.in-progress.error-vapifault-transport-never-connected":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTransportNeverConnected, nil
	case "call.in-progress.error-vapifault-transport-connected-but-call-not-active":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTransportConnectedButCallNotActive, nil
	case "call.in-progress.error-vapifault-call-started-but-connection-to-transport-missing":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCallStartedButConnectionToTransportMissing, nil
	case "call.in-progress.error-vapifault-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-azure-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-groq-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroqLlmFailed, nil
	case "call.in-progress.error-vapifault-google-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogleLlmFailed, nil
	case "call.in-progress.error-vapifault-xai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXaiLlmFailed, nil
	case "call.in-progress.error-vapifault-mistral-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistralLlmFailed, nil
	case "call.in-progress.error-vapifault-inflection-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAiLlmFailed, nil
	case "call.in-progress.error-vapifault-cerebras-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebrasLlmFailed, nil
	case "call.in-progress.error-vapifault-deep-seek-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeekLlmFailed, nil
	case "pipeline-error-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401Unauthorized, nil
	case "pipeline-error-openai-401-incorrect-api-key":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401IncorrectApiKey, nil
	case "pipeline-error-openai-401-account-not-in-organization":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401AccountNotInOrganization, nil
	case "pipeline-error-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai403ModelAccessDenied, nil
	case "pipeline-error-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429ExceededQuota, nil
	case "pipeline-error-openai-429-rate-limit-reached":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429RateLimitReached, nil
	case "pipeline-error-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai500ServerError, nil
	case "pipeline-error-openai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai503ServerOverloadedError, nil
	case "pipeline-error-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai401Unauthorized, nil
	case "call.in-progress.error-vapifault-openai-401-incorrect-api-key":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai401IncorrectApiKey, nil
	case "call.in-progress.error-vapifault-openai-401-account-not-in-organization":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai401AccountNotInOrganization, nil
	case "call.in-progress.error-vapifault-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai429ExceededQuota, nil
	case "call.in-progress.error-vapifault-openai-429-rate-limit-reached":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenai429RateLimitReached, nil
	case "call.in-progress.error-providerfault-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenai500ServerError, nil
	case "call.in-progress.error-providerfault-openai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenai503ServerOverloadedError, nil
	case "pipeline-error-azure-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-azure-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai401Unauthorized, nil
	case "pipeline-error-azure-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied, nil
	case "pipeline-error-azure-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai429ExceededQuota, nil
	case "pipeline-error-azure-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai500ServerError, nil
	case "pipeline-error-azure-openai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai503ServerOverloadedError, nil
	case "pipeline-error-azure-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-azure-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-azure-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai401Unauthorized, nil
	case "call.in-progress.error-vapifault-azure-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-azure-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAzureOpenai429ExceededQuota, nil
	case "call.in-progress.error-providerfault-azure-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAzureOpenai500ServerError, nil
	case "call.in-progress.error-providerfault-azure-openai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAzureOpenai503ServerOverloadedError, nil
	case "pipeline-error-google-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle400BadRequestValidationFailed, nil
	case "pipeline-error-google-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle401Unauthorized, nil
	case "pipeline-error-google-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle403ModelAccessDenied, nil
	case "pipeline-error-google-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle429ExceededQuota, nil
	case "pipeline-error-google-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle500ServerError, nil
	case "pipeline-error-google-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle503ServerOverloadedError, nil
	case "pipeline-error-google-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogleLlmFailed, nil
	case "call.in-progress.error-vapifault-google-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-google-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle401Unauthorized, nil
	case "call.in-progress.error-vapifault-google-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-google-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogle429ExceededQuota, nil
	case "call.in-progress.error-providerfault-google-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGoogle500ServerError, nil
	case "call.in-progress.error-providerfault-google-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGoogle503ServerOverloadedError, nil
	case "pipeline-error-xai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai400BadRequestValidationFailed, nil
	case "pipeline-error-xai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai401Unauthorized, nil
	case "pipeline-error-xai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai403ModelAccessDenied, nil
	case "pipeline-error-xai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai429ExceededQuota, nil
	case "pipeline-error-xai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai500ServerError, nil
	case "pipeline-error-xai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai503ServerOverloadedError, nil
	case "pipeline-error-xai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXaiLlmFailed, nil
	case "call.in-progress.error-vapifault-xai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-xai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai401Unauthorized, nil
	case "call.in-progress.error-vapifault-xai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-xai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultXai429ExceededQuota, nil
	case "call.in-progress.error-providerfault-xai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultXai500ServerError, nil
	case "call.in-progress.error-providerfault-xai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultXai503ServerOverloadedError, nil
	case "pipeline-error-mistral-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral400BadRequestValidationFailed, nil
	case "pipeline-error-mistral-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral401Unauthorized, nil
	case "pipeline-error-mistral-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral403ModelAccessDenied, nil
	case "pipeline-error-mistral-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral429ExceededQuota, nil
	case "pipeline-error-mistral-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral500ServerError, nil
	case "pipeline-error-mistral-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorMistral503ServerOverloadedError, nil
	case "pipeline-error-mistral-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorMistralLlmFailed, nil
	case "call.in-progress.error-vapifault-mistral-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-mistral-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral401Unauthorized, nil
	case "call.in-progress.error-vapifault-mistral-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-mistral-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultMistral429ExceededQuota, nil
	case "call.in-progress.error-providerfault-mistral-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultMistral500ServerError, nil
	case "call.in-progress.error-providerfault-mistral-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultMistral503ServerOverloadedError, nil
	case "pipeline-error-inflection-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed, nil
	case "pipeline-error-inflection-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi401Unauthorized, nil
	case "pipeline-error-inflection-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi403ModelAccessDenied, nil
	case "pipeline-error-inflection-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi429ExceededQuota, nil
	case "pipeline-error-inflection-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi500ServerError, nil
	case "pipeline-error-inflection-ai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi503ServerOverloadedError, nil
	case "pipeline-error-inflection-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAiLlmFailed, nil
	case "call.in-progress.error-vapifault-inflection-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-inflection-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi401Unauthorized, nil
	case "call.in-progress.error-vapifault-inflection-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-inflection-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultInflectionAi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-inflection-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultInflectionAi500ServerError, nil
	case "call.in-progress.error-providerfault-inflection-ai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultInflectionAi503ServerOverloadedError, nil
	case "pipeline-error-deep-seek-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed, nil
	case "pipeline-error-deep-seek-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek401Unauthorized, nil
	case "pipeline-error-deep-seek-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek403ModelAccessDenied, nil
	case "pipeline-error-deep-seek-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek429ExceededQuota, nil
	case "pipeline-error-deep-seek-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek500ServerError, nil
	case "pipeline-error-deep-seek-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek503ServerOverloadedError, nil
	case "pipeline-error-deep-seek-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeekLlmFailed, nil
	case "call.in-progress.error-vapifault-deep-seek-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-deep-seek-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek401Unauthorized, nil
	case "call.in-progress.error-vapifault-deep-seek-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-deep-seek-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepSeek429ExceededQuota, nil
	case "call.in-progress.error-providerfault-deep-seek-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepSeek500ServerError, nil
	case "call.in-progress.error-providerfault-deep-seek-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepSeek503ServerOverloadedError, nil
	case "pipeline-error-groq-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq400BadRequestValidationFailed, nil
	case "pipeline-error-groq-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq401Unauthorized, nil
	case "pipeline-error-groq-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq403ModelAccessDenied, nil
	case "pipeline-error-groq-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq429ExceededQuota, nil
	case "pipeline-error-groq-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq500ServerError, nil
	case "pipeline-error-groq-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq503ServerOverloadedError, nil
	case "pipeline-error-groq-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroqLlmFailed, nil
	case "call.in-progress.error-vapifault-groq-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-groq-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq401Unauthorized, nil
	case "call.in-progress.error-vapifault-groq-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-groq-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGroq429ExceededQuota, nil
	case "call.in-progress.error-providerfault-groq-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGroq500ServerError, nil
	case "call.in-progress.error-providerfault-groq-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultGroq503ServerOverloadedError, nil
	case "pipeline-error-cerebras-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras400BadRequestValidationFailed, nil
	case "pipeline-error-cerebras-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras401Unauthorized, nil
	case "pipeline-error-cerebras-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras403ModelAccessDenied, nil
	case "pipeline-error-cerebras-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras429ExceededQuota, nil
	case "pipeline-error-cerebras-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras500ServerError, nil
	case "pipeline-error-cerebras-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras503ServerOverloadedError, nil
	case "pipeline-error-cerebras-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebrasLlmFailed, nil
	case "call.in-progress.error-vapifault-cerebras-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-cerebras-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras401Unauthorized, nil
	case "call.in-progress.error-vapifault-cerebras-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-cerebras-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCerebras429ExceededQuota, nil
	case "call.in-progress.error-providerfault-cerebras-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCerebras500ServerError, nil
	case "call.in-progress.error-providerfault-cerebras-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCerebras503ServerOverloadedError, nil
	case "pipeline-error-anthropic-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic401Unauthorized, nil
	case "pipeline-error-anthropic-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic403ModelAccessDenied, nil
	case "pipeline-error-anthropic-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic429ExceededQuota, nil
	case "pipeline-error-anthropic-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic500ServerError, nil
	case "pipeline-error-anthropic-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic503ServerOverloadedError, nil
	case "pipeline-error-anthropic-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anthropic-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic401Unauthorized, nil
	case "call.in-progress.error-vapifault-anthropic-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anthropic-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropic429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anthropic-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropic500ServerError, nil
	case "call.in-progress.error-providerfault-anthropic-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropic503ServerOverloadedError, nil
	case "pipeline-error-anthropic-bedrock-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-bedrock-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock401Unauthorized, nil
	case "pipeline-error-anthropic-bedrock-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock403ModelAccessDenied, nil
	case "pipeline-error-anthropic-bedrock-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock429ExceededQuota, nil
	case "pipeline-error-anthropic-bedrock-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock500ServerError, nil
	case "pipeline-error-anthropic-bedrock-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrock503ServerOverloadedError, nil
	case "pipeline-error-anthropic-bedrock-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicBedrockLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrockLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock401Unauthorized, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicBedrock429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anthropic-bedrock-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock500ServerError, nil
	case "call.in-progress.error-providerfault-anthropic-bedrock-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock503ServerOverloadedError, nil
	case "pipeline-error-anthropic-vertex-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-vertex-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex401Unauthorized, nil
	case "pipeline-error-anthropic-vertex-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex403ModelAccessDenied, nil
	case "pipeline-error-anthropic-vertex-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex429ExceededQuota, nil
	case "pipeline-error-anthropic-vertex-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex500ServerError, nil
	case "pipeline-error-anthropic-vertex-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertex503ServerOverloadedError, nil
	case "pipeline-error-anthropic-vertex-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicVertexLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertexLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex401Unauthorized, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnthropicVertex429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anthropic-vertex-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicVertex500ServerError, nil
	case "call.in-progress.error-providerfault-anthropic-vertex-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnthropicVertex503ServerOverloadedError, nil
	case "pipeline-error-together-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed, nil
	case "pipeline-error-together-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi401Unauthorized, nil
	case "pipeline-error-together-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi403ModelAccessDenied, nil
	case "pipeline-error-together-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi429ExceededQuota, nil
	case "pipeline-error-together-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi500ServerError, nil
	case "pipeline-error-together-ai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi503ServerOverloadedError, nil
	case "pipeline-error-together-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAiLlmFailed, nil
	case "call.in-progress.error-vapifault-together-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAiLlmFailed, nil
	case "call.in-progress.error-vapifault-together-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-together-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi401Unauthorized, nil
	case "call.in-progress.error-vapifault-together-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-together-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultTogetherAi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-together-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultTogetherAi500ServerError, nil
	case "call.in-progress.error-providerfault-together-ai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultTogetherAi503ServerOverloadedError, nil
	case "pipeline-error-anyscale-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed, nil
	case "pipeline-error-anyscale-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale401Unauthorized, nil
	case "pipeline-error-anyscale-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale403ModelAccessDenied, nil
	case "pipeline-error-anyscale-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale429ExceededQuota, nil
	case "pipeline-error-anyscale-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale500ServerError, nil
	case "pipeline-error-anyscale-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale503ServerOverloadedError, nil
	case "pipeline-error-anyscale-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscaleLlmFailed, nil
	case "call.in-progress.error-vapifault-anyscale-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscaleLlmFailed, nil
	case "call.in-progress.error-vapifault-anyscale-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anyscale-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale401Unauthorized, nil
	case "call.in-progress.error-vapifault-anyscale-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anyscale-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultAnyscale429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anyscale-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnyscale500ServerError, nil
	case "call.in-progress.error-providerfault-anyscale-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultAnyscale503ServerOverloadedError, nil
	case "pipeline-error-openrouter-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed, nil
	case "pipeline-error-openrouter-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter401Unauthorized, nil
	case "pipeline-error-openrouter-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter403ModelAccessDenied, nil
	case "pipeline-error-openrouter-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter429ExceededQuota, nil
	case "pipeline-error-openrouter-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter500ServerError, nil
	case "pipeline-error-openrouter-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter503ServerOverloadedError, nil
	case "pipeline-error-openrouter-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouterLlmFailed, nil
	case "call.in-progress.error-vapifault-openrouter-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouterLlmFailed, nil
	case "call.in-progress.error-vapifault-openrouter-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-openrouter-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter401Unauthorized, nil
	case "call.in-progress.error-vapifault-openrouter-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-openrouter-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenrouter429ExceededQuota, nil
	case "call.in-progress.error-providerfault-openrouter-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenrouter500ServerError, nil
	case "call.in-progress.error-providerfault-openrouter-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultOpenrouter503ServerOverloadedError, nil
	case "pipeline-error-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed, nil
	case "pipeline-error-perplexity-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi401Unauthorized, nil
	case "pipeline-error-perplexity-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied, nil
	case "pipeline-error-perplexity-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi429ExceededQuota, nil
	case "pipeline-error-perplexity-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi500ServerError, nil
	case "pipeline-error-perplexity-ai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi503ServerOverloadedError, nil
	case "pipeline-error-perplexity-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAiLlmFailed, nil
	case "call.in-progress.error-vapifault-perplexity-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAiLlmFailed, nil
	case "call.in-progress.error-vapifault-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-perplexity-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi401Unauthorized, nil
	case "call.in-progress.error-vapifault-perplexity-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-perplexity-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPerplexityAi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-perplexity-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPerplexityAi500ServerError, nil
	case "call.in-progress.error-providerfault-perplexity-ai-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPerplexityAi503ServerOverloadedError, nil
	case "pipeline-error-deepinfra-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed, nil
	case "pipeline-error-deepinfra-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra401Unauthorized, nil
	case "pipeline-error-deepinfra-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra403ModelAccessDenied, nil
	case "pipeline-error-deepinfra-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra429ExceededQuota, nil
	case "pipeline-error-deepinfra-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra500ServerError, nil
	case "pipeline-error-deepinfra-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra503ServerOverloadedError, nil
	case "pipeline-error-deepinfra-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfraLlmFailed, nil
	case "call.in-progress.error-vapifault-deepinfra-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfraLlmFailed, nil
	case "call.in-progress.error-vapifault-deepinfra-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-deepinfra-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra401Unauthorized, nil
	case "call.in-progress.error-vapifault-deepinfra-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-deepinfra-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepinfra429ExceededQuota, nil
	case "call.in-progress.error-providerfault-deepinfra-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepinfra500ServerError, nil
	case "call.in-progress.error-providerfault-deepinfra-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepinfra503ServerOverloadedError, nil
	case "pipeline-error-runpod-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod400BadRequestValidationFailed, nil
	case "pipeline-error-runpod-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod401Unauthorized, nil
	case "pipeline-error-runpod-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod403ModelAccessDenied, nil
	case "pipeline-error-runpod-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod429ExceededQuota, nil
	case "pipeline-error-runpod-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod500ServerError, nil
	case "pipeline-error-runpod-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod503ServerOverloadedError, nil
	case "pipeline-error-runpod-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpodLlmFailed, nil
	case "call.in-progress.error-vapifault-runpod-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpodLlmFailed, nil
	case "call.in-progress.error-vapifault-runpod-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-runpod-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod401Unauthorized, nil
	case "call.in-progress.error-vapifault-runpod-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-runpod-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultRunpod429ExceededQuota, nil
	case "call.in-progress.error-providerfault-runpod-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultRunpod500ServerError, nil
	case "call.in-progress.error-providerfault-runpod-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultRunpod503ServerOverloadedError, nil
	case "pipeline-error-custom-llm-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed, nil
	case "pipeline-error-custom-llm-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm401Unauthorized, nil
	case "pipeline-error-custom-llm-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm403ModelAccessDenied, nil
	case "pipeline-error-custom-llm-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm429ExceededQuota, nil
	case "pipeline-error-custom-llm-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm500ServerError, nil
	case "pipeline-error-custom-llm-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm503ServerOverloadedError, nil
	case "pipeline-error-custom-llm-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlmLlmFailed, nil
	case "call.in-progress.error-vapifault-custom-llm-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlmLlmFailed, nil
	case "call.in-progress.error-vapifault-custom-llm-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-custom-llm-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm401Unauthorized, nil
	case "call.in-progress.error-vapifault-custom-llm-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-custom-llm-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomLlm429ExceededQuota, nil
	case "call.in-progress.error-providerfault-custom-llm-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCustomLlm500ServerError, nil
	case "call.in-progress.error-providerfault-custom-llm-503-server-overloaded-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCustomLlm503ServerOverloadedError, nil
	case "pipeline-error-custom-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomVoiceFailed, nil
	case "pipeline-error-cartesia-socket-hang-up":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaSocketHangUp, nil
	case "pipeline-error-cartesia-requested-payment":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaRequestedPayment, nil
	case "pipeline-error-cartesia-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia500ServerError, nil
	case "pipeline-error-cartesia-503-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia503ServerError, nil
	case "pipeline-error-cartesia-522-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia522ServerError, nil
	case "call.in-progress.error-vapifault-cartesia-socket-hang-up":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCartesiaSocketHangUp, nil
	case "call.in-progress.error-vapifault-cartesia-requested-payment":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCartesiaRequestedPayment, nil
	case "call.in-progress.error-providerfault-cartesia-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCartesia500ServerError, nil
	case "call.in-progress.error-providerfault-cartesia-503-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCartesia503ServerError, nil
	case "call.in-progress.error-providerfault-cartesia-522-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultCartesia522ServerError, nil
	case "pipeline-error-eleven-labs-voice-not-found":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFound, nil
	case "pipeline-error-eleven-labs-quota-exceeded":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsQuotaExceeded, nil
	case "pipeline-error-eleven-labs-unauthorized-access":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedAccess, nil
	case "pipeline-error-eleven-labs-unauthorized-to-access-model":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel, nil
	case "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned, nil
	case "pipeline-error-eleven-labs-invalid-api-key":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidApiKey, nil
	case "pipeline-error-eleven-labs-invalid-voice-samples":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples, nil
	case "pipeline-error-eleven-labs-voice-disabled-by-owner":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner, nil
	case "pipeline-error-eleven-labs-blocked-account-in-probation":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation, nil
	case "pipeline-error-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "pipeline-error-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "pipeline-error-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "pipeline-error-eleven-labs-max-character-limit-exceeded":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded, nil
	case "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification, nil
	case "pipeline-error-eleven-labs-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabs500ServerError, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-found":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFound, nil
	case "call.in-progress.error-vapifault-eleven-labs-quota-exceeded":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsQuotaExceeded, nil
	case "call.in-progress.error-vapifault-eleven-labs-unauthorized-access":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedAccess, nil
	case "call.in-progress.error-vapifault-eleven-labs-unauthorized-to-access-model":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedToAccessModel, nil
	case "call.in-progress.error-vapifault-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTuned, nil
	case "call.in-progress.error-vapifault-eleven-labs-invalid-api-key":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidApiKey, nil
	case "call.in-progress.error-vapifault-eleven-labs-invalid-voice-samples":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidVoiceSamples, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-disabled-by-owner":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceDisabledByOwner, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-account-in-probation":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedAccountInProbation, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "call.in-progress.error-vapifault-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsMissingSamplesForVoiceClone, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "call.in-progress.error-vapifault-eleven-labs-max-character-limit-exceeded":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsMaxCharacterLimitExceeded, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification, nil
	case "call.in-progress.error-providerfault-eleven-labs-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultElevenLabs500ServerError, nil
	case "pipeline-error-playht-request-timed-out":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtRequestTimedOut, nil
	case "pipeline-error-playht-invalid-voice":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidVoice, nil
	case "pipeline-error-playht-unexpected-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtUnexpectedError, nil
	case "pipeline-error-playht-out-of-credits":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtOutOfCredits, nil
	case "pipeline-error-playht-invalid-emotion":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidEmotion, nil
	case "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "pipeline-error-playht-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht401Unauthorized, nil
	case "pipeline-error-playht-403-forbidden-out-of-characters":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters, nil
	case "pipeline-error-playht-403-forbidden-api-access-not-available":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable, nil
	case "pipeline-error-playht-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht429ExceededQuota, nil
	case "pipeline-error-playht-502-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht502GatewayError, nil
	case "pipeline-error-playht-504-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht504GatewayError, nil
	case "call.in-progress.error-vapifault-playht-request-timed-out":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtRequestTimedOut, nil
	case "call.in-progress.error-vapifault-playht-invalid-voice":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtInvalidVoice, nil
	case "call.in-progress.error-vapifault-playht-unexpected-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtUnexpectedError, nil
	case "call.in-progress.error-vapifault-playht-out-of-credits":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtOutOfCredits, nil
	case "call.in-progress.error-vapifault-playht-invalid-emotion":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtInvalidEmotion, nil
	case "call.in-progress.error-vapifault-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "call.in-progress.error-vapifault-playht-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht401Unauthorized, nil
	case "call.in-progress.error-vapifault-playht-403-forbidden-out-of-characters":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenOutOfCharacters, nil
	case "call.in-progress.error-vapifault-playht-403-forbidden-api-access-not-available":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenApiAccessNotAvailable, nil
	case "call.in-progress.error-vapifault-playht-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultPlayht429ExceededQuota, nil
	case "call.in-progress.error-providerfault-playht-502-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPlayht502GatewayError, nil
	case "call.in-progress.error-providerfault-playht-504-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultPlayht504GatewayError, nil
	case "pipeline-error-custom-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomTranscriberFailed, nil
	case "call.in-progress.error-vapifault-custom-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultCustomTranscriberFailed, nil
	case "pipeline-error-eleven-labs-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsTranscriberFailed, nil
	case "call.in-progress.error-vapifault-eleven-labs-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultElevenLabsTranscriberFailed, nil
	case "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination, nil
	case "pipeline-error-deepgram-returning-401-invalid-credentials":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials, nil
	case "pipeline-error-deepgram-returning-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied, nil
	case "pipeline-error-deepgram-returning-404-not-found":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning404NotFound, nil
	case "pipeline-error-deepgram-returning-500-invalid-json":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning500InvalidJson, nil
	case "pipeline-error-deepgram-returning-502-network-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502NetworkError, nil
	case "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach, nil
	case "call.in-progress.error-vapifault-deepgram-returning-400-no-such-model-language-tier-combination":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning400NoSuchModelLanguageTierCombination, nil
	case "call.in-progress.error-vapifault-deepgram-returning-401-invalid-credentials":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning401InvalidCredentials, nil
	case "call.in-progress.error-vapifault-deepgram-returning-404-not-found":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning404NotFound, nil
	case "call.in-progress.error-vapifault-deepgram-returning-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultDeepgramReturning403ModelAccessDenied, nil
	case "call.in-progress.error-providerfault-deepgram-returning-500-invalid-json":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepgramReturning500InvalidJson, nil
	case "call.in-progress.error-providerfault-deepgram-returning-502-network-error":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502NetworkError, nil
	case "call.in-progress.error-providerfault-deepgram-returning-502-bad-gateway-ehostunreach":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502BadGatewayEhostunreach, nil
	case "pipeline-error-google-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogleTranscriberFailed, nil
	case "call.in-progress.error-vapifault-google-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultGoogleTranscriberFailed, nil
	case "pipeline-error-openai-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiTranscriberFailed, nil
	case "call.in-progress.error-vapifault-openai-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorVapifaultOpenaiTranscriberFailed, nil
	case "assistant-ended-call":
		return ServerMessageEndOfCallReportEndedReasonAssistantEndedCall, nil
	case "assistant-said-end-call-phrase":
		return ServerMessageEndOfCallReportEndedReasonAssistantSaidEndCallPhrase, nil
	case "assistant-ended-call-with-hangup-task":
		return ServerMessageEndOfCallReportEndedReasonAssistantEndedCallWithHangupTask, nil
	case "assistant-ended-call-after-message-spoken":
		return ServerMessageEndOfCallReportEndedReasonAssistantEndedCallAfterMessageSpoken, nil
	case "assistant-forwarded-call":
		return ServerMessageEndOfCallReportEndedReasonAssistantForwardedCall, nil
	case "assistant-join-timed-out":
		return ServerMessageEndOfCallReportEndedReasonAssistantJoinTimedOut, nil
	case "call.in-progress.error-assistant-did-not-receive-customer-audio":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorAssistantDidNotReceiveCustomerAudio, nil
	case "customer-busy":
		return ServerMessageEndOfCallReportEndedReasonCustomerBusy, nil
	case "customer-ended-call":
		return ServerMessageEndOfCallReportEndedReasonCustomerEndedCall, nil
	case "customer-did-not-answer":
		return ServerMessageEndOfCallReportEndedReasonCustomerDidNotAnswer, nil
	case "customer-did-not-give-microphone-permission":
		return ServerMessageEndOfCallReportEndedReasonCustomerDidNotGiveMicrophonePermission, nil
	case "exceeded-max-duration":
		return ServerMessageEndOfCallReportEndedReasonExceededMaxDuration, nil
	case "manually-canceled":
		return ServerMessageEndOfCallReportEndedReasonManuallyCanceled, nil
	case "phone-call-provider-closed-websocket":
		return ServerMessageEndOfCallReportEndedReasonPhoneCallProviderClosedWebsocket, nil
	case "call.forwarding.operator-busy":
		return ServerMessageEndOfCallReportEndedReasonCallForwardingOperatorBusy, nil
	case "silence-timed-out":
		return ServerMessageEndOfCallReportEndedReasonSilenceTimedOut, nil
	case "call.in-progress.error-sip-telephony-provider-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonCallInProgressErrorSipTelephonyProviderFailedToConnectCall, nil
	case "call.ringing.hook-executed-say":
		return ServerMessageEndOfCallReportEndedReasonCallRingingHookExecutedSay, nil
	case "call.ringing.hook-executed-transfer":
		return ServerMessageEndOfCallReportEndedReasonCallRingingHookExecutedTransfer, nil
	case "twilio-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonTwilioFailedToConnectCall, nil
	case "twilio-reported-customer-misdialed":
		return ServerMessageEndOfCallReportEndedReasonTwilioReportedCustomerMisdialed, nil
	case "vonage-rejected":
		return ServerMessageEndOfCallReportEndedReasonVonageRejected, nil
	case "voicemail":
		return ServerMessageEndOfCallReportEndedReasonVoicemail, nil
	}
	var t ServerMessageEndOfCallReportEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageEndOfCallReportEndedReason) Ptr() *ServerMessageEndOfCallReportEndedReason {
	return &s
}

// This is the phone number that the message is associated with.
type ServerMessageEndOfCallReportPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageEndOfCallReportPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReportPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageEndOfCallReportPhoneNumber) Accept(visitor ServerMessageEndOfCallReportPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageHang struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageHangPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "hang" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:
	// - the model is too slow to respond
	// - the voice is too slow to respond
	// - the tool call is still waiting for a response from your server
	// - etc.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageHang) GetPhoneNumber() *ServerMessageHangPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageHang) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageHang) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageHang) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageHang) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageHang) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageHang) Type() string {
	return s.type_
}

func (s *ServerMessageHang) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageHang) UnmarshalJSON(data []byte) error {
	type embed ServerMessageHang
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageHang(unmarshaler.embed)
	if unmarshaler.Type != "hang" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "hang", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageHang) MarshalJSON() ([]byte, error) {
	type embed ServerMessageHang
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "hang",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageHang) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageHangPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageHangPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageHangPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageHangPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageHangPhoneNumber) Accept(visitor ServerMessageHangPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageKnowledgeBaseRequest struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageKnowledgeBaseRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "knowledge-base-request" is sent to request knowledge base documents. To enable, use `assistant.knowledgeBase.provider=custom-knowledge-base`.
	// These are the messages that are going to be sent to the `model` right after the `knowledge-base-request` webhook completes.
	Messages []*ServerMessageKnowledgeBaseRequestMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is just `messages` formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageKnowledgeBaseRequest) GetPhoneNumber() *ServerMessageKnowledgeBaseRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageKnowledgeBaseRequest) GetMessages() []*ServerMessageKnowledgeBaseRequestMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *ServerMessageKnowledgeBaseRequest) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if s == nil {
		return nil
	}
	return s.MessagesOpenAiFormatted
}

func (s *ServerMessageKnowledgeBaseRequest) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageKnowledgeBaseRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageKnowledgeBaseRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageKnowledgeBaseRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageKnowledgeBaseRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageKnowledgeBaseRequest) Type() string {
	return s.type_
}

func (s *ServerMessageKnowledgeBaseRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageKnowledgeBaseRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageKnowledgeBaseRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageKnowledgeBaseRequest(unmarshaler.embed)
	if unmarshaler.Type != "knowledge-base-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "knowledge-base-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageKnowledgeBaseRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageKnowledgeBaseRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "knowledge-base-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageKnowledgeBaseRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageKnowledgeBaseRequestMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetUserMessage() *UserMessage {
	if s == nil {
		return nil
	}
	return s.UserMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetSystemMessage() *SystemMessage {
	if s == nil {
		return nil
	}
	return s.SystemMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetBotMessage() *BotMessage {
	if s == nil {
		return nil
	}
	return s.BotMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallResultMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.typ = "UserMessage"
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.typ = "SystemMessage"
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.typ = "BotMessage"
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.typ = "ToolCallMessage"
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.typ = "ToolCallResultMessage"
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageKnowledgeBaseRequestMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageKnowledgeBaseRequestMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) Accept(visitor ServerMessageKnowledgeBaseRequestMessagesItemVisitor) error {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number that the message is associated with.
type ServerMessageKnowledgeBaseRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageKnowledgeBaseRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageKnowledgeBaseRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) Accept(visitor ServerMessageKnowledgeBaseRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageLanguageChangeDetected struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageLanguageChangeDetectedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "language-change-detected" is sent when the transcriber is automatically switched based on the detected language.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the language the transcriber is switched to.
	Language string `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageLanguageChangeDetected) GetPhoneNumber() *ServerMessageLanguageChangeDetectedPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageLanguageChangeDetected) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageLanguageChangeDetected) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageLanguageChangeDetected) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageLanguageChangeDetected) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageLanguageChangeDetected) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageLanguageChangeDetected) GetLanguage() string {
	if s == nil {
		return ""
	}
	return s.Language
}

func (s *ServerMessageLanguageChangeDetected) Type() string {
	return s.type_
}

func (s *ServerMessageLanguageChangeDetected) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageLanguageChangeDetected) UnmarshalJSON(data []byte) error {
	type embed ServerMessageLanguageChangeDetected
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageLanguageChangeDetected(unmarshaler.embed)
	if unmarshaler.Type != "language-change-detected" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "language-change-detected", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageLanguageChangeDetected) MarshalJSON() ([]byte, error) {
	type embed ServerMessageLanguageChangeDetected
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "language-change-detected",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageLanguageChangeDetected) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageLanguageChangeDetectedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageLanguageChangeDetectedPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageLanguageChangeDetectedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) Accept(visitor ServerMessageLanguageChangeDetectedPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// These are all the messages that can be sent to your server before, after and during the call. Configure the messages you'd like to receive in `assistant.serverMessages`.
//
// The server where the message is sent is determined by the following precedence order:
//
// 1. `tool.server.url` (if configured, and only for "tool-calls" message)
// 2. `assistant.serverUrl` (if configure)
// 3. `phoneNumber.serverUrl` (if configured)
// 4. `org.serverUrl` (if configured)
type ServerMessageMessage struct {
	ServerMessageAssistantRequest           *ServerMessageAssistantRequest
	ServerMessageConversationUpdate         *ServerMessageConversationUpdate
	ServerMessageEndOfCallReport            *ServerMessageEndOfCallReport
	ServerMessageHang                       *ServerMessageHang
	ServerMessageKnowledgeBaseRequest       *ServerMessageKnowledgeBaseRequest
	ServerMessageModelOutput                *ServerMessageModelOutput
	ServerMessagePhoneCallControl           *ServerMessagePhoneCallControl
	ServerMessageSpeechUpdate               *ServerMessageSpeechUpdate
	ServerMessageStatusUpdate               *ServerMessageStatusUpdate
	ServerMessageToolCalls                  *ServerMessageToolCalls
	ServerMessageTransferDestinationRequest *ServerMessageTransferDestinationRequest
	ServerMessageTransferUpdate             *ServerMessageTransferUpdate
	ServerMessageTranscript                 *ServerMessageTranscript
	ServerMessageUserInterrupted            *ServerMessageUserInterrupted
	ServerMessageLanguageChangeDetected     *ServerMessageLanguageChangeDetected
	ServerMessageVoiceInput                 *ServerMessageVoiceInput
	ServerMessageVoiceRequest               *ServerMessageVoiceRequest

	typ string
}

func (s *ServerMessageMessage) GetServerMessageAssistantRequest() *ServerMessageAssistantRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageAssistantRequest
}

func (s *ServerMessageMessage) GetServerMessageConversationUpdate() *ServerMessageConversationUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageConversationUpdate
}

func (s *ServerMessageMessage) GetServerMessageEndOfCallReport() *ServerMessageEndOfCallReport {
	if s == nil {
		return nil
	}
	return s.ServerMessageEndOfCallReport
}

func (s *ServerMessageMessage) GetServerMessageHang() *ServerMessageHang {
	if s == nil {
		return nil
	}
	return s.ServerMessageHang
}

func (s *ServerMessageMessage) GetServerMessageKnowledgeBaseRequest() *ServerMessageKnowledgeBaseRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageKnowledgeBaseRequest
}

func (s *ServerMessageMessage) GetServerMessageModelOutput() *ServerMessageModelOutput {
	if s == nil {
		return nil
	}
	return s.ServerMessageModelOutput
}

func (s *ServerMessageMessage) GetServerMessagePhoneCallControl() *ServerMessagePhoneCallControl {
	if s == nil {
		return nil
	}
	return s.ServerMessagePhoneCallControl
}

func (s *ServerMessageMessage) GetServerMessageSpeechUpdate() *ServerMessageSpeechUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageSpeechUpdate
}

func (s *ServerMessageMessage) GetServerMessageStatusUpdate() *ServerMessageStatusUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageStatusUpdate
}

func (s *ServerMessageMessage) GetServerMessageToolCalls() *ServerMessageToolCalls {
	if s == nil {
		return nil
	}
	return s.ServerMessageToolCalls
}

func (s *ServerMessageMessage) GetServerMessageTransferDestinationRequest() *ServerMessageTransferDestinationRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageTransferDestinationRequest
}

func (s *ServerMessageMessage) GetServerMessageTransferUpdate() *ServerMessageTransferUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageTransferUpdate
}

func (s *ServerMessageMessage) GetServerMessageTranscript() *ServerMessageTranscript {
	if s == nil {
		return nil
	}
	return s.ServerMessageTranscript
}

func (s *ServerMessageMessage) GetServerMessageUserInterrupted() *ServerMessageUserInterrupted {
	if s == nil {
		return nil
	}
	return s.ServerMessageUserInterrupted
}

func (s *ServerMessageMessage) GetServerMessageLanguageChangeDetected() *ServerMessageLanguageChangeDetected {
	if s == nil {
		return nil
	}
	return s.ServerMessageLanguageChangeDetected
}

func (s *ServerMessageMessage) GetServerMessageVoiceInput() *ServerMessageVoiceInput {
	if s == nil {
		return nil
	}
	return s.ServerMessageVoiceInput
}

func (s *ServerMessageMessage) GetServerMessageVoiceRequest() *ServerMessageVoiceRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageVoiceRequest
}

func (s *ServerMessageMessage) UnmarshalJSON(data []byte) error {
	valueServerMessageAssistantRequest := new(ServerMessageAssistantRequest)
	if err := json.Unmarshal(data, &valueServerMessageAssistantRequest); err == nil {
		s.typ = "ServerMessageAssistantRequest"
		s.ServerMessageAssistantRequest = valueServerMessageAssistantRequest
		return nil
	}
	valueServerMessageConversationUpdate := new(ServerMessageConversationUpdate)
	if err := json.Unmarshal(data, &valueServerMessageConversationUpdate); err == nil {
		s.typ = "ServerMessageConversationUpdate"
		s.ServerMessageConversationUpdate = valueServerMessageConversationUpdate
		return nil
	}
	valueServerMessageEndOfCallReport := new(ServerMessageEndOfCallReport)
	if err := json.Unmarshal(data, &valueServerMessageEndOfCallReport); err == nil {
		s.typ = "ServerMessageEndOfCallReport"
		s.ServerMessageEndOfCallReport = valueServerMessageEndOfCallReport
		return nil
	}
	valueServerMessageHang := new(ServerMessageHang)
	if err := json.Unmarshal(data, &valueServerMessageHang); err == nil {
		s.typ = "ServerMessageHang"
		s.ServerMessageHang = valueServerMessageHang
		return nil
	}
	valueServerMessageKnowledgeBaseRequest := new(ServerMessageKnowledgeBaseRequest)
	if err := json.Unmarshal(data, &valueServerMessageKnowledgeBaseRequest); err == nil {
		s.typ = "ServerMessageKnowledgeBaseRequest"
		s.ServerMessageKnowledgeBaseRequest = valueServerMessageKnowledgeBaseRequest
		return nil
	}
	valueServerMessageModelOutput := new(ServerMessageModelOutput)
	if err := json.Unmarshal(data, &valueServerMessageModelOutput); err == nil {
		s.typ = "ServerMessageModelOutput"
		s.ServerMessageModelOutput = valueServerMessageModelOutput
		return nil
	}
	valueServerMessagePhoneCallControl := new(ServerMessagePhoneCallControl)
	if err := json.Unmarshal(data, &valueServerMessagePhoneCallControl); err == nil {
		s.typ = "ServerMessagePhoneCallControl"
		s.ServerMessagePhoneCallControl = valueServerMessagePhoneCallControl
		return nil
	}
	valueServerMessageSpeechUpdate := new(ServerMessageSpeechUpdate)
	if err := json.Unmarshal(data, &valueServerMessageSpeechUpdate); err == nil {
		s.typ = "ServerMessageSpeechUpdate"
		s.ServerMessageSpeechUpdate = valueServerMessageSpeechUpdate
		return nil
	}
	valueServerMessageStatusUpdate := new(ServerMessageStatusUpdate)
	if err := json.Unmarshal(data, &valueServerMessageStatusUpdate); err == nil {
		s.typ = "ServerMessageStatusUpdate"
		s.ServerMessageStatusUpdate = valueServerMessageStatusUpdate
		return nil
	}
	valueServerMessageToolCalls := new(ServerMessageToolCalls)
	if err := json.Unmarshal(data, &valueServerMessageToolCalls); err == nil {
		s.typ = "ServerMessageToolCalls"
		s.ServerMessageToolCalls = valueServerMessageToolCalls
		return nil
	}
	valueServerMessageTransferDestinationRequest := new(ServerMessageTransferDestinationRequest)
	if err := json.Unmarshal(data, &valueServerMessageTransferDestinationRequest); err == nil {
		s.typ = "ServerMessageTransferDestinationRequest"
		s.ServerMessageTransferDestinationRequest = valueServerMessageTransferDestinationRequest
		return nil
	}
	valueServerMessageTransferUpdate := new(ServerMessageTransferUpdate)
	if err := json.Unmarshal(data, &valueServerMessageTransferUpdate); err == nil {
		s.typ = "ServerMessageTransferUpdate"
		s.ServerMessageTransferUpdate = valueServerMessageTransferUpdate
		return nil
	}
	valueServerMessageTranscript := new(ServerMessageTranscript)
	if err := json.Unmarshal(data, &valueServerMessageTranscript); err == nil {
		s.typ = "ServerMessageTranscript"
		s.ServerMessageTranscript = valueServerMessageTranscript
		return nil
	}
	valueServerMessageUserInterrupted := new(ServerMessageUserInterrupted)
	if err := json.Unmarshal(data, &valueServerMessageUserInterrupted); err == nil {
		s.typ = "ServerMessageUserInterrupted"
		s.ServerMessageUserInterrupted = valueServerMessageUserInterrupted
		return nil
	}
	valueServerMessageLanguageChangeDetected := new(ServerMessageLanguageChangeDetected)
	if err := json.Unmarshal(data, &valueServerMessageLanguageChangeDetected); err == nil {
		s.typ = "ServerMessageLanguageChangeDetected"
		s.ServerMessageLanguageChangeDetected = valueServerMessageLanguageChangeDetected
		return nil
	}
	valueServerMessageVoiceInput := new(ServerMessageVoiceInput)
	if err := json.Unmarshal(data, &valueServerMessageVoiceInput); err == nil {
		s.typ = "ServerMessageVoiceInput"
		s.ServerMessageVoiceInput = valueServerMessageVoiceInput
		return nil
	}
	valueServerMessageVoiceRequest := new(ServerMessageVoiceRequest)
	if err := json.Unmarshal(data, &valueServerMessageVoiceRequest); err == nil {
		s.typ = "ServerMessageVoiceRequest"
		s.ServerMessageVoiceRequest = valueServerMessageVoiceRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageMessage) MarshalJSON() ([]byte, error) {
	if s.typ == "ServerMessageAssistantRequest" || s.ServerMessageAssistantRequest != nil {
		return json.Marshal(s.ServerMessageAssistantRequest)
	}
	if s.typ == "ServerMessageConversationUpdate" || s.ServerMessageConversationUpdate != nil {
		return json.Marshal(s.ServerMessageConversationUpdate)
	}
	if s.typ == "ServerMessageEndOfCallReport" || s.ServerMessageEndOfCallReport != nil {
		return json.Marshal(s.ServerMessageEndOfCallReport)
	}
	if s.typ == "ServerMessageHang" || s.ServerMessageHang != nil {
		return json.Marshal(s.ServerMessageHang)
	}
	if s.typ == "ServerMessageKnowledgeBaseRequest" || s.ServerMessageKnowledgeBaseRequest != nil {
		return json.Marshal(s.ServerMessageKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageModelOutput" || s.ServerMessageModelOutput != nil {
		return json.Marshal(s.ServerMessageModelOutput)
	}
	if s.typ == "ServerMessagePhoneCallControl" || s.ServerMessagePhoneCallControl != nil {
		return json.Marshal(s.ServerMessagePhoneCallControl)
	}
	if s.typ == "ServerMessageSpeechUpdate" || s.ServerMessageSpeechUpdate != nil {
		return json.Marshal(s.ServerMessageSpeechUpdate)
	}
	if s.typ == "ServerMessageStatusUpdate" || s.ServerMessageStatusUpdate != nil {
		return json.Marshal(s.ServerMessageStatusUpdate)
	}
	if s.typ == "ServerMessageToolCalls" || s.ServerMessageToolCalls != nil {
		return json.Marshal(s.ServerMessageToolCalls)
	}
	if s.typ == "ServerMessageTransferDestinationRequest" || s.ServerMessageTransferDestinationRequest != nil {
		return json.Marshal(s.ServerMessageTransferDestinationRequest)
	}
	if s.typ == "ServerMessageTransferUpdate" || s.ServerMessageTransferUpdate != nil {
		return json.Marshal(s.ServerMessageTransferUpdate)
	}
	if s.typ == "ServerMessageTranscript" || s.ServerMessageTranscript != nil {
		return json.Marshal(s.ServerMessageTranscript)
	}
	if s.typ == "ServerMessageUserInterrupted" || s.ServerMessageUserInterrupted != nil {
		return json.Marshal(s.ServerMessageUserInterrupted)
	}
	if s.typ == "ServerMessageLanguageChangeDetected" || s.ServerMessageLanguageChangeDetected != nil {
		return json.Marshal(s.ServerMessageLanguageChangeDetected)
	}
	if s.typ == "ServerMessageVoiceInput" || s.ServerMessageVoiceInput != nil {
		return json.Marshal(s.ServerMessageVoiceInput)
	}
	if s.typ == "ServerMessageVoiceRequest" || s.ServerMessageVoiceRequest != nil {
		return json.Marshal(s.ServerMessageVoiceRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageMessageVisitor interface {
	VisitServerMessageAssistantRequest(*ServerMessageAssistantRequest) error
	VisitServerMessageConversationUpdate(*ServerMessageConversationUpdate) error
	VisitServerMessageEndOfCallReport(*ServerMessageEndOfCallReport) error
	VisitServerMessageHang(*ServerMessageHang) error
	VisitServerMessageKnowledgeBaseRequest(*ServerMessageKnowledgeBaseRequest) error
	VisitServerMessageModelOutput(*ServerMessageModelOutput) error
	VisitServerMessagePhoneCallControl(*ServerMessagePhoneCallControl) error
	VisitServerMessageSpeechUpdate(*ServerMessageSpeechUpdate) error
	VisitServerMessageStatusUpdate(*ServerMessageStatusUpdate) error
	VisitServerMessageToolCalls(*ServerMessageToolCalls) error
	VisitServerMessageTransferDestinationRequest(*ServerMessageTransferDestinationRequest) error
	VisitServerMessageTransferUpdate(*ServerMessageTransferUpdate) error
	VisitServerMessageTranscript(*ServerMessageTranscript) error
	VisitServerMessageUserInterrupted(*ServerMessageUserInterrupted) error
	VisitServerMessageLanguageChangeDetected(*ServerMessageLanguageChangeDetected) error
	VisitServerMessageVoiceInput(*ServerMessageVoiceInput) error
	VisitServerMessageVoiceRequest(*ServerMessageVoiceRequest) error
}

func (s *ServerMessageMessage) Accept(visitor ServerMessageMessageVisitor) error {
	if s.typ == "ServerMessageAssistantRequest" || s.ServerMessageAssistantRequest != nil {
		return visitor.VisitServerMessageAssistantRequest(s.ServerMessageAssistantRequest)
	}
	if s.typ == "ServerMessageConversationUpdate" || s.ServerMessageConversationUpdate != nil {
		return visitor.VisitServerMessageConversationUpdate(s.ServerMessageConversationUpdate)
	}
	if s.typ == "ServerMessageEndOfCallReport" || s.ServerMessageEndOfCallReport != nil {
		return visitor.VisitServerMessageEndOfCallReport(s.ServerMessageEndOfCallReport)
	}
	if s.typ == "ServerMessageHang" || s.ServerMessageHang != nil {
		return visitor.VisitServerMessageHang(s.ServerMessageHang)
	}
	if s.typ == "ServerMessageKnowledgeBaseRequest" || s.ServerMessageKnowledgeBaseRequest != nil {
		return visitor.VisitServerMessageKnowledgeBaseRequest(s.ServerMessageKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageModelOutput" || s.ServerMessageModelOutput != nil {
		return visitor.VisitServerMessageModelOutput(s.ServerMessageModelOutput)
	}
	if s.typ == "ServerMessagePhoneCallControl" || s.ServerMessagePhoneCallControl != nil {
		return visitor.VisitServerMessagePhoneCallControl(s.ServerMessagePhoneCallControl)
	}
	if s.typ == "ServerMessageSpeechUpdate" || s.ServerMessageSpeechUpdate != nil {
		return visitor.VisitServerMessageSpeechUpdate(s.ServerMessageSpeechUpdate)
	}
	if s.typ == "ServerMessageStatusUpdate" || s.ServerMessageStatusUpdate != nil {
		return visitor.VisitServerMessageStatusUpdate(s.ServerMessageStatusUpdate)
	}
	if s.typ == "ServerMessageToolCalls" || s.ServerMessageToolCalls != nil {
		return visitor.VisitServerMessageToolCalls(s.ServerMessageToolCalls)
	}
	if s.typ == "ServerMessageTransferDestinationRequest" || s.ServerMessageTransferDestinationRequest != nil {
		return visitor.VisitServerMessageTransferDestinationRequest(s.ServerMessageTransferDestinationRequest)
	}
	if s.typ == "ServerMessageTransferUpdate" || s.ServerMessageTransferUpdate != nil {
		return visitor.VisitServerMessageTransferUpdate(s.ServerMessageTransferUpdate)
	}
	if s.typ == "ServerMessageTranscript" || s.ServerMessageTranscript != nil {
		return visitor.VisitServerMessageTranscript(s.ServerMessageTranscript)
	}
	if s.typ == "ServerMessageUserInterrupted" || s.ServerMessageUserInterrupted != nil {
		return visitor.VisitServerMessageUserInterrupted(s.ServerMessageUserInterrupted)
	}
	if s.typ == "ServerMessageLanguageChangeDetected" || s.ServerMessageLanguageChangeDetected != nil {
		return visitor.VisitServerMessageLanguageChangeDetected(s.ServerMessageLanguageChangeDetected)
	}
	if s.typ == "ServerMessageVoiceInput" || s.ServerMessageVoiceInput != nil {
		return visitor.VisitServerMessageVoiceInput(s.ServerMessageVoiceInput)
	}
	if s.typ == "ServerMessageVoiceRequest" || s.ServerMessageVoiceRequest != nil {
		return visitor.VisitServerMessageVoiceRequest(s.ServerMessageVoiceRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageModelOutput struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageModelOutputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "model-output" is sent as the model outputs tokens.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the output of the model. It can be a token or tool call.
	Output map[string]interface{} `json:"output,omitempty" url:"output,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageModelOutput) GetPhoneNumber() *ServerMessageModelOutputPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageModelOutput) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageModelOutput) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageModelOutput) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageModelOutput) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageModelOutput) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageModelOutput) GetOutput() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Output
}

func (s *ServerMessageModelOutput) Type() string {
	return s.type_
}

func (s *ServerMessageModelOutput) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageModelOutput) UnmarshalJSON(data []byte) error {
	type embed ServerMessageModelOutput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageModelOutput(unmarshaler.embed)
	if unmarshaler.Type != "model-output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "model-output", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageModelOutput) MarshalJSON() ([]byte, error) {
	type embed ServerMessageModelOutput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "model-output",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageModelOutput) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageModelOutputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageModelOutputPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageModelOutputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageModelOutputPhoneNumber) Accept(visitor ServerMessageModelOutputPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControl struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessagePhoneCallControlPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "phone-call-control" is an advanced type of message.
	//
	// When it is requested in `assistant.serverMessages`, the hangup and forwarding responsibilities are delegated to your server. Vapi will no longer do the actual transfer and hangup.
	// This is the request to control the phone call.
	Request ServerMessagePhoneCallControlRequest `json:"request" url:"request"`
	// This is the destination to forward the call to if the request is "forward".
	Destination *ServerMessagePhoneCallControlDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessagePhoneCallControl) GetPhoneNumber() *ServerMessagePhoneCallControlPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessagePhoneCallControl) GetRequest() ServerMessagePhoneCallControlRequest {
	if s == nil {
		return ""
	}
	return s.Request
}

func (s *ServerMessagePhoneCallControl) GetDestination() *ServerMessagePhoneCallControlDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessagePhoneCallControl) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessagePhoneCallControl) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessagePhoneCallControl) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessagePhoneCallControl) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessagePhoneCallControl) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessagePhoneCallControl) Type() string {
	return s.type_
}

func (s *ServerMessagePhoneCallControl) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessagePhoneCallControl) UnmarshalJSON(data []byte) error {
	type embed ServerMessagePhoneCallControl
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessagePhoneCallControl(unmarshaler.embed)
	if unmarshaler.Type != "phone-call-control" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "phone-call-control", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessagePhoneCallControl) MarshalJSON() ([]byte, error) {
	type embed ServerMessagePhoneCallControl
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "phone-call-control",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessagePhoneCallControl) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination to forward the call to if the request is "forward".
type ServerMessagePhoneCallControlDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (s *ServerMessagePhoneCallControlDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessagePhoneCallControlDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessagePhoneCallControlDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessagePhoneCallControlDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControlDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessagePhoneCallControlDestination) Accept(visitor ServerMessagePhoneCallControlDestinationVisitor) error {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number that the message is associated with.
type ServerMessagePhoneCallControlPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessagePhoneCallControlPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControlPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessagePhoneCallControlPhoneNumber) Accept(visitor ServerMessagePhoneCallControlPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the request to control the phone call.
type ServerMessagePhoneCallControlRequest string

const (
	ServerMessagePhoneCallControlRequestForward ServerMessagePhoneCallControlRequest = "forward"
	ServerMessagePhoneCallControlRequestHangUp  ServerMessagePhoneCallControlRequest = "hang-up"
)

func NewServerMessagePhoneCallControlRequestFromString(s string) (ServerMessagePhoneCallControlRequest, error) {
	switch s {
	case "forward":
		return ServerMessagePhoneCallControlRequestForward, nil
	case "hang-up":
		return ServerMessagePhoneCallControlRequestHangUp, nil
	}
	var t ServerMessagePhoneCallControlRequest
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessagePhoneCallControlRequest) Ptr() *ServerMessagePhoneCallControlRequest {
	return &s
}

type ServerMessageResponse struct {
	// This is the response that is expected from the server to the message.
	//
	// Note: Most messages don't expect a response. Only "assistant-request", "tool-calls" and "transfer-destination-request" do.
	MessageResponse *ServerMessageResponseMessageResponse `json:"messageResponse,omitempty" url:"messageResponse,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponse) GetMessageResponse() *ServerMessageResponseMessageResponse {
	if s == nil {
		return nil
	}
	return s.MessageResponse
}

func (s *ServerMessageResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageResponseAssistantRequest struct {
	// This is the destination to transfer the inbound call to. This will immediately transfer without using any assistants.
	//
	// If this is sent, `assistantId`, `assistant`, `squadId`, and `squad` are ignored.
	Destination *ServerMessageResponseAssistantRequestDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.
	//
	// To start a call with:
	// - Assistant, use `assistantId` or `assistant`
	// - Squad, use `squadId` or `squad`
	// - Workflow, use `workflowId` or `workflow`
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant`
	// - Squad, use `squad`
	// - Workflow, use `workflow`
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// [BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.
	//
	// This is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	// [BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.
	//
	// This is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.
	//
	// To start a call with:
	// - Assistant, use `assistant` or `assistantId`
	// - Squad, use `squad` or `squadId`
	// - Workflow, use `workflow` or `workflowId`
	Workflow *CreateWorkflowDto `json:"workflow,omitempty" url:"workflow,omitempty"`
	// This is the error if the call shouldn't be accepted. This is spoken to the customer.
	//
	// If this is sent, `assistantId`, `assistant`, `squadId`, `squad`, and `destination` are ignored.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseAssistantRequest) GetDestination() *ServerMessageResponseAssistantRequestDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageResponseAssistantRequest) GetAssistantId() *string {
	if s == nil {
		return nil
	}
	return s.AssistantId
}

func (s *ServerMessageResponseAssistantRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageResponseAssistantRequest) GetAssistantOverrides() *AssistantOverrides {
	if s == nil {
		return nil
	}
	return s.AssistantOverrides
}

func (s *ServerMessageResponseAssistantRequest) GetSquadId() *string {
	if s == nil {
		return nil
	}
	return s.SquadId
}

func (s *ServerMessageResponseAssistantRequest) GetSquad() *CreateSquadDto {
	if s == nil {
		return nil
	}
	return s.Squad
}

func (s *ServerMessageResponseAssistantRequest) GetWorkflowId() *string {
	if s == nil {
		return nil
	}
	return s.WorkflowId
}

func (s *ServerMessageResponseAssistantRequest) GetWorkflow() *CreateWorkflowDto {
	if s == nil {
		return nil
	}
	return s.Workflow
}

func (s *ServerMessageResponseAssistantRequest) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *ServerMessageResponseAssistantRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseAssistantRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseAssistantRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseAssistantRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseAssistantRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination to transfer the inbound call to. This will immediately transfer without using any assistants.
//
// If this is sent, `assistantId`, `assistant`, `squadId`, and `squad` are ignored.
type ServerMessageResponseAssistantRequestDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (s *ServerMessageResponseAssistantRequestDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageResponseAssistantRequestDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageResponseAssistantRequestDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseAssistantRequestDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseAssistantRequestDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageResponseAssistantRequestDestination) Accept(visitor ServerMessageResponseAssistantRequestDestinationVisitor) error {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseKnowledgeBaseRequest struct {
	// This is the list of documents that will be sent to the model alongside the `messages` to generate a response.
	Documents []*KnowledgeBaseResponseDocument `json:"documents,omitempty" url:"documents,omitempty"`
	// This can be used to skip the model output generation and speak a custom message.
	Message *CustomMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseKnowledgeBaseRequest) GetDocuments() []*KnowledgeBaseResponseDocument {
	if s == nil {
		return nil
	}
	return s.Documents
}

func (s *ServerMessageResponseKnowledgeBaseRequest) GetMessage() *CustomMessage {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *ServerMessageResponseKnowledgeBaseRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseKnowledgeBaseRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseKnowledgeBaseRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseKnowledgeBaseRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseKnowledgeBaseRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the response that is expected from the server to the message.
//
// Note: Most messages don't expect a response. Only "assistant-request", "tool-calls" and "transfer-destination-request" do.
type ServerMessageResponseMessageResponse struct {
	ServerMessageResponseAssistantRequest           *ServerMessageResponseAssistantRequest
	ServerMessageResponseKnowledgeBaseRequest       *ServerMessageResponseKnowledgeBaseRequest
	ServerMessageResponseToolCalls                  *ServerMessageResponseToolCalls
	ServerMessageResponseTransferDestinationRequest *ServerMessageResponseTransferDestinationRequest
	ServerMessageResponseVoiceRequest               *ServerMessageResponseVoiceRequest

	typ string
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseAssistantRequest() *ServerMessageResponseAssistantRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseAssistantRequest
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseKnowledgeBaseRequest() *ServerMessageResponseKnowledgeBaseRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseKnowledgeBaseRequest
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseToolCalls() *ServerMessageResponseToolCalls {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseToolCalls
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseTransferDestinationRequest() *ServerMessageResponseTransferDestinationRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseTransferDestinationRequest
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseVoiceRequest() *ServerMessageResponseVoiceRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseVoiceRequest
}

func (s *ServerMessageResponseMessageResponse) UnmarshalJSON(data []byte) error {
	valueServerMessageResponseAssistantRequest := new(ServerMessageResponseAssistantRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseAssistantRequest); err == nil {
		s.typ = "ServerMessageResponseAssistantRequest"
		s.ServerMessageResponseAssistantRequest = valueServerMessageResponseAssistantRequest
		return nil
	}
	valueServerMessageResponseKnowledgeBaseRequest := new(ServerMessageResponseKnowledgeBaseRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseKnowledgeBaseRequest); err == nil {
		s.typ = "ServerMessageResponseKnowledgeBaseRequest"
		s.ServerMessageResponseKnowledgeBaseRequest = valueServerMessageResponseKnowledgeBaseRequest
		return nil
	}
	valueServerMessageResponseToolCalls := new(ServerMessageResponseToolCalls)
	if err := json.Unmarshal(data, &valueServerMessageResponseToolCalls); err == nil {
		s.typ = "ServerMessageResponseToolCalls"
		s.ServerMessageResponseToolCalls = valueServerMessageResponseToolCalls
		return nil
	}
	valueServerMessageResponseTransferDestinationRequest := new(ServerMessageResponseTransferDestinationRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseTransferDestinationRequest); err == nil {
		s.typ = "ServerMessageResponseTransferDestinationRequest"
		s.ServerMessageResponseTransferDestinationRequest = valueServerMessageResponseTransferDestinationRequest
		return nil
	}
	valueServerMessageResponseVoiceRequest := new(ServerMessageResponseVoiceRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseVoiceRequest); err == nil {
		s.typ = "ServerMessageResponseVoiceRequest"
		s.ServerMessageResponseVoiceRequest = valueServerMessageResponseVoiceRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseMessageResponse) MarshalJSON() ([]byte, error) {
	if s.typ == "ServerMessageResponseAssistantRequest" || s.ServerMessageResponseAssistantRequest != nil {
		return json.Marshal(s.ServerMessageResponseAssistantRequest)
	}
	if s.typ == "ServerMessageResponseKnowledgeBaseRequest" || s.ServerMessageResponseKnowledgeBaseRequest != nil {
		return json.Marshal(s.ServerMessageResponseKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageResponseToolCalls" || s.ServerMessageResponseToolCalls != nil {
		return json.Marshal(s.ServerMessageResponseToolCalls)
	}
	if s.typ == "ServerMessageResponseTransferDestinationRequest" || s.ServerMessageResponseTransferDestinationRequest != nil {
		return json.Marshal(s.ServerMessageResponseTransferDestinationRequest)
	}
	if s.typ == "ServerMessageResponseVoiceRequest" || s.ServerMessageResponseVoiceRequest != nil {
		return json.Marshal(s.ServerMessageResponseVoiceRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseMessageResponseVisitor interface {
	VisitServerMessageResponseAssistantRequest(*ServerMessageResponseAssistantRequest) error
	VisitServerMessageResponseKnowledgeBaseRequest(*ServerMessageResponseKnowledgeBaseRequest) error
	VisitServerMessageResponseToolCalls(*ServerMessageResponseToolCalls) error
	VisitServerMessageResponseTransferDestinationRequest(*ServerMessageResponseTransferDestinationRequest) error
	VisitServerMessageResponseVoiceRequest(*ServerMessageResponseVoiceRequest) error
}

func (s *ServerMessageResponseMessageResponse) Accept(visitor ServerMessageResponseMessageResponseVisitor) error {
	if s.typ == "ServerMessageResponseAssistantRequest" || s.ServerMessageResponseAssistantRequest != nil {
		return visitor.VisitServerMessageResponseAssistantRequest(s.ServerMessageResponseAssistantRequest)
	}
	if s.typ == "ServerMessageResponseKnowledgeBaseRequest" || s.ServerMessageResponseKnowledgeBaseRequest != nil {
		return visitor.VisitServerMessageResponseKnowledgeBaseRequest(s.ServerMessageResponseKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageResponseToolCalls" || s.ServerMessageResponseToolCalls != nil {
		return visitor.VisitServerMessageResponseToolCalls(s.ServerMessageResponseToolCalls)
	}
	if s.typ == "ServerMessageResponseTransferDestinationRequest" || s.ServerMessageResponseTransferDestinationRequest != nil {
		return visitor.VisitServerMessageResponseTransferDestinationRequest(s.ServerMessageResponseTransferDestinationRequest)
	}
	if s.typ == "ServerMessageResponseVoiceRequest" || s.ServerMessageResponseVoiceRequest != nil {
		return visitor.VisitServerMessageResponseVoiceRequest(s.ServerMessageResponseVoiceRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseToolCalls struct {
	// These are the results of the "tool-calls" message.
	Results []*ToolCallResult `json:"results,omitempty" url:"results,omitempty"`
	// This is the error message if the tool call was not successful.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseToolCalls) GetResults() []*ToolCallResult {
	if s == nil {
		return nil
	}
	return s.Results
}

func (s *ServerMessageResponseToolCalls) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *ServerMessageResponseToolCalls) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseToolCalls) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageResponseTransferDestinationRequest struct {
	// This is the destination you'd like the call to be transferred to.
	Destination *ServerMessageResponseTransferDestinationRequestDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the error message if the transfer should not be made.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseTransferDestinationRequest) GetDestination() *ServerMessageResponseTransferDestinationRequestDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageResponseTransferDestinationRequest) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *ServerMessageResponseTransferDestinationRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseTransferDestinationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseTransferDestinationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseTransferDestinationRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseTransferDestinationRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination you'd like the call to be transferred to.
type ServerMessageResponseTransferDestinationRequestDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if s == nil {
		return nil
	}
	return s.TransferDestinationAssistant
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		s.typ = "TransferDestinationAssistant"
		s.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseTransferDestinationRequestDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return json.Marshal(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseTransferDestinationRequestDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) Accept(visitor ServerMessageResponseTransferDestinationRequestDestinationVisitor) error {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseVoiceRequest struct {
	// DO NOT respond to a `voice-request` webhook with this schema of { data }. This schema just exists to document what the response should look like. Follow these instructions:
	//
	// Here is what the request will look like:
	//
	// POST https://{assistant.voice.server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// The expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	Data string `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseVoiceRequest) GetData() string {
	if s == nil {
		return ""
	}
	return s.Data
}

func (s *ServerMessageResponseVoiceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseVoiceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseVoiceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseVoiceRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseVoiceRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageSpeechUpdate struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageSpeechUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "speech-update" is sent whenever assistant or user start or stop speaking.
	// This is the status of the speech update.
	Status ServerMessageSpeechUpdateStatus `json:"status" url:"status"`
	// This is the role which the speech update is for.
	Role ServerMessageSpeechUpdateRole `json:"role" url:"role"`
	// This is the turn number of the speech update (0-indexed).
	Turn *float64 `json:"turn,omitempty" url:"turn,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageSpeechUpdate) GetPhoneNumber() *ServerMessageSpeechUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageSpeechUpdate) GetStatus() ServerMessageSpeechUpdateStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *ServerMessageSpeechUpdate) GetRole() ServerMessageSpeechUpdateRole {
	if s == nil {
		return ""
	}
	return s.Role
}

func (s *ServerMessageSpeechUpdate) GetTurn() *float64 {
	if s == nil {
		return nil
	}
	return s.Turn
}

func (s *ServerMessageSpeechUpdate) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageSpeechUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageSpeechUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageSpeechUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageSpeechUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageSpeechUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageSpeechUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageSpeechUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageSpeechUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageSpeechUpdate(unmarshaler.embed)
	if unmarshaler.Type != "speech-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "speech-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageSpeechUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageSpeechUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "speech-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageSpeechUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageSpeechUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageSpeechUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageSpeechUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageSpeechUpdatePhoneNumber) Accept(visitor ServerMessageSpeechUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the role which the speech update is for.
type ServerMessageSpeechUpdateRole string

const (
	ServerMessageSpeechUpdateRoleAssistant ServerMessageSpeechUpdateRole = "assistant"
	ServerMessageSpeechUpdateRoleUser      ServerMessageSpeechUpdateRole = "user"
)

func NewServerMessageSpeechUpdateRoleFromString(s string) (ServerMessageSpeechUpdateRole, error) {
	switch s {
	case "assistant":
		return ServerMessageSpeechUpdateRoleAssistant, nil
	case "user":
		return ServerMessageSpeechUpdateRoleUser, nil
	}
	var t ServerMessageSpeechUpdateRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageSpeechUpdateRole) Ptr() *ServerMessageSpeechUpdateRole {
	return &s
}

// This is the status of the speech update.
type ServerMessageSpeechUpdateStatus string

const (
	ServerMessageSpeechUpdateStatusStarted ServerMessageSpeechUpdateStatus = "started"
	ServerMessageSpeechUpdateStatusStopped ServerMessageSpeechUpdateStatus = "stopped"
)

func NewServerMessageSpeechUpdateStatusFromString(s string) (ServerMessageSpeechUpdateStatus, error) {
	switch s {
	case "started":
		return ServerMessageSpeechUpdateStatusStarted, nil
	case "stopped":
		return ServerMessageSpeechUpdateStatusStopped, nil
	}
	var t ServerMessageSpeechUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageSpeechUpdateStatus) Ptr() *ServerMessageSpeechUpdateStatus {
	return &s
}

type ServerMessageStatusUpdate struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageStatusUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "status-update" is sent whenever the `call.status` changes.
	// This is the status of the call.
	Status ServerMessageStatusUpdateStatus `json:"status" url:"status"`
	// This is the reason the call ended. This is only sent if the status is "ended".
	EndedReason *ServerMessageStatusUpdateEndedReason `json:"endedReason,omitempty" url:"endedReason,omitempty"`
	// These are the conversation messages of the call. This is only sent if the status is "forwarding".
	Messages []*ServerMessageStatusUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the conversation messages of the call. This is only sent if the status is "forwarding".
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the destination the call is being transferred to. This is only sent if the status is "forwarding".
	Destination *ServerMessageStatusUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the transcript of the call. This is only sent if the status is "forwarding".
	Transcript *string `json:"transcript,omitempty" url:"transcript,omitempty"`
	// This is the summary of the call. This is only sent if the status is "forwarding".
	Summary *string `json:"summary,omitempty" url:"summary,omitempty"`
	// This is the inbound phone call debugging artifacts. This is only sent if the status is "ended" and there was an error accepting the inbound phone call.
	//
	// This will include any errors related to the "assistant-request" if one was made.
	InboundPhoneCallDebuggingArtifacts map[string]interface{} `json:"inboundPhoneCallDebuggingArtifacts,omitempty" url:"inboundPhoneCallDebuggingArtifacts,omitempty"`
	type_                              string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageStatusUpdate) GetPhoneNumber() *ServerMessageStatusUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageStatusUpdate) GetStatus() ServerMessageStatusUpdateStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *ServerMessageStatusUpdate) GetEndedReason() *ServerMessageStatusUpdateEndedReason {
	if s == nil {
		return nil
	}
	return s.EndedReason
}

func (s *ServerMessageStatusUpdate) GetMessages() []*ServerMessageStatusUpdateMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *ServerMessageStatusUpdate) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if s == nil {
		return nil
	}
	return s.MessagesOpenAiFormatted
}

func (s *ServerMessageStatusUpdate) GetDestination() *ServerMessageStatusUpdateDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageStatusUpdate) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageStatusUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageStatusUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageStatusUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageStatusUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageStatusUpdate) GetTranscript() *string {
	if s == nil {
		return nil
	}
	return s.Transcript
}

func (s *ServerMessageStatusUpdate) GetSummary() *string {
	if s == nil {
		return nil
	}
	return s.Summary
}

func (s *ServerMessageStatusUpdate) GetInboundPhoneCallDebuggingArtifacts() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.InboundPhoneCallDebuggingArtifacts
}

func (s *ServerMessageStatusUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageStatusUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageStatusUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageStatusUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageStatusUpdate(unmarshaler.embed)
	if unmarshaler.Type != "status-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "status-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageStatusUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageStatusUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "status-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageStatusUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination the call is being transferred to. This is only sent if the status is "forwarding".
type ServerMessageStatusUpdateDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (s *ServerMessageStatusUpdateDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageStatusUpdateDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageStatusUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdateDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdateDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageStatusUpdateDestination) Accept(visitor ServerMessageStatusUpdateDestinationVisitor) error {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the reason the call ended. This is only sent if the status is "ended".
type ServerMessageStatusUpdateEndedReason string

const (
	ServerMessageStatusUpdateEndedReasonCallStartErrorNeitherAssistantNorServerSet                                                                ServerMessageStatusUpdateEndedReason = "call-start-error-neither-assistant-nor-server-set"
	ServerMessageStatusUpdateEndedReasonAssistantRequestFailed                                                                                    ServerMessageStatusUpdateEndedReason = "assistant-request-failed"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedError                                                                             ServerMessageStatusUpdateEndedReason = "assistant-request-returned-error"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedUnspeakableError                                                                  ServerMessageStatusUpdateEndedReason = "assistant-request-returned-unspeakable-error"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedInvalidAssistant                                                                  ServerMessageStatusUpdateEndedReason = "assistant-request-returned-invalid-assistant"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedNoAssistant                                                                       ServerMessageStatusUpdateEndedReason = "assistant-request-returned-no-assistant"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedForwardingPhoneNumber                                                             ServerMessageStatusUpdateEndedReason = "assistant-request-returned-forwarding-phone-number"
	ServerMessageStatusUpdateEndedReasonCallStartErrorGetOrg                                                                                      ServerMessageStatusUpdateEndedReason = "call.start.error-get-org"
	ServerMessageStatusUpdateEndedReasonCallStartErrorGetSubscription                                                                             ServerMessageStatusUpdateEndedReason = "call.start.error-get-subscription"
	ServerMessageStatusUpdateEndedReasonCallStartErrorGetAssistant                                                                                ServerMessageStatusUpdateEndedReason = "call.start.error-get-assistant"
	ServerMessageStatusUpdateEndedReasonCallStartErrorGetPhoneNumber                                                                              ServerMessageStatusUpdateEndedReason = "call.start.error-get-phone-number"
	ServerMessageStatusUpdateEndedReasonCallStartErrorGetCustomer                                                                                 ServerMessageStatusUpdateEndedReason = "call.start.error-get-customer"
	ServerMessageStatusUpdateEndedReasonCallStartErrorGetResourcesValidation                                                                      ServerMessageStatusUpdateEndedReason = "call.start.error-get-resources-validation"
	ServerMessageStatusUpdateEndedReasonCallStartErrorVapiNumberInternational                                                                     ServerMessageStatusUpdateEndedReason = "call.start.error-vapi-number-international"
	ServerMessageStatusUpdateEndedReasonCallStartErrorVapiNumberOutboundDailyLimit                                                                ServerMessageStatusUpdateEndedReason = "call.start.error-vapi-number-outbound-daily-limit"
	ServerMessageStatusUpdateEndedReasonCallStartErrorGetTransport                                                                                ServerMessageStatusUpdateEndedReason = "call.start.error-get-transport"
	ServerMessageStatusUpdateEndedReasonAssistantNotValid                                                                                         ServerMessageStatusUpdateEndedReason = "assistant-not-valid"
	ServerMessageStatusUpdateEndedReasonDatabaseError                                                                                             ServerMessageStatusUpdateEndedReason = "database-error"
	ServerMessageStatusUpdateEndedReasonAssistantNotFound                                                                                         ServerMessageStatusUpdateEndedReason = "assistant-not-found"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiVoiceFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaVoiceFailed                                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramVoiceFailed                                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceFailed                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorLmntVoiceFailed                                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-lmnt-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureVoiceFailed                                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRimeAiVoiceFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-rime-ai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorSmallestAiVoiceFailed                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-smallest-ai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorNeuphonicVoiceFailed                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-neuphonic-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorHumeVoiceFailed                                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-hume-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorSesameVoiceFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-sesame-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTavusVideoFailed                                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-tavus-video-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenaiVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCartesiaVoiceFailed                                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cartesia-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramVoiceFailed                                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepgram-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceFailed                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultLmntVoiceFailed                                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-lmnt-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureVoiceFailed                                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-azure-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRimeAiVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-rime-ai-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultSmallestAiVoiceFailed                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-smallest-ai-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultNeuphonicVoiceFailed                                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-neuphonic-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultHumeVoiceFailed                                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-hume-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultSesameVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-sesame-voice-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTavusVideoFailed                                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-tavus-video-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapiLlmFailed                                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi400BadRequestValidationFailed                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi401Unauthorized                                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi403ModelAccessDenied                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi429ExceededQuota                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi500ServerError                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi503ServerOverloadedError                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapiLlmFailed                                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-vapi-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi400BadRequestValidationFailed                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-vapi-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi401Unauthorized                                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-vapi-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi403ModelAccessDenied                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-vapi-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi429ExceededQuota                                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-vapi-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultVapi500ServerError                                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-vapi-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultVapi503ServerOverloadedError                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-vapi-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramTranscriberFailed                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramTranscriberFailed                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepgram-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGladiaTranscriberFailed                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-gladia-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGladiaTranscriberFailed                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-gladia-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorSpeechmaticsTranscriberFailed                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-speechmatics-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultSpeechmaticsTranscriberFailed                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-speechmatics-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiTranscriberFailed                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-assembly-ai-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning400InsufficentFunds                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-assembly-ai-returning-400-insufficent-funds"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning400PaidOnlyFeature                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-assembly-ai-returning-400-paid-only-feature"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning401InvalidCredentials                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-assembly-ai-returning-401-invalid-credentials"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning500InvalidSchema                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-assembly-ai-returning-500-invalid-schema"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning500WordBoostParsingFailed                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-assembly-ai-returning-500-word-boost-parsing-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiTranscriberFailed                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-assembly-ai-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400InsufficentFunds                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-400-insufficent-funds"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400PaidOnlyFeature                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-400-paid-only-feature"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning401InvalidCredentials                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-401-invalid-credentials"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500InvalidSchema                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-500-invalid-schema"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500WordBoostParsingFailed                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-assembly-ai-returning-500-word-boost-parsing-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTalkscriberTranscriberFailed                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-talkscriber-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTalkscriberTranscriberFailed                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-talkscriber-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureSpeechTranscriberFailed                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-speech-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureSpeechTranscriberFailed                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-azure-speech-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorPipelineNoAvailableLlmModel                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-pipeline-no-available-llm-model"
	ServerMessageStatusUpdateEndedReasonWorkerShutdown                                                                                            ServerMessageStatusUpdateEndedReason = "worker-shutdown"
	ServerMessageStatusUpdateEndedReasonUnknownError                                                                                              ServerMessageStatusUpdateEndedReason = "unknown-error"
	ServerMessageStatusUpdateEndedReasonVonageDisconnected                                                                                        ServerMessageStatusUpdateEndedReason = "vonage-disconnected"
	ServerMessageStatusUpdateEndedReasonVonageFailedToConnectCall                                                                                 ServerMessageStatusUpdateEndedReason = "vonage-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonVonageCompleted                                                                                           ServerMessageStatusUpdateEndedReason = "vonage-completed"
	ServerMessageStatusUpdateEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived                                                           ServerMessageStatusUpdateEndedReason = "phone-call-provider-bypass-enabled-but-no-call-received"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultTransportNeverConnected                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-transport-never-connected"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultWorkerNotAvailable                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-worker-not-available"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTransportNeverConnected                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-transport-never-connected"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTransportConnectedButCallNotActive                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-transport-connected-but-call-not-active"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCallStartedButConnectionToTransportMissing                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-call-started-but-connection-to-transport-missing"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenaiLlmFailed                                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenaiLlmFailed                                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-azure-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroqLlmFailed                                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-groq-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogleLlmFailed                                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-google-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXaiLlmFailed                                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-xai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistralLlmFailed                                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-mistral-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAiLlmFailed                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-inflection-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebrasLlmFailed                                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cerebras-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeekLlmFailed                                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deep-seek-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai400BadRequestValidationFailed                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401Unauthorized                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401IncorrectApiKey                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-401-incorrect-api-key"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401AccountNotInOrganization                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-401-account-not-in-organization"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai403ModelAccessDenied                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429ExceededQuota                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429RateLimitReached                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-429-rate-limit-reached"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai500ServerError                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai503ServerOverloadedError                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiLlmFailed                                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai400BadRequestValidationFailed                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai401IncorrectApiKey                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-401-incorrect-api-key"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai401AccountNotInOrganization                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-401-account-not-in-organization"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai403ModelAccessDenied                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai429RateLimitReached                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-429-rate-limit-reached"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenai500ServerError                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenai503ServerOverloadedError                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-openai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai401Unauthorized                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai429ExceededQuota                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai500ServerError                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai503ServerOverloadedError                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenaiLlmFailed                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai400BadRequestValidationFailed                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-azure-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai401Unauthorized                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-azure-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai403ModelAccessDenied                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-azure-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai429ExceededQuota                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-azure-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAzureOpenai500ServerError                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-azure-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAzureOpenai503ServerOverloadedError                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-azure-openai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle400BadRequestValidationFailed                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-google-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle401Unauthorized                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-google-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle403ModelAccessDenied                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-google-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle429ExceededQuota                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-google-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle500ServerError                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-google-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle503ServerOverloadedError                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-google-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogleLlmFailed                                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-google-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle400BadRequestValidationFailed                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-google-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-google-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle403ModelAccessDenied                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-google-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-google-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGoogle500ServerError                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-google-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGoogle503ServerOverloadedError                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-google-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai400BadRequestValidationFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai401Unauthorized                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai403ModelAccessDenied                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai429ExceededQuota                                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai500ServerError                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai503ServerOverloadedError                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXaiLlmFailed                                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai400BadRequestValidationFailed                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-xai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai401Unauthorized                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-xai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai403ModelAccessDenied                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-xai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai429ExceededQuota                                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-xai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultXai500ServerError                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-xai-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultXai503ServerOverloadedError                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-xai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorMistral400BadRequestValidationFailed                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-mistral-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorMistral401Unauthorized                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-mistral-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorMistral403ModelAccessDenied                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-mistral-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorMistral429ExceededQuota                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-mistral-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorMistral500ServerError                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-mistral-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorMistral503ServerOverloadedError                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-mistral-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorMistralLlmFailed                                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-mistral-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral400BadRequestValidationFailed                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-mistral-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral401Unauthorized                                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-mistral-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral403ModelAccessDenied                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-mistral-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral429ExceededQuota                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-mistral-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultMistral500ServerError                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-mistral-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultMistral503ServerOverloadedError                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-mistral-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi401Unauthorized                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi403ModelAccessDenied                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi429ExceededQuota                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi500ServerError                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi503ServerOverloadedError                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAiLlmFailed                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi400BadRequestValidationFailed                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-inflection-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi401Unauthorized                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-inflection-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi403ModelAccessDenied                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-inflection-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi429ExceededQuota                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-inflection-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultInflectionAi500ServerError                                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-inflection-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultInflectionAi503ServerOverloadedError                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-inflection-ai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek401Unauthorized                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek403ModelAccessDenied                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek429ExceededQuota                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek500ServerError                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek503ServerOverloadedError                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeekLlmFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek400BadRequestValidationFailed                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deep-seek-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek401Unauthorized                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deep-seek-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek403ModelAccessDenied                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deep-seek-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek429ExceededQuota                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deep-seek-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepSeek500ServerError                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-deep-seek-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepSeek503ServerOverloadedError                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-deep-seek-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq400BadRequestValidationFailed                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq401Unauthorized                                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq403ModelAccessDenied                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq429ExceededQuota                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq500ServerError                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq503ServerOverloadedError                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroqLlmFailed                                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq400BadRequestValidationFailed                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-groq-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq401Unauthorized                                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-groq-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq403ModelAccessDenied                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-groq-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq429ExceededQuota                                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-groq-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGroq500ServerError                                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-groq-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGroq503ServerOverloadedError                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-groq-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras400BadRequestValidationFailed                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras401Unauthorized                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras403ModelAccessDenied                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras429ExceededQuota                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras500ServerError                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras503ServerOverloadedError                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebrasLlmFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras400BadRequestValidationFailed                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cerebras-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras401Unauthorized                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cerebras-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras403ModelAccessDenied                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cerebras-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras429ExceededQuota                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cerebras-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCerebras500ServerError                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-cerebras-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCerebras503ServerOverloadedError                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-cerebras-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic401Unauthorized                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic403ModelAccessDenied                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic429ExceededQuota                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic500ServerError                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic503ServerOverloadedError                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicLlmFailed                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicLlmFailed                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic400BadRequestValidationFailed                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic401Unauthorized                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic403ModelAccessDenied                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic429ExceededQuota                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropic500ServerError                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anthropic-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropic503ServerOverloadedError                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anthropic-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock400BadRequestValidationFailed                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-bedrock-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock401Unauthorized                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-bedrock-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock403ModelAccessDenied                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-bedrock-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock429ExceededQuota                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-bedrock-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock500ServerError                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-bedrock-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock503ServerOverloadedError                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-bedrock-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrockLlmFailed                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-bedrock-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrockLlmFailed                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock400BadRequestValidationFailed                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock401Unauthorized                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock403ModelAccessDenied                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock429ExceededQuota                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-bedrock-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock500ServerError                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anthropic-bedrock-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock503ServerOverloadedError                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anthropic-bedrock-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex400BadRequestValidationFailed                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-vertex-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex401Unauthorized                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-vertex-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex403ModelAccessDenied                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-vertex-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex429ExceededQuota                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-vertex-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex500ServerError                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-vertex-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex503ServerOverloadedError                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-vertex-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertexLlmFailed                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-vertex-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertexLlmFailed                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex400BadRequestValidationFailed                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex401Unauthorized                                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex403ModelAccessDenied                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex429ExceededQuota                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anthropic-vertex-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicVertex500ServerError                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anthropic-vertex-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicVertex503ServerOverloadedError                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anthropic-vertex-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi401Unauthorized                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi403ModelAccessDenied                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi429ExceededQuota                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi500ServerError                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi503ServerOverloadedError                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAiLlmFailed                                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAiLlmFailed                                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-together-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi400BadRequestValidationFailed                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-together-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi401Unauthorized                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-together-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi403ModelAccessDenied                                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-together-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi429ExceededQuota                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-together-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultTogetherAi500ServerError                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-together-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultTogetherAi503ServerOverloadedError                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-together-ai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale401Unauthorized                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale403ModelAccessDenied                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale429ExceededQuota                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale500ServerError                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale503ServerOverloadedError                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscaleLlmFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscaleLlmFailed                                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anyscale-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale400BadRequestValidationFailed                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anyscale-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale401Unauthorized                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anyscale-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale403ModelAccessDenied                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anyscale-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale429ExceededQuota                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-anyscale-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnyscale500ServerError                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anyscale-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnyscale503ServerOverloadedError                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-anyscale-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter401Unauthorized                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter403ModelAccessDenied                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter429ExceededQuota                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter500ServerError                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter503ServerOverloadedError                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouterLlmFailed                                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouterLlmFailed                                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openrouter-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter400BadRequestValidationFailed                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openrouter-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter401Unauthorized                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openrouter-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter403ModelAccessDenied                                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openrouter-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter429ExceededQuota                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openrouter-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenrouter500ServerError                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-openrouter-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenrouter503ServerOverloadedError                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-openrouter-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi401Unauthorized                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi429ExceededQuota                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi500ServerError                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi503ServerOverloadedError                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAiLlmFailed                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAiLlmFailed                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-perplexity-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi400BadRequestValidationFailed                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi401Unauthorized                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-perplexity-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi403ModelAccessDenied                                              ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-perplexity-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi429ExceededQuota                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-perplexity-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPerplexityAi500ServerError                                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-perplexity-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPerplexityAi503ServerOverloadedError                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-perplexity-ai-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra401Unauthorized                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra403ModelAccessDenied                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra429ExceededQuota                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra500ServerError                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra503ServerOverloadedError                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfraLlmFailed                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfraLlmFailed                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepinfra-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra400BadRequestValidationFailed                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepinfra-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra401Unauthorized                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepinfra-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra403ModelAccessDenied                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepinfra-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra429ExceededQuota                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepinfra-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepinfra500ServerError                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-deepinfra-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepinfra503ServerOverloadedError                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-deepinfra-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod400BadRequestValidationFailed                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod401Unauthorized                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod403ModelAccessDenied                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod429ExceededQuota                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod500ServerError                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod503ServerOverloadedError                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpodLlmFailed                                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpodLlmFailed                                                               ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-runpod-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod400BadRequestValidationFailed                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-runpod-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-runpod-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod403ModelAccessDenied                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-runpod-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-runpod-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultRunpod500ServerError                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-runpod-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultRunpod503ServerOverloadedError                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-runpod-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm401Unauthorized                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm403ModelAccessDenied                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm429ExceededQuota                                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm500ServerError                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm503ServerOverloadedError                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlmLlmFailed                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlmLlmFailed                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-custom-llm-llm-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm400BadRequestValidationFailed                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-custom-llm-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm401Unauthorized                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-custom-llm-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm403ModelAccessDenied                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-custom-llm-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm429ExceededQuota                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-custom-llm-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCustomLlm500ServerError                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-custom-llm-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCustomLlm503ServerOverloadedError                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-custom-llm-503-server-overloaded-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomVoiceFailed                                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaSocketHangUp                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-socket-hang-up"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaRequestedPayment                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-requested-payment"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia500ServerError                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia503ServerError                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-503-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia522ServerError                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-522-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCartesiaSocketHangUp                                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cartesia-socket-hang-up"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCartesiaRequestedPayment                                                      ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-cartesia-requested-payment"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCartesia500ServerError                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-cartesia-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCartesia503ServerError                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-cartesia-503-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCartesia522ServerError                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-cartesia-522-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFound                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-found"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsQuotaExceeded                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-quota-exceeded"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedAccess                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-unauthorized-access"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-unauthorized-to-access-model"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidApiKey                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-invalid-api-key"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples                                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-invalid-voice-samples"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-disabled-by-owner"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-account-in-probation"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-content-against-their-policy"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-max-character-limit-exceeded"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification                ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabs500ServerError                                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-500-server-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFound                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-found"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsQuotaExceeded                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-quota-exceeded"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedAccess                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-unauthorized-access"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedToAccessModel                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-unauthorized-to-access-model"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsProfessionalVoicesOnlyForCreatorPlus                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedFreePlanAndRequestedUpgrade                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsSystemBusyAndRequestedUpgrade                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTuned                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidApiKey                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-invalid-api-key"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidVoiceSamples                                                 ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-invalid-voice-samples"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceDisabledByOwner                                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-disabled-by-owner"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedAccountInProbation                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-account-in-probation"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedContentAgainstTheirPolicy                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-content-against-their-policy"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsMissingSamplesForVoiceClone                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTunedAndCannotBeUsed                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotAllowedForFreeUsers                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsMaxCharacterLimitExceeded                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-max-character-limit-exceeded"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultElevenLabs500ServerError                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-eleven-labs-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtRequestTimedOut                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-request-timed-out"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidVoice                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-invalid-voice"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtUnexpectedError                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-unexpected-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtOutOfCredits                                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-out-of-credits"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidEmotion                                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-invalid-emotion"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht401Unauthorized                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-403-forbidden-out-of-characters"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-403-forbidden-api-access-not-available"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht429ExceededQuota                                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht502GatewayError                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-502-gateway-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht504GatewayError                                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-504-gateway-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtRequestTimedOut                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-request-timed-out"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtInvalidVoice                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-invalid-voice"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtUnexpectedError                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-unexpected-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtOutOfCredits                                                            ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-out-of-credits"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtInvalidEmotion                                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-invalid-emotion"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtVoiceMustBeAValidVoiceManifestUri                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenOutOfCharacters                                             ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-403-forbidden-out-of-characters"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenApiAccessNotAvailable                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-403-forbidden-api-access-not-available"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-playht-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPlayht502GatewayError                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-playht-502-gateway-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPlayht504GatewayError                                                     ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-playht-504-gateway-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomTranscriberFailed                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomTranscriberFailed                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-custom-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsTranscriberFailed                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsTranscriberFailed                                                   ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-eleven-labs-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-401-invalid-credentials"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning404NotFound                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-404-not-found"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning500InvalidJson                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-500-invalid-json"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502NetworkError                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-502-network-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning400NoSuchModelLanguageTierCombination                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepgram-returning-400-no-such-model-language-tier-combination"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning401InvalidCredentials                                        ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepgram-returning-401-invalid-credentials"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning404NotFound                                                  ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepgram-returning-404-not-found"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning403ModelAccessDenied                                         ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-deepgram-returning-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepgramReturning500InvalidJson                                           ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-deepgram-returning-500-invalid-json"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502NetworkError                                          ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-deepgram-returning-502-network-error"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502BadGatewayEhostunreach                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-providerfault-deepgram-returning-502-bad-gateway-ehostunreach"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogleTranscriberFailed                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-google-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogleTranscriberFailed                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-google-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiTranscriberFailed                                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenaiTranscriberFailed                                                       ServerMessageStatusUpdateEndedReason = "call.in-progress.error-vapifault-openai-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonAssistantEndedCall                                                                                        ServerMessageStatusUpdateEndedReason = "assistant-ended-call"
	ServerMessageStatusUpdateEndedReasonAssistantSaidEndCallPhrase                                                                                ServerMessageStatusUpdateEndedReason = "assistant-said-end-call-phrase"
	ServerMessageStatusUpdateEndedReasonAssistantEndedCallWithHangupTask                                                                          ServerMessageStatusUpdateEndedReason = "assistant-ended-call-with-hangup-task"
	ServerMessageStatusUpdateEndedReasonAssistantEndedCallAfterMessageSpoken                                                                      ServerMessageStatusUpdateEndedReason = "assistant-ended-call-after-message-spoken"
	ServerMessageStatusUpdateEndedReasonAssistantForwardedCall                                                                                    ServerMessageStatusUpdateEndedReason = "assistant-forwarded-call"
	ServerMessageStatusUpdateEndedReasonAssistantJoinTimedOut                                                                                     ServerMessageStatusUpdateEndedReason = "assistant-join-timed-out"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorAssistantDidNotReceiveCustomerAudio                                                    ServerMessageStatusUpdateEndedReason = "call.in-progress.error-assistant-did-not-receive-customer-audio"
	ServerMessageStatusUpdateEndedReasonCustomerBusy                                                                                              ServerMessageStatusUpdateEndedReason = "customer-busy"
	ServerMessageStatusUpdateEndedReasonCustomerEndedCall                                                                                         ServerMessageStatusUpdateEndedReason = "customer-ended-call"
	ServerMessageStatusUpdateEndedReasonCustomerDidNotAnswer                                                                                      ServerMessageStatusUpdateEndedReason = "customer-did-not-answer"
	ServerMessageStatusUpdateEndedReasonCustomerDidNotGiveMicrophonePermission                                                                    ServerMessageStatusUpdateEndedReason = "customer-did-not-give-microphone-permission"
	ServerMessageStatusUpdateEndedReasonExceededMaxDuration                                                                                       ServerMessageStatusUpdateEndedReason = "exceeded-max-duration"
	ServerMessageStatusUpdateEndedReasonManuallyCanceled                                                                                          ServerMessageStatusUpdateEndedReason = "manually-canceled"
	ServerMessageStatusUpdateEndedReasonPhoneCallProviderClosedWebsocket                                                                          ServerMessageStatusUpdateEndedReason = "phone-call-provider-closed-websocket"
	ServerMessageStatusUpdateEndedReasonCallForwardingOperatorBusy                                                                                ServerMessageStatusUpdateEndedReason = "call.forwarding.operator-busy"
	ServerMessageStatusUpdateEndedReasonSilenceTimedOut                                                                                           ServerMessageStatusUpdateEndedReason = "silence-timed-out"
	ServerMessageStatusUpdateEndedReasonCallInProgressErrorSipTelephonyProviderFailedToConnectCall                                                ServerMessageStatusUpdateEndedReason = "call.in-progress.error-sip-telephony-provider-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonCallRingingHookExecutedSay                                                                                ServerMessageStatusUpdateEndedReason = "call.ringing.hook-executed-say"
	ServerMessageStatusUpdateEndedReasonCallRingingHookExecutedTransfer                                                                           ServerMessageStatusUpdateEndedReason = "call.ringing.hook-executed-transfer"
	ServerMessageStatusUpdateEndedReasonTwilioFailedToConnectCall                                                                                 ServerMessageStatusUpdateEndedReason = "twilio-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonTwilioReportedCustomerMisdialed                                                                           ServerMessageStatusUpdateEndedReason = "twilio-reported-customer-misdialed"
	ServerMessageStatusUpdateEndedReasonVonageRejected                                                                                            ServerMessageStatusUpdateEndedReason = "vonage-rejected"
	ServerMessageStatusUpdateEndedReasonVoicemail                                                                                                 ServerMessageStatusUpdateEndedReason = "voicemail"
)

func NewServerMessageStatusUpdateEndedReasonFromString(s string) (ServerMessageStatusUpdateEndedReason, error) {
	switch s {
	case "call-start-error-neither-assistant-nor-server-set":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorNeitherAssistantNorServerSet, nil
	case "assistant-request-failed":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestFailed, nil
	case "assistant-request-returned-error":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedError, nil
	case "assistant-request-returned-unspeakable-error":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedUnspeakableError, nil
	case "assistant-request-returned-invalid-assistant":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedInvalidAssistant, nil
	case "assistant-request-returned-no-assistant":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedNoAssistant, nil
	case "assistant-request-returned-forwarding-phone-number":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedForwardingPhoneNumber, nil
	case "call.start.error-get-org":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorGetOrg, nil
	case "call.start.error-get-subscription":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorGetSubscription, nil
	case "call.start.error-get-assistant":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorGetAssistant, nil
	case "call.start.error-get-phone-number":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorGetPhoneNumber, nil
	case "call.start.error-get-customer":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorGetCustomer, nil
	case "call.start.error-get-resources-validation":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorGetResourcesValidation, nil
	case "call.start.error-vapi-number-international":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorVapiNumberInternational, nil
	case "call.start.error-vapi-number-outbound-daily-limit":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorVapiNumberOutboundDailyLimit, nil
	case "call.start.error-get-transport":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorGetTransport, nil
	case "assistant-not-valid":
		return ServerMessageStatusUpdateEndedReasonAssistantNotValid, nil
	case "database-error":
		return ServerMessageStatusUpdateEndedReasonDatabaseError, nil
	case "assistant-not-found":
		return ServerMessageStatusUpdateEndedReasonAssistantNotFound, nil
	case "pipeline-error-openai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiVoiceFailed, nil
	case "pipeline-error-cartesia-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaVoiceFailed, nil
	case "pipeline-error-deepgram-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramVoiceFailed, nil
	case "pipeline-error-eleven-labs-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceFailed, nil
	case "pipeline-error-playht-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceFailed, nil
	case "pipeline-error-lmnt-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorLmntVoiceFailed, nil
	case "pipeline-error-azure-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureVoiceFailed, nil
	case "pipeline-error-rime-ai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRimeAiVoiceFailed, nil
	case "pipeline-error-smallest-ai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorSmallestAiVoiceFailed, nil
	case "pipeline-error-neuphonic-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorNeuphonicVoiceFailed, nil
	case "pipeline-error-hume-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorHumeVoiceFailed, nil
	case "pipeline-error-sesame-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorSesameVoiceFailed, nil
	case "pipeline-error-tavus-video-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTavusVideoFailed, nil
	case "call.in-progress.error-vapifault-openai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenaiVoiceFailed, nil
	case "call.in-progress.error-vapifault-cartesia-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCartesiaVoiceFailed, nil
	case "call.in-progress.error-vapifault-deepgram-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramVoiceFailed, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceFailed, nil
	case "call.in-progress.error-vapifault-playht-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtVoiceFailed, nil
	case "call.in-progress.error-vapifault-lmnt-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultLmntVoiceFailed, nil
	case "call.in-progress.error-vapifault-azure-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureVoiceFailed, nil
	case "call.in-progress.error-vapifault-rime-ai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRimeAiVoiceFailed, nil
	case "call.in-progress.error-vapifault-smallest-ai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultSmallestAiVoiceFailed, nil
	case "call.in-progress.error-vapifault-neuphonic-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultNeuphonicVoiceFailed, nil
	case "call.in-progress.error-vapifault-hume-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultHumeVoiceFailed, nil
	case "call.in-progress.error-vapifault-sesame-voice-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultSesameVoiceFailed, nil
	case "call.in-progress.error-vapifault-tavus-video-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTavusVideoFailed, nil
	case "pipeline-error-vapi-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapiLlmFailed, nil
	case "pipeline-error-vapi-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi400BadRequestValidationFailed, nil
	case "pipeline-error-vapi-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi401Unauthorized, nil
	case "pipeline-error-vapi-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi403ModelAccessDenied, nil
	case "pipeline-error-vapi-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi429ExceededQuota, nil
	case "pipeline-error-vapi-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi500ServerError, nil
	case "pipeline-error-vapi-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi503ServerOverloadedError, nil
	case "call.in-progress.error-vapifault-vapi-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapiLlmFailed, nil
	case "call.in-progress.error-vapifault-vapi-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-vapi-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi401Unauthorized, nil
	case "call.in-progress.error-vapifault-vapi-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-vapi-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultVapi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-vapi-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultVapi500ServerError, nil
	case "call.in-progress.error-providerfault-vapi-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultVapi503ServerOverloadedError, nil
	case "pipeline-error-deepgram-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramTranscriberFailed, nil
	case "call.in-progress.error-vapifault-deepgram-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramTranscriberFailed, nil
	case "pipeline-error-gladia-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGladiaTranscriberFailed, nil
	case "call.in-progress.error-vapifault-gladia-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGladiaTranscriberFailed, nil
	case "pipeline-error-speechmatics-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorSpeechmaticsTranscriberFailed, nil
	case "call.in-progress.error-vapifault-speechmatics-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultSpeechmaticsTranscriberFailed, nil
	case "pipeline-error-assembly-ai-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiTranscriberFailed, nil
	case "pipeline-error-assembly-ai-returning-400-insufficent-funds":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning400InsufficentFunds, nil
	case "pipeline-error-assembly-ai-returning-400-paid-only-feature":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning400PaidOnlyFeature, nil
	case "pipeline-error-assembly-ai-returning-401-invalid-credentials":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning401InvalidCredentials, nil
	case "pipeline-error-assembly-ai-returning-500-invalid-schema":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning500InvalidSchema, nil
	case "pipeline-error-assembly-ai-returning-500-word-boost-parsing-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiReturning500WordBoostParsingFailed, nil
	case "call.in-progress.error-vapifault-assembly-ai-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiTranscriberFailed, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-400-insufficent-funds":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400InsufficentFunds, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-400-paid-only-feature":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning400PaidOnlyFeature, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-401-invalid-credentials":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning401InvalidCredentials, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-500-invalid-schema":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500InvalidSchema, nil
	case "call.in-progress.error-vapifault-assembly-ai-returning-500-word-boost-parsing-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAssemblyAiReturning500WordBoostParsingFailed, nil
	case "pipeline-error-talkscriber-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTalkscriberTranscriberFailed, nil
	case "call.in-progress.error-vapifault-talkscriber-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTalkscriberTranscriberFailed, nil
	case "pipeline-error-azure-speech-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureSpeechTranscriberFailed, nil
	case "call.in-progress.error-vapifault-azure-speech-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureSpeechTranscriberFailed, nil
	case "call.in-progress.error-pipeline-no-available-llm-model":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorPipelineNoAvailableLlmModel, nil
	case "worker-shutdown":
		return ServerMessageStatusUpdateEndedReasonWorkerShutdown, nil
	case "unknown-error":
		return ServerMessageStatusUpdateEndedReasonUnknownError, nil
	case "vonage-disconnected":
		return ServerMessageStatusUpdateEndedReasonVonageDisconnected, nil
	case "vonage-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonVonageFailedToConnectCall, nil
	case "vonage-completed":
		return ServerMessageStatusUpdateEndedReasonVonageCompleted, nil
	case "phone-call-provider-bypass-enabled-but-no-call-received":
		return ServerMessageStatusUpdateEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived, nil
	case "call.in-progress.error-providerfault-transport-never-connected":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultTransportNeverConnected, nil
	case "call.in-progress.error-vapifault-worker-not-available":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultWorkerNotAvailable, nil
	case "call.in-progress.error-vapifault-transport-never-connected":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTransportNeverConnected, nil
	case "call.in-progress.error-vapifault-transport-connected-but-call-not-active":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTransportConnectedButCallNotActive, nil
	case "call.in-progress.error-vapifault-call-started-but-connection-to-transport-missing":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCallStartedButConnectionToTransportMissing, nil
	case "call.in-progress.error-vapifault-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-azure-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-groq-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroqLlmFailed, nil
	case "call.in-progress.error-vapifault-google-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogleLlmFailed, nil
	case "call.in-progress.error-vapifault-xai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXaiLlmFailed, nil
	case "call.in-progress.error-vapifault-mistral-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistralLlmFailed, nil
	case "call.in-progress.error-vapifault-inflection-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAiLlmFailed, nil
	case "call.in-progress.error-vapifault-cerebras-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebrasLlmFailed, nil
	case "call.in-progress.error-vapifault-deep-seek-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeekLlmFailed, nil
	case "pipeline-error-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401Unauthorized, nil
	case "pipeline-error-openai-401-incorrect-api-key":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401IncorrectApiKey, nil
	case "pipeline-error-openai-401-account-not-in-organization":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401AccountNotInOrganization, nil
	case "pipeline-error-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai403ModelAccessDenied, nil
	case "pipeline-error-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429ExceededQuota, nil
	case "pipeline-error-openai-429-rate-limit-reached":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429RateLimitReached, nil
	case "pipeline-error-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai500ServerError, nil
	case "pipeline-error-openai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai503ServerOverloadedError, nil
	case "pipeline-error-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai401Unauthorized, nil
	case "call.in-progress.error-vapifault-openai-401-incorrect-api-key":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai401IncorrectApiKey, nil
	case "call.in-progress.error-vapifault-openai-401-account-not-in-organization":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai401AccountNotInOrganization, nil
	case "call.in-progress.error-vapifault-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai429ExceededQuota, nil
	case "call.in-progress.error-vapifault-openai-429-rate-limit-reached":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenai429RateLimitReached, nil
	case "call.in-progress.error-providerfault-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenai500ServerError, nil
	case "call.in-progress.error-providerfault-openai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenai503ServerOverloadedError, nil
	case "pipeline-error-azure-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-azure-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai401Unauthorized, nil
	case "pipeline-error-azure-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied, nil
	case "pipeline-error-azure-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai429ExceededQuota, nil
	case "pipeline-error-azure-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai500ServerError, nil
	case "pipeline-error-azure-openai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai503ServerOverloadedError, nil
	case "pipeline-error-azure-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenaiLlmFailed, nil
	case "call.in-progress.error-vapifault-azure-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-azure-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai401Unauthorized, nil
	case "call.in-progress.error-vapifault-azure-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-azure-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAzureOpenai429ExceededQuota, nil
	case "call.in-progress.error-providerfault-azure-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAzureOpenai500ServerError, nil
	case "call.in-progress.error-providerfault-azure-openai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAzureOpenai503ServerOverloadedError, nil
	case "pipeline-error-google-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle400BadRequestValidationFailed, nil
	case "pipeline-error-google-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle401Unauthorized, nil
	case "pipeline-error-google-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle403ModelAccessDenied, nil
	case "pipeline-error-google-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle429ExceededQuota, nil
	case "pipeline-error-google-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle500ServerError, nil
	case "pipeline-error-google-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle503ServerOverloadedError, nil
	case "pipeline-error-google-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogleLlmFailed, nil
	case "call.in-progress.error-vapifault-google-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-google-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle401Unauthorized, nil
	case "call.in-progress.error-vapifault-google-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-google-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogle429ExceededQuota, nil
	case "call.in-progress.error-providerfault-google-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGoogle500ServerError, nil
	case "call.in-progress.error-providerfault-google-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGoogle503ServerOverloadedError, nil
	case "pipeline-error-xai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai400BadRequestValidationFailed, nil
	case "pipeline-error-xai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai401Unauthorized, nil
	case "pipeline-error-xai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai403ModelAccessDenied, nil
	case "pipeline-error-xai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai429ExceededQuota, nil
	case "pipeline-error-xai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai500ServerError, nil
	case "pipeline-error-xai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai503ServerOverloadedError, nil
	case "pipeline-error-xai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXaiLlmFailed, nil
	case "call.in-progress.error-vapifault-xai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-xai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai401Unauthorized, nil
	case "call.in-progress.error-vapifault-xai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-xai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultXai429ExceededQuota, nil
	case "call.in-progress.error-providerfault-xai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultXai500ServerError, nil
	case "call.in-progress.error-providerfault-xai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultXai503ServerOverloadedError, nil
	case "pipeline-error-mistral-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorMistral400BadRequestValidationFailed, nil
	case "pipeline-error-mistral-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorMistral401Unauthorized, nil
	case "pipeline-error-mistral-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorMistral403ModelAccessDenied, nil
	case "pipeline-error-mistral-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorMistral429ExceededQuota, nil
	case "pipeline-error-mistral-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorMistral500ServerError, nil
	case "pipeline-error-mistral-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorMistral503ServerOverloadedError, nil
	case "pipeline-error-mistral-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorMistralLlmFailed, nil
	case "call.in-progress.error-vapifault-mistral-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-mistral-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral401Unauthorized, nil
	case "call.in-progress.error-vapifault-mistral-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-mistral-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultMistral429ExceededQuota, nil
	case "call.in-progress.error-providerfault-mistral-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultMistral500ServerError, nil
	case "call.in-progress.error-providerfault-mistral-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultMistral503ServerOverloadedError, nil
	case "pipeline-error-inflection-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed, nil
	case "pipeline-error-inflection-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi401Unauthorized, nil
	case "pipeline-error-inflection-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi403ModelAccessDenied, nil
	case "pipeline-error-inflection-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi429ExceededQuota, nil
	case "pipeline-error-inflection-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi500ServerError, nil
	case "pipeline-error-inflection-ai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi503ServerOverloadedError, nil
	case "pipeline-error-inflection-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAiLlmFailed, nil
	case "call.in-progress.error-vapifault-inflection-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-inflection-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi401Unauthorized, nil
	case "call.in-progress.error-vapifault-inflection-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-inflection-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultInflectionAi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-inflection-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultInflectionAi500ServerError, nil
	case "call.in-progress.error-providerfault-inflection-ai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultInflectionAi503ServerOverloadedError, nil
	case "pipeline-error-deep-seek-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed, nil
	case "pipeline-error-deep-seek-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek401Unauthorized, nil
	case "pipeline-error-deep-seek-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek403ModelAccessDenied, nil
	case "pipeline-error-deep-seek-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek429ExceededQuota, nil
	case "pipeline-error-deep-seek-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek500ServerError, nil
	case "pipeline-error-deep-seek-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek503ServerOverloadedError, nil
	case "pipeline-error-deep-seek-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeekLlmFailed, nil
	case "call.in-progress.error-vapifault-deep-seek-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-deep-seek-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek401Unauthorized, nil
	case "call.in-progress.error-vapifault-deep-seek-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-deep-seek-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepSeek429ExceededQuota, nil
	case "call.in-progress.error-providerfault-deep-seek-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepSeek500ServerError, nil
	case "call.in-progress.error-providerfault-deep-seek-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepSeek503ServerOverloadedError, nil
	case "pipeline-error-groq-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq400BadRequestValidationFailed, nil
	case "pipeline-error-groq-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq401Unauthorized, nil
	case "pipeline-error-groq-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq403ModelAccessDenied, nil
	case "pipeline-error-groq-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq429ExceededQuota, nil
	case "pipeline-error-groq-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq500ServerError, nil
	case "pipeline-error-groq-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq503ServerOverloadedError, nil
	case "pipeline-error-groq-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroqLlmFailed, nil
	case "call.in-progress.error-vapifault-groq-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-groq-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq401Unauthorized, nil
	case "call.in-progress.error-vapifault-groq-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-groq-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGroq429ExceededQuota, nil
	case "call.in-progress.error-providerfault-groq-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGroq500ServerError, nil
	case "call.in-progress.error-providerfault-groq-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultGroq503ServerOverloadedError, nil
	case "pipeline-error-cerebras-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras400BadRequestValidationFailed, nil
	case "pipeline-error-cerebras-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras401Unauthorized, nil
	case "pipeline-error-cerebras-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras403ModelAccessDenied, nil
	case "pipeline-error-cerebras-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras429ExceededQuota, nil
	case "pipeline-error-cerebras-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras500ServerError, nil
	case "pipeline-error-cerebras-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras503ServerOverloadedError, nil
	case "pipeline-error-cerebras-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebrasLlmFailed, nil
	case "call.in-progress.error-vapifault-cerebras-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-cerebras-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras401Unauthorized, nil
	case "call.in-progress.error-vapifault-cerebras-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-cerebras-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCerebras429ExceededQuota, nil
	case "call.in-progress.error-providerfault-cerebras-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCerebras500ServerError, nil
	case "call.in-progress.error-providerfault-cerebras-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCerebras503ServerOverloadedError, nil
	case "pipeline-error-anthropic-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic401Unauthorized, nil
	case "pipeline-error-anthropic-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic403ModelAccessDenied, nil
	case "pipeline-error-anthropic-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic429ExceededQuota, nil
	case "pipeline-error-anthropic-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic500ServerError, nil
	case "pipeline-error-anthropic-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic503ServerOverloadedError, nil
	case "pipeline-error-anthropic-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anthropic-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic401Unauthorized, nil
	case "call.in-progress.error-vapifault-anthropic-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anthropic-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropic429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anthropic-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropic500ServerError, nil
	case "call.in-progress.error-providerfault-anthropic-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropic503ServerOverloadedError, nil
	case "pipeline-error-anthropic-bedrock-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-bedrock-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock401Unauthorized, nil
	case "pipeline-error-anthropic-bedrock-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock403ModelAccessDenied, nil
	case "pipeline-error-anthropic-bedrock-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock429ExceededQuota, nil
	case "pipeline-error-anthropic-bedrock-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock500ServerError, nil
	case "pipeline-error-anthropic-bedrock-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrock503ServerOverloadedError, nil
	case "pipeline-error-anthropic-bedrock-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicBedrockLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrockLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock401Unauthorized, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anthropic-bedrock-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicBedrock429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anthropic-bedrock-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock500ServerError, nil
	case "call.in-progress.error-providerfault-anthropic-bedrock-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicBedrock503ServerOverloadedError, nil
	case "pipeline-error-anthropic-vertex-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-vertex-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex401Unauthorized, nil
	case "pipeline-error-anthropic-vertex-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex403ModelAccessDenied, nil
	case "pipeline-error-anthropic-vertex-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex429ExceededQuota, nil
	case "pipeline-error-anthropic-vertex-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex500ServerError, nil
	case "pipeline-error-anthropic-vertex-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertex503ServerOverloadedError, nil
	case "pipeline-error-anthropic-vertex-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicVertexLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertexLlmFailed, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex401Unauthorized, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anthropic-vertex-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnthropicVertex429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anthropic-vertex-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicVertex500ServerError, nil
	case "call.in-progress.error-providerfault-anthropic-vertex-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnthropicVertex503ServerOverloadedError, nil
	case "pipeline-error-together-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed, nil
	case "pipeline-error-together-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi401Unauthorized, nil
	case "pipeline-error-together-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi403ModelAccessDenied, nil
	case "pipeline-error-together-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi429ExceededQuota, nil
	case "pipeline-error-together-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi500ServerError, nil
	case "pipeline-error-together-ai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi503ServerOverloadedError, nil
	case "pipeline-error-together-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAiLlmFailed, nil
	case "call.in-progress.error-vapifault-together-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAiLlmFailed, nil
	case "call.in-progress.error-vapifault-together-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-together-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi401Unauthorized, nil
	case "call.in-progress.error-vapifault-together-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-together-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultTogetherAi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-together-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultTogetherAi500ServerError, nil
	case "call.in-progress.error-providerfault-together-ai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultTogetherAi503ServerOverloadedError, nil
	case "pipeline-error-anyscale-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed, nil
	case "pipeline-error-anyscale-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale401Unauthorized, nil
	case "pipeline-error-anyscale-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale403ModelAccessDenied, nil
	case "pipeline-error-anyscale-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale429ExceededQuota, nil
	case "pipeline-error-anyscale-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale500ServerError, nil
	case "pipeline-error-anyscale-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale503ServerOverloadedError, nil
	case "pipeline-error-anyscale-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscaleLlmFailed, nil
	case "call.in-progress.error-vapifault-anyscale-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscaleLlmFailed, nil
	case "call.in-progress.error-vapifault-anyscale-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-anyscale-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale401Unauthorized, nil
	case "call.in-progress.error-vapifault-anyscale-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-anyscale-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultAnyscale429ExceededQuota, nil
	case "call.in-progress.error-providerfault-anyscale-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnyscale500ServerError, nil
	case "call.in-progress.error-providerfault-anyscale-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultAnyscale503ServerOverloadedError, nil
	case "pipeline-error-openrouter-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed, nil
	case "pipeline-error-openrouter-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter401Unauthorized, nil
	case "pipeline-error-openrouter-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter403ModelAccessDenied, nil
	case "pipeline-error-openrouter-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter429ExceededQuota, nil
	case "pipeline-error-openrouter-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter500ServerError, nil
	case "pipeline-error-openrouter-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter503ServerOverloadedError, nil
	case "pipeline-error-openrouter-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouterLlmFailed, nil
	case "call.in-progress.error-vapifault-openrouter-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouterLlmFailed, nil
	case "call.in-progress.error-vapifault-openrouter-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-openrouter-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter401Unauthorized, nil
	case "call.in-progress.error-vapifault-openrouter-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-openrouter-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenrouter429ExceededQuota, nil
	case "call.in-progress.error-providerfault-openrouter-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenrouter500ServerError, nil
	case "call.in-progress.error-providerfault-openrouter-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultOpenrouter503ServerOverloadedError, nil
	case "pipeline-error-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed, nil
	case "pipeline-error-perplexity-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi401Unauthorized, nil
	case "pipeline-error-perplexity-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied, nil
	case "pipeline-error-perplexity-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi429ExceededQuota, nil
	case "pipeline-error-perplexity-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi500ServerError, nil
	case "pipeline-error-perplexity-ai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi503ServerOverloadedError, nil
	case "pipeline-error-perplexity-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAiLlmFailed, nil
	case "call.in-progress.error-vapifault-perplexity-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAiLlmFailed, nil
	case "call.in-progress.error-vapifault-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-perplexity-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi401Unauthorized, nil
	case "call.in-progress.error-vapifault-perplexity-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-perplexity-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPerplexityAi429ExceededQuota, nil
	case "call.in-progress.error-providerfault-perplexity-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPerplexityAi500ServerError, nil
	case "call.in-progress.error-providerfault-perplexity-ai-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPerplexityAi503ServerOverloadedError, nil
	case "pipeline-error-deepinfra-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed, nil
	case "pipeline-error-deepinfra-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra401Unauthorized, nil
	case "pipeline-error-deepinfra-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra403ModelAccessDenied, nil
	case "pipeline-error-deepinfra-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra429ExceededQuota, nil
	case "pipeline-error-deepinfra-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra500ServerError, nil
	case "pipeline-error-deepinfra-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra503ServerOverloadedError, nil
	case "pipeline-error-deepinfra-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfraLlmFailed, nil
	case "call.in-progress.error-vapifault-deepinfra-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfraLlmFailed, nil
	case "call.in-progress.error-vapifault-deepinfra-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-deepinfra-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra401Unauthorized, nil
	case "call.in-progress.error-vapifault-deepinfra-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-deepinfra-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepinfra429ExceededQuota, nil
	case "call.in-progress.error-providerfault-deepinfra-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepinfra500ServerError, nil
	case "call.in-progress.error-providerfault-deepinfra-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepinfra503ServerOverloadedError, nil
	case "pipeline-error-runpod-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod400BadRequestValidationFailed, nil
	case "pipeline-error-runpod-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod401Unauthorized, nil
	case "pipeline-error-runpod-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod403ModelAccessDenied, nil
	case "pipeline-error-runpod-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod429ExceededQuota, nil
	case "pipeline-error-runpod-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod500ServerError, nil
	case "pipeline-error-runpod-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod503ServerOverloadedError, nil
	case "pipeline-error-runpod-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpodLlmFailed, nil
	case "call.in-progress.error-vapifault-runpod-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpodLlmFailed, nil
	case "call.in-progress.error-vapifault-runpod-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-runpod-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod401Unauthorized, nil
	case "call.in-progress.error-vapifault-runpod-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-runpod-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultRunpod429ExceededQuota, nil
	case "call.in-progress.error-providerfault-runpod-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultRunpod500ServerError, nil
	case "call.in-progress.error-providerfault-runpod-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultRunpod503ServerOverloadedError, nil
	case "pipeline-error-custom-llm-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed, nil
	case "pipeline-error-custom-llm-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm401Unauthorized, nil
	case "pipeline-error-custom-llm-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm403ModelAccessDenied, nil
	case "pipeline-error-custom-llm-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm429ExceededQuota, nil
	case "pipeline-error-custom-llm-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm500ServerError, nil
	case "pipeline-error-custom-llm-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm503ServerOverloadedError, nil
	case "pipeline-error-custom-llm-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlmLlmFailed, nil
	case "call.in-progress.error-vapifault-custom-llm-llm-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlmLlmFailed, nil
	case "call.in-progress.error-vapifault-custom-llm-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm400BadRequestValidationFailed, nil
	case "call.in-progress.error-vapifault-custom-llm-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm401Unauthorized, nil
	case "call.in-progress.error-vapifault-custom-llm-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm403ModelAccessDenied, nil
	case "call.in-progress.error-vapifault-custom-llm-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomLlm429ExceededQuota, nil
	case "call.in-progress.error-providerfault-custom-llm-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCustomLlm500ServerError, nil
	case "call.in-progress.error-providerfault-custom-llm-503-server-overloaded-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCustomLlm503ServerOverloadedError, nil
	case "pipeline-error-custom-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomVoiceFailed, nil
	case "pipeline-error-cartesia-socket-hang-up":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaSocketHangUp, nil
	case "pipeline-error-cartesia-requested-payment":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaRequestedPayment, nil
	case "pipeline-error-cartesia-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia500ServerError, nil
	case "pipeline-error-cartesia-503-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia503ServerError, nil
	case "pipeline-error-cartesia-522-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia522ServerError, nil
	case "call.in-progress.error-vapifault-cartesia-socket-hang-up":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCartesiaSocketHangUp, nil
	case "call.in-progress.error-vapifault-cartesia-requested-payment":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCartesiaRequestedPayment, nil
	case "call.in-progress.error-providerfault-cartesia-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCartesia500ServerError, nil
	case "call.in-progress.error-providerfault-cartesia-503-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCartesia503ServerError, nil
	case "call.in-progress.error-providerfault-cartesia-522-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultCartesia522ServerError, nil
	case "pipeline-error-eleven-labs-voice-not-found":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFound, nil
	case "pipeline-error-eleven-labs-quota-exceeded":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsQuotaExceeded, nil
	case "pipeline-error-eleven-labs-unauthorized-access":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedAccess, nil
	case "pipeline-error-eleven-labs-unauthorized-to-access-model":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel, nil
	case "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned, nil
	case "pipeline-error-eleven-labs-invalid-api-key":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidApiKey, nil
	case "pipeline-error-eleven-labs-invalid-voice-samples":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples, nil
	case "pipeline-error-eleven-labs-voice-disabled-by-owner":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner, nil
	case "pipeline-error-eleven-labs-blocked-account-in-probation":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation, nil
	case "pipeline-error-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "pipeline-error-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "pipeline-error-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "pipeline-error-eleven-labs-max-character-limit-exceeded":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded, nil
	case "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification, nil
	case "pipeline-error-eleven-labs-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabs500ServerError, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-found":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFound, nil
	case "call.in-progress.error-vapifault-eleven-labs-quota-exceeded":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsQuotaExceeded, nil
	case "call.in-progress.error-vapifault-eleven-labs-unauthorized-access":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedAccess, nil
	case "call.in-progress.error-vapifault-eleven-labs-unauthorized-to-access-model":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsUnauthorizedToAccessModel, nil
	case "call.in-progress.error-vapifault-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTuned, nil
	case "call.in-progress.error-vapifault-eleven-labs-invalid-api-key":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidApiKey, nil
	case "call.in-progress.error-vapifault-eleven-labs-invalid-voice-samples":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsInvalidVoiceSamples, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-disabled-by-owner":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceDisabledByOwner, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-account-in-probation":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedAccountInProbation, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "call.in-progress.error-vapifault-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsMissingSamplesForVoiceClone, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "call.in-progress.error-vapifault-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "call.in-progress.error-vapifault-eleven-labs-max-character-limit-exceeded":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsMaxCharacterLimitExceeded, nil
	case "call.in-progress.error-vapifault-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification, nil
	case "call.in-progress.error-providerfault-eleven-labs-500-server-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultElevenLabs500ServerError, nil
	case "pipeline-error-playht-request-timed-out":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtRequestTimedOut, nil
	case "pipeline-error-playht-invalid-voice":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidVoice, nil
	case "pipeline-error-playht-unexpected-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtUnexpectedError, nil
	case "pipeline-error-playht-out-of-credits":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtOutOfCredits, nil
	case "pipeline-error-playht-invalid-emotion":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidEmotion, nil
	case "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "pipeline-error-playht-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht401Unauthorized, nil
	case "pipeline-error-playht-403-forbidden-out-of-characters":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters, nil
	case "pipeline-error-playht-403-forbidden-api-access-not-available":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable, nil
	case "pipeline-error-playht-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht429ExceededQuota, nil
	case "pipeline-error-playht-502-gateway-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht502GatewayError, nil
	case "pipeline-error-playht-504-gateway-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht504GatewayError, nil
	case "call.in-progress.error-vapifault-playht-request-timed-out":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtRequestTimedOut, nil
	case "call.in-progress.error-vapifault-playht-invalid-voice":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtInvalidVoice, nil
	case "call.in-progress.error-vapifault-playht-unexpected-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtUnexpectedError, nil
	case "call.in-progress.error-vapifault-playht-out-of-credits":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtOutOfCredits, nil
	case "call.in-progress.error-vapifault-playht-invalid-emotion":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtInvalidEmotion, nil
	case "call.in-progress.error-vapifault-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "call.in-progress.error-vapifault-playht-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht401Unauthorized, nil
	case "call.in-progress.error-vapifault-playht-403-forbidden-out-of-characters":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenOutOfCharacters, nil
	case "call.in-progress.error-vapifault-playht-403-forbidden-api-access-not-available":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht403ForbiddenApiAccessNotAvailable, nil
	case "call.in-progress.error-vapifault-playht-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultPlayht429ExceededQuota, nil
	case "call.in-progress.error-providerfault-playht-502-gateway-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPlayht502GatewayError, nil
	case "call.in-progress.error-providerfault-playht-504-gateway-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultPlayht504GatewayError, nil
	case "pipeline-error-custom-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomTranscriberFailed, nil
	case "call.in-progress.error-vapifault-custom-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultCustomTranscriberFailed, nil
	case "pipeline-error-eleven-labs-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsTranscriberFailed, nil
	case "call.in-progress.error-vapifault-eleven-labs-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultElevenLabsTranscriberFailed, nil
	case "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination, nil
	case "pipeline-error-deepgram-returning-401-invalid-credentials":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials, nil
	case "pipeline-error-deepgram-returning-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied, nil
	case "pipeline-error-deepgram-returning-404-not-found":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning404NotFound, nil
	case "pipeline-error-deepgram-returning-500-invalid-json":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning500InvalidJson, nil
	case "pipeline-error-deepgram-returning-502-network-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502NetworkError, nil
	case "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach, nil
	case "call.in-progress.error-vapifault-deepgram-returning-400-no-such-model-language-tier-combination":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning400NoSuchModelLanguageTierCombination, nil
	case "call.in-progress.error-vapifault-deepgram-returning-401-invalid-credentials":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning401InvalidCredentials, nil
	case "call.in-progress.error-vapifault-deepgram-returning-404-not-found":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning404NotFound, nil
	case "call.in-progress.error-vapifault-deepgram-returning-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultDeepgramReturning403ModelAccessDenied, nil
	case "call.in-progress.error-providerfault-deepgram-returning-500-invalid-json":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepgramReturning500InvalidJson, nil
	case "call.in-progress.error-providerfault-deepgram-returning-502-network-error":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502NetworkError, nil
	case "call.in-progress.error-providerfault-deepgram-returning-502-bad-gateway-ehostunreach":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorProviderfaultDeepgramReturning502BadGatewayEhostunreach, nil
	case "pipeline-error-google-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogleTranscriberFailed, nil
	case "call.in-progress.error-vapifault-google-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultGoogleTranscriberFailed, nil
	case "pipeline-error-openai-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiTranscriberFailed, nil
	case "call.in-progress.error-vapifault-openai-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorVapifaultOpenaiTranscriberFailed, nil
	case "assistant-ended-call":
		return ServerMessageStatusUpdateEndedReasonAssistantEndedCall, nil
	case "assistant-said-end-call-phrase":
		return ServerMessageStatusUpdateEndedReasonAssistantSaidEndCallPhrase, nil
	case "assistant-ended-call-with-hangup-task":
		return ServerMessageStatusUpdateEndedReasonAssistantEndedCallWithHangupTask, nil
	case "assistant-ended-call-after-message-spoken":
		return ServerMessageStatusUpdateEndedReasonAssistantEndedCallAfterMessageSpoken, nil
	case "assistant-forwarded-call":
		return ServerMessageStatusUpdateEndedReasonAssistantForwardedCall, nil
	case "assistant-join-timed-out":
		return ServerMessageStatusUpdateEndedReasonAssistantJoinTimedOut, nil
	case "call.in-progress.error-assistant-did-not-receive-customer-audio":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorAssistantDidNotReceiveCustomerAudio, nil
	case "customer-busy":
		return ServerMessageStatusUpdateEndedReasonCustomerBusy, nil
	case "customer-ended-call":
		return ServerMessageStatusUpdateEndedReasonCustomerEndedCall, nil
	case "customer-did-not-answer":
		return ServerMessageStatusUpdateEndedReasonCustomerDidNotAnswer, nil
	case "customer-did-not-give-microphone-permission":
		return ServerMessageStatusUpdateEndedReasonCustomerDidNotGiveMicrophonePermission, nil
	case "exceeded-max-duration":
		return ServerMessageStatusUpdateEndedReasonExceededMaxDuration, nil
	case "manually-canceled":
		return ServerMessageStatusUpdateEndedReasonManuallyCanceled, nil
	case "phone-call-provider-closed-websocket":
		return ServerMessageStatusUpdateEndedReasonPhoneCallProviderClosedWebsocket, nil
	case "call.forwarding.operator-busy":
		return ServerMessageStatusUpdateEndedReasonCallForwardingOperatorBusy, nil
	case "silence-timed-out":
		return ServerMessageStatusUpdateEndedReasonSilenceTimedOut, nil
	case "call.in-progress.error-sip-telephony-provider-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonCallInProgressErrorSipTelephonyProviderFailedToConnectCall, nil
	case "call.ringing.hook-executed-say":
		return ServerMessageStatusUpdateEndedReasonCallRingingHookExecutedSay, nil
	case "call.ringing.hook-executed-transfer":
		return ServerMessageStatusUpdateEndedReasonCallRingingHookExecutedTransfer, nil
	case "twilio-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonTwilioFailedToConnectCall, nil
	case "twilio-reported-customer-misdialed":
		return ServerMessageStatusUpdateEndedReasonTwilioReportedCustomerMisdialed, nil
	case "vonage-rejected":
		return ServerMessageStatusUpdateEndedReasonVonageRejected, nil
	case "voicemail":
		return ServerMessageStatusUpdateEndedReasonVoicemail, nil
	}
	var t ServerMessageStatusUpdateEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageStatusUpdateEndedReason) Ptr() *ServerMessageStatusUpdateEndedReason {
	return &s
}

type ServerMessageStatusUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (s *ServerMessageStatusUpdateMessagesItem) GetUserMessage() *UserMessage {
	if s == nil {
		return nil
	}
	return s.UserMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetSystemMessage() *SystemMessage {
	if s == nil {
		return nil
	}
	return s.SystemMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetBotMessage() *BotMessage {
	if s == nil {
		return nil
	}
	return s.BotMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallResultMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.typ = "UserMessage"
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.typ = "SystemMessage"
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.typ = "BotMessage"
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.typ = "ToolCallMessage"
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.typ = "ToolCallResultMessage"
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageStatusUpdateMessagesItem) Accept(visitor ServerMessageStatusUpdateMessagesItemVisitor) error {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number that the message is associated with.
type ServerMessageStatusUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageStatusUpdatePhoneNumber) Accept(visitor ServerMessageStatusUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the status of the call.
type ServerMessageStatusUpdateStatus string

const (
	ServerMessageStatusUpdateStatusScheduled  ServerMessageStatusUpdateStatus = "scheduled"
	ServerMessageStatusUpdateStatusQueued     ServerMessageStatusUpdateStatus = "queued"
	ServerMessageStatusUpdateStatusRinging    ServerMessageStatusUpdateStatus = "ringing"
	ServerMessageStatusUpdateStatusInProgress ServerMessageStatusUpdateStatus = "in-progress"
	ServerMessageStatusUpdateStatusForwarding ServerMessageStatusUpdateStatus = "forwarding"
	ServerMessageStatusUpdateStatusEnded      ServerMessageStatusUpdateStatus = "ended"
)

func NewServerMessageStatusUpdateStatusFromString(s string) (ServerMessageStatusUpdateStatus, error) {
	switch s {
	case "scheduled":
		return ServerMessageStatusUpdateStatusScheduled, nil
	case "queued":
		return ServerMessageStatusUpdateStatusQueued, nil
	case "ringing":
		return ServerMessageStatusUpdateStatusRinging, nil
	case "in-progress":
		return ServerMessageStatusUpdateStatusInProgress, nil
	case "forwarding":
		return ServerMessageStatusUpdateStatusForwarding, nil
	case "ended":
		return ServerMessageStatusUpdateStatusEnded, nil
	}
	var t ServerMessageStatusUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageStatusUpdateStatus) Ptr() *ServerMessageStatusUpdateStatus {
	return &s
}

type ServerMessageToolCalls struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageToolCallsPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "tool-calls" is sent to call a tool.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the list of tools calls that the model is requesting along with the original tool configuration.
	ToolWithToolCallList []*ServerMessageToolCallsToolWithToolCallListItem `json:"toolWithToolCallList,omitempty" url:"toolWithToolCallList,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the list of tool calls that the model is requesting.
	ToolCallList []*ToolCall `json:"toolCallList,omitempty" url:"toolCallList,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageToolCalls) GetPhoneNumber() *ServerMessageToolCallsPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageToolCalls) GetToolWithToolCallList() []*ServerMessageToolCallsToolWithToolCallListItem {
	if s == nil {
		return nil
	}
	return s.ToolWithToolCallList
}

func (s *ServerMessageToolCalls) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageToolCalls) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageToolCalls) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageToolCalls) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageToolCalls) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageToolCalls) GetToolCallList() []*ToolCall {
	if s == nil {
		return nil
	}
	return s.ToolCallList
}

func (s *ServerMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageToolCalls) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageToolCallsPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageToolCallsPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageToolCallsPhoneNumber) Accept(visitor ServerMessageToolCallsPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsToolWithToolCallListItem struct {
	FunctionToolWithToolCall                  *FunctionToolWithToolCall
	GhlToolWithToolCall                       *GhlToolWithToolCall
	MakeToolWithToolCall                      *MakeToolWithToolCall
	BashToolWithToolCall                      *BashToolWithToolCall
	ComputerToolWithToolCall                  *ComputerToolWithToolCall
	TextEditorToolWithToolCall                *TextEditorToolWithToolCall
	GoogleCalendarCreateEventToolWithToolCall *GoogleCalendarCreateEventToolWithToolCall

	typ string
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetFunctionToolWithToolCall() *FunctionToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.FunctionToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetGhlToolWithToolCall() *GhlToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.GhlToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetMakeToolWithToolCall() *MakeToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.MakeToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetBashToolWithToolCall() *BashToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.BashToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetComputerToolWithToolCall() *ComputerToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.ComputerToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetTextEditorToolWithToolCall() *TextEditorToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.TextEditorToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetGoogleCalendarCreateEventToolWithToolCall() *GoogleCalendarCreateEventToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.GoogleCalendarCreateEventToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) UnmarshalJSON(data []byte) error {
	valueFunctionToolWithToolCall := new(FunctionToolWithToolCall)
	if err := json.Unmarshal(data, &valueFunctionToolWithToolCall); err == nil {
		s.typ = "FunctionToolWithToolCall"
		s.FunctionToolWithToolCall = valueFunctionToolWithToolCall
		return nil
	}
	valueGhlToolWithToolCall := new(GhlToolWithToolCall)
	if err := json.Unmarshal(data, &valueGhlToolWithToolCall); err == nil {
		s.typ = "GhlToolWithToolCall"
		s.GhlToolWithToolCall = valueGhlToolWithToolCall
		return nil
	}
	valueMakeToolWithToolCall := new(MakeToolWithToolCall)
	if err := json.Unmarshal(data, &valueMakeToolWithToolCall); err == nil {
		s.typ = "MakeToolWithToolCall"
		s.MakeToolWithToolCall = valueMakeToolWithToolCall
		return nil
	}
	valueBashToolWithToolCall := new(BashToolWithToolCall)
	if err := json.Unmarshal(data, &valueBashToolWithToolCall); err == nil {
		s.typ = "BashToolWithToolCall"
		s.BashToolWithToolCall = valueBashToolWithToolCall
		return nil
	}
	valueComputerToolWithToolCall := new(ComputerToolWithToolCall)
	if err := json.Unmarshal(data, &valueComputerToolWithToolCall); err == nil {
		s.typ = "ComputerToolWithToolCall"
		s.ComputerToolWithToolCall = valueComputerToolWithToolCall
		return nil
	}
	valueTextEditorToolWithToolCall := new(TextEditorToolWithToolCall)
	if err := json.Unmarshal(data, &valueTextEditorToolWithToolCall); err == nil {
		s.typ = "TextEditorToolWithToolCall"
		s.TextEditorToolWithToolCall = valueTextEditorToolWithToolCall
		return nil
	}
	valueGoogleCalendarCreateEventToolWithToolCall := new(GoogleCalendarCreateEventToolWithToolCall)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventToolWithToolCall); err == nil {
		s.typ = "GoogleCalendarCreateEventToolWithToolCall"
		s.GoogleCalendarCreateEventToolWithToolCall = valueGoogleCalendarCreateEventToolWithToolCall
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageToolCallsToolWithToolCallListItem) MarshalJSON() ([]byte, error) {
	if s.typ == "FunctionToolWithToolCall" || s.FunctionToolWithToolCall != nil {
		return json.Marshal(s.FunctionToolWithToolCall)
	}
	if s.typ == "GhlToolWithToolCall" || s.GhlToolWithToolCall != nil {
		return json.Marshal(s.GhlToolWithToolCall)
	}
	if s.typ == "MakeToolWithToolCall" || s.MakeToolWithToolCall != nil {
		return json.Marshal(s.MakeToolWithToolCall)
	}
	if s.typ == "BashToolWithToolCall" || s.BashToolWithToolCall != nil {
		return json.Marshal(s.BashToolWithToolCall)
	}
	if s.typ == "ComputerToolWithToolCall" || s.ComputerToolWithToolCall != nil {
		return json.Marshal(s.ComputerToolWithToolCall)
	}
	if s.typ == "TextEditorToolWithToolCall" || s.TextEditorToolWithToolCall != nil {
		return json.Marshal(s.TextEditorToolWithToolCall)
	}
	if s.typ == "GoogleCalendarCreateEventToolWithToolCall" || s.GoogleCalendarCreateEventToolWithToolCall != nil {
		return json.Marshal(s.GoogleCalendarCreateEventToolWithToolCall)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsToolWithToolCallListItemVisitor interface {
	VisitFunctionToolWithToolCall(*FunctionToolWithToolCall) error
	VisitGhlToolWithToolCall(*GhlToolWithToolCall) error
	VisitMakeToolWithToolCall(*MakeToolWithToolCall) error
	VisitBashToolWithToolCall(*BashToolWithToolCall) error
	VisitComputerToolWithToolCall(*ComputerToolWithToolCall) error
	VisitTextEditorToolWithToolCall(*TextEditorToolWithToolCall) error
	VisitGoogleCalendarCreateEventToolWithToolCall(*GoogleCalendarCreateEventToolWithToolCall) error
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) Accept(visitor ServerMessageToolCallsToolWithToolCallListItemVisitor) error {
	if s.typ == "FunctionToolWithToolCall" || s.FunctionToolWithToolCall != nil {
		return visitor.VisitFunctionToolWithToolCall(s.FunctionToolWithToolCall)
	}
	if s.typ == "GhlToolWithToolCall" || s.GhlToolWithToolCall != nil {
		return visitor.VisitGhlToolWithToolCall(s.GhlToolWithToolCall)
	}
	if s.typ == "MakeToolWithToolCall" || s.MakeToolWithToolCall != nil {
		return visitor.VisitMakeToolWithToolCall(s.MakeToolWithToolCall)
	}
	if s.typ == "BashToolWithToolCall" || s.BashToolWithToolCall != nil {
		return visitor.VisitBashToolWithToolCall(s.BashToolWithToolCall)
	}
	if s.typ == "ComputerToolWithToolCall" || s.ComputerToolWithToolCall != nil {
		return visitor.VisitComputerToolWithToolCall(s.ComputerToolWithToolCall)
	}
	if s.typ == "TextEditorToolWithToolCall" || s.TextEditorToolWithToolCall != nil {
		return visitor.VisitTextEditorToolWithToolCall(s.TextEditorToolWithToolCall)
	}
	if s.typ == "GoogleCalendarCreateEventToolWithToolCall" || s.GoogleCalendarCreateEventToolWithToolCall != nil {
		return visitor.VisitGoogleCalendarCreateEventToolWithToolCall(s.GoogleCalendarCreateEventToolWithToolCall)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTranscript struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageTranscriptPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
	Type ServerMessageTranscriptType `json:"type" url:"type"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the role for which the transcript is for.
	Role ServerMessageTranscriptRole `json:"role" url:"role"`
	// This is the type of the transcript.
	TranscriptType ServerMessageTranscriptTranscriptType `json:"transcriptType" url:"transcriptType"`
	// This is the transcript content.
	Transcript string `json:"transcript" url:"transcript"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageTranscript) GetPhoneNumber() *ServerMessageTranscriptPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageTranscript) GetType() ServerMessageTranscriptType {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *ServerMessageTranscript) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageTranscript) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageTranscript) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageTranscript) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageTranscript) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageTranscript) GetRole() ServerMessageTranscriptRole {
	if s == nil {
		return ""
	}
	return s.Role
}

func (s *ServerMessageTranscript) GetTranscriptType() ServerMessageTranscriptTranscriptType {
	if s == nil {
		return ""
	}
	return s.TranscriptType
}

func (s *ServerMessageTranscript) GetTranscript() string {
	if s == nil {
		return ""
	}
	return s.Transcript
}

func (s *ServerMessageTranscript) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTranscript) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageTranscript
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageTranscript(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTranscript) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageTranscriptPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTranscriptPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTranscriptPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageTranscriptPhoneNumber) Accept(visitor ServerMessageTranscriptPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the role for which the transcript is for.
type ServerMessageTranscriptRole string

const (
	ServerMessageTranscriptRoleAssistant ServerMessageTranscriptRole = "assistant"
	ServerMessageTranscriptRoleUser      ServerMessageTranscriptRole = "user"
)

func NewServerMessageTranscriptRoleFromString(s string) (ServerMessageTranscriptRole, error) {
	switch s {
	case "assistant":
		return ServerMessageTranscriptRoleAssistant, nil
	case "user":
		return ServerMessageTranscriptRoleUser, nil
	}
	var t ServerMessageTranscriptRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageTranscriptRole) Ptr() *ServerMessageTranscriptRole {
	return &s
}

// This is the type of the transcript.
type ServerMessageTranscriptTranscriptType string

const (
	ServerMessageTranscriptTranscriptTypePartial ServerMessageTranscriptTranscriptType = "partial"
	ServerMessageTranscriptTranscriptTypeFinal   ServerMessageTranscriptTranscriptType = "final"
)

func NewServerMessageTranscriptTranscriptTypeFromString(s string) (ServerMessageTranscriptTranscriptType, error) {
	switch s {
	case "partial":
		return ServerMessageTranscriptTranscriptTypePartial, nil
	case "final":
		return ServerMessageTranscriptTranscriptTypeFinal, nil
	}
	var t ServerMessageTranscriptTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageTranscriptTranscriptType) Ptr() *ServerMessageTranscriptTranscriptType {
	return &s
}

// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
type ServerMessageTranscriptType string

const (
	ServerMessageTranscriptTypeTranscript                    ServerMessageTranscriptType = "transcript"
	ServerMessageTranscriptTypeTranscriptTranscriptTypeFinal ServerMessageTranscriptType = "transcript[transcriptType=\\\"final\\\"]"
)

func NewServerMessageTranscriptTypeFromString(s string) (ServerMessageTranscriptType, error) {
	switch s {
	case "transcript":
		return ServerMessageTranscriptTypeTranscript, nil
	case "transcript[transcriptType=\"final\"]":
		return ServerMessageTranscriptTypeTranscriptTranscriptTypeFinal, nil
	}
	var t ServerMessageTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageTranscriptType) Ptr() *ServerMessageTranscriptType {
	return &s
}

type ServerMessageTransferDestinationRequest struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageTransferDestinationRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transfer-destination-request" is sent when the model is requesting transfer but destination is unknown.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageTransferDestinationRequest) GetPhoneNumber() *ServerMessageTransferDestinationRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageTransferDestinationRequest) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageTransferDestinationRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageTransferDestinationRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageTransferDestinationRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageTransferDestinationRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageTransferDestinationRequest) Type() string {
	return s.type_
}

func (s *ServerMessageTransferDestinationRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTransferDestinationRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTransferDestinationRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTransferDestinationRequest(unmarshaler.embed)
	if unmarshaler.Type != "transfer-destination-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transfer-destination-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTransferDestinationRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTransferDestinationRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transfer-destination-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTransferDestinationRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageTransferDestinationRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferDestinationRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferDestinationRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) Accept(visitor ServerMessageTransferDestinationRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdate struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageTransferUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transfer-update" is sent whenever a transfer happens.
	// This is the destination of the transfer.
	Destination *ServerMessageTransferUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the assistant that the call is being transferred to. This is only sent if `destination.type` is "assistant".
	ToAssistant *CreateAssistantDto `json:"toAssistant,omitempty" url:"toAssistant,omitempty"`
	// This is the assistant that the call is being transferred from. This is only sent if `destination.type` is "assistant".
	FromAssistant *CreateAssistantDto `json:"fromAssistant,omitempty" url:"fromAssistant,omitempty"`
	// This is the step that the conversation moved to.
	ToStepRecord map[string]interface{} `json:"toStepRecord,omitempty" url:"toStepRecord,omitempty"`
	// This is the step that the conversation moved from. =
	FromStepRecord map[string]interface{} `json:"fromStepRecord,omitempty" url:"fromStepRecord,omitempty"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageTransferUpdate) GetPhoneNumber() *ServerMessageTransferUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageTransferUpdate) GetDestination() *ServerMessageTransferUpdateDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageTransferUpdate) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageTransferUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageTransferUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageTransferUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageTransferUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageTransferUpdate) GetToAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.ToAssistant
}

func (s *ServerMessageTransferUpdate) GetFromAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.FromAssistant
}

func (s *ServerMessageTransferUpdate) GetToStepRecord() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.ToStepRecord
}

func (s *ServerMessageTransferUpdate) GetFromStepRecord() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.FromStepRecord
}

func (s *ServerMessageTransferUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageTransferUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTransferUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTransferUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTransferUpdate(unmarshaler.embed)
	if unmarshaler.Type != "transfer-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transfer-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTransferUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTransferUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transfer-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTransferUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination of the transfer.
type ServerMessageTransferUpdateDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (s *ServerMessageTransferUpdateDestination) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if s == nil {
		return nil
	}
	return s.TransferDestinationAssistant
}

func (s *ServerMessageTransferUpdateDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageTransferUpdateDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageTransferUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		s.typ = "TransferDestinationAssistant"
		s.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferUpdateDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return json.Marshal(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdateDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageTransferUpdateDestination) Accept(visitor ServerMessageTransferUpdateDestinationVisitor) error {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number that the message is associated with.
type ServerMessageTransferUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageTransferUpdatePhoneNumber) Accept(visitor ServerMessageTransferUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageUserInterrupted struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageUserInterruptedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "user-interrupted" is sent when the user interrupts the assistant.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageUserInterrupted) GetPhoneNumber() *ServerMessageUserInterruptedPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageUserInterrupted) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageUserInterrupted) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageUserInterrupted) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageUserInterrupted) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageUserInterrupted) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageUserInterrupted) Type() string {
	return s.type_
}

func (s *ServerMessageUserInterrupted) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageUserInterrupted) UnmarshalJSON(data []byte) error {
	type embed ServerMessageUserInterrupted
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageUserInterrupted(unmarshaler.embed)
	if unmarshaler.Type != "user-interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "user-interrupted", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageUserInterrupted) MarshalJSON() ([]byte, error) {
	type embed ServerMessageUserInterrupted
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "user-interrupted",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageUserInterrupted) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageUserInterruptedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageUserInterruptedPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageUserInterruptedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageUserInterruptedPhoneNumber) Accept(visitor ServerMessageUserInterruptedPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceInput struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageVoiceInputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "voice-input" is sent when a generation is requested from voice provider.
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the voice input content
	Input string `json:"input" url:"input"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageVoiceInput) GetPhoneNumber() *ServerMessageVoiceInputPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageVoiceInput) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageVoiceInput) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageVoiceInput) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageVoiceInput) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageVoiceInput) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageVoiceInput) GetInput() string {
	if s == nil {
		return ""
	}
	return s.Input
}

func (s *ServerMessageVoiceInput) Type() string {
	return s.type_
}

func (s *ServerMessageVoiceInput) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageVoiceInput) UnmarshalJSON(data []byte) error {
	type embed ServerMessageVoiceInput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageVoiceInput(unmarshaler.embed)
	if unmarshaler.Type != "voice-input" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "voice-input", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageVoiceInput) MarshalJSON() ([]byte, error) {
	type embed ServerMessageVoiceInput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "voice-input",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageVoiceInput) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageVoiceInputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageVoiceInputPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceInputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageVoiceInputPhoneNumber) Accept(visitor ServerMessageVoiceInputPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceRequest struct {
	// This is the phone number that the message is associated with.
	PhoneNumber *ServerMessageVoiceRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "voice-request" is sent when using `assistant.voice={ "type": "custom-voice" }`.
	//
	// Here is what the request will look like:
	//
	// POST https://{assistant.voice.server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// The expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	// This is the timestamp of the message.
	Timestamp *float64 `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that the message is associated with.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer that the message is associated with.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call that the message is associated with.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the text to be synthesized.
	Text string `json:"text" url:"text"`
	// This is the sample rate to be synthesized.
	SampleRate float64 `json:"sampleRate" url:"sampleRate"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageVoiceRequest) GetPhoneNumber() *ServerMessageVoiceRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageVoiceRequest) GetTimestamp() *float64 {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageVoiceRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageVoiceRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageVoiceRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageVoiceRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageVoiceRequest) GetText() string {
	if s == nil {
		return ""
	}
	return s.Text
}

func (s *ServerMessageVoiceRequest) GetSampleRate() float64 {
	if s == nil {
		return 0
	}
	return s.SampleRate
}

func (s *ServerMessageVoiceRequest) Type() string {
	return s.type_
}

func (s *ServerMessageVoiceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageVoiceRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageVoiceRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageVoiceRequest(unmarshaler.embed)
	if unmarshaler.Type != "voice-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "voice-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageVoiceRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageVoiceRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "voice-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageVoiceRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number that the message is associated with.
type ServerMessageVoiceRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto
	CreateTelnyxPhoneNumberDto *CreateTelnyxPhoneNumberDto

	typ string
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateTelnyxPhoneNumberDto() *CreateTelnyxPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTelnyxPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	valueCreateTelnyxPhoneNumberDto := new(CreateTelnyxPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTelnyxPhoneNumberDto); err == nil {
		s.typ = "CreateTelnyxPhoneNumberDto"
		s.CreateTelnyxPhoneNumberDto = valueCreateTelnyxPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageVoiceRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return json.Marshal(s.CreateTelnyxPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
	VisitCreateTelnyxPhoneNumberDto(*CreateTelnyxPhoneNumberDto) error
}

func (s *ServerMessageVoiceRequestPhoneNumber) Accept(visitor ServerMessageVoiceRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	if s.typ == "CreateTelnyxPhoneNumberDto" || s.CreateTelnyxPhoneNumberDto != nil {
		return visitor.VisitCreateTelnyxPhoneNumberDto(s.CreateTelnyxPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SesameVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the model that will be used.
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string
	model        string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SesameVoice) GetCachingEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.CachingEnabled
}

func (s *SesameVoice) GetVoiceId() string {
	if s == nil {
		return ""
	}
	return s.VoiceId
}

func (s *SesameVoice) GetChunkPlan() *ChunkPlan {
	if s == nil {
		return nil
	}
	return s.ChunkPlan
}

func (s *SesameVoice) GetFallbackPlan() *FallbackPlan {
	if s == nil {
		return nil
	}
	return s.FallbackPlan
}

func (s *SesameVoice) Provider() string {
	return s.provider
}

func (s *SesameVoice) Model() string {
	return s.model
}

func (s *SesameVoice) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SesameVoice) UnmarshalJSON(data []byte) error {
	type embed SesameVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
		Model    string `json:"model"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SesameVoice(unmarshaler.embed)
	if unmarshaler.Provider != "sesame" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "sesame", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	if unmarshaler.Model != "csm-1b" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "csm-1b", unmarshaler.Model)
	}
	s.model = unmarshaler.Model
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider", "model")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SesameVoice) MarshalJSON() ([]byte, error) {
	type embed SesameVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
		Model    string `json:"model"`
	}{
		embed:    embed(*s),
		Provider: "sesame",
		Model:    "csm-1b",
	}
	return json.Marshal(marshaler)
}

func (s *SesameVoice) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SipTrunkGateway struct {
	// This is the address of the gateway. It can be an IPv4 address like 1.1.1.1 or a fully qualified domain name like my-sip-trunk.pstn.twilio.com.
	Ip string `json:"ip" url:"ip"`
	// This is the port number of the gateway. Default is 5060.
	//
	// @default 5060
	Port *float64 `json:"port,omitempty" url:"port,omitempty"`
	// This is the netmask of the gateway. Defaults to 32.
	//
	// @default 32
	Netmask *float64 `json:"netmask,omitempty" url:"netmask,omitempty"`
	// This is whether inbound calls are allowed from this gateway. Default is true.
	//
	// @default true
	InboundEnabled *bool `json:"inboundEnabled,omitempty" url:"inboundEnabled,omitempty"`
	// This is whether outbound calls should be sent to this gateway. Default is true.
	//
	// Note, if netmask is less than 32, it doesn't affect the outbound IPs that are tried. 1 attempt is made to `ip:port`.
	//
	// @default true
	OutboundEnabled *bool `json:"outboundEnabled,omitempty" url:"outboundEnabled,omitempty"`
	// This is the protocol to use for SIP signaling outbound calls. Default is udp.
	//
	// @default udp
	OutboundProtocol *SipTrunkGatewayOutboundProtocol `json:"outboundProtocol,omitempty" url:"outboundProtocol,omitempty"`
	// This is whether to send options ping to the gateway. This can be used to check if the gateway is reachable. Default is false.
	//
	// This is useful for high availability setups where you want to check if the gateway is reachable before routing calls to it. Note, if no gateway for a trunk is reachable, outbound calls will be rejected.
	//
	// @default false
	OptionsPingEnabled *bool `json:"optionsPingEnabled,omitempty" url:"optionsPingEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SipTrunkGateway) GetIp() string {
	if s == nil {
		return ""
	}
	return s.Ip
}

func (s *SipTrunkGateway) GetPort() *float64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SipTrunkGateway) GetNetmask() *float64 {
	if s == nil {
		return nil
	}
	return s.Netmask
}

func (s *SipTrunkGateway) GetInboundEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.InboundEnabled
}

func (s *SipTrunkGateway) GetOutboundEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.OutboundEnabled
}

func (s *SipTrunkGateway) GetOutboundProtocol() *SipTrunkGatewayOutboundProtocol {
	if s == nil {
		return nil
	}
	return s.OutboundProtocol
}

func (s *SipTrunkGateway) GetOptionsPingEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.OptionsPingEnabled
}

func (s *SipTrunkGateway) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkGateway) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkGateway
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkGateway(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkGateway) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the protocol to use for SIP signaling outbound calls. Default is udp.
//
// @default udp
type SipTrunkGatewayOutboundProtocol string

const (
	SipTrunkGatewayOutboundProtocolTlsSrtp SipTrunkGatewayOutboundProtocol = "tls/srtp"
	SipTrunkGatewayOutboundProtocolTcp     SipTrunkGatewayOutboundProtocol = "tcp"
	SipTrunkGatewayOutboundProtocolTls     SipTrunkGatewayOutboundProtocol = "tls"
	SipTrunkGatewayOutboundProtocolUdp     SipTrunkGatewayOutboundProtocol = "udp"
)

func NewSipTrunkGatewayOutboundProtocolFromString(s string) (SipTrunkGatewayOutboundProtocol, error) {
	switch s {
	case "tls/srtp":
		return SipTrunkGatewayOutboundProtocolTlsSrtp, nil
	case "tcp":
		return SipTrunkGatewayOutboundProtocolTcp, nil
	case "tls":
		return SipTrunkGatewayOutboundProtocolTls, nil
	case "udp":
		return SipTrunkGatewayOutboundProtocolUdp, nil
	}
	var t SipTrunkGatewayOutboundProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SipTrunkGatewayOutboundProtocol) Ptr() *SipTrunkGatewayOutboundProtocol {
	return &s
}

type SipTrunkOutboundAuthenticationPlan struct {
	// This is not returned in the API.
	AuthPassword *string `json:"authPassword,omitempty" url:"authPassword,omitempty"`
	AuthUsername *string `json:"authUsername,omitempty" url:"authUsername,omitempty"`
	// This can be used to configure if SIP register is required by the SIP trunk. If not provided, no SIP registration will be attempted.
	SipRegisterPlan *SipTrunkOutboundSipRegisterPlan `json:"sipRegisterPlan,omitempty" url:"sipRegisterPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SipTrunkOutboundAuthenticationPlan) GetAuthPassword() *string {
	if s == nil {
		return nil
	}
	return s.AuthPassword
}

func (s *SipTrunkOutboundAuthenticationPlan) GetAuthUsername() *string {
	if s == nil {
		return nil
	}
	return s.AuthUsername
}

func (s *SipTrunkOutboundAuthenticationPlan) GetSipRegisterPlan() *SipTrunkOutboundSipRegisterPlan {
	if s == nil {
		return nil
	}
	return s.SipRegisterPlan
}

func (s *SipTrunkOutboundAuthenticationPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkOutboundAuthenticationPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkOutboundAuthenticationPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkOutboundAuthenticationPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkOutboundAuthenticationPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SipTrunkOutboundSipRegisterPlan struct {
	Domain   *string `json:"domain,omitempty" url:"domain,omitempty"`
	Username *string `json:"username,omitempty" url:"username,omitempty"`
	Realm    *string `json:"realm,omitempty" url:"realm,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SipTrunkOutboundSipRegisterPlan) GetDomain() *string {
	if s == nil {
		return nil
	}
	return s.Domain
}

func (s *SipTrunkOutboundSipRegisterPlan) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SipTrunkOutboundSipRegisterPlan) GetRealm() *string {
	if s == nil {
		return nil
	}
	return s.Realm
}

func (s *SipTrunkOutboundSipRegisterPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkOutboundSipRegisterPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkOutboundSipRegisterPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkOutboundSipRegisterPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkOutboundSipRegisterPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SlackOAuth2AuthorizationCredential struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId string `json:"authorizationId" url:"authorizationId"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SlackOAuth2AuthorizationCredential) GetAuthorizationId() string {
	if s == nil {
		return ""
	}
	return s.AuthorizationId
}

func (s *SlackOAuth2AuthorizationCredential) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SlackOAuth2AuthorizationCredential) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SlackOAuth2AuthorizationCredential) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SlackOAuth2AuthorizationCredential) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SlackOAuth2AuthorizationCredential) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SlackOAuth2AuthorizationCredential) Provider() string {
	return s.provider
}

func (s *SlackOAuth2AuthorizationCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SlackOAuth2AuthorizationCredential) UnmarshalJSON(data []byte) error {
	type embed SlackOAuth2AuthorizationCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SlackOAuth2AuthorizationCredential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "slack.oauth2-authorization" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "slack.oauth2-authorization", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlackOAuth2AuthorizationCredential) MarshalJSON() ([]byte, error) {
	type embed SlackOAuth2AuthorizationCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Provider:  "slack.oauth2-authorization",
	}
	return json.Marshal(marshaler)
}

func (s *SlackOAuth2AuthorizationCredential) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the provider-specific ID that will be used.
type SmallestAiVoiceId struct {
	SmallestAiVoiceIdEnum SmallestAiVoiceIdEnum
	String                string

	typ string
}

func (s *SmallestAiVoiceId) GetSmallestAiVoiceIdEnum() SmallestAiVoiceIdEnum {
	if s == nil {
		return ""
	}
	return s.SmallestAiVoiceIdEnum
}

func (s *SmallestAiVoiceId) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SmallestAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueSmallestAiVoiceIdEnum SmallestAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueSmallestAiVoiceIdEnum); err == nil {
		s.typ = "SmallestAiVoiceIdEnum"
		s.SmallestAiVoiceIdEnum = valueSmallestAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SmallestAiVoiceId) MarshalJSON() ([]byte, error) {
	if s.typ == "SmallestAiVoiceIdEnum" || s.SmallestAiVoiceIdEnum != "" {
		return json.Marshal(s.SmallestAiVoiceIdEnum)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SmallestAiVoiceIdVisitor interface {
	VisitSmallestAiVoiceIdEnum(SmallestAiVoiceIdEnum) error
	VisitString(string) error
}

func (s *SmallestAiVoiceId) Accept(visitor SmallestAiVoiceIdVisitor) error {
	if s.typ == "SmallestAiVoiceIdEnum" || s.SmallestAiVoiceIdEnum != "" {
		return visitor.VisitSmallestAiVoiceIdEnum(s.SmallestAiVoiceIdEnum)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SmallestAiVoiceIdEnum string

const (
	SmallestAiVoiceIdEnumEmily    SmallestAiVoiceIdEnum = "emily"
	SmallestAiVoiceIdEnumJasmine  SmallestAiVoiceIdEnum = "jasmine"
	SmallestAiVoiceIdEnumArman    SmallestAiVoiceIdEnum = "arman"
	SmallestAiVoiceIdEnumJames    SmallestAiVoiceIdEnum = "james"
	SmallestAiVoiceIdEnumMithali  SmallestAiVoiceIdEnum = "mithali"
	SmallestAiVoiceIdEnumAravind  SmallestAiVoiceIdEnum = "aravind"
	SmallestAiVoiceIdEnumRaj      SmallestAiVoiceIdEnum = "raj"
	SmallestAiVoiceIdEnumDiya     SmallestAiVoiceIdEnum = "diya"
	SmallestAiVoiceIdEnumRaman    SmallestAiVoiceIdEnum = "raman"
	SmallestAiVoiceIdEnumAnanya   SmallestAiVoiceIdEnum = "ananya"
	SmallestAiVoiceIdEnumIsha     SmallestAiVoiceIdEnum = "isha"
	SmallestAiVoiceIdEnumWilliam  SmallestAiVoiceIdEnum = "william"
	SmallestAiVoiceIdEnumAarav    SmallestAiVoiceIdEnum = "aarav"
	SmallestAiVoiceIdEnumMonika   SmallestAiVoiceIdEnum = "monika"
	SmallestAiVoiceIdEnumNiharika SmallestAiVoiceIdEnum = "niharika"
	SmallestAiVoiceIdEnumDeepika  SmallestAiVoiceIdEnum = "deepika"
	SmallestAiVoiceIdEnumRaghav   SmallestAiVoiceIdEnum = "raghav"
	SmallestAiVoiceIdEnumKajal    SmallestAiVoiceIdEnum = "kajal"
	SmallestAiVoiceIdEnumRadhika  SmallestAiVoiceIdEnum = "radhika"
	SmallestAiVoiceIdEnumMansi    SmallestAiVoiceIdEnum = "mansi"
	SmallestAiVoiceIdEnumNisha    SmallestAiVoiceIdEnum = "nisha"
	SmallestAiVoiceIdEnumSaurabh  SmallestAiVoiceIdEnum = "saurabh"
	SmallestAiVoiceIdEnumPooja    SmallestAiVoiceIdEnum = "pooja"
	SmallestAiVoiceIdEnumSaina    SmallestAiVoiceIdEnum = "saina"
	SmallestAiVoiceIdEnumSanya    SmallestAiVoiceIdEnum = "sanya"
)

func NewSmallestAiVoiceIdEnumFromString(s string) (SmallestAiVoiceIdEnum, error) {
	switch s {
	case "emily":
		return SmallestAiVoiceIdEnumEmily, nil
	case "jasmine":
		return SmallestAiVoiceIdEnumJasmine, nil
	case "arman":
		return SmallestAiVoiceIdEnumArman, nil
	case "james":
		return SmallestAiVoiceIdEnumJames, nil
	case "mithali":
		return SmallestAiVoiceIdEnumMithali, nil
	case "aravind":
		return SmallestAiVoiceIdEnumAravind, nil
	case "raj":
		return SmallestAiVoiceIdEnumRaj, nil
	case "diya":
		return SmallestAiVoiceIdEnumDiya, nil
	case "raman":
		return SmallestAiVoiceIdEnumRaman, nil
	case "ananya":
		return SmallestAiVoiceIdEnumAnanya, nil
	case "isha":
		return SmallestAiVoiceIdEnumIsha, nil
	case "william":
		return SmallestAiVoiceIdEnumWilliam, nil
	case "aarav":
		return SmallestAiVoiceIdEnumAarav, nil
	case "monika":
		return SmallestAiVoiceIdEnumMonika, nil
	case "niharika":
		return SmallestAiVoiceIdEnumNiharika, nil
	case "deepika":
		return SmallestAiVoiceIdEnumDeepika, nil
	case "raghav":
		return SmallestAiVoiceIdEnumRaghav, nil
	case "kajal":
		return SmallestAiVoiceIdEnumKajal, nil
	case "radhika":
		return SmallestAiVoiceIdEnumRadhika, nil
	case "mansi":
		return SmallestAiVoiceIdEnumMansi, nil
	case "nisha":
		return SmallestAiVoiceIdEnumNisha, nil
	case "saurabh":
		return SmallestAiVoiceIdEnumSaurabh, nil
	case "pooja":
		return SmallestAiVoiceIdEnumPooja, nil
	case "saina":
		return SmallestAiVoiceIdEnumSaina, nil
	case "sanya":
		return SmallestAiVoiceIdEnumSanya, nil
	}
	var t SmallestAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SmallestAiVoiceIdEnum) Ptr() *SmallestAiVoiceIdEnum {
	return &s
}

type SmallestAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SmallestAiCredential) GetApiKey() string {
	if s == nil {
		return ""
	}
	return s.ApiKey
}

func (s *SmallestAiCredential) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SmallestAiCredential) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SmallestAiCredential) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SmallestAiCredential) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SmallestAiCredential) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SmallestAiCredential) Provider() string {
	return s.provider
}

func (s *SmallestAiCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SmallestAiCredential) UnmarshalJSON(data []byte) error {
	type embed SmallestAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SmallestAiCredential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "smallest-ai", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SmallestAiCredential) MarshalJSON() ([]byte, error) {
	type embed SmallestAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Provider:  "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (s *SmallestAiCredential) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SmallestAiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *SmallestAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Smallest AI voice model to use. Defaults to 'lightning' when not specified.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SmallestAiVoice) GetCachingEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.CachingEnabled
}

func (s *SmallestAiVoice) GetVoiceId() *SmallestAiVoiceId {
	if s == nil {
		return nil
	}
	return s.VoiceId
}

func (s *SmallestAiVoice) GetSpeed() *float64 {
	if s == nil {
		return nil
	}
	return s.Speed
}

func (s *SmallestAiVoice) GetChunkPlan() *ChunkPlan {
	if s == nil {
		return nil
	}
	return s.ChunkPlan
}

func (s *SmallestAiVoice) GetFallbackPlan() *FallbackPlan {
	if s == nil {
		return nil
	}
	return s.FallbackPlan
}

func (s *SmallestAiVoice) Provider() string {
	return s.provider
}

func (s *SmallestAiVoice) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SmallestAiVoice) UnmarshalJSON(data []byte) error {
	type embed SmallestAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SmallestAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "smallest-ai", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SmallestAiVoice) MarshalJSON() ([]byte, error) {
	type embed SmallestAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*s),
		Provider: "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (s *SmallestAiVoice) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpeechmaticsCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpeechmaticsCredential) GetApiKey() string {
	if s == nil {
		return ""
	}
	return s.ApiKey
}

func (s *SpeechmaticsCredential) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SpeechmaticsCredential) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SpeechmaticsCredential) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SpeechmaticsCredential) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SpeechmaticsCredential) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SpeechmaticsCredential) Provider() string {
	return s.provider
}

func (s *SpeechmaticsCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpeechmaticsCredential) UnmarshalJSON(data []byte) error {
	type embed SpeechmaticsCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SpeechmaticsCredential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "speechmatics" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "speechmatics", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpeechmaticsCredential) MarshalJSON() ([]byte, error) {
	type embed SpeechmaticsCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Provider:  "speechmatics",
	}
	return json.Marshal(marshaler)
}

func (s *SpeechmaticsCredential) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpeechmaticsTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model    *string                          `json:"model,omitempty" url:"model,omitempty"`
	Language *SpeechmaticsTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpeechmaticsTranscriber) GetLanguage() *SpeechmaticsTranscriberLanguage {
	if s == nil {
		return nil
	}
	return s.Language
}

func (s *SpeechmaticsTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if s == nil {
		return nil
	}
	return s.FallbackPlan
}

func (s *SpeechmaticsTranscriber) Provider() string {
	return s.provider
}

func (s *SpeechmaticsTranscriber) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpeechmaticsTranscriber) UnmarshalJSON(data []byte) error {
	type embed SpeechmaticsTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SpeechmaticsTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "speechmatics" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "speechmatics", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpeechmaticsTranscriber) MarshalJSON() ([]byte, error) {
	type embed SpeechmaticsTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*s),
		Provider: "speechmatics",
	}
	return json.Marshal(marshaler)
}

func (s *SpeechmaticsTranscriber) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SpeechmaticsTranscriberLanguage string

const (
	SpeechmaticsTranscriberLanguageAuto SpeechmaticsTranscriberLanguage = "auto"
	SpeechmaticsTranscriberLanguageAr   SpeechmaticsTranscriberLanguage = "ar"
	SpeechmaticsTranscriberLanguageBa   SpeechmaticsTranscriberLanguage = "ba"
	SpeechmaticsTranscriberLanguageEu   SpeechmaticsTranscriberLanguage = "eu"
	SpeechmaticsTranscriberLanguageBe   SpeechmaticsTranscriberLanguage = "be"
	SpeechmaticsTranscriberLanguageBn   SpeechmaticsTranscriberLanguage = "bn"
	SpeechmaticsTranscriberLanguageBg   SpeechmaticsTranscriberLanguage = "bg"
	SpeechmaticsTranscriberLanguageYue  SpeechmaticsTranscriberLanguage = "yue"
	SpeechmaticsTranscriberLanguageCa   SpeechmaticsTranscriberLanguage = "ca"
	SpeechmaticsTranscriberLanguageHr   SpeechmaticsTranscriberLanguage = "hr"
	SpeechmaticsTranscriberLanguageCs   SpeechmaticsTranscriberLanguage = "cs"
	SpeechmaticsTranscriberLanguageDa   SpeechmaticsTranscriberLanguage = "da"
	SpeechmaticsTranscriberLanguageNl   SpeechmaticsTranscriberLanguage = "nl"
	SpeechmaticsTranscriberLanguageEn   SpeechmaticsTranscriberLanguage = "en"
	SpeechmaticsTranscriberLanguageEo   SpeechmaticsTranscriberLanguage = "eo"
	SpeechmaticsTranscriberLanguageEt   SpeechmaticsTranscriberLanguage = "et"
	SpeechmaticsTranscriberLanguageFi   SpeechmaticsTranscriberLanguage = "fi"
	SpeechmaticsTranscriberLanguageFr   SpeechmaticsTranscriberLanguage = "fr"
	SpeechmaticsTranscriberLanguageGl   SpeechmaticsTranscriberLanguage = "gl"
	SpeechmaticsTranscriberLanguageDe   SpeechmaticsTranscriberLanguage = "de"
	SpeechmaticsTranscriberLanguageEl   SpeechmaticsTranscriberLanguage = "el"
	SpeechmaticsTranscriberLanguageHe   SpeechmaticsTranscriberLanguage = "he"
	SpeechmaticsTranscriberLanguageHi   SpeechmaticsTranscriberLanguage = "hi"
	SpeechmaticsTranscriberLanguageHu   SpeechmaticsTranscriberLanguage = "hu"
	SpeechmaticsTranscriberLanguageId   SpeechmaticsTranscriberLanguage = "id"
	SpeechmaticsTranscriberLanguageIa   SpeechmaticsTranscriberLanguage = "ia"
	SpeechmaticsTranscriberLanguageGa   SpeechmaticsTranscriberLanguage = "ga"
	SpeechmaticsTranscriberLanguageIt   SpeechmaticsTranscriberLanguage = "it"
	SpeechmaticsTranscriberLanguageJa   SpeechmaticsTranscriberLanguage = "ja"
	SpeechmaticsTranscriberLanguageKo   SpeechmaticsTranscriberLanguage = "ko"
	SpeechmaticsTranscriberLanguageLv   SpeechmaticsTranscriberLanguage = "lv"
	SpeechmaticsTranscriberLanguageLt   SpeechmaticsTranscriberLanguage = "lt"
	SpeechmaticsTranscriberLanguageMs   SpeechmaticsTranscriberLanguage = "ms"
	SpeechmaticsTranscriberLanguageMt   SpeechmaticsTranscriberLanguage = "mt"
	SpeechmaticsTranscriberLanguageCmn  SpeechmaticsTranscriberLanguage = "cmn"
	SpeechmaticsTranscriberLanguageMr   SpeechmaticsTranscriberLanguage = "mr"
	SpeechmaticsTranscriberLanguageMn   SpeechmaticsTranscriberLanguage = "mn"
	SpeechmaticsTranscriberLanguageNo   SpeechmaticsTranscriberLanguage = "no"
	SpeechmaticsTranscriberLanguageFa   SpeechmaticsTranscriberLanguage = "fa"
	SpeechmaticsTranscriberLanguagePl   SpeechmaticsTranscriberLanguage = "pl"
	SpeechmaticsTranscriberLanguagePt   SpeechmaticsTranscriberLanguage = "pt"
	SpeechmaticsTranscriberLanguageRo   SpeechmaticsTranscriberLanguage = "ro"
	SpeechmaticsTranscriberLanguageRu   SpeechmaticsTranscriberLanguage = "ru"
	SpeechmaticsTranscriberLanguageSk   SpeechmaticsTranscriberLanguage = "sk"
	SpeechmaticsTranscriberLanguageSl   SpeechmaticsTranscriberLanguage = "sl"
	SpeechmaticsTranscriberLanguageEs   SpeechmaticsTranscriberLanguage = "es"
	SpeechmaticsTranscriberLanguageSw   SpeechmaticsTranscriberLanguage = "sw"
	SpeechmaticsTranscriberLanguageSv   SpeechmaticsTranscriberLanguage = "sv"
	SpeechmaticsTranscriberLanguageTa   SpeechmaticsTranscriberLanguage = "ta"
	SpeechmaticsTranscriberLanguageTh   SpeechmaticsTranscriberLanguage = "th"
	SpeechmaticsTranscriberLanguageTr   SpeechmaticsTranscriberLanguage = "tr"
	SpeechmaticsTranscriberLanguageUk   SpeechmaticsTranscriberLanguage = "uk"
	SpeechmaticsTranscriberLanguageUr   SpeechmaticsTranscriberLanguage = "ur"
	SpeechmaticsTranscriberLanguageUg   SpeechmaticsTranscriberLanguage = "ug"
	SpeechmaticsTranscriberLanguageVi   SpeechmaticsTranscriberLanguage = "vi"
	SpeechmaticsTranscriberLanguageCy   SpeechmaticsTranscriberLanguage = "cy"
)

func NewSpeechmaticsTranscriberLanguageFromString(s string) (SpeechmaticsTranscriberLanguage, error) {
	switch s {
	case "auto":
		return SpeechmaticsTranscriberLanguageAuto, nil
	case "ar":
		return SpeechmaticsTranscriberLanguageAr, nil
	case "ba":
		return SpeechmaticsTranscriberLanguageBa, nil
	case "eu":
		return SpeechmaticsTranscriberLanguageEu, nil
	case "be":
		return SpeechmaticsTranscriberLanguageBe, nil
	case "bn":
		return SpeechmaticsTranscriberLanguageBn, nil
	case "bg":
		return SpeechmaticsTranscriberLanguageBg, nil
	case "yue":
		return SpeechmaticsTranscriberLanguageYue, nil
	case "ca":
		return SpeechmaticsTranscriberLanguageCa, nil
	case "hr":
		return SpeechmaticsTranscriberLanguageHr, nil
	case "cs":
		return SpeechmaticsTranscriberLanguageCs, nil
	case "da":
		return SpeechmaticsTranscriberLanguageDa, nil
	case "nl":
		return SpeechmaticsTranscriberLanguageNl, nil
	case "en":
		return SpeechmaticsTranscriberLanguageEn, nil
	case "eo":
		return SpeechmaticsTranscriberLanguageEo, nil
	case "et":
		return SpeechmaticsTranscriberLanguageEt, nil
	case "fi":
		return SpeechmaticsTranscriberLanguageFi, nil
	case "fr":
		return SpeechmaticsTranscriberLanguageFr, nil
	case "gl":
		return SpeechmaticsTranscriberLanguageGl, nil
	case "de":
		return SpeechmaticsTranscriberLanguageDe, nil
	case "el":
		return SpeechmaticsTranscriberLanguageEl, nil
	case "he":
		return SpeechmaticsTranscriberLanguageHe, nil
	case "hi":
		return SpeechmaticsTranscriberLanguageHi, nil
	case "hu":
		return SpeechmaticsTranscriberLanguageHu, nil
	case "id":
		return SpeechmaticsTranscriberLanguageId, nil
	case "ia":
		return SpeechmaticsTranscriberLanguageIa, nil
	case "ga":
		return SpeechmaticsTranscriberLanguageGa, nil
	case "it":
		return SpeechmaticsTranscriberLanguageIt, nil
	case "ja":
		return SpeechmaticsTranscriberLanguageJa, nil
	case "ko":
		return SpeechmaticsTranscriberLanguageKo, nil
	case "lv":
		return SpeechmaticsTranscriberLanguageLv, nil
	case "lt":
		return SpeechmaticsTranscriberLanguageLt, nil
	case "ms":
		return SpeechmaticsTranscriberLanguageMs, nil
	case "mt":
		return SpeechmaticsTranscriberLanguageMt, nil
	case "cmn":
		return SpeechmaticsTranscriberLanguageCmn, nil
	case "mr":
		return SpeechmaticsTranscriberLanguageMr, nil
	case "mn":
		return SpeechmaticsTranscriberLanguageMn, nil
	case "no":
		return SpeechmaticsTranscriberLanguageNo, nil
	case "fa":
		return SpeechmaticsTranscriberLanguageFa, nil
	case "pl":
		return SpeechmaticsTranscriberLanguagePl, nil
	case "pt":
		return SpeechmaticsTranscriberLanguagePt, nil
	case "ro":
		return SpeechmaticsTranscriberLanguageRo, nil
	case "ru":
		return SpeechmaticsTranscriberLanguageRu, nil
	case "sk":
		return SpeechmaticsTranscriberLanguageSk, nil
	case "sl":
		return SpeechmaticsTranscriberLanguageSl, nil
	case "es":
		return SpeechmaticsTranscriberLanguageEs, nil
	case "sw":
		return SpeechmaticsTranscriberLanguageSw, nil
	case "sv":
		return SpeechmaticsTranscriberLanguageSv, nil
	case "ta":
		return SpeechmaticsTranscriberLanguageTa, nil
	case "th":
		return SpeechmaticsTranscriberLanguageTh, nil
	case "tr":
		return SpeechmaticsTranscriberLanguageTr, nil
	case "uk":
		return SpeechmaticsTranscriberLanguageUk, nil
	case "ur":
		return SpeechmaticsTranscriberLanguageUr, nil
	case "ug":
		return SpeechmaticsTranscriberLanguageUg, nil
	case "vi":
		return SpeechmaticsTranscriberLanguageVi, nil
	case "cy":
		return SpeechmaticsTranscriberLanguageCy, nil
	}
	var t SpeechmaticsTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SpeechmaticsTranscriberLanguage) Ptr() *SpeechmaticsTranscriberLanguage {
	return &s
}

type SquadMemberDto struct {
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This can be used to override the assistant's settings and provide values for it's template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// These are the others assistants that this assistant can transfer to.
	//
	// If the assistant already has transfer call tool, these destinations are just appended to existing ones.
	AssistantDestinations []*TransferDestinationAssistant `json:"assistantDestinations,omitempty" url:"assistantDestinations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SquadMemberDto) GetAssistantId() *string {
	if s == nil {
		return nil
	}
	return s.AssistantId
}

func (s *SquadMemberDto) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *SquadMemberDto) GetAssistantOverrides() *AssistantOverrides {
	if s == nil {
		return nil
	}
	return s.AssistantOverrides
}

func (s *SquadMemberDto) GetAssistantDestinations() []*TransferDestinationAssistant {
	if s == nil {
		return nil
	}
	return s.AssistantDestinations
}

func (s *SquadMemberDto) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SquadMemberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler SquadMemberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SquadMemberDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SquadMemberDto) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartSpeakingPlan struct {
	// This is how long assistant waits before speaking. Defaults to 0.4.
	//
	// This is the minimum it will wait but if there is latency is the pipeline, this minimum will be exceeded. This is intended as a stopgap in case the pipeline is moving too fast.
	//
	// Example:
	// - If model generates tokens and voice generates bytes within 100ms, the pipeline still waits 300ms before outputting speech.
	//
	// Usage:
	// - If the customer is taking long pauses, set this to a higher value.
	// - If the assistant is accidentally jumping in too much, set this to a higher value.
	//
	// @default 0.4
	WaitSeconds             *float64                                  `json:"waitSeconds,omitempty" url:"waitSeconds,omitempty"`
	SmartEndpointingEnabled *StartSpeakingPlanSmartEndpointingEnabled `json:"smartEndpointingEnabled,omitempty" url:"smartEndpointingEnabled,omitempty"`
	// This is the plan for smart endpointing. Pick between Vapi smart endpointing or LiveKit smart endpointing (or nothing). We strongly recommend using livekit endpointing when working in English. LiveKit endpointing is not supported in other languages, yet.
	//
	// If this is set, it will override and take precedence over `transcriptionEndpointingPlan`.
	// This plan will still be overridden by any matching `customEndpointingRules`.
	SmartEndpointingPlan *StartSpeakingPlanSmartEndpointingPlan `json:"smartEndpointingPlan,omitempty" url:"smartEndpointingPlan,omitempty"`
	// These are the custom endpointing rules to set an endpointing timeout based on a regex on the customer's speech or the assistant's last message.
	//
	// Usage:
	// - If you have yes/no questions like "are you interested in a loan?", you can set a shorter timeout.
	// - If you have questions where the customer may pause to look up information like "what's my account number?", you can set a longer timeout.
	// - If you want to wait longer while customer is enumerating a list of numbers, you can set a longer timeout.
	//
	// These rules have the highest precedence and will override both `smartEndpointingPlan` and `transcriptionEndpointingPlan` when a rule is matched.
	//
	// The rules are evaluated in order and the first one that matches will be used.
	//
	// Order of precedence for endpointing:
	// 1. customEndpointingRules (if any match)
	// 2. smartEndpointingPlan (if set)
	// 3. transcriptionEndpointingPlan
	//
	// @default []
	CustomEndpointingRules []*StartSpeakingPlanCustomEndpointingRulesItem `json:"customEndpointingRules,omitempty" url:"customEndpointingRules,omitempty"`
	// This determines how a customer speech is considered done (endpointing) using the transcription of customer's speech.
	//
	// Once an endpoint is triggered, the request is sent to `assistant.model`.
	//
	// Note: This plan is only used if `smartEndpointingPlan` is not set. If both are provided, `smartEndpointingPlan` takes precedence.
	// This plan will also be overridden by any matching `customEndpointingRules`.
	TranscriptionEndpointingPlan *TranscriptionEndpointingPlan `json:"transcriptionEndpointingPlan,omitempty" url:"transcriptionEndpointingPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StartSpeakingPlan) GetWaitSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.WaitSeconds
}

func (s *StartSpeakingPlan) GetSmartEndpointingEnabled() *StartSpeakingPlanSmartEndpointingEnabled {
	if s == nil {
		return nil
	}
	return s.SmartEndpointingEnabled
}

func (s *StartSpeakingPlan) GetSmartEndpointingPlan() *StartSpeakingPlanSmartEndpointingPlan {
	if s == nil {
		return nil
	}
	return s.SmartEndpointingPlan
}

func (s *StartSpeakingPlan) GetCustomEndpointingRules() []*StartSpeakingPlanCustomEndpointingRulesItem {
	if s == nil {
		return nil
	}
	return s.CustomEndpointingRules
}

func (s *StartSpeakingPlan) GetTranscriptionEndpointingPlan() *TranscriptionEndpointingPlan {
	if s == nil {
		return nil
	}
	return s.TranscriptionEndpointingPlan
}

func (s *StartSpeakingPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StartSpeakingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StartSpeakingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StartSpeakingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StartSpeakingPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartSpeakingPlanCustomEndpointingRulesItem struct {
	AssistantCustomEndpointingRule *AssistantCustomEndpointingRule
	CustomerCustomEndpointingRule  *CustomerCustomEndpointingRule
	BothCustomEndpointingRule      *BothCustomEndpointingRule

	typ string
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) GetAssistantCustomEndpointingRule() *AssistantCustomEndpointingRule {
	if s == nil {
		return nil
	}
	return s.AssistantCustomEndpointingRule
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) GetCustomerCustomEndpointingRule() *CustomerCustomEndpointingRule {
	if s == nil {
		return nil
	}
	return s.CustomerCustomEndpointingRule
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) GetBothCustomEndpointingRule() *BothCustomEndpointingRule {
	if s == nil {
		return nil
	}
	return s.BothCustomEndpointingRule
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) UnmarshalJSON(data []byte) error {
	valueAssistantCustomEndpointingRule := new(AssistantCustomEndpointingRule)
	if err := json.Unmarshal(data, &valueAssistantCustomEndpointingRule); err == nil {
		s.typ = "AssistantCustomEndpointingRule"
		s.AssistantCustomEndpointingRule = valueAssistantCustomEndpointingRule
		return nil
	}
	valueCustomerCustomEndpointingRule := new(CustomerCustomEndpointingRule)
	if err := json.Unmarshal(data, &valueCustomerCustomEndpointingRule); err == nil {
		s.typ = "CustomerCustomEndpointingRule"
		s.CustomerCustomEndpointingRule = valueCustomerCustomEndpointingRule
		return nil
	}
	valueBothCustomEndpointingRule := new(BothCustomEndpointingRule)
	if err := json.Unmarshal(data, &valueBothCustomEndpointingRule); err == nil {
		s.typ = "BothCustomEndpointingRule"
		s.BothCustomEndpointingRule = valueBothCustomEndpointingRule
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StartSpeakingPlanCustomEndpointingRulesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "AssistantCustomEndpointingRule" || s.AssistantCustomEndpointingRule != nil {
		return json.Marshal(s.AssistantCustomEndpointingRule)
	}
	if s.typ == "CustomerCustomEndpointingRule" || s.CustomerCustomEndpointingRule != nil {
		return json.Marshal(s.CustomerCustomEndpointingRule)
	}
	if s.typ == "BothCustomEndpointingRule" || s.BothCustomEndpointingRule != nil {
		return json.Marshal(s.BothCustomEndpointingRule)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StartSpeakingPlanCustomEndpointingRulesItemVisitor interface {
	VisitAssistantCustomEndpointingRule(*AssistantCustomEndpointingRule) error
	VisitCustomerCustomEndpointingRule(*CustomerCustomEndpointingRule) error
	VisitBothCustomEndpointingRule(*BothCustomEndpointingRule) error
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) Accept(visitor StartSpeakingPlanCustomEndpointingRulesItemVisitor) error {
	if s.typ == "AssistantCustomEndpointingRule" || s.AssistantCustomEndpointingRule != nil {
		return visitor.VisitAssistantCustomEndpointingRule(s.AssistantCustomEndpointingRule)
	}
	if s.typ == "CustomerCustomEndpointingRule" || s.CustomerCustomEndpointingRule != nil {
		return visitor.VisitCustomerCustomEndpointingRule(s.CustomerCustomEndpointingRule)
	}
	if s.typ == "BothCustomEndpointingRule" || s.BothCustomEndpointingRule != nil {
		return visitor.VisitBothCustomEndpointingRule(s.BothCustomEndpointingRule)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StartSpeakingPlanSmartEndpointingEnabled struct {
	Boolean              bool
	LivekitStringLiteral string

	typ string
}

func NewStartSpeakingPlanSmartEndpointingEnabledWithLivekitStringLiteral() *StartSpeakingPlanSmartEndpointingEnabled {
	return &StartSpeakingPlanSmartEndpointingEnabled{typ: "LivekitStringLiteral", LivekitStringLiteral: "livekit"}
}

func (s *StartSpeakingPlanSmartEndpointingEnabled) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *StartSpeakingPlanSmartEndpointingEnabled) UnmarshalJSON(data []byte) error {
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	var valueLivekitStringLiteral string
	if err := json.Unmarshal(data, &valueLivekitStringLiteral); err == nil {
		s.typ = "LivekitStringLiteral"
		s.LivekitStringLiteral = valueLivekitStringLiteral
		if s.LivekitStringLiteral != "livekit" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "livekit", valueLivekitStringLiteral)
		}
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StartSpeakingPlanSmartEndpointingEnabled) MarshalJSON() ([]byte, error) {
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	if s.typ == "LivekitStringLiteral" || s.LivekitStringLiteral != "" {
		return json.Marshal("livekit")
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StartSpeakingPlanSmartEndpointingEnabledVisitor interface {
	VisitBoolean(bool) error
	VisitLivekitStringLiteral(string) error
}

func (s *StartSpeakingPlanSmartEndpointingEnabled) Accept(visitor StartSpeakingPlanSmartEndpointingEnabledVisitor) error {
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	if s.typ == "LivekitStringLiteral" || s.LivekitStringLiteral != "" {
		return visitor.VisitLivekitStringLiteral(s.LivekitStringLiteral)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the plan for smart endpointing. Pick between Vapi smart endpointing or LiveKit smart endpointing (or nothing). We strongly recommend using livekit endpointing when working in English. LiveKit endpointing is not supported in other languages, yet.
//
// If this is set, it will override and take precedence over `transcriptionEndpointingPlan`.
// This plan will still be overridden by any matching `customEndpointingRules`.
type StartSpeakingPlanSmartEndpointingPlan struct {
	VapiSmartEndpointingPlan    *VapiSmartEndpointingPlan
	LivekitSmartEndpointingPlan *LivekitSmartEndpointingPlan

	typ string
}

func (s *StartSpeakingPlanSmartEndpointingPlan) GetVapiSmartEndpointingPlan() *VapiSmartEndpointingPlan {
	if s == nil {
		return nil
	}
	return s.VapiSmartEndpointingPlan
}

func (s *StartSpeakingPlanSmartEndpointingPlan) GetLivekitSmartEndpointingPlan() *LivekitSmartEndpointingPlan {
	if s == nil {
		return nil
	}
	return s.LivekitSmartEndpointingPlan
}

func (s *StartSpeakingPlanSmartEndpointingPlan) UnmarshalJSON(data []byte) error {
	valueVapiSmartEndpointingPlan := new(VapiSmartEndpointingPlan)
	if err := json.Unmarshal(data, &valueVapiSmartEndpointingPlan); err == nil {
		s.typ = "VapiSmartEndpointingPlan"
		s.VapiSmartEndpointingPlan = valueVapiSmartEndpointingPlan
		return nil
	}
	valueLivekitSmartEndpointingPlan := new(LivekitSmartEndpointingPlan)
	if err := json.Unmarshal(data, &valueLivekitSmartEndpointingPlan); err == nil {
		s.typ = "LivekitSmartEndpointingPlan"
		s.LivekitSmartEndpointingPlan = valueLivekitSmartEndpointingPlan
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StartSpeakingPlanSmartEndpointingPlan) MarshalJSON() ([]byte, error) {
	if s.typ == "VapiSmartEndpointingPlan" || s.VapiSmartEndpointingPlan != nil {
		return json.Marshal(s.VapiSmartEndpointingPlan)
	}
	if s.typ == "LivekitSmartEndpointingPlan" || s.LivekitSmartEndpointingPlan != nil {
		return json.Marshal(s.LivekitSmartEndpointingPlan)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StartSpeakingPlanSmartEndpointingPlanVisitor interface {
	VisitVapiSmartEndpointingPlan(*VapiSmartEndpointingPlan) error
	VisitLivekitSmartEndpointingPlan(*LivekitSmartEndpointingPlan) error
}

func (s *StartSpeakingPlanSmartEndpointingPlan) Accept(visitor StartSpeakingPlanSmartEndpointingPlanVisitor) error {
	if s.typ == "VapiSmartEndpointingPlan" || s.VapiSmartEndpointingPlan != nil {
		return visitor.VisitVapiSmartEndpointingPlan(s.VapiSmartEndpointingPlan)
	}
	if s.typ == "LivekitSmartEndpointingPlan" || s.LivekitSmartEndpointingPlan != nil {
		return visitor.VisitLivekitSmartEndpointingPlan(s.LivekitSmartEndpointingPlan)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StopSpeakingPlan struct {
	// This is the number of words that the customer has to say before the assistant will stop talking.
	//
	// Words like "stop", "actually", "no", etc. will always interrupt immediately regardless of this value.
	//
	// Words like "okay", "yeah", "right" will never interrupt.
	//
	// When set to 0, `voiceSeconds` is used in addition to the transcriptions to determine the customer has started speaking.
	//
	// Defaults to 0.
	//
	// @default 0
	NumWords *float64 `json:"numWords,omitempty" url:"numWords,omitempty"`
	// This is the seconds customer has to speak before the assistant stops talking. This uses the VAD (Voice Activity Detection) spike to determine if the customer has started speaking.
	//
	// Considerations:
	// - A lower value might be more responsive but could potentially pick up non-speech sounds.
	// - A higher value reduces false positives but might slightly delay the detection of speech onset.
	//
	// This is only used if `numWords` is set to 0.
	//
	// # Defaults to 0.2
	//
	// @default 0.2
	VoiceSeconds *float64 `json:"voiceSeconds,omitempty" url:"voiceSeconds,omitempty"`
	// This is the seconds to wait before the assistant will start talking again after being interrupted.
	//
	// Defaults to 1.
	//
	// @default 1
	BackoffSeconds *float64 `json:"backoffSeconds,omitempty" url:"backoffSeconds,omitempty"`
	// These are the phrases that will never interrupt the assistant, even if numWords threshold is met.
	// These are typically acknowledgement or backchanneling phrases.
	AcknowledgementPhrases []string `json:"acknowledgementPhrases,omitempty" url:"acknowledgementPhrases,omitempty"`
	// These are the phrases that will always interrupt the assistant immediately, regardless of numWords.
	// These are typically phrases indicating disagreement or desire to stop.
	InterruptionPhrases []string `json:"interruptionPhrases,omitempty" url:"interruptionPhrases,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StopSpeakingPlan) GetNumWords() *float64 {
	if s == nil {
		return nil
	}
	return s.NumWords
}

func (s *StopSpeakingPlan) GetVoiceSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.VoiceSeconds
}

func (s *StopSpeakingPlan) GetBackoffSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.BackoffSeconds
}

func (s *StopSpeakingPlan) GetAcknowledgementPhrases() []string {
	if s == nil {
		return nil
	}
	return s.AcknowledgementPhrases
}

func (s *StopSpeakingPlan) GetInterruptionPhrases() []string {
	if s == nil {
		return nil
	}
	return s.InterruptionPhrases
}

func (s *StopSpeakingPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StopSpeakingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StopSpeakingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StopSpeakingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StopSpeakingPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StructuredDataMultiPlan struct {
	// This is the key of the structured data plan in the catalog.
	Key string `json:"key" url:"key"`
	// This is an individual structured data plan in the catalog.
	Plan *StructuredDataPlan `json:"plan,omitempty" url:"plan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StructuredDataMultiPlan) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *StructuredDataMultiPlan) GetPlan() *StructuredDataPlan {
	if s == nil {
		return nil
	}
	return s.Plan
}

func (s *StructuredDataMultiPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StructuredDataMultiPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StructuredDataMultiPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StructuredDataMultiPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StructuredDataMultiPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StructuredDataPlan struct {
	// These are the messages used to generate the structured data.
	//
	// @default: ```
	// [
	//
	//	{
	//	  "role": "system",
	//	  "content": "You are an expert data extractor. You will be given a transcript of a call. Extract structured data per the JSON Schema. DO NOT return anything except the structured data.\n\nJson Schema:\\n{{schema}}\n\nOnly respond with the JSON."
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here is the transcript:\n\n{{transcript}}\n\n. Here is the ended reason of the call:\n\n{{endedReason}}\n\n"
	//	}
	//
	// ]```
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	// - {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{schema}}: the schema of the structured data from `structuredDataPlan.schema`- {{endedReason}}: the ended reason of the call from `call.endedReason`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether structured data is generated and stored in `call.analysis.structuredData`. Defaults to false.
	//
	// Usage:
	// - If you want to extract structured data, set this to true and provide a `schema`.
	//
	// @default false
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the schema of the structured data. The output is stored in `call.analysis.structuredData`.
	//
	// Complete guide on JSON Schema can be found [here](https://ajv.js.org/json-schema.html#json-data-type).
	Schema *JsonSchema `json:"schema,omitempty" url:"schema,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.structuredData` will be empty.
	//
	// Usage:
	// - To guarantee the structured data is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StructuredDataPlan) GetMessages() []map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *StructuredDataPlan) GetEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *StructuredDataPlan) GetSchema() *JsonSchema {
	if s == nil {
		return nil
	}
	return s.Schema
}

func (s *StructuredDataPlan) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *StructuredDataPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StructuredDataPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StructuredDataPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StructuredDataPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StructuredDataPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Subscription struct {
	// This is the unique identifier for the subscription.
	Id string `json:"id" url:"id"`
	// This is the timestamp when the subscription was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the timestamp when the subscription was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the type / tier of the subscription.
	Type SubscriptionType `json:"type" url:"type"`
	// This is the status of the subscription. Past due subscriptions are subscriptions
	// with past due payments.
	Status SubscriptionStatus `json:"status" url:"status"`
	// This is the number of credits the subscription currently has.
	//
	// Note: This is a string to avoid floating point precision issues.
	Credits string `json:"credits" url:"credits"`
	// This is the total number of active calls (concurrency) across all orgs under this subscription.
	ConcurrencyCounter float64 `json:"concurrencyCounter" url:"concurrencyCounter"`
	// This is the default concurrency limit for the subscription.
	ConcurrencyLimitIncluded float64 `json:"concurrencyLimitIncluded" url:"concurrencyLimitIncluded"`
	// This is the number of free phone numbers the subscription has
	PhoneNumbersCounter *float64 `json:"phoneNumbersCounter,omitempty" url:"phoneNumbersCounter,omitempty"`
	// This is the maximum number of free phone numbers the subscription can have
	PhoneNumbersIncluded *float64 `json:"phoneNumbersIncluded,omitempty" url:"phoneNumbersIncluded,omitempty"`
	// This is the purchased add-on concurrency limit for the subscription.
	ConcurrencyLimitPurchased float64 `json:"concurrencyLimitPurchased" url:"concurrencyLimitPurchased"`
	// This is the ID of the monthly job that charges for subscription add ons and phone numbers.
	MonthlyChargeScheduleId *float64 `json:"monthlyChargeScheduleId,omitempty" url:"monthlyChargeScheduleId,omitempty"`
	// This is the ID of the monthly job that checks whether the credit balance of the subscription
	// is sufficient for the monthly charge.
	MonthlyCreditCheckScheduleId *float64 `json:"monthlyCreditCheckScheduleId,omitempty" url:"monthlyCreditCheckScheduleId,omitempty"`
	// This is the Stripe customer ID.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	// This is the Stripe payment ID.
	StripePaymentMethodId *string `json:"stripePaymentMethodId,omitempty" url:"stripePaymentMethodId,omitempty"`
	// If this flag is true, then the user has purchased slack support.
	SlackSupportEnabled *bool `json:"slackSupportEnabled,omitempty" url:"slackSupportEnabled,omitempty"`
	// If this subscription has a slack support subscription, the slack channel's ID will be stored here.
	SlackChannelId *string `json:"slackChannelId,omitempty" url:"slackChannelId,omitempty"`
	// This is the HIPAA enabled flag for the subscription. It determines whether orgs under this
	// subscription have the option to enable HIPAA compliance.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the ID for the Common Paper agreement outlining the HIPAA contract.
	HipaaCommonPaperAgreementId *string `json:"hipaaCommonPaperAgreementId,omitempty" url:"hipaaCommonPaperAgreementId,omitempty"`
	// This is the Stripe fingerprint of the payment method (card). It allows us
	// to detect users who try to abuse our system through multiple sign-ups.
	StripePaymentMethodFingerprint *string `json:"stripePaymentMethodFingerprint,omitempty" url:"stripePaymentMethodFingerprint,omitempty"`
	// This is the customer's email on Stripe.
	StripeCustomerEmail *string `json:"stripeCustomerEmail,omitempty" url:"stripeCustomerEmail,omitempty"`
	// This is the email of the referrer for the subscription.
	ReferredByEmail *string `json:"referredByEmail,omitempty" url:"referredByEmail,omitempty"`
	// This is the auto reload plan configured for the subscription.
	AutoReloadPlan *AutoReloadPlan `json:"autoReloadPlan,omitempty" url:"autoReloadPlan,omitempty"`
	// The number of minutes included in the subscription.
	MinutesIncluded *float64 `json:"minutesIncluded,omitempty" url:"minutesIncluded,omitempty"`
	// The number of minutes used in the subscription.
	MinutesUsed *float64 `json:"minutesUsed,omitempty" url:"minutesUsed,omitempty"`
	// This is the timestamp at which the number of monthly free minutes is scheduled to reset at.
	MinutesUsedNextResetAt *time.Time `json:"minutesUsedNextResetAt,omitempty" url:"minutesUsedNextResetAt,omitempty"`
	// The per minute charge on minutes that exceed the included minutes. Enterprise only.
	MinutesOverageCost *float64 `json:"minutesOverageCost,omitempty" url:"minutesOverageCost,omitempty"`
	// The list of providers included in the subscription. Enterprise only.
	ProvidersIncluded []string `json:"providersIncluded,omitempty" url:"providersIncluded,omitempty"`
	// The maximum number of outbound calls this subscription may make in a day. Resets every night.
	OutboundCallsDailyLimit *float64 `json:"outboundCallsDailyLimit,omitempty" url:"outboundCallsDailyLimit,omitempty"`
	// The current number of outbound calls the subscription has made in the current day.
	OutboundCallsCounter *float64 `json:"outboundCallsCounter,omitempty" url:"outboundCallsCounter,omitempty"`
	// This is the timestamp at which the outbound calls counter is scheduled to reset at.
	OutboundCallsCounterNextResetAt *time.Time `json:"outboundCallsCounterNextResetAt,omitempty" url:"outboundCallsCounterNextResetAt,omitempty"`
	// This is the IDs of the coupons applicable to this subscription.
	CouponIds []string `json:"couponIds,omitempty" url:"couponIds,omitempty"`
	// This is the number of credits left obtained from a coupon.
	CouponUsageLeft *string `json:"couponUsageLeft,omitempty" url:"couponUsageLeft,omitempty"`
	// This is the invoice plan for the subscription.
	InvoicePlan *InvoicePlan `json:"invoicePlan,omitempty" url:"invoicePlan,omitempty"`
	// This is the PCI enabled flag for the subscription. It determines whether orgs under this
	// subscription have the option to enable PCI compliance.
	PciEnabled *bool `json:"pciEnabled,omitempty" url:"pciEnabled,omitempty"`
	// This is the ID for the Common Paper agreement outlining the PCI contract.
	PciCommonPaperAgreementId *string `json:"pciCommonPaperAgreementId,omitempty" url:"pciCommonPaperAgreementId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Subscription) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *Subscription) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *Subscription) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *Subscription) GetType() SubscriptionType {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Subscription) GetStatus() SubscriptionStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *Subscription) GetCredits() string {
	if s == nil {
		return ""
	}
	return s.Credits
}

func (s *Subscription) GetConcurrencyCounter() float64 {
	if s == nil {
		return 0
	}
	return s.ConcurrencyCounter
}

func (s *Subscription) GetConcurrencyLimitIncluded() float64 {
	if s == nil {
		return 0
	}
	return s.ConcurrencyLimitIncluded
}

func (s *Subscription) GetPhoneNumbersCounter() *float64 {
	if s == nil {
		return nil
	}
	return s.PhoneNumbersCounter
}

func (s *Subscription) GetPhoneNumbersIncluded() *float64 {
	if s == nil {
		return nil
	}
	return s.PhoneNumbersIncluded
}

func (s *Subscription) GetConcurrencyLimitPurchased() float64 {
	if s == nil {
		return 0
	}
	return s.ConcurrencyLimitPurchased
}

func (s *Subscription) GetMonthlyChargeScheduleId() *float64 {
	if s == nil {
		return nil
	}
	return s.MonthlyChargeScheduleId
}

func (s *Subscription) GetMonthlyCreditCheckScheduleId() *float64 {
	if s == nil {
		return nil
	}
	return s.MonthlyCreditCheckScheduleId
}

func (s *Subscription) GetStripeCustomerId() *string {
	if s == nil {
		return nil
	}
	return s.StripeCustomerId
}

func (s *Subscription) GetStripePaymentMethodId() *string {
	if s == nil {
		return nil
	}
	return s.StripePaymentMethodId
}

func (s *Subscription) GetSlackSupportEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.SlackSupportEnabled
}

func (s *Subscription) GetSlackChannelId() *string {
	if s == nil {
		return nil
	}
	return s.SlackChannelId
}

func (s *Subscription) GetHipaaEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.HipaaEnabled
}

func (s *Subscription) GetHipaaCommonPaperAgreementId() *string {
	if s == nil {
		return nil
	}
	return s.HipaaCommonPaperAgreementId
}

func (s *Subscription) GetStripePaymentMethodFingerprint() *string {
	if s == nil {
		return nil
	}
	return s.StripePaymentMethodFingerprint
}

func (s *Subscription) GetStripeCustomerEmail() *string {
	if s == nil {
		return nil
	}
	return s.StripeCustomerEmail
}

func (s *Subscription) GetReferredByEmail() *string {
	if s == nil {
		return nil
	}
	return s.ReferredByEmail
}

func (s *Subscription) GetAutoReloadPlan() *AutoReloadPlan {
	if s == nil {
		return nil
	}
	return s.AutoReloadPlan
}

func (s *Subscription) GetMinutesIncluded() *float64 {
	if s == nil {
		return nil
	}
	return s.MinutesIncluded
}

func (s *Subscription) GetMinutesUsed() *float64 {
	if s == nil {
		return nil
	}
	return s.MinutesUsed
}

func (s *Subscription) GetMinutesUsedNextResetAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.MinutesUsedNextResetAt
}

func (s *Subscription) GetMinutesOverageCost() *float64 {
	if s == nil {
		return nil
	}
	return s.MinutesOverageCost
}

func (s *Subscription) GetProvidersIncluded() []string {
	if s == nil {
		return nil
	}
	return s.ProvidersIncluded
}

func (s *Subscription) GetOutboundCallsDailyLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.OutboundCallsDailyLimit
}

func (s *Subscription) GetOutboundCallsCounter() *float64 {
	if s == nil {
		return nil
	}
	return s.OutboundCallsCounter
}

func (s *Subscription) GetOutboundCallsCounterNextResetAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.OutboundCallsCounterNextResetAt
}

func (s *Subscription) GetCouponIds() []string {
	if s == nil {
		return nil
	}
	return s.CouponIds
}

func (s *Subscription) GetCouponUsageLeft() *string {
	if s == nil {
		return nil
	}
	return s.CouponUsageLeft
}

func (s *Subscription) GetInvoicePlan() *InvoicePlan {
	if s == nil {
		return nil
	}
	return s.InvoicePlan
}

func (s *Subscription) GetPciEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.PciEnabled
}

func (s *Subscription) GetPciCommonPaperAgreementId() *string {
	if s == nil {
		return nil
	}
	return s.PciCommonPaperAgreementId
}

func (s *Subscription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subscription) UnmarshalJSON(data []byte) error {
	type embed Subscription
	var unmarshaler = struct {
		embed
		CreatedAt                       *internal.DateTime `json:"createdAt"`
		UpdatedAt                       *internal.DateTime `json:"updatedAt"`
		MinutesUsedNextResetAt          *internal.DateTime `json:"minutesUsedNextResetAt,omitempty"`
		OutboundCallsCounterNextResetAt *internal.DateTime `json:"outboundCallsCounterNextResetAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Subscription(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.MinutesUsedNextResetAt = unmarshaler.MinutesUsedNextResetAt.TimePtr()
	s.OutboundCallsCounterNextResetAt = unmarshaler.OutboundCallsCounterNextResetAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Subscription) MarshalJSON() ([]byte, error) {
	type embed Subscription
	var marshaler = struct {
		embed
		CreatedAt                       *internal.DateTime `json:"createdAt"`
		UpdatedAt                       *internal.DateTime `json:"updatedAt"`
		MinutesUsedNextResetAt          *internal.DateTime `json:"minutesUsedNextResetAt,omitempty"`
		OutboundCallsCounterNextResetAt *internal.DateTime `json:"outboundCallsCounterNextResetAt,omitempty"`
	}{
		embed:                           embed(*s),
		CreatedAt:                       internal.NewDateTime(s.CreatedAt),
		UpdatedAt:                       internal.NewDateTime(s.UpdatedAt),
		MinutesUsedNextResetAt:          internal.NewOptionalDateTime(s.MinutesUsedNextResetAt),
		OutboundCallsCounterNextResetAt: internal.NewOptionalDateTime(s.OutboundCallsCounterNextResetAt),
	}
	return json.Marshal(marshaler)
}

func (s *Subscription) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the status of the subscription. Past due subscriptions are subscriptions
// with past due payments.
type SubscriptionStatus string

const (
	SubscriptionStatusActive SubscriptionStatus = "active"
	SubscriptionStatusFrozen SubscriptionStatus = "frozen"
)

func NewSubscriptionStatusFromString(s string) (SubscriptionStatus, error) {
	switch s {
	case "active":
		return SubscriptionStatusActive, nil
	case "frozen":
		return SubscriptionStatusFrozen, nil
	}
	var t SubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStatus) Ptr() *SubscriptionStatus {
	return &s
}

// This is the type / tier of the subscription.
type SubscriptionType string

const (
	SubscriptionTypeTrial      SubscriptionType = "trial"
	SubscriptionTypePayAsYouGo SubscriptionType = "pay-as-you-go"
	SubscriptionTypeEnterprise SubscriptionType = "enterprise"
)

func NewSubscriptionTypeFromString(s string) (SubscriptionType, error) {
	switch s {
	case "trial":
		return SubscriptionTypeTrial, nil
	case "pay-as-you-go":
		return SubscriptionTypePayAsYouGo, nil
	case "enterprise":
		return SubscriptionTypeEnterprise, nil
	}
	var t SubscriptionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionType) Ptr() *SubscriptionType {
	return &s
}

type SuccessEvaluationPlan struct {
	// This enforces the rubric of the evaluation. The output is stored in `call.analysis.successEvaluation`.
	//
	// Options include:
	// - 'NumericScale': A scale of 1 to 10.
	// - 'DescriptiveScale': A scale of Excellent, Good, Fair, Poor.
	// - 'Checklist': A checklist of criteria and their status.
	// - 'Matrix': A grid that evaluates multiple criteria across different performance levels.
	// - 'PercentageScale': A scale of 0% to 100%.
	// - 'LikertScale': A scale of Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree.
	// - 'AutomaticRubric': Automatically break down evaluation into several criteria, each with its own score.
	// - 'PassFail': A simple 'true' if call passed, 'false' if not.
	//
	// Default is 'PassFail'.
	Rubric *SuccessEvaluationPlanRubric `json:"rubric,omitempty" url:"rubric,omitempty"`
	// These are the messages used to generate the success evaluation.
	//
	// @default: ```
	// [
	//
	//	{
	//	  "role": "system",
	//	  "content": "You are an expert call evaluator. You will be given a transcript of a call and the system prompt of the AI participant. Determine if the call was successful based on the objectives inferred from the system prompt. DO NOT return anything except the result.\n\nRubric:\\n{{rubric}}\n\nOnly respond with the result."
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here is the transcript:\n\n{{transcript}}\n\n"
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here was the system prompt of the call:\n\n{{systemPrompt}}\n\n. Here is the ended reason of the call:\n\n{{endedReason}}\n\n"
	//	}
	//
	// ]```
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	// - {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{rubric}}: the rubric of the success evaluation from `successEvaluationPlan.rubric`- {{endedReason}}: the ended reason of the call from `call.endedReason`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether a success evaluation is generated and stored in `call.analysis.successEvaluation`. Defaults to true.
	//
	// Usage:
	// - If you want to disable the success evaluation, set this to false.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.successEvaluation` will be empty.
	//
	// Usage:
	// - To guarantee the success evaluation is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessEvaluationPlan) GetRubric() *SuccessEvaluationPlanRubric {
	if s == nil {
		return nil
	}
	return s.Rubric
}

func (s *SuccessEvaluationPlan) GetMessages() []map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SuccessEvaluationPlan) GetEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *SuccessEvaluationPlan) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *SuccessEvaluationPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessEvaluationPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessEvaluationPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessEvaluationPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessEvaluationPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This enforces the rubric of the evaluation. The output is stored in `call.analysis.successEvaluation`.
//
// Options include:
// - 'NumericScale': A scale of 1 to 10.
// - 'DescriptiveScale': A scale of Excellent, Good, Fair, Poor.
// - 'Checklist': A checklist of criteria and their status.
// - 'Matrix': A grid that evaluates multiple criteria across different performance levels.
// - 'PercentageScale': A scale of 0% to 100%.
// - 'LikertScale': A scale of Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree.
// - 'AutomaticRubric': Automatically break down evaluation into several criteria, each with its own score.
// - 'PassFail': A simple 'true' if call passed, 'false' if not.
//
// Default is 'PassFail'.
type SuccessEvaluationPlanRubric string

const (
	SuccessEvaluationPlanRubricNumericScale     SuccessEvaluationPlanRubric = "NumericScale"
	SuccessEvaluationPlanRubricDescriptiveScale SuccessEvaluationPlanRubric = "DescriptiveScale"
	SuccessEvaluationPlanRubricChecklist        SuccessEvaluationPlanRubric = "Checklist"
	SuccessEvaluationPlanRubricMatrix           SuccessEvaluationPlanRubric = "Matrix"
	SuccessEvaluationPlanRubricPercentageScale  SuccessEvaluationPlanRubric = "PercentageScale"
	SuccessEvaluationPlanRubricLikertScale      SuccessEvaluationPlanRubric = "LikertScale"
	SuccessEvaluationPlanRubricAutomaticRubric  SuccessEvaluationPlanRubric = "AutomaticRubric"
	SuccessEvaluationPlanRubricPassFail         SuccessEvaluationPlanRubric = "PassFail"
)

func NewSuccessEvaluationPlanRubricFromString(s string) (SuccessEvaluationPlanRubric, error) {
	switch s {
	case "NumericScale":
		return SuccessEvaluationPlanRubricNumericScale, nil
	case "DescriptiveScale":
		return SuccessEvaluationPlanRubricDescriptiveScale, nil
	case "Checklist":
		return SuccessEvaluationPlanRubricChecklist, nil
	case "Matrix":
		return SuccessEvaluationPlanRubricMatrix, nil
	case "PercentageScale":
		return SuccessEvaluationPlanRubricPercentageScale, nil
	case "LikertScale":
		return SuccessEvaluationPlanRubricLikertScale, nil
	case "AutomaticRubric":
		return SuccessEvaluationPlanRubricAutomaticRubric, nil
	case "PassFail":
		return SuccessEvaluationPlanRubricPassFail, nil
	}
	var t SuccessEvaluationPlanRubric
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SuccessEvaluationPlanRubric) Ptr() *SuccessEvaluationPlanRubric {
	return &s
}

type SummaryPlan struct {
	// These are the messages used to generate the summary.
	//
	// @default: ```
	// [
	//
	//	{
	//	  "role": "system",
	//	  "content": "You are an expert note-taker. You will be given a transcript of a call. Summarize the call in 2-3 sentences. DO NOT return anything except the summary."
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here is the transcript:\n\n{{transcript}}\n\n. Here is the ended reason of the call:\n\n{{endedReason}}\n\n"
	//	}
	//
	// ]```
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	// - {{transcript}}: The transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: The system prompt of the call from `assistant.model.messages[type=system].content`- {{endedReason}}: The ended reason of the call from `call.endedReason`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether a summary is generated and stored in `call.analysis.summary`. Defaults to true.
	//
	// Usage:
	// - If you want to disable the summary, set this to false.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.summary` will be empty.
	//
	// Usage:
	// - To guarantee the summary is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SummaryPlan) GetMessages() []map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SummaryPlan) GetEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *SummaryPlan) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *SummaryPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SummaryPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SummaryPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummaryPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummaryPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SupabaseBucketPlan struct {
	// This is the S3 Region. It should look like us-east-1
	// It should be one of the supabase regions defined in the SUPABASE_REGION enum
	// Check https://supabase.com/docs/guides/platform/regions for up to date regions
	Region SupabaseBucketPlanRegion `json:"region" url:"region"`
	// This is the S3 compatible URL for Supabase S3
	// This should look like https://<project-ID>.supabase.co/storage/v1/s3
	Url string `json:"url" url:"url"`
	// This is the Supabase S3 Access Key ID.
	// The user creates this in the Supabase project Storage settings
	AccessKeyId string `json:"accessKeyId" url:"accessKeyId"`
	// This is the Supabase S3 Secret Access Key.
	// The user creates this in the Supabase project Storage settings along with the access key id
	SecretAccessKey string `json:"secretAccessKey" url:"secretAccessKey"`
	// This is the Supabase S3 Bucket Name.
	// The user must create this in Supabase under Storage > Buckets
	// A bucket that does not exist will not be checked now, but file uploads will fail
	Name string `json:"name" url:"name"`
	// This is the Supabase S3 Bucket Folder Path.
	// The user can create this in Supabase under Storage > Buckets
	// A path that does not exist will not be checked now, but file uploads will fail
	// A Path is like a folder in the bucket
	// Eg. If the bucket is called "my-bucket" and the path is "my-folder", the full path is "my-bucket/my-folder"
	Path *string `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SupabaseBucketPlan) GetRegion() SupabaseBucketPlanRegion {
	if s == nil {
		return ""
	}
	return s.Region
}

func (s *SupabaseBucketPlan) GetUrl() string {
	if s == nil {
		return ""
	}
	return s.Url
}

func (s *SupabaseBucketPlan) GetAccessKeyId() string {
	if s == nil {
		return ""
	}
	return s.AccessKeyId
}

func (s *SupabaseBucketPlan) GetSecretAccessKey() string {
	if s == nil {
		return ""
	}
	return s.SecretAccessKey
}

func (s *SupabaseBucketPlan) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SupabaseBucketPlan) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *SupabaseBucketPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SupabaseBucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SupabaseBucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SupabaseBucketPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SupabaseBucketPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the S3 Region. It should look like us-east-1
// It should be one of the supabase regions defined in the SUPABASE_REGION enum
// Check https://supabase.com/docs/guides/platform/regions for up to date regions
type SupabaseBucketPlanRegion string

const (
	SupabaseBucketPlanRegionUsWest1      SupabaseBucketPlanRegion = "us-west-1"
	SupabaseBucketPlanRegionUsEast1      SupabaseBucketPlanRegion = "us-east-1"
	SupabaseBucketPlanRegionUsEast2      SupabaseBucketPlanRegion = "us-east-2"
	SupabaseBucketPlanRegionCaCentral1   SupabaseBucketPlanRegion = "ca-central-1"
	SupabaseBucketPlanRegionEuWest1      SupabaseBucketPlanRegion = "eu-west-1"
	SupabaseBucketPlanRegionEuWest2      SupabaseBucketPlanRegion = "eu-west-2"
	SupabaseBucketPlanRegionEuWest3      SupabaseBucketPlanRegion = "eu-west-3"
	SupabaseBucketPlanRegionEuCentral1   SupabaseBucketPlanRegion = "eu-central-1"
	SupabaseBucketPlanRegionEuCentral2   SupabaseBucketPlanRegion = "eu-central-2"
	SupabaseBucketPlanRegionEuNorth1     SupabaseBucketPlanRegion = "eu-north-1"
	SupabaseBucketPlanRegionApSouth1     SupabaseBucketPlanRegion = "ap-south-1"
	SupabaseBucketPlanRegionApSoutheast1 SupabaseBucketPlanRegion = "ap-southeast-1"
	SupabaseBucketPlanRegionApNortheast1 SupabaseBucketPlanRegion = "ap-northeast-1"
	SupabaseBucketPlanRegionApNortheast2 SupabaseBucketPlanRegion = "ap-northeast-2"
	SupabaseBucketPlanRegionApSoutheast2 SupabaseBucketPlanRegion = "ap-southeast-2"
	SupabaseBucketPlanRegionSaEast1      SupabaseBucketPlanRegion = "sa-east-1"
)

func NewSupabaseBucketPlanRegionFromString(s string) (SupabaseBucketPlanRegion, error) {
	switch s {
	case "us-west-1":
		return SupabaseBucketPlanRegionUsWest1, nil
	case "us-east-1":
		return SupabaseBucketPlanRegionUsEast1, nil
	case "us-east-2":
		return SupabaseBucketPlanRegionUsEast2, nil
	case "ca-central-1":
		return SupabaseBucketPlanRegionCaCentral1, nil
	case "eu-west-1":
		return SupabaseBucketPlanRegionEuWest1, nil
	case "eu-west-2":
		return SupabaseBucketPlanRegionEuWest2, nil
	case "eu-west-3":
		return SupabaseBucketPlanRegionEuWest3, nil
	case "eu-central-1":
		return SupabaseBucketPlanRegionEuCentral1, nil
	case "eu-central-2":
		return SupabaseBucketPlanRegionEuCentral2, nil
	case "eu-north-1":
		return SupabaseBucketPlanRegionEuNorth1, nil
	case "ap-south-1":
		return SupabaseBucketPlanRegionApSouth1, nil
	case "ap-southeast-1":
		return SupabaseBucketPlanRegionApSoutheast1, nil
	case "ap-northeast-1":
		return SupabaseBucketPlanRegionApNortheast1, nil
	case "ap-northeast-2":
		return SupabaseBucketPlanRegionApNortheast2, nil
	case "ap-southeast-2":
		return SupabaseBucketPlanRegionApSoutheast2, nil
	case "sa-east-1":
		return SupabaseBucketPlanRegionSaEast1, nil
	}
	var t SupabaseBucketPlanRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SupabaseBucketPlanRegion) Ptr() *SupabaseBucketPlanRegion {
	return &s
}

type SupabaseCredential struct {
	// This is for supabase storage.
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name       *string             `json:"name,omitempty" url:"name,omitempty"`
	BucketPlan *SupabaseBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SupabaseCredential) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SupabaseCredential) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SupabaseCredential) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SupabaseCredential) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SupabaseCredential) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SupabaseCredential) GetBucketPlan() *SupabaseBucketPlan {
	if s == nil {
		return nil
	}
	return s.BucketPlan
}

func (s *SupabaseCredential) Provider() string {
	return s.provider
}

func (s *SupabaseCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SupabaseCredential) UnmarshalJSON(data []byte) error {
	type embed SupabaseCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SupabaseCredential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "supabase" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "supabase", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SupabaseCredential) MarshalJSON() ([]byte, error) {
	type embed SupabaseCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Provider:  "supabase",
	}
	return json.Marshal(marshaler)
}

func (s *SupabaseCredential) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncVoiceLibraryDto struct {
	// List of providers you want to sync.
	Providers []SyncVoiceLibraryDtoProvidersItem `json:"providers,omitempty" url:"providers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncVoiceLibraryDto) GetProviders() []SyncVoiceLibraryDtoProvidersItem {
	if s == nil {
		return nil
	}
	return s.Providers
}

func (s *SyncVoiceLibraryDto) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncVoiceLibraryDto) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncVoiceLibraryDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncVoiceLibraryDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncVoiceLibraryDto) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncVoiceLibraryDtoProvidersItem string

const (
	SyncVoiceLibraryDtoProvidersItemVapi        SyncVoiceLibraryDtoProvidersItem = "vapi"
	SyncVoiceLibraryDtoProvidersItemElevenLabs  SyncVoiceLibraryDtoProvidersItem = "11labs"
	SyncVoiceLibraryDtoProvidersItemAzure       SyncVoiceLibraryDtoProvidersItem = "azure"
	SyncVoiceLibraryDtoProvidersItemCartesia    SyncVoiceLibraryDtoProvidersItem = "cartesia"
	SyncVoiceLibraryDtoProvidersItemCustomVoice SyncVoiceLibraryDtoProvidersItem = "custom-voice"
	SyncVoiceLibraryDtoProvidersItemDeepgram    SyncVoiceLibraryDtoProvidersItem = "deepgram"
	SyncVoiceLibraryDtoProvidersItemHume        SyncVoiceLibraryDtoProvidersItem = "hume"
	SyncVoiceLibraryDtoProvidersItemLmnt        SyncVoiceLibraryDtoProvidersItem = "lmnt"
	SyncVoiceLibraryDtoProvidersItemNeuphonic   SyncVoiceLibraryDtoProvidersItem = "neuphonic"
	SyncVoiceLibraryDtoProvidersItemOpenai      SyncVoiceLibraryDtoProvidersItem = "openai"
	SyncVoiceLibraryDtoProvidersItemPlayht      SyncVoiceLibraryDtoProvidersItem = "playht"
	SyncVoiceLibraryDtoProvidersItemRimeAi      SyncVoiceLibraryDtoProvidersItem = "rime-ai"
	SyncVoiceLibraryDtoProvidersItemSmallestAi  SyncVoiceLibraryDtoProvidersItem = "smallest-ai"
	SyncVoiceLibraryDtoProvidersItemTavus       SyncVoiceLibraryDtoProvidersItem = "tavus"
	SyncVoiceLibraryDtoProvidersItemSesame      SyncVoiceLibraryDtoProvidersItem = "sesame"
)

func NewSyncVoiceLibraryDtoProvidersItemFromString(s string) (SyncVoiceLibraryDtoProvidersItem, error) {
	switch s {
	case "vapi":
		return SyncVoiceLibraryDtoProvidersItemVapi, nil
	case "11labs":
		return SyncVoiceLibraryDtoProvidersItemElevenLabs, nil
	case "azure":
		return SyncVoiceLibraryDtoProvidersItemAzure, nil
	case "cartesia":
		return SyncVoiceLibraryDtoProvidersItemCartesia, nil
	case "custom-voice":
		return SyncVoiceLibraryDtoProvidersItemCustomVoice, nil
	case "deepgram":
		return SyncVoiceLibraryDtoProvidersItemDeepgram, nil
	case "hume":
		return SyncVoiceLibraryDtoProvidersItemHume, nil
	case "lmnt":
		return SyncVoiceLibraryDtoProvidersItemLmnt, nil
	case "neuphonic":
		return SyncVoiceLibraryDtoProvidersItemNeuphonic, nil
	case "openai":
		return SyncVoiceLibraryDtoProvidersItemOpenai, nil
	case "playht":
		return SyncVoiceLibraryDtoProvidersItemPlayht, nil
	case "rime-ai":
		return SyncVoiceLibraryDtoProvidersItemRimeAi, nil
	case "smallest-ai":
		return SyncVoiceLibraryDtoProvidersItemSmallestAi, nil
	case "tavus":
		return SyncVoiceLibraryDtoProvidersItemTavus, nil
	case "sesame":
		return SyncVoiceLibraryDtoProvidersItemSesame, nil
	}
	var t SyncVoiceLibraryDtoProvidersItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncVoiceLibraryDtoProvidersItem) Ptr() *SyncVoiceLibraryDtoProvidersItem {
	return &s
}

type SystemMessage struct {
	// The role of the system in the conversation.
	Role string `json:"role" url:"role"`
	// The message content from the system.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SystemMessage) GetRole() string {
	if s == nil {
		return ""
	}
	return s.Role
}

func (s *SystemMessage) GetMessage() string {
	if s == nil {
		return ""
	}
	return s.Message
}

func (s *SystemMessage) GetTime() float64 {
	if s == nil {
		return 0
	}
	return s.Time
}

func (s *SystemMessage) GetSecondsFromStart() float64 {
	if s == nil {
		return 0
	}
	return s.SecondsFromStart
}

func (s *SystemMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SystemMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemMessage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TalkscriberTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
	Language *TalkscriberTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackTranscriberPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TalkscriberTranscriber) GetLanguage() *TalkscriberTranscriberLanguage {
	if t == nil {
		return nil
	}
	return t.Language
}

func (t *TalkscriberTranscriber) GetFallbackPlan() *FallbackTranscriberPlan {
	if t == nil {
		return nil
	}
	return t.FallbackPlan
}

func (t *TalkscriberTranscriber) Provider() string {
	return t.provider
}

func (t *TalkscriberTranscriber) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TalkscriberTranscriber) UnmarshalJSON(data []byte) error {
	type embed TalkscriberTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TalkscriberTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "talkscriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "talkscriber", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TalkscriberTranscriber) MarshalJSON() ([]byte, error) {
	type embed TalkscriberTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "talkscriber",
	}
	return json.Marshal(marshaler)
}

func (t *TalkscriberTranscriber) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
type TalkscriberTranscriberLanguage string

const (
	TalkscriberTranscriberLanguageEn  TalkscriberTranscriberLanguage = "en"
	TalkscriberTranscriberLanguageZh  TalkscriberTranscriberLanguage = "zh"
	TalkscriberTranscriberLanguageDe  TalkscriberTranscriberLanguage = "de"
	TalkscriberTranscriberLanguageEs  TalkscriberTranscriberLanguage = "es"
	TalkscriberTranscriberLanguageRu  TalkscriberTranscriberLanguage = "ru"
	TalkscriberTranscriberLanguageKo  TalkscriberTranscriberLanguage = "ko"
	TalkscriberTranscriberLanguageFr  TalkscriberTranscriberLanguage = "fr"
	TalkscriberTranscriberLanguageJa  TalkscriberTranscriberLanguage = "ja"
	TalkscriberTranscriberLanguagePt  TalkscriberTranscriberLanguage = "pt"
	TalkscriberTranscriberLanguageTr  TalkscriberTranscriberLanguage = "tr"
	TalkscriberTranscriberLanguagePl  TalkscriberTranscriberLanguage = "pl"
	TalkscriberTranscriberLanguageCa  TalkscriberTranscriberLanguage = "ca"
	TalkscriberTranscriberLanguageNl  TalkscriberTranscriberLanguage = "nl"
	TalkscriberTranscriberLanguageAr  TalkscriberTranscriberLanguage = "ar"
	TalkscriberTranscriberLanguageSv  TalkscriberTranscriberLanguage = "sv"
	TalkscriberTranscriberLanguageIt  TalkscriberTranscriberLanguage = "it"
	TalkscriberTranscriberLanguageId  TalkscriberTranscriberLanguage = "id"
	TalkscriberTranscriberLanguageHi  TalkscriberTranscriberLanguage = "hi"
	TalkscriberTranscriberLanguageFi  TalkscriberTranscriberLanguage = "fi"
	TalkscriberTranscriberLanguageVi  TalkscriberTranscriberLanguage = "vi"
	TalkscriberTranscriberLanguageHe  TalkscriberTranscriberLanguage = "he"
	TalkscriberTranscriberLanguageUk  TalkscriberTranscriberLanguage = "uk"
	TalkscriberTranscriberLanguageEl  TalkscriberTranscriberLanguage = "el"
	TalkscriberTranscriberLanguageMs  TalkscriberTranscriberLanguage = "ms"
	TalkscriberTranscriberLanguageCs  TalkscriberTranscriberLanguage = "cs"
	TalkscriberTranscriberLanguageRo  TalkscriberTranscriberLanguage = "ro"
	TalkscriberTranscriberLanguageDa  TalkscriberTranscriberLanguage = "da"
	TalkscriberTranscriberLanguageHu  TalkscriberTranscriberLanguage = "hu"
	TalkscriberTranscriberLanguageTa  TalkscriberTranscriberLanguage = "ta"
	TalkscriberTranscriberLanguageNo  TalkscriberTranscriberLanguage = "no"
	TalkscriberTranscriberLanguageTh  TalkscriberTranscriberLanguage = "th"
	TalkscriberTranscriberLanguageUr  TalkscriberTranscriberLanguage = "ur"
	TalkscriberTranscriberLanguageHr  TalkscriberTranscriberLanguage = "hr"
	TalkscriberTranscriberLanguageBg  TalkscriberTranscriberLanguage = "bg"
	TalkscriberTranscriberLanguageLt  TalkscriberTranscriberLanguage = "lt"
	TalkscriberTranscriberLanguageLa  TalkscriberTranscriberLanguage = "la"
	TalkscriberTranscriberLanguageMi  TalkscriberTranscriberLanguage = "mi"
	TalkscriberTranscriberLanguageMl  TalkscriberTranscriberLanguage = "ml"
	TalkscriberTranscriberLanguageCy  TalkscriberTranscriberLanguage = "cy"
	TalkscriberTranscriberLanguageSk  TalkscriberTranscriberLanguage = "sk"
	TalkscriberTranscriberLanguageTe  TalkscriberTranscriberLanguage = "te"
	TalkscriberTranscriberLanguageFa  TalkscriberTranscriberLanguage = "fa"
	TalkscriberTranscriberLanguageLv  TalkscriberTranscriberLanguage = "lv"
	TalkscriberTranscriberLanguageBn  TalkscriberTranscriberLanguage = "bn"
	TalkscriberTranscriberLanguageSr  TalkscriberTranscriberLanguage = "sr"
	TalkscriberTranscriberLanguageAz  TalkscriberTranscriberLanguage = "az"
	TalkscriberTranscriberLanguageSl  TalkscriberTranscriberLanguage = "sl"
	TalkscriberTranscriberLanguageKn  TalkscriberTranscriberLanguage = "kn"
	TalkscriberTranscriberLanguageEt  TalkscriberTranscriberLanguage = "et"
	TalkscriberTranscriberLanguageMk  TalkscriberTranscriberLanguage = "mk"
	TalkscriberTranscriberLanguageBr  TalkscriberTranscriberLanguage = "br"
	TalkscriberTranscriberLanguageEu  TalkscriberTranscriberLanguage = "eu"
	TalkscriberTranscriberLanguageIs  TalkscriberTranscriberLanguage = "is"
	TalkscriberTranscriberLanguageHy  TalkscriberTranscriberLanguage = "hy"
	TalkscriberTranscriberLanguageNe  TalkscriberTranscriberLanguage = "ne"
	TalkscriberTranscriberLanguageMn  TalkscriberTranscriberLanguage = "mn"
	TalkscriberTranscriberLanguageBs  TalkscriberTranscriberLanguage = "bs"
	TalkscriberTranscriberLanguageKk  TalkscriberTranscriberLanguage = "kk"
	TalkscriberTranscriberLanguageSq  TalkscriberTranscriberLanguage = "sq"
	TalkscriberTranscriberLanguageSw  TalkscriberTranscriberLanguage = "sw"
	TalkscriberTranscriberLanguageGl  TalkscriberTranscriberLanguage = "gl"
	TalkscriberTranscriberLanguageMr  TalkscriberTranscriberLanguage = "mr"
	TalkscriberTranscriberLanguagePa  TalkscriberTranscriberLanguage = "pa"
	TalkscriberTranscriberLanguageSi  TalkscriberTranscriberLanguage = "si"
	TalkscriberTranscriberLanguageKm  TalkscriberTranscriberLanguage = "km"
	TalkscriberTranscriberLanguageSn  TalkscriberTranscriberLanguage = "sn"
	TalkscriberTranscriberLanguageYo  TalkscriberTranscriberLanguage = "yo"
	TalkscriberTranscriberLanguageSo  TalkscriberTranscriberLanguage = "so"
	TalkscriberTranscriberLanguageAf  TalkscriberTranscriberLanguage = "af"
	TalkscriberTranscriberLanguageOc  TalkscriberTranscriberLanguage = "oc"
	TalkscriberTranscriberLanguageKa  TalkscriberTranscriberLanguage = "ka"
	TalkscriberTranscriberLanguageBe  TalkscriberTranscriberLanguage = "be"
	TalkscriberTranscriberLanguageTg  TalkscriberTranscriberLanguage = "tg"
	TalkscriberTranscriberLanguageSd  TalkscriberTranscriberLanguage = "sd"
	TalkscriberTranscriberLanguageGu  TalkscriberTranscriberLanguage = "gu"
	TalkscriberTranscriberLanguageAm  TalkscriberTranscriberLanguage = "am"
	TalkscriberTranscriberLanguageYi  TalkscriberTranscriberLanguage = "yi"
	TalkscriberTranscriberLanguageLo  TalkscriberTranscriberLanguage = "lo"
	TalkscriberTranscriberLanguageUz  TalkscriberTranscriberLanguage = "uz"
	TalkscriberTranscriberLanguageFo  TalkscriberTranscriberLanguage = "fo"
	TalkscriberTranscriberLanguageHt  TalkscriberTranscriberLanguage = "ht"
	TalkscriberTranscriberLanguagePs  TalkscriberTranscriberLanguage = "ps"
	TalkscriberTranscriberLanguageTk  TalkscriberTranscriberLanguage = "tk"
	TalkscriberTranscriberLanguageNn  TalkscriberTranscriberLanguage = "nn"
	TalkscriberTranscriberLanguageMt  TalkscriberTranscriberLanguage = "mt"
	TalkscriberTranscriberLanguageSa  TalkscriberTranscriberLanguage = "sa"
	TalkscriberTranscriberLanguageLb  TalkscriberTranscriberLanguage = "lb"
	TalkscriberTranscriberLanguageMy  TalkscriberTranscriberLanguage = "my"
	TalkscriberTranscriberLanguageBo  TalkscriberTranscriberLanguage = "bo"
	TalkscriberTranscriberLanguageTl  TalkscriberTranscriberLanguage = "tl"
	TalkscriberTranscriberLanguageMg  TalkscriberTranscriberLanguage = "mg"
	TalkscriberTranscriberLanguageAs  TalkscriberTranscriberLanguage = "as"
	TalkscriberTranscriberLanguageTt  TalkscriberTranscriberLanguage = "tt"
	TalkscriberTranscriberLanguageHaw TalkscriberTranscriberLanguage = "haw"
	TalkscriberTranscriberLanguageLn  TalkscriberTranscriberLanguage = "ln"
	TalkscriberTranscriberLanguageHa  TalkscriberTranscriberLanguage = "ha"
	TalkscriberTranscriberLanguageBa  TalkscriberTranscriberLanguage = "ba"
	TalkscriberTranscriberLanguageJw  TalkscriberTranscriberLanguage = "jw"
	TalkscriberTranscriberLanguageSu  TalkscriberTranscriberLanguage = "su"
	TalkscriberTranscriberLanguageYue TalkscriberTranscriberLanguage = "yue"
)

func NewTalkscriberTranscriberLanguageFromString(s string) (TalkscriberTranscriberLanguage, error) {
	switch s {
	case "en":
		return TalkscriberTranscriberLanguageEn, nil
	case "zh":
		return TalkscriberTranscriberLanguageZh, nil
	case "de":
		return TalkscriberTranscriberLanguageDe, nil
	case "es":
		return TalkscriberTranscriberLanguageEs, nil
	case "ru":
		return TalkscriberTranscriberLanguageRu, nil
	case "ko":
		return TalkscriberTranscriberLanguageKo, nil
	case "fr":
		return TalkscriberTranscriberLanguageFr, nil
	case "ja":
		return TalkscriberTranscriberLanguageJa, nil
	case "pt":
		return TalkscriberTranscriberLanguagePt, nil
	case "tr":
		return TalkscriberTranscriberLanguageTr, nil
	case "pl":
		return TalkscriberTranscriberLanguagePl, nil
	case "ca":
		return TalkscriberTranscriberLanguageCa, nil
	case "nl":
		return TalkscriberTranscriberLanguageNl, nil
	case "ar":
		return TalkscriberTranscriberLanguageAr, nil
	case "sv":
		return TalkscriberTranscriberLanguageSv, nil
	case "it":
		return TalkscriberTranscriberLanguageIt, nil
	case "id":
		return TalkscriberTranscriberLanguageId, nil
	case "hi":
		return TalkscriberTranscriberLanguageHi, nil
	case "fi":
		return TalkscriberTranscriberLanguageFi, nil
	case "vi":
		return TalkscriberTranscriberLanguageVi, nil
	case "he":
		return TalkscriberTranscriberLanguageHe, nil
	case "uk":
		return TalkscriberTranscriberLanguageUk, nil
	case "el":
		return TalkscriberTranscriberLanguageEl, nil
	case "ms":
		return TalkscriberTranscriberLanguageMs, nil
	case "cs":
		return TalkscriberTranscriberLanguageCs, nil
	case "ro":
		return TalkscriberTranscriberLanguageRo, nil
	case "da":
		return TalkscriberTranscriberLanguageDa, nil
	case "hu":
		return TalkscriberTranscriberLanguageHu, nil
	case "ta":
		return TalkscriberTranscriberLanguageTa, nil
	case "no":
		return TalkscriberTranscriberLanguageNo, nil
	case "th":
		return TalkscriberTranscriberLanguageTh, nil
	case "ur":
		return TalkscriberTranscriberLanguageUr, nil
	case "hr":
		return TalkscriberTranscriberLanguageHr, nil
	case "bg":
		return TalkscriberTranscriberLanguageBg, nil
	case "lt":
		return TalkscriberTranscriberLanguageLt, nil
	case "la":
		return TalkscriberTranscriberLanguageLa, nil
	case "mi":
		return TalkscriberTranscriberLanguageMi, nil
	case "ml":
		return TalkscriberTranscriberLanguageMl, nil
	case "cy":
		return TalkscriberTranscriberLanguageCy, nil
	case "sk":
		return TalkscriberTranscriberLanguageSk, nil
	case "te":
		return TalkscriberTranscriberLanguageTe, nil
	case "fa":
		return TalkscriberTranscriberLanguageFa, nil
	case "lv":
		return TalkscriberTranscriberLanguageLv, nil
	case "bn":
		return TalkscriberTranscriberLanguageBn, nil
	case "sr":
		return TalkscriberTranscriberLanguageSr, nil
	case "az":
		return TalkscriberTranscriberLanguageAz, nil
	case "sl":
		return TalkscriberTranscriberLanguageSl, nil
	case "kn":
		return TalkscriberTranscriberLanguageKn, nil
	case "et":
		return TalkscriberTranscriberLanguageEt, nil
	case "mk":
		return TalkscriberTranscriberLanguageMk, nil
	case "br":
		return TalkscriberTranscriberLanguageBr, nil
	case "eu":
		return TalkscriberTranscriberLanguageEu, nil
	case "is":
		return TalkscriberTranscriberLanguageIs, nil
	case "hy":
		return TalkscriberTranscriberLanguageHy, nil
	case "ne":
		return TalkscriberTranscriberLanguageNe, nil
	case "mn":
		return TalkscriberTranscriberLanguageMn, nil
	case "bs":
		return TalkscriberTranscriberLanguageBs, nil
	case "kk":
		return TalkscriberTranscriberLanguageKk, nil
	case "sq":
		return TalkscriberTranscriberLanguageSq, nil
	case "sw":
		return TalkscriberTranscriberLanguageSw, nil
	case "gl":
		return TalkscriberTranscriberLanguageGl, nil
	case "mr":
		return TalkscriberTranscriberLanguageMr, nil
	case "pa":
		return TalkscriberTranscriberLanguagePa, nil
	case "si":
		return TalkscriberTranscriberLanguageSi, nil
	case "km":
		return TalkscriberTranscriberLanguageKm, nil
	case "sn":
		return TalkscriberTranscriberLanguageSn, nil
	case "yo":
		return TalkscriberTranscriberLanguageYo, nil
	case "so":
		return TalkscriberTranscriberLanguageSo, nil
	case "af":
		return TalkscriberTranscriberLanguageAf, nil
	case "oc":
		return TalkscriberTranscriberLanguageOc, nil
	case "ka":
		return TalkscriberTranscriberLanguageKa, nil
	case "be":
		return TalkscriberTranscriberLanguageBe, nil
	case "tg":
		return TalkscriberTranscriberLanguageTg, nil
	case "sd":
		return TalkscriberTranscriberLanguageSd, nil
	case "gu":
		return TalkscriberTranscriberLanguageGu, nil
	case "am":
		return TalkscriberTranscriberLanguageAm, nil
	case "yi":
		return TalkscriberTranscriberLanguageYi, nil
	case "lo":
		return TalkscriberTranscriberLanguageLo, nil
	case "uz":
		return TalkscriberTranscriberLanguageUz, nil
	case "fo":
		return TalkscriberTranscriberLanguageFo, nil
	case "ht":
		return TalkscriberTranscriberLanguageHt, nil
	case "ps":
		return TalkscriberTranscriberLanguagePs, nil
	case "tk":
		return TalkscriberTranscriberLanguageTk, nil
	case "nn":
		return TalkscriberTranscriberLanguageNn, nil
	case "mt":
		return TalkscriberTranscriberLanguageMt, nil
	case "sa":
		return TalkscriberTranscriberLanguageSa, nil
	case "lb":
		return TalkscriberTranscriberLanguageLb, nil
	case "my":
		return TalkscriberTranscriberLanguageMy, nil
	case "bo":
		return TalkscriberTranscriberLanguageBo, nil
	case "tl":
		return TalkscriberTranscriberLanguageTl, nil
	case "mg":
		return TalkscriberTranscriberLanguageMg, nil
	case "as":
		return TalkscriberTranscriberLanguageAs, nil
	case "tt":
		return TalkscriberTranscriberLanguageTt, nil
	case "haw":
		return TalkscriberTranscriberLanguageHaw, nil
	case "ln":
		return TalkscriberTranscriberLanguageLn, nil
	case "ha":
		return TalkscriberTranscriberLanguageHa, nil
	case "ba":
		return TalkscriberTranscriberLanguageBa, nil
	case "jw":
		return TalkscriberTranscriberLanguageJw, nil
	case "su":
		return TalkscriberTranscriberLanguageSu, nil
	case "yue":
		return TalkscriberTranscriberLanguageYue, nil
	}
	var t TalkscriberTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TalkscriberTranscriberLanguage) Ptr() *TalkscriberTranscriberLanguage {
	return &t
}

type TavusConversationProperties struct {
	// The maximum duration of the call in seconds. The default `maxCallDuration` is 3600 seconds (1 hour).
	// Once the time limit specified by this parameter has been reached, the conversation will automatically shut down.
	MaxCallDuration *float64 `json:"maxCallDuration,omitempty" url:"maxCallDuration,omitempty"`
	// The duration in seconds after which the call will be automatically shut down once the last participant leaves.
	ParticipantLeftTimeout *float64 `json:"participantLeftTimeout,omitempty" url:"participantLeftTimeout,omitempty"`
	// Starting from conversation creation, the duration in seconds after which the call will be automatically shut down if no participant joins the call.
	// Default is 300 seconds (5 minutes).
	ParticipantAbsentTimeout *float64 `json:"participantAbsentTimeout,omitempty" url:"participantAbsentTimeout,omitempty"`
	// If true, the user will be able to record the conversation.
	EnableRecording *bool `json:"enableRecording,omitempty" url:"enableRecording,omitempty"`
	// If true, the user will be able to transcribe the conversation.
	// You can find more instructions on displaying transcriptions if you are using your custom DailyJS components here.
	// You need to have an event listener on Daily that listens for `app-messages`.
	EnableTranscription *bool `json:"enableTranscription,omitempty" url:"enableTranscription,omitempty"`
	// If true, the background will be replaced with a greenscreen (RGB values: `[0, 255, 155]`).
	// You can use WebGL on the frontend to make the greenscreen transparent or change its color.
	ApplyGreenscreen *bool `json:"applyGreenscreen,omitempty" url:"applyGreenscreen,omitempty"`
	// The language of the conversation. Please provide the **full language name**, not the two-letter code.
	// If you are using your own TTS voice, please ensure it supports the language you provide.
	// If you are using a stock replica or default persona, please note that only ElevenLabs and Cartesia supported languages are available.
	// You can find a full list of supported languages for Cartesia here, for ElevenLabs here, and for PlayHT here.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the S3 bucket where the recording will be stored.
	RecordingS3BucketName *string `json:"recordingS3BucketName,omitempty" url:"recordingS3BucketName,omitempty"`
	// The region of the S3 bucket where the recording will be stored.
	RecordingS3BucketRegion *string `json:"recordingS3BucketRegion,omitempty" url:"recordingS3BucketRegion,omitempty"`
	// The ARN of the role that will be assumed to access the S3 bucket.
	AwsAssumeRoleArn *string `json:"awsAssumeRoleArn,omitempty" url:"awsAssumeRoleArn,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TavusConversationProperties) GetMaxCallDuration() *float64 {
	if t == nil {
		return nil
	}
	return t.MaxCallDuration
}

func (t *TavusConversationProperties) GetParticipantLeftTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.ParticipantLeftTimeout
}

func (t *TavusConversationProperties) GetParticipantAbsentTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.ParticipantAbsentTimeout
}

func (t *TavusConversationProperties) GetEnableRecording() *bool {
	if t == nil {
		return nil
	}
	return t.EnableRecording
}

func (t *TavusConversationProperties) GetEnableTranscription() *bool {
	if t == nil {
		return nil
	}
	return t.EnableTranscription
}

func (t *TavusConversationProperties) GetApplyGreenscreen() *bool {
	if t == nil {
		return nil
	}
	return t.ApplyGreenscreen
}

func (t *TavusConversationProperties) GetLanguage() *string {
	if t == nil {
		return nil
	}
	return t.Language
}

func (t *TavusConversationProperties) GetRecordingS3BucketName() *string {
	if t == nil {
		return nil
	}
	return t.RecordingS3BucketName
}

func (t *TavusConversationProperties) GetRecordingS3BucketRegion() *string {
	if t == nil {
		return nil
	}
	return t.RecordingS3BucketRegion
}

func (t *TavusConversationProperties) GetAwsAssumeRoleArn() *string {
	if t == nil {
		return nil
	}
	return t.AwsAssumeRoleArn
}

func (t *TavusConversationProperties) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TavusConversationProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler TavusConversationProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TavusConversationProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TavusConversationProperties) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TavusCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TavusCredential) GetApiKey() string {
	if t == nil {
		return ""
	}
	return t.ApiKey
}

func (t *TavusCredential) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TavusCredential) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TavusCredential) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TavusCredential) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TavusCredential) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TavusCredential) Provider() string {
	return t.provider
}

func (t *TavusCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TavusCredential) UnmarshalJSON(data []byte) error {
	type embed TavusCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TavusCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tavus", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TavusCredential) MarshalJSON() ([]byte, error) {
	type embed TavusCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Provider:  "tavus",
	}
	return json.Marshal(marshaler)
}

func (t *TavusCredential) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TavusVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *TavusVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the unique identifier for the persona that the replica will use in the conversation.
	PersonaId *string `json:"personaId,omitempty" url:"personaId,omitempty"`
	// This is the url that will receive webhooks with updates regarding the conversation state.
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// This is the name for the conversation.
	ConversationName *string `json:"conversationName,omitempty" url:"conversationName,omitempty"`
	// This is the context that will be appended to any context provided in the persona, if one is provided.
	ConversationalContext *string `json:"conversationalContext,omitempty" url:"conversationalContext,omitempty"`
	// This is the custom greeting that the replica will give once a participant joines the conversation.
	CustomGreeting *string `json:"customGreeting,omitempty" url:"customGreeting,omitempty"`
	// These are optional properties used to customize the conversation.
	Properties *TavusConversationProperties `json:"properties,omitempty" url:"properties,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TavusVoice) GetCachingEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.CachingEnabled
}

func (t *TavusVoice) GetVoiceId() *TavusVoiceVoiceId {
	if t == nil {
		return nil
	}
	return t.VoiceId
}

func (t *TavusVoice) GetChunkPlan() *ChunkPlan {
	if t == nil {
		return nil
	}
	return t.ChunkPlan
}

func (t *TavusVoice) GetPersonaId() *string {
	if t == nil {
		return nil
	}
	return t.PersonaId
}

func (t *TavusVoice) GetCallbackUrl() *string {
	if t == nil {
		return nil
	}
	return t.CallbackUrl
}

func (t *TavusVoice) GetConversationName() *string {
	if t == nil {
		return nil
	}
	return t.ConversationName
}

func (t *TavusVoice) GetConversationalContext() *string {
	if t == nil {
		return nil
	}
	return t.ConversationalContext
}

func (t *TavusVoice) GetCustomGreeting() *string {
	if t == nil {
		return nil
	}
	return t.CustomGreeting
}

func (t *TavusVoice) GetProperties() *TavusConversationProperties {
	if t == nil {
		return nil
	}
	return t.Properties
}

func (t *TavusVoice) GetFallbackPlan() *FallbackPlan {
	if t == nil {
		return nil
	}
	return t.FallbackPlan
}

func (t *TavusVoice) Provider() string {
	return t.provider
}

func (t *TavusVoice) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TavusVoice) UnmarshalJSON(data []byte) error {
	type embed TavusVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TavusVoice(unmarshaler.embed)
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tavus", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TavusVoice) MarshalJSON() ([]byte, error) {
	type embed TavusVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "tavus",
	}
	return json.Marshal(marshaler)
}

func (t *TavusVoice) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the provider-specific ID that will be used.
type TavusVoiceVoiceId struct {
	R52da2535aStringLiteral string
	String                  string

	typ string
}

func NewTavusVoiceVoiceIdWithR52da2535aStringLiteral() *TavusVoiceVoiceId {
	return &TavusVoiceVoiceId{typ: "R52da2535aStringLiteral", R52da2535aStringLiteral: "r52da2535a"}
}

func (t *TavusVoiceVoiceId) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TavusVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueR52da2535aStringLiteral string
	if err := json.Unmarshal(data, &valueR52da2535aStringLiteral); err == nil {
		t.typ = "R52da2535aStringLiteral"
		t.R52da2535aStringLiteral = valueR52da2535aStringLiteral
		if t.R52da2535aStringLiteral != "r52da2535a" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "r52da2535a", valueR52da2535aStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TavusVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if t.typ == "R52da2535aStringLiteral" || t.R52da2535aStringLiteral != "" {
		return json.Marshal("r52da2535a")
	}
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TavusVoiceVoiceIdVisitor interface {
	VisitR52da2535aStringLiteral(string) error
	VisitString(string) error
}

func (t *TavusVoiceVoiceId) Accept(visitor TavusVoiceVoiceIdVisitor) error {
	if t.typ == "R52da2535aStringLiteral" || t.R52da2535aStringLiteral != "" {
		return visitor.VisitR52da2535aStringLiteral(t.R52da2535aStringLiteral)
	}
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type Template struct {
	Details         *TemplateDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *TemplateProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata    `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *TemplateVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string           `json:"name,omitempty" url:"name,omitempty"`
	Provider *TemplateProvider `json:"provider,omitempty" url:"provider,omitempty"`
	// The unique identifier for the template.
	Id string `json:"id" url:"id"`
	// The unique identifier for the organization that this template belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// The ISO 8601 date-time string of when the template was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The ISO 8601 date-time string of when the template was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	type_     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Template) GetDetails() *TemplateDetails {
	if t == nil {
		return nil
	}
	return t.Details
}

func (t *Template) GetProviderDetails() *TemplateProviderDetails {
	if t == nil {
		return nil
	}
	return t.ProviderDetails
}

func (t *Template) GetMetadata() *ToolTemplateMetadata {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *Template) GetVisibility() *TemplateVisibility {
	if t == nil {
		return nil
	}
	return t.Visibility
}

func (t *Template) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *Template) GetProvider() *TemplateProvider {
	if t == nil {
		return nil
	}
	return t.Provider
}

func (t *Template) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *Template) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *Template) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *Template) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *Template) Type() string {
	return t.type_
}

func (t *Template) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Template) UnmarshalJSON(data []byte) error {
	type embed Template
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Template(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tool", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Template) MarshalJSON() ([]byte, error) {
	type embed Template
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "tool",
	}
	return json.Marshal(marshaler)
}

func (t *Template) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TemplateDetails struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (t *TemplateDetails) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if t == nil {
		return nil
	}
	return t.CreateApiRequestToolDto
}

func (t *TemplateDetails) GetCreateBashToolDto() *CreateBashToolDto {
	if t == nil {
		return nil
	}
	return t.CreateBashToolDto
}

func (t *TemplateDetails) GetCreateComputerToolDto() *CreateComputerToolDto {
	if t == nil {
		return nil
	}
	return t.CreateComputerToolDto
}

func (t *TemplateDetails) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if t == nil {
		return nil
	}
	return t.CreateDtmfToolDto
}

func (t *TemplateDetails) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateEndCallToolDto
}

func (t *TemplateDetails) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if t == nil {
		return nil
	}
	return t.CreateFunctionToolDto
}

func (t *TemplateDetails) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (t *TemplateDetails) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarEventCreateToolDto
}

func (t *TemplateDetails) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactCreateToolDto
}

func (t *TemplateDetails) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactGetToolDto
}

func (t *TemplateDetails) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (t *TemplateDetails) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCreateEventToolDto
}

func (t *TemplateDetails) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleSheetsRowAppendToolDto
}

func (t *TemplateDetails) GetCreateMcpToolDto() *CreateMcpToolDto {
	if t == nil {
		return nil
	}
	return t.CreateMcpToolDto
}

func (t *TemplateDetails) GetCreateQueryToolDto() *CreateQueryToolDto {
	if t == nil {
		return nil
	}
	return t.CreateQueryToolDto
}

func (t *TemplateDetails) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSlackSendMessageToolDto
}

func (t *TemplateDetails) GetCreateSmsToolDto() *CreateSmsToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSmsToolDto
}

func (t *TemplateDetails) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTextEditorToolDto
}

func (t *TemplateDetails) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTransferCallToolDto
}

func (t *TemplateDetails) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		t.typ = "CreateApiRequestToolDto"
		t.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		t.typ = "CreateBashToolDto"
		t.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		t.typ = "CreateComputerToolDto"
		t.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.typ = "CreateDtmfToolDto"
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.typ = "CreateEndCallToolDto"
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.typ = "CreateFunctionToolDto"
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		t.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		t.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactCreateToolDto"
		t.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactGetToolDto"
		t.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		t.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCreateEventToolDto"
		t.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		t.typ = "CreateGoogleSheetsRowAppendToolDto"
		t.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		t.typ = "CreateMcpToolDto"
		t.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		t.typ = "CreateQueryToolDto"
		t.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		t.typ = "CreateSlackSendMessageToolDto"
		t.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		t.typ = "CreateSmsToolDto"
		t.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		t.typ = "CreateTextEditorToolDto"
		t.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.typ = "CreateTransferCallToolDto"
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TemplateDetails) MarshalJSON() ([]byte, error) {
	if t.typ == "CreateApiRequestToolDto" || t.CreateApiRequestToolDto != nil {
		return json.Marshal(t.CreateApiRequestToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return json.Marshal(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return json.Marshal(t.CreateComputerToolDto)
	}
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactGetToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return json.Marshal(t.CreateMcpToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return json.Marshal(t.CreateQueryToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return json.Marshal(t.CreateSmsToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return json.Marshal(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateDetailsVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *TemplateDetails) Accept(visitor TemplateDetailsVisitor) error {
	if t.typ == "CreateApiRequestToolDto" || t.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(t.CreateApiRequestToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(t.CreateComputerToolDto)
	}
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(t.CreateGoHighLevelContactGetToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(t.CreateMcpToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(t.CreateQueryToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(t.CreateSmsToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateProvider string

const (
	TemplateProviderMake        TemplateProvider = "make"
	TemplateProviderGohighlevel TemplateProvider = "gohighlevel"
	TemplateProviderFunction    TemplateProvider = "function"
)

func NewTemplateProviderFromString(s string) (TemplateProvider, error) {
	switch s {
	case "make":
		return TemplateProviderMake, nil
	case "gohighlevel":
		return TemplateProviderGohighlevel, nil
	case "function":
		return TemplateProviderFunction, nil
	}
	var t TemplateProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemplateProvider) Ptr() *TemplateProvider {
	return &t
}

type TemplateProviderDetails struct {
	MakeToolProviderDetails                            *MakeToolProviderDetails
	GhlToolProviderDetails                             *GhlToolProviderDetails
	FunctionToolProviderDetails                        *FunctionToolProviderDetails
	GoogleCalendarCreateEventToolProviderDetails       *GoogleCalendarCreateEventToolProviderDetails
	GoogleSheetsRowAppendToolProviderDetails           *GoogleSheetsRowAppendToolProviderDetails
	GoHighLevelCalendarAvailabilityToolProviderDetails *GoHighLevelCalendarAvailabilityToolProviderDetails
	GoHighLevelCalendarEventCreateToolProviderDetails  *GoHighLevelCalendarEventCreateToolProviderDetails
	GoHighLevelContactCreateToolProviderDetails        *GoHighLevelContactCreateToolProviderDetails
	GoHighLevelContactGetToolProviderDetails           *GoHighLevelContactGetToolProviderDetails

	typ string
}

func (t *TemplateProviderDetails) GetMakeToolProviderDetails() *MakeToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.MakeToolProviderDetails
}

func (t *TemplateProviderDetails) GetGhlToolProviderDetails() *GhlToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GhlToolProviderDetails
}

func (t *TemplateProviderDetails) GetFunctionToolProviderDetails() *FunctionToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.FunctionToolProviderDetails
}

func (t *TemplateProviderDetails) GetGoogleCalendarCreateEventToolProviderDetails() *GoogleCalendarCreateEventToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCreateEventToolProviderDetails
}

func (t *TemplateProviderDetails) GetGoogleSheetsRowAppendToolProviderDetails() *GoogleSheetsRowAppendToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GoogleSheetsRowAppendToolProviderDetails
}

func (t *TemplateProviderDetails) GetGoHighLevelCalendarAvailabilityToolProviderDetails() *GoHighLevelCalendarAvailabilityToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarAvailabilityToolProviderDetails
}

func (t *TemplateProviderDetails) GetGoHighLevelCalendarEventCreateToolProviderDetails() *GoHighLevelCalendarEventCreateToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarEventCreateToolProviderDetails
}

func (t *TemplateProviderDetails) GetGoHighLevelContactCreateToolProviderDetails() *GoHighLevelContactCreateToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactCreateToolProviderDetails
}

func (t *TemplateProviderDetails) GetGoHighLevelContactGetToolProviderDetails() *GoHighLevelContactGetToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactGetToolProviderDetails
}

func (t *TemplateProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		t.typ = "MakeToolProviderDetails"
		t.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		t.typ = "GhlToolProviderDetails"
		t.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		t.typ = "FunctionToolProviderDetails"
		t.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	valueGoogleCalendarCreateEventToolProviderDetails := new(GoogleCalendarCreateEventToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventToolProviderDetails); err == nil {
		t.typ = "GoogleCalendarCreateEventToolProviderDetails"
		t.GoogleCalendarCreateEventToolProviderDetails = valueGoogleCalendarCreateEventToolProviderDetails
		return nil
	}
	valueGoogleSheetsRowAppendToolProviderDetails := new(GoogleSheetsRowAppendToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendToolProviderDetails); err == nil {
		t.typ = "GoogleSheetsRowAppendToolProviderDetails"
		t.GoogleSheetsRowAppendToolProviderDetails = valueGoogleSheetsRowAppendToolProviderDetails
		return nil
	}
	valueGoHighLevelCalendarAvailabilityToolProviderDetails := new(GoHighLevelCalendarAvailabilityToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityToolProviderDetails); err == nil {
		t.typ = "GoHighLevelCalendarAvailabilityToolProviderDetails"
		t.GoHighLevelCalendarAvailabilityToolProviderDetails = valueGoHighLevelCalendarAvailabilityToolProviderDetails
		return nil
	}
	valueGoHighLevelCalendarEventCreateToolProviderDetails := new(GoHighLevelCalendarEventCreateToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateToolProviderDetails); err == nil {
		t.typ = "GoHighLevelCalendarEventCreateToolProviderDetails"
		t.GoHighLevelCalendarEventCreateToolProviderDetails = valueGoHighLevelCalendarEventCreateToolProviderDetails
		return nil
	}
	valueGoHighLevelContactCreateToolProviderDetails := new(GoHighLevelContactCreateToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateToolProviderDetails); err == nil {
		t.typ = "GoHighLevelContactCreateToolProviderDetails"
		t.GoHighLevelContactCreateToolProviderDetails = valueGoHighLevelContactCreateToolProviderDetails
		return nil
	}
	valueGoHighLevelContactGetToolProviderDetails := new(GoHighLevelContactGetToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetToolProviderDetails); err == nil {
		t.typ = "GoHighLevelContactGetToolProviderDetails"
		t.GoHighLevelContactGetToolProviderDetails = valueGoHighLevelContactGetToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TemplateProviderDetails) MarshalJSON() ([]byte, error) {
	if t.typ == "MakeToolProviderDetails" || t.MakeToolProviderDetails != nil {
		return json.Marshal(t.MakeToolProviderDetails)
	}
	if t.typ == "GhlToolProviderDetails" || t.GhlToolProviderDetails != nil {
		return json.Marshal(t.GhlToolProviderDetails)
	}
	if t.typ == "FunctionToolProviderDetails" || t.FunctionToolProviderDetails != nil {
		return json.Marshal(t.FunctionToolProviderDetails)
	}
	if t.typ == "GoogleCalendarCreateEventToolProviderDetails" || t.GoogleCalendarCreateEventToolProviderDetails != nil {
		return json.Marshal(t.GoogleCalendarCreateEventToolProviderDetails)
	}
	if t.typ == "GoogleSheetsRowAppendToolProviderDetails" || t.GoogleSheetsRowAppendToolProviderDetails != nil {
		return json.Marshal(t.GoogleSheetsRowAppendToolProviderDetails)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityToolProviderDetails" || t.GoHighLevelCalendarAvailabilityToolProviderDetails != nil {
		return json.Marshal(t.GoHighLevelCalendarAvailabilityToolProviderDetails)
	}
	if t.typ == "GoHighLevelCalendarEventCreateToolProviderDetails" || t.GoHighLevelCalendarEventCreateToolProviderDetails != nil {
		return json.Marshal(t.GoHighLevelCalendarEventCreateToolProviderDetails)
	}
	if t.typ == "GoHighLevelContactCreateToolProviderDetails" || t.GoHighLevelContactCreateToolProviderDetails != nil {
		return json.Marshal(t.GoHighLevelContactCreateToolProviderDetails)
	}
	if t.typ == "GoHighLevelContactGetToolProviderDetails" || t.GoHighLevelContactGetToolProviderDetails != nil {
		return json.Marshal(t.GoHighLevelContactGetToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
	VisitGoogleCalendarCreateEventToolProviderDetails(*GoogleCalendarCreateEventToolProviderDetails) error
	VisitGoogleSheetsRowAppendToolProviderDetails(*GoogleSheetsRowAppendToolProviderDetails) error
	VisitGoHighLevelCalendarAvailabilityToolProviderDetails(*GoHighLevelCalendarAvailabilityToolProviderDetails) error
	VisitGoHighLevelCalendarEventCreateToolProviderDetails(*GoHighLevelCalendarEventCreateToolProviderDetails) error
	VisitGoHighLevelContactCreateToolProviderDetails(*GoHighLevelContactCreateToolProviderDetails) error
	VisitGoHighLevelContactGetToolProviderDetails(*GoHighLevelContactGetToolProviderDetails) error
}

func (t *TemplateProviderDetails) Accept(visitor TemplateProviderDetailsVisitor) error {
	if t.typ == "MakeToolProviderDetails" || t.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(t.MakeToolProviderDetails)
	}
	if t.typ == "GhlToolProviderDetails" || t.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(t.GhlToolProviderDetails)
	}
	if t.typ == "FunctionToolProviderDetails" || t.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(t.FunctionToolProviderDetails)
	}
	if t.typ == "GoogleCalendarCreateEventToolProviderDetails" || t.GoogleCalendarCreateEventToolProviderDetails != nil {
		return visitor.VisitGoogleCalendarCreateEventToolProviderDetails(t.GoogleCalendarCreateEventToolProviderDetails)
	}
	if t.typ == "GoogleSheetsRowAppendToolProviderDetails" || t.GoogleSheetsRowAppendToolProviderDetails != nil {
		return visitor.VisitGoogleSheetsRowAppendToolProviderDetails(t.GoogleSheetsRowAppendToolProviderDetails)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityToolProviderDetails" || t.GoHighLevelCalendarAvailabilityToolProviderDetails != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityToolProviderDetails(t.GoHighLevelCalendarAvailabilityToolProviderDetails)
	}
	if t.typ == "GoHighLevelCalendarEventCreateToolProviderDetails" || t.GoHighLevelCalendarEventCreateToolProviderDetails != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateToolProviderDetails(t.GoHighLevelCalendarEventCreateToolProviderDetails)
	}
	if t.typ == "GoHighLevelContactCreateToolProviderDetails" || t.GoHighLevelContactCreateToolProviderDetails != nil {
		return visitor.VisitGoHighLevelContactCreateToolProviderDetails(t.GoHighLevelContactCreateToolProviderDetails)
	}
	if t.typ == "GoHighLevelContactGetToolProviderDetails" || t.GoHighLevelContactGetToolProviderDetails != nil {
		return visitor.VisitGoHighLevelContactGetToolProviderDetails(t.GoHighLevelContactGetToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateVisibility string

const (
	TemplateVisibilityPublic  TemplateVisibility = "public"
	TemplateVisibilityPrivate TemplateVisibility = "private"
)

func NewTemplateVisibilityFromString(s string) (TemplateVisibility, error) {
	switch s {
	case "public":
		return TemplateVisibilityPublic, nil
	case "private":
		return TemplateVisibilityPrivate, nil
	}
	var t TemplateVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemplateVisibility) Ptr() *TemplateVisibility {
	return &t
}

type TestSuiteTestScorerAi struct {
	// This is the type of the scorer, which must be AI.
	// This is the rubric used by the AI scorer.
	Rubric string `json:"rubric" url:"rubric"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TestSuiteTestScorerAi) GetRubric() string {
	if t == nil {
		return ""
	}
	return t.Rubric
}

func (t *TestSuiteTestScorerAi) Type() string {
	return t.type_
}

func (t *TestSuiteTestScorerAi) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestSuiteTestScorerAi) UnmarshalJSON(data []byte) error {
	type embed TestSuiteTestScorerAi
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TestSuiteTestScorerAi(unmarshaler.embed)
	if unmarshaler.Type != "ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "ai", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestSuiteTestScorerAi) MarshalJSON() ([]byte, error) {
	type embed TestSuiteTestScorerAi
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "ai",
	}
	return json.Marshal(marshaler)
}

func (t *TestSuiteTestScorerAi) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TestSuiteTestVoice struct {
	// These are the scorers used to evaluate the test.
	Scorers []*TestSuiteTestScorerAi `json:"scorers,omitempty" url:"scorers,omitempty"`
	// This is the unique identifier for the test.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the test suite this test belongs to.
	TestSuiteId string `json:"testSuiteId" url:"testSuiteId"`
	// This is the unique identifier for the organization this test belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the test was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the test was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of the test.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the script to be used for the voice test.
	Script string `json:"script" url:"script"`
	// This is the number of attempts allowed for the test.
	NumAttempts *float64 `json:"numAttempts,omitempty" url:"numAttempts,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TestSuiteTestVoice) GetScorers() []*TestSuiteTestScorerAi {
	if t == nil {
		return nil
	}
	return t.Scorers
}

func (t *TestSuiteTestVoice) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TestSuiteTestVoice) GetTestSuiteId() string {
	if t == nil {
		return ""
	}
	return t.TestSuiteId
}

func (t *TestSuiteTestVoice) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TestSuiteTestVoice) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TestSuiteTestVoice) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TestSuiteTestVoice) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TestSuiteTestVoice) GetScript() string {
	if t == nil {
		return ""
	}
	return t.Script
}

func (t *TestSuiteTestVoice) GetNumAttempts() *float64 {
	if t == nil {
		return nil
	}
	return t.NumAttempts
}

func (t *TestSuiteTestVoice) Type() string {
	return t.type_
}

func (t *TestSuiteTestVoice) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestSuiteTestVoice) UnmarshalJSON(data []byte) error {
	type embed TestSuiteTestVoice
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TestSuiteTestVoice(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "voice" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "voice", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestSuiteTestVoice) MarshalJSON() ([]byte, error) {
	type embed TestSuiteTestVoice
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "voice",
	}
	return json.Marshal(marshaler)
}

func (t *TestSuiteTestVoice) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextContent struct {
	Text     string              `json:"text" url:"text"`
	Language TextContentLanguage `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TextContent) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TextContent) GetLanguage() TextContentLanguage {
	if t == nil {
		return ""
	}
	return t.Language
}

func (t *TextContent) Type() string {
	return t.type_
}

func (t *TextContent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextContent) UnmarshalJSON(data []byte) error {
	type embed TextContent
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextContent(unmarshaler.embed)
	if unmarshaler.Type != "text" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "text", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextContent) MarshalJSON() ([]byte, error) {
	type embed TextContent
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "text",
	}
	return json.Marshal(marshaler)
}

func (t *TextContent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextContentLanguage string

const (
	TextContentLanguageAa  TextContentLanguage = "aa"
	TextContentLanguageAb  TextContentLanguage = "ab"
	TextContentLanguageAe  TextContentLanguage = "ae"
	TextContentLanguageAf  TextContentLanguage = "af"
	TextContentLanguageAk  TextContentLanguage = "ak"
	TextContentLanguageAm  TextContentLanguage = "am"
	TextContentLanguageAn  TextContentLanguage = "an"
	TextContentLanguageAr  TextContentLanguage = "ar"
	TextContentLanguageAs  TextContentLanguage = "as"
	TextContentLanguageAv  TextContentLanguage = "av"
	TextContentLanguageAy  TextContentLanguage = "ay"
	TextContentLanguageAz  TextContentLanguage = "az"
	TextContentLanguageBa  TextContentLanguage = "ba"
	TextContentLanguageBe  TextContentLanguage = "be"
	TextContentLanguageBg  TextContentLanguage = "bg"
	TextContentLanguageBh  TextContentLanguage = "bh"
	TextContentLanguageBi  TextContentLanguage = "bi"
	TextContentLanguageBm  TextContentLanguage = "bm"
	TextContentLanguageBn  TextContentLanguage = "bn"
	TextContentLanguageBo  TextContentLanguage = "bo"
	TextContentLanguageBr  TextContentLanguage = "br"
	TextContentLanguageBs  TextContentLanguage = "bs"
	TextContentLanguageCa  TextContentLanguage = "ca"
	TextContentLanguageCe  TextContentLanguage = "ce"
	TextContentLanguageCh  TextContentLanguage = "ch"
	TextContentLanguageCo  TextContentLanguage = "co"
	TextContentLanguageCr  TextContentLanguage = "cr"
	TextContentLanguageCs  TextContentLanguage = "cs"
	TextContentLanguageCu  TextContentLanguage = "cu"
	TextContentLanguageCv  TextContentLanguage = "cv"
	TextContentLanguageCy  TextContentLanguage = "cy"
	TextContentLanguageDa  TextContentLanguage = "da"
	TextContentLanguageDe  TextContentLanguage = "de"
	TextContentLanguageDv  TextContentLanguage = "dv"
	TextContentLanguageDz  TextContentLanguage = "dz"
	TextContentLanguageEe  TextContentLanguage = "ee"
	TextContentLanguageEl  TextContentLanguage = "el"
	TextContentLanguageEn  TextContentLanguage = "en"
	TextContentLanguageEo  TextContentLanguage = "eo"
	TextContentLanguageEs  TextContentLanguage = "es"
	TextContentLanguageEt  TextContentLanguage = "et"
	TextContentLanguageEu  TextContentLanguage = "eu"
	TextContentLanguageFa  TextContentLanguage = "fa"
	TextContentLanguageFf  TextContentLanguage = "ff"
	TextContentLanguageFi  TextContentLanguage = "fi"
	TextContentLanguageFj  TextContentLanguage = "fj"
	TextContentLanguageFo  TextContentLanguage = "fo"
	TextContentLanguageFr  TextContentLanguage = "fr"
	TextContentLanguageFy  TextContentLanguage = "fy"
	TextContentLanguageGa  TextContentLanguage = "ga"
	TextContentLanguageGd  TextContentLanguage = "gd"
	TextContentLanguageGl  TextContentLanguage = "gl"
	TextContentLanguageGn  TextContentLanguage = "gn"
	TextContentLanguageGu  TextContentLanguage = "gu"
	TextContentLanguageGv  TextContentLanguage = "gv"
	TextContentLanguageHa  TextContentLanguage = "ha"
	TextContentLanguageHe  TextContentLanguage = "he"
	TextContentLanguageHi  TextContentLanguage = "hi"
	TextContentLanguageHo  TextContentLanguage = "ho"
	TextContentLanguageHr  TextContentLanguage = "hr"
	TextContentLanguageHt  TextContentLanguage = "ht"
	TextContentLanguageHu  TextContentLanguage = "hu"
	TextContentLanguageHy  TextContentLanguage = "hy"
	TextContentLanguageHz  TextContentLanguage = "hz"
	TextContentLanguageIa  TextContentLanguage = "ia"
	TextContentLanguageId  TextContentLanguage = "id"
	TextContentLanguageIe  TextContentLanguage = "ie"
	TextContentLanguageIg  TextContentLanguage = "ig"
	TextContentLanguageIi  TextContentLanguage = "ii"
	TextContentLanguageIk  TextContentLanguage = "ik"
	TextContentLanguageIo  TextContentLanguage = "io"
	TextContentLanguageIs  TextContentLanguage = "is"
	TextContentLanguageIt  TextContentLanguage = "it"
	TextContentLanguageIu  TextContentLanguage = "iu"
	TextContentLanguageJa  TextContentLanguage = "ja"
	TextContentLanguageJv  TextContentLanguage = "jv"
	TextContentLanguageKa  TextContentLanguage = "ka"
	TextContentLanguageKg  TextContentLanguage = "kg"
	TextContentLanguageKi  TextContentLanguage = "ki"
	TextContentLanguageKj  TextContentLanguage = "kj"
	TextContentLanguageKk  TextContentLanguage = "kk"
	TextContentLanguageKl  TextContentLanguage = "kl"
	TextContentLanguageKm  TextContentLanguage = "km"
	TextContentLanguageKn  TextContentLanguage = "kn"
	TextContentLanguageKo  TextContentLanguage = "ko"
	TextContentLanguageKr  TextContentLanguage = "kr"
	TextContentLanguageKs  TextContentLanguage = "ks"
	TextContentLanguageKu  TextContentLanguage = "ku"
	TextContentLanguageKv  TextContentLanguage = "kv"
	TextContentLanguageKw  TextContentLanguage = "kw"
	TextContentLanguageKy  TextContentLanguage = "ky"
	TextContentLanguageLa  TextContentLanguage = "la"
	TextContentLanguageLb  TextContentLanguage = "lb"
	TextContentLanguageLg  TextContentLanguage = "lg"
	TextContentLanguageLi  TextContentLanguage = "li"
	TextContentLanguageLn  TextContentLanguage = "ln"
	TextContentLanguageLo  TextContentLanguage = "lo"
	TextContentLanguageLt  TextContentLanguage = "lt"
	TextContentLanguageLu  TextContentLanguage = "lu"
	TextContentLanguageLv  TextContentLanguage = "lv"
	TextContentLanguageMg  TextContentLanguage = "mg"
	TextContentLanguageMh  TextContentLanguage = "mh"
	TextContentLanguageMi  TextContentLanguage = "mi"
	TextContentLanguageMk  TextContentLanguage = "mk"
	TextContentLanguageMl  TextContentLanguage = "ml"
	TextContentLanguageMn  TextContentLanguage = "mn"
	TextContentLanguageMr  TextContentLanguage = "mr"
	TextContentLanguageMs  TextContentLanguage = "ms"
	TextContentLanguageMt  TextContentLanguage = "mt"
	TextContentLanguageMy  TextContentLanguage = "my"
	TextContentLanguageNa  TextContentLanguage = "na"
	TextContentLanguageNb  TextContentLanguage = "nb"
	TextContentLanguageNd  TextContentLanguage = "nd"
	TextContentLanguageNe  TextContentLanguage = "ne"
	TextContentLanguageNg  TextContentLanguage = "ng"
	TextContentLanguageNl  TextContentLanguage = "nl"
	TextContentLanguageNn  TextContentLanguage = "nn"
	TextContentLanguageNo  TextContentLanguage = "no"
	TextContentLanguageNr  TextContentLanguage = "nr"
	TextContentLanguageNv  TextContentLanguage = "nv"
	TextContentLanguageNy  TextContentLanguage = "ny"
	TextContentLanguageOc  TextContentLanguage = "oc"
	TextContentLanguageOj  TextContentLanguage = "oj"
	TextContentLanguageOm  TextContentLanguage = "om"
	TextContentLanguageOr  TextContentLanguage = "or"
	TextContentLanguageOs  TextContentLanguage = "os"
	TextContentLanguagePa  TextContentLanguage = "pa"
	TextContentLanguagePi  TextContentLanguage = "pi"
	TextContentLanguagePl  TextContentLanguage = "pl"
	TextContentLanguagePs  TextContentLanguage = "ps"
	TextContentLanguagePt  TextContentLanguage = "pt"
	TextContentLanguageQu  TextContentLanguage = "qu"
	TextContentLanguageRm  TextContentLanguage = "rm"
	TextContentLanguageRn  TextContentLanguage = "rn"
	TextContentLanguageRo  TextContentLanguage = "ro"
	TextContentLanguageRu  TextContentLanguage = "ru"
	TextContentLanguageRw  TextContentLanguage = "rw"
	TextContentLanguageSa  TextContentLanguage = "sa"
	TextContentLanguageSc  TextContentLanguage = "sc"
	TextContentLanguageSd  TextContentLanguage = "sd"
	TextContentLanguageSe  TextContentLanguage = "se"
	TextContentLanguageSg  TextContentLanguage = "sg"
	TextContentLanguageSi  TextContentLanguage = "si"
	TextContentLanguageSk  TextContentLanguage = "sk"
	TextContentLanguageSl  TextContentLanguage = "sl"
	TextContentLanguageSm  TextContentLanguage = "sm"
	TextContentLanguageSn  TextContentLanguage = "sn"
	TextContentLanguageSo  TextContentLanguage = "so"
	TextContentLanguageSq  TextContentLanguage = "sq"
	TextContentLanguageSr  TextContentLanguage = "sr"
	TextContentLanguageSs  TextContentLanguage = "ss"
	TextContentLanguageSt  TextContentLanguage = "st"
	TextContentLanguageSu  TextContentLanguage = "su"
	TextContentLanguageSv  TextContentLanguage = "sv"
	TextContentLanguageSw  TextContentLanguage = "sw"
	TextContentLanguageTa  TextContentLanguage = "ta"
	TextContentLanguageTe  TextContentLanguage = "te"
	TextContentLanguageTg  TextContentLanguage = "tg"
	TextContentLanguageTh  TextContentLanguage = "th"
	TextContentLanguageTi  TextContentLanguage = "ti"
	TextContentLanguageTk  TextContentLanguage = "tk"
	TextContentLanguageTl  TextContentLanguage = "tl"
	TextContentLanguageTn  TextContentLanguage = "tn"
	TextContentLanguageTo  TextContentLanguage = "to"
	TextContentLanguageTr  TextContentLanguage = "tr"
	TextContentLanguageTs  TextContentLanguage = "ts"
	TextContentLanguageTt  TextContentLanguage = "tt"
	TextContentLanguageTw  TextContentLanguage = "tw"
	TextContentLanguageTy  TextContentLanguage = "ty"
	TextContentLanguageUg  TextContentLanguage = "ug"
	TextContentLanguageUk  TextContentLanguage = "uk"
	TextContentLanguageUr  TextContentLanguage = "ur"
	TextContentLanguageUz  TextContentLanguage = "uz"
	TextContentLanguageVe  TextContentLanguage = "ve"
	TextContentLanguageVi  TextContentLanguage = "vi"
	TextContentLanguageVo  TextContentLanguage = "vo"
	TextContentLanguageWa  TextContentLanguage = "wa"
	TextContentLanguageWo  TextContentLanguage = "wo"
	TextContentLanguageXh  TextContentLanguage = "xh"
	TextContentLanguageYi  TextContentLanguage = "yi"
	TextContentLanguageYue TextContentLanguage = "yue"
	TextContentLanguageYo  TextContentLanguage = "yo"
	TextContentLanguageZa  TextContentLanguage = "za"
	TextContentLanguageZh  TextContentLanguage = "zh"
	TextContentLanguageZu  TextContentLanguage = "zu"
)

func NewTextContentLanguageFromString(s string) (TextContentLanguage, error) {
	switch s {
	case "aa":
		return TextContentLanguageAa, nil
	case "ab":
		return TextContentLanguageAb, nil
	case "ae":
		return TextContentLanguageAe, nil
	case "af":
		return TextContentLanguageAf, nil
	case "ak":
		return TextContentLanguageAk, nil
	case "am":
		return TextContentLanguageAm, nil
	case "an":
		return TextContentLanguageAn, nil
	case "ar":
		return TextContentLanguageAr, nil
	case "as":
		return TextContentLanguageAs, nil
	case "av":
		return TextContentLanguageAv, nil
	case "ay":
		return TextContentLanguageAy, nil
	case "az":
		return TextContentLanguageAz, nil
	case "ba":
		return TextContentLanguageBa, nil
	case "be":
		return TextContentLanguageBe, nil
	case "bg":
		return TextContentLanguageBg, nil
	case "bh":
		return TextContentLanguageBh, nil
	case "bi":
		return TextContentLanguageBi, nil
	case "bm":
		return TextContentLanguageBm, nil
	case "bn":
		return TextContentLanguageBn, nil
	case "bo":
		return TextContentLanguageBo, nil
	case "br":
		return TextContentLanguageBr, nil
	case "bs":
		return TextContentLanguageBs, nil
	case "ca":
		return TextContentLanguageCa, nil
	case "ce":
		return TextContentLanguageCe, nil
	case "ch":
		return TextContentLanguageCh, nil
	case "co":
		return TextContentLanguageCo, nil
	case "cr":
		return TextContentLanguageCr, nil
	case "cs":
		return TextContentLanguageCs, nil
	case "cu":
		return TextContentLanguageCu, nil
	case "cv":
		return TextContentLanguageCv, nil
	case "cy":
		return TextContentLanguageCy, nil
	case "da":
		return TextContentLanguageDa, nil
	case "de":
		return TextContentLanguageDe, nil
	case "dv":
		return TextContentLanguageDv, nil
	case "dz":
		return TextContentLanguageDz, nil
	case "ee":
		return TextContentLanguageEe, nil
	case "el":
		return TextContentLanguageEl, nil
	case "en":
		return TextContentLanguageEn, nil
	case "eo":
		return TextContentLanguageEo, nil
	case "es":
		return TextContentLanguageEs, nil
	case "et":
		return TextContentLanguageEt, nil
	case "eu":
		return TextContentLanguageEu, nil
	case "fa":
		return TextContentLanguageFa, nil
	case "ff":
		return TextContentLanguageFf, nil
	case "fi":
		return TextContentLanguageFi, nil
	case "fj":
		return TextContentLanguageFj, nil
	case "fo":
		return TextContentLanguageFo, nil
	case "fr":
		return TextContentLanguageFr, nil
	case "fy":
		return TextContentLanguageFy, nil
	case "ga":
		return TextContentLanguageGa, nil
	case "gd":
		return TextContentLanguageGd, nil
	case "gl":
		return TextContentLanguageGl, nil
	case "gn":
		return TextContentLanguageGn, nil
	case "gu":
		return TextContentLanguageGu, nil
	case "gv":
		return TextContentLanguageGv, nil
	case "ha":
		return TextContentLanguageHa, nil
	case "he":
		return TextContentLanguageHe, nil
	case "hi":
		return TextContentLanguageHi, nil
	case "ho":
		return TextContentLanguageHo, nil
	case "hr":
		return TextContentLanguageHr, nil
	case "ht":
		return TextContentLanguageHt, nil
	case "hu":
		return TextContentLanguageHu, nil
	case "hy":
		return TextContentLanguageHy, nil
	case "hz":
		return TextContentLanguageHz, nil
	case "ia":
		return TextContentLanguageIa, nil
	case "id":
		return TextContentLanguageId, nil
	case "ie":
		return TextContentLanguageIe, nil
	case "ig":
		return TextContentLanguageIg, nil
	case "ii":
		return TextContentLanguageIi, nil
	case "ik":
		return TextContentLanguageIk, nil
	case "io":
		return TextContentLanguageIo, nil
	case "is":
		return TextContentLanguageIs, nil
	case "it":
		return TextContentLanguageIt, nil
	case "iu":
		return TextContentLanguageIu, nil
	case "ja":
		return TextContentLanguageJa, nil
	case "jv":
		return TextContentLanguageJv, nil
	case "ka":
		return TextContentLanguageKa, nil
	case "kg":
		return TextContentLanguageKg, nil
	case "ki":
		return TextContentLanguageKi, nil
	case "kj":
		return TextContentLanguageKj, nil
	case "kk":
		return TextContentLanguageKk, nil
	case "kl":
		return TextContentLanguageKl, nil
	case "km":
		return TextContentLanguageKm, nil
	case "kn":
		return TextContentLanguageKn, nil
	case "ko":
		return TextContentLanguageKo, nil
	case "kr":
		return TextContentLanguageKr, nil
	case "ks":
		return TextContentLanguageKs, nil
	case "ku":
		return TextContentLanguageKu, nil
	case "kv":
		return TextContentLanguageKv, nil
	case "kw":
		return TextContentLanguageKw, nil
	case "ky":
		return TextContentLanguageKy, nil
	case "la":
		return TextContentLanguageLa, nil
	case "lb":
		return TextContentLanguageLb, nil
	case "lg":
		return TextContentLanguageLg, nil
	case "li":
		return TextContentLanguageLi, nil
	case "ln":
		return TextContentLanguageLn, nil
	case "lo":
		return TextContentLanguageLo, nil
	case "lt":
		return TextContentLanguageLt, nil
	case "lu":
		return TextContentLanguageLu, nil
	case "lv":
		return TextContentLanguageLv, nil
	case "mg":
		return TextContentLanguageMg, nil
	case "mh":
		return TextContentLanguageMh, nil
	case "mi":
		return TextContentLanguageMi, nil
	case "mk":
		return TextContentLanguageMk, nil
	case "ml":
		return TextContentLanguageMl, nil
	case "mn":
		return TextContentLanguageMn, nil
	case "mr":
		return TextContentLanguageMr, nil
	case "ms":
		return TextContentLanguageMs, nil
	case "mt":
		return TextContentLanguageMt, nil
	case "my":
		return TextContentLanguageMy, nil
	case "na":
		return TextContentLanguageNa, nil
	case "nb":
		return TextContentLanguageNb, nil
	case "nd":
		return TextContentLanguageNd, nil
	case "ne":
		return TextContentLanguageNe, nil
	case "ng":
		return TextContentLanguageNg, nil
	case "nl":
		return TextContentLanguageNl, nil
	case "nn":
		return TextContentLanguageNn, nil
	case "no":
		return TextContentLanguageNo, nil
	case "nr":
		return TextContentLanguageNr, nil
	case "nv":
		return TextContentLanguageNv, nil
	case "ny":
		return TextContentLanguageNy, nil
	case "oc":
		return TextContentLanguageOc, nil
	case "oj":
		return TextContentLanguageOj, nil
	case "om":
		return TextContentLanguageOm, nil
	case "or":
		return TextContentLanguageOr, nil
	case "os":
		return TextContentLanguageOs, nil
	case "pa":
		return TextContentLanguagePa, nil
	case "pi":
		return TextContentLanguagePi, nil
	case "pl":
		return TextContentLanguagePl, nil
	case "ps":
		return TextContentLanguagePs, nil
	case "pt":
		return TextContentLanguagePt, nil
	case "qu":
		return TextContentLanguageQu, nil
	case "rm":
		return TextContentLanguageRm, nil
	case "rn":
		return TextContentLanguageRn, nil
	case "ro":
		return TextContentLanguageRo, nil
	case "ru":
		return TextContentLanguageRu, nil
	case "rw":
		return TextContentLanguageRw, nil
	case "sa":
		return TextContentLanguageSa, nil
	case "sc":
		return TextContentLanguageSc, nil
	case "sd":
		return TextContentLanguageSd, nil
	case "se":
		return TextContentLanguageSe, nil
	case "sg":
		return TextContentLanguageSg, nil
	case "si":
		return TextContentLanguageSi, nil
	case "sk":
		return TextContentLanguageSk, nil
	case "sl":
		return TextContentLanguageSl, nil
	case "sm":
		return TextContentLanguageSm, nil
	case "sn":
		return TextContentLanguageSn, nil
	case "so":
		return TextContentLanguageSo, nil
	case "sq":
		return TextContentLanguageSq, nil
	case "sr":
		return TextContentLanguageSr, nil
	case "ss":
		return TextContentLanguageSs, nil
	case "st":
		return TextContentLanguageSt, nil
	case "su":
		return TextContentLanguageSu, nil
	case "sv":
		return TextContentLanguageSv, nil
	case "sw":
		return TextContentLanguageSw, nil
	case "ta":
		return TextContentLanguageTa, nil
	case "te":
		return TextContentLanguageTe, nil
	case "tg":
		return TextContentLanguageTg, nil
	case "th":
		return TextContentLanguageTh, nil
	case "ti":
		return TextContentLanguageTi, nil
	case "tk":
		return TextContentLanguageTk, nil
	case "tl":
		return TextContentLanguageTl, nil
	case "tn":
		return TextContentLanguageTn, nil
	case "to":
		return TextContentLanguageTo, nil
	case "tr":
		return TextContentLanguageTr, nil
	case "ts":
		return TextContentLanguageTs, nil
	case "tt":
		return TextContentLanguageTt, nil
	case "tw":
		return TextContentLanguageTw, nil
	case "ty":
		return TextContentLanguageTy, nil
	case "ug":
		return TextContentLanguageUg, nil
	case "uk":
		return TextContentLanguageUk, nil
	case "ur":
		return TextContentLanguageUr, nil
	case "uz":
		return TextContentLanguageUz, nil
	case "ve":
		return TextContentLanguageVe, nil
	case "vi":
		return TextContentLanguageVi, nil
	case "vo":
		return TextContentLanguageVo, nil
	case "wa":
		return TextContentLanguageWa, nil
	case "wo":
		return TextContentLanguageWo, nil
	case "xh":
		return TextContentLanguageXh, nil
	case "yi":
		return TextContentLanguageYi, nil
	case "yue":
		return TextContentLanguageYue, nil
	case "yo":
		return TextContentLanguageYo, nil
	case "za":
		return TextContentLanguageZa, nil
	case "zh":
		return TextContentLanguageZh, nil
	case "zu":
		return TextContentLanguageZu, nil
	}
	var t TextContentLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextContentLanguage) Ptr() *TextContentLanguage {
	return &t
}

type TextEditorToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*TextEditorToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "textEditor" for Text Editor tool.
	// The sub type of tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// The name of the tool, fixed to 'str_replace_editor'
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server  *Server `json:"server,omitempty" url:"server,omitempty"`
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TextEditorToolWithToolCall) GetAsync() *bool {
	if t == nil {
		return nil
	}
	return t.Async
}

func (t *TextEditorToolWithToolCall) GetMessages() []*TextEditorToolWithToolCallMessagesItem {
	if t == nil {
		return nil
	}
	return t.Messages
}

func (t *TextEditorToolWithToolCall) GetToolCall() *ToolCall {
	if t == nil {
		return nil
	}
	return t.ToolCall
}

func (t *TextEditorToolWithToolCall) GetFunction() *OpenAiFunction {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *TextEditorToolWithToolCall) GetServer() *Server {
	if t == nil {
		return nil
	}
	return t.Server
}

func (t *TextEditorToolWithToolCall) Type() string {
	return t.type_
}

func (t *TextEditorToolWithToolCall) SubType() string {
	return t.subType
}

func (t *TextEditorToolWithToolCall) Name() string {
	return t.name
}

func (t *TextEditorToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextEditorToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed TextEditorToolWithToolCall
	var unmarshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextEditorToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "textEditor" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "textEditor", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	if unmarshaler.SubType != "text_editor_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "text_editor_20241022", unmarshaler.SubType)
	}
	t.subType = unmarshaler.SubType
	if unmarshaler.Name != "str_replace_editor" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "str_replace_editor", unmarshaler.Name)
	}
	t.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type", "subType", "name")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextEditorToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed TextEditorToolWithToolCall
	var marshaler = struct {
		embed
		Type    string `json:"type"`
		SubType string `json:"subType"`
		Name    string `json:"name"`
	}{
		embed:   embed(*t),
		Type:    "textEditor",
		SubType: "text_editor_20241022",
		Name:    "str_replace_editor",
	}
	return json.Marshal(marshaler)
}

func (t *TextEditorToolWithToolCall) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextEditorToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (t *TextEditorToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if t == nil {
		return nil
	}
	return t.ToolMessageStart
}

func (t *TextEditorToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if t == nil {
		return nil
	}
	return t.ToolMessageComplete
}

func (t *TextEditorToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if t == nil {
		return nil
	}
	return t.ToolMessageFailed
}

func (t *TextEditorToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if t == nil {
		return nil
	}
	return t.ToolMessageDelayed
}

func (t *TextEditorToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		t.typ = "ToolMessageStart"
		t.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.typ = "ToolMessageComplete"
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.typ = "ToolMessageFailed"
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		t.typ = "ToolMessageDelayed"
		t.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TextEditorToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return json.Marshal(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return json.Marshal(t.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TextEditorToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (t *TextEditorToolWithToolCallMessagesItem) Accept(visitor TextEditorToolWithToolCallMessagesItemVisitor) error {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(t.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TogetherAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TogetherAiCredential) GetApiKey() string {
	if t == nil {
		return ""
	}
	return t.ApiKey
}

func (t *TogetherAiCredential) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TogetherAiCredential) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TogetherAiCredential) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TogetherAiCredential) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TogetherAiCredential) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TogetherAiCredential) Provider() string {
	return t.provider
}

func (t *TogetherAiCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TogetherAiCredential) UnmarshalJSON(data []byte) error {
	type embed TogetherAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TogetherAiCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "together-ai", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TogetherAiCredential) MarshalJSON() ([]byte, error) {
	type embed TogetherAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Provider:  "together-ai",
	}
	return json.Marshal(marshaler)
}

func (t *TogetherAiCredential) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TogetherAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*TogetherAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TogetherAiModel) GetMessages() []*OpenAiMessage {
	if t == nil {
		return nil
	}
	return t.Messages
}

func (t *TogetherAiModel) GetTools() []*TogetherAiModelToolsItem {
	if t == nil {
		return nil
	}
	return t.Tools
}

func (t *TogetherAiModel) GetToolIds() []string {
	if t == nil {
		return nil
	}
	return t.ToolIds
}

func (t *TogetherAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if t == nil {
		return nil
	}
	return t.KnowledgeBase
}

func (t *TogetherAiModel) GetKnowledgeBaseId() *string {
	if t == nil {
		return nil
	}
	return t.KnowledgeBaseId
}

func (t *TogetherAiModel) GetModel() string {
	if t == nil {
		return ""
	}
	return t.Model
}

func (t *TogetherAiModel) GetTemperature() *float64 {
	if t == nil {
		return nil
	}
	return t.Temperature
}

func (t *TogetherAiModel) GetMaxTokens() *float64 {
	if t == nil {
		return nil
	}
	return t.MaxTokens
}

func (t *TogetherAiModel) GetEmotionRecognitionEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.EmotionRecognitionEnabled
}

func (t *TogetherAiModel) GetNumFastTurns() *float64 {
	if t == nil {
		return nil
	}
	return t.NumFastTurns
}

func (t *TogetherAiModel) Provider() string {
	return t.provider
}

func (t *TogetherAiModel) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TogetherAiModel) UnmarshalJSON(data []byte) error {
	type embed TogetherAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TogetherAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "together-ai", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TogetherAiModel) MarshalJSON() ([]byte, error) {
	type embed TogetherAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "together-ai",
	}
	return json.Marshal(marshaler)
}

func (t *TogetherAiModel) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TogetherAiModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (t *TogetherAiModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if t == nil {
		return nil
	}
	return t.CreateApiRequestToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if t == nil {
		return nil
	}
	return t.CreateBashToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if t == nil {
		return nil
	}
	return t.CreateComputerToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if t == nil {
		return nil
	}
	return t.CreateDtmfToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateEndCallToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if t == nil {
		return nil
	}
	return t.CreateFunctionToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarEventCreateToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactCreateToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactGetToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCreateEventToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleSheetsRowAppendToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if t == nil {
		return nil
	}
	return t.CreateMcpToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if t == nil {
		return nil
	}
	return t.CreateQueryToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSlackSendMessageToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSmsToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTextEditorToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTransferCallToolDto
}

func (t *TogetherAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		t.typ = "CreateApiRequestToolDto"
		t.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		t.typ = "CreateBashToolDto"
		t.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		t.typ = "CreateComputerToolDto"
		t.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.typ = "CreateDtmfToolDto"
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.typ = "CreateEndCallToolDto"
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.typ = "CreateFunctionToolDto"
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		t.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		t.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactCreateToolDto"
		t.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactGetToolDto"
		t.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		t.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCreateEventToolDto"
		t.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		t.typ = "CreateGoogleSheetsRowAppendToolDto"
		t.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		t.typ = "CreateMcpToolDto"
		t.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		t.typ = "CreateQueryToolDto"
		t.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		t.typ = "CreateSlackSendMessageToolDto"
		t.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		t.typ = "CreateSmsToolDto"
		t.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		t.typ = "CreateTextEditorToolDto"
		t.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.typ = "CreateTransferCallToolDto"
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TogetherAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "CreateApiRequestToolDto" || t.CreateApiRequestToolDto != nil {
		return json.Marshal(t.CreateApiRequestToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return json.Marshal(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return json.Marshal(t.CreateComputerToolDto)
	}
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactGetToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return json.Marshal(t.CreateMcpToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return json.Marshal(t.CreateQueryToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return json.Marshal(t.CreateSmsToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return json.Marshal(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TogetherAiModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *TogetherAiModelToolsItem) Accept(visitor TogetherAiModelToolsItemVisitor) error {
	if t.typ == "CreateApiRequestToolDto" || t.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(t.CreateApiRequestToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(t.CreateComputerToolDto)
	}
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(t.CreateGoHighLevelContactGetToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(t.CreateMcpToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(t.CreateQueryToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(t.CreateSmsToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type Token struct {
	// This is the tag for the token. It represents its scope.
	Tag *TokenTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the unique identifier for the token.
	Id string `json:"id" url:"id"`
	// This is unique identifier for the org that this token belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the token was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the token was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the token key.
	Value string `json:"value" url:"value"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Token) GetTag() *TokenTag {
	if t == nil {
		return nil
	}
	return t.Tag
}

func (t *Token) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *Token) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *Token) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *Token) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *Token) GetValue() string {
	if t == nil {
		return ""
	}
	return t.Value
}

func (t *Token) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *Token) GetRestrictions() *TokenRestrictions {
	if t == nil {
		return nil
	}
	return t.Restrictions
}

func (t *Token) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type embed Token
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Token(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Token) MarshalJSON() ([]byte, error) {
	type embed Token
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Token) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenRestrictions struct {
	// This determines whether the token is enabled or disabled. Default is true, it's enabled.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This determines the allowed origins for this token. Validates the `Origin` header. Default is any origin.
	//
	// Only relevant for `public` tokens.
	AllowedOrigins []string `json:"allowedOrigins,omitempty" url:"allowedOrigins,omitempty"`
	// This determines which assistantIds can be used when creating a call. Default is any assistantId.
	//
	// Only relevant for `public` tokens.
	AllowedAssistantIds []string `json:"allowedAssistantIds,omitempty" url:"allowedAssistantIds,omitempty"`
	// This determines whether transient assistants can be used when creating a call. Default is true.
	//
	// If `allowedAssistantIds` is provided, this is automatically false.
	//
	// Only relevant for `public` tokens.
	AllowTransientAssistant *bool `json:"allowTransientAssistant,omitempty" url:"allowTransientAssistant,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenRestrictions) GetEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.Enabled
}

func (t *TokenRestrictions) GetAllowedOrigins() []string {
	if t == nil {
		return nil
	}
	return t.AllowedOrigins
}

func (t *TokenRestrictions) GetAllowedAssistantIds() []string {
	if t == nil {
		return nil
	}
	return t.AllowedAssistantIds
}

func (t *TokenRestrictions) GetAllowTransientAssistant() *bool {
	if t == nil {
		return nil
	}
	return t.AllowTransientAssistant
}

func (t *TokenRestrictions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenRestrictions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenRestrictions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenRestrictions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenRestrictions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the tag for the token. It represents its scope.
type TokenTag string

const (
	TokenTagPrivate TokenTag = "private"
	TokenTagPublic  TokenTag = "public"
)

func NewTokenTagFromString(s string) (TokenTag, error) {
	switch s {
	case "private":
		return TokenTagPrivate, nil
	case "public":
		return TokenTagPublic, nil
	}
	var t TokenTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenTag) Ptr() *TokenTag {
	return &t
}

type ToolCall struct {
	// This is the type of tool the model called.
	// This is the function the model called.
	Function *ToolCallFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the unique identifier for the tool call.
	Id    string `json:"id" url:"id"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCall) GetFunction() *ToolCallFunction {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *ToolCall) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *ToolCall) Type() string {
	return t.type_
}

func (t *ToolCall) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCall) UnmarshalJSON(data []byte) error {
	type embed ToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolCall(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "function", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCall) MarshalJSON() ([]byte, error) {
	type embed ToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (t *ToolCall) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallFunction struct {
	// This is the name of the function the model called.
	Name string `json:"name" url:"name"`
	// These are the arguments that the function was called with.
	Arguments map[string]interface{} `json:"arguments,omitempty" url:"arguments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallFunction) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolCallFunction) GetArguments() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Arguments
}

func (t *ToolCallFunction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallFunction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallFunction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallMessage struct {
	// The role of the tool call in the conversation.
	Role string `json:"role" url:"role"`
	// The list of tool calls made during the conversation.
	ToolCalls []map[string]interface{} `json:"toolCalls,omitempty" url:"toolCalls,omitempty"`
	// The message content for the tool call.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallMessage) GetRole() string {
	if t == nil {
		return ""
	}
	return t.Role
}

func (t *ToolCallMessage) GetToolCalls() []map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.ToolCalls
}

func (t *ToolCallMessage) GetMessage() string {
	if t == nil {
		return ""
	}
	return t.Message
}

func (t *ToolCallMessage) GetTime() float64 {
	if t == nil {
		return 0
	}
	return t.Time
}

func (t *ToolCallMessage) GetSecondsFromStart() float64 {
	if t == nil {
		return 0
	}
	return t.SecondsFromStart
}

func (t *ToolCallMessage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallMessage) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallResult struct {
	// This is the message that will be spoken to the user.
	//
	// If this is not returned, assistant will speak:
	// 1. a `request-complete` or `request-failed` message from `tool.messages`, if it exists
	// 2. a response generated by the model, if not
	Message *ToolCallResultMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the name of the function the model called.
	Name string `json:"name" url:"name"`
	// This is the unique identifier for the tool call.
	ToolCallId string `json:"toolCallId" url:"toolCallId"`
	// This is the result if the tool call was successful. This is added to the conversation history.
	//
	// Further, if this is returned, assistant will speak:
	// 1. the `message`, if it exists and is of type `request-complete`
	// 2. a `request-complete` message from `tool.messages`, if it exists
	// 3. a response generated by the model, if neither exist
	Result *string `json:"result,omitempty" url:"result,omitempty"`
	// This is the error if the tool call was not successful. This is added to the conversation history.
	//
	// Further, if this is returned, assistant will speak:
	// 1. the `message`, if it exists and is of type `request-failed`
	// 2. a `request-failed` message from `tool.messages`, if it exists
	// 3. a response generated by the model, if neither exist
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// This is optional metadata for the tool call result to be sent to the client.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallResult) GetMessage() *ToolCallResultMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *ToolCallResult) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolCallResult) GetToolCallId() string {
	if t == nil {
		return ""
	}
	return t.ToolCallId
}

func (t *ToolCallResult) GetResult() *string {
	if t == nil {
		return nil
	}
	return t.Result
}

func (t *ToolCallResult) GetError() *string {
	if t == nil {
		return nil
	}
	return t.Error
}

func (t *ToolCallResult) GetMetadata() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *ToolCallResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallResult) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallResultMessage struct {
	// The role of the tool call result in the conversation.
	Role string `json:"role" url:"role"`
	// The ID of the tool call.
	ToolCallId string `json:"toolCallId" url:"toolCallId"`
	// The name of the tool that returned the result.
	Name string `json:"name" url:"name"`
	// The result of the tool call in JSON format.
	Result string `json:"result" url:"result"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`
	// The metadata for the tool call result.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallResultMessage) GetRole() string {
	if t == nil {
		return ""
	}
	return t.Role
}

func (t *ToolCallResultMessage) GetToolCallId() string {
	if t == nil {
		return ""
	}
	return t.ToolCallId
}

func (t *ToolCallResultMessage) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolCallResultMessage) GetResult() string {
	if t == nil {
		return ""
	}
	return t.Result
}

func (t *ToolCallResultMessage) GetTime() float64 {
	if t == nil {
		return 0
	}
	return t.Time
}

func (t *ToolCallResultMessage) GetSecondsFromStart() float64 {
	if t == nil {
		return 0
	}
	return t.SecondsFromStart
}

func (t *ToolCallResultMessage) GetMetadata() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *ToolCallResultMessage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallResultMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallResultMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallResultMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallResultMessage) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolMessageComplete struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call is complete.
	//
	// This message is triggered immediately without waiting for your server to respond for async tool calls.
	//
	// If this message is not provided, the model will be requested to respond.
	//
	// If this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.
	// This is optional and defaults to "assistant".
	//
	// When role=assistant, `content` is said out loud.
	//
	// When role=system, `content` is passed to the model in a system message. Example:
	//
	//	system: default one
	//	assistant:
	//	user:
	//	assistant:
	//	user:
	//	assistant:
	//	user:
	//	assistant: tool called
	//	tool: your server response
	//	<--- system prompt as hint
	//	---> model generates response which is spoken
	//
	// This is useful when you want to provide a hint to the model about what to say next.
	Role *ToolMessageCompleteRole `json:"role,omitempty" url:"role,omitempty"`
	// This is an optional boolean that if true, the call will end after the message is spoken. Default is false.
	//
	// This is ignored if `role` is set to `system`.
	//
	// @default false
	EndCallAfterSpokenEnabled *bool `json:"endCallAfterSpokenEnabled,omitempty" url:"endCallAfterSpokenEnabled,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageComplete) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageComplete) GetRole() *ToolMessageCompleteRole {
	if t == nil {
		return nil
	}
	return t.Role
}

func (t *ToolMessageComplete) GetEndCallAfterSpokenEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.EndCallAfterSpokenEnabled
}

func (t *ToolMessageComplete) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageComplete) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageComplete) Type() string {
	return t.type_
}

func (t *ToolMessageComplete) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageComplete) UnmarshalJSON(data []byte) error {
	type embed ToolMessageComplete
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageComplete(unmarshaler.embed)
	if unmarshaler.Type != "request-complete" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-complete", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageComplete) MarshalJSON() ([]byte, error) {
	type embed ToolMessageComplete
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-complete",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageComplete) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is optional and defaults to "assistant".
//
// When role=assistant, `content` is said out loud.
//
// When role=system, `content` is passed to the model in a system message. Example:
//
//	system: default one
//	assistant:
//	user:
//	assistant:
//	user:
//	assistant:
//	user:
//	assistant: tool called
//	tool: your server response
//	<--- system prompt as hint
//	---> model generates response which is spoken
//
// This is useful when you want to provide a hint to the model about what to say next.
type ToolMessageCompleteRole string

const (
	ToolMessageCompleteRoleAssistant ToolMessageCompleteRole = "assistant"
	ToolMessageCompleteRoleSystem    ToolMessageCompleteRole = "system"
)

func NewToolMessageCompleteRoleFromString(s string) (ToolMessageCompleteRole, error) {
	switch s {
	case "assistant":
		return ToolMessageCompleteRoleAssistant, nil
	case "system":
		return ToolMessageCompleteRoleSystem, nil
	}
	var t ToolMessageCompleteRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t ToolMessageCompleteRole) Ptr() *ToolMessageCompleteRole {
	return &t
}

type ToolMessageDelayed struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call is delayed.
	//
	// There are the two things that can trigger this message:
	// 1. The user talks with the assistant while your server is processing the request. Default is "Sorry, a few more seconds."
	// 2. The server doesn't respond within `timingMilliseconds`.
	//
	// This message is never triggered for async tool calls.
	// The number of milliseconds to wait for the server response before saying this message.
	TimingMilliseconds *float64 `json:"timingMilliseconds,omitempty" url:"timingMilliseconds,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageDelayed) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageDelayed) GetTimingMilliseconds() *float64 {
	if t == nil {
		return nil
	}
	return t.TimingMilliseconds
}

func (t *ToolMessageDelayed) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageDelayed) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageDelayed) Type() string {
	return t.type_
}

func (t *ToolMessageDelayed) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageDelayed) UnmarshalJSON(data []byte) error {
	type embed ToolMessageDelayed
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageDelayed(unmarshaler.embed)
	if unmarshaler.Type != "request-response-delayed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-response-delayed", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageDelayed) MarshalJSON() ([]byte, error) {
	type embed ToolMessageDelayed
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-response-delayed",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageDelayed) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolMessageFailed struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call fails.
	//
	// This message is never triggered for async tool calls.
	//
	// If this message is not provided, the model will be requested to respond.
	//
	// If this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.
	// This is an optional boolean that if true, the call will end after the message is spoken. Default is false.
	//
	// @default false
	EndCallAfterSpokenEnabled *bool `json:"endCallAfterSpokenEnabled,omitempty" url:"endCallAfterSpokenEnabled,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageFailed) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageFailed) GetEndCallAfterSpokenEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.EndCallAfterSpokenEnabled
}

func (t *ToolMessageFailed) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageFailed) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageFailed) Type() string {
	return t.type_
}

func (t *ToolMessageFailed) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageFailed) UnmarshalJSON(data []byte) error {
	type embed ToolMessageFailed
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageFailed(unmarshaler.embed)
	if unmarshaler.Type != "request-failed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-failed", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageFailed) MarshalJSON() ([]byte, error) {
	type embed ToolMessageFailed
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-failed",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageFailed) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolMessageStart struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call starts.
	//
	// This message is never triggered for async tools.
	//
	// If this message is not provided, one of the default filler messages "Hold on a sec", "One moment", "Just a sec", "Give me a moment" or "This'll just take a sec" will be used.
	// This is an optional boolean that if true, the tool call will only trigger after the message is spoken. Default is false.
	//
	// @default false
	Blocking *bool `json:"blocking,omitempty" url:"blocking,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageStart) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageStart) GetBlocking() *bool {
	if t == nil {
		return nil
	}
	return t.Blocking
}

func (t *ToolMessageStart) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageStart) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageStart) Type() string {
	return t.type_
}

func (t *ToolMessageStart) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageStart) UnmarshalJSON(data []byte) error {
	type embed ToolMessageStart
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageStart(unmarshaler.embed)
	if unmarshaler.Type != "request-start" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-start", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageStart) MarshalJSON() ([]byte, error) {
	type embed ToolMessageStart
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-start",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageStart) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolNode struct {
	// This is the Tool node. This can be used to call a tool in your workflow.
	//
	// The flow is:
	// - Workflow starts the tool node
	// - Model is called to extract parameters needed by the tool from the conversation history
	// - Tool is called with the parameters
	// - Server returns a response
	// - Workflow continues with the response
	// This is the tool to call. To use an existing tool, send `toolId` instead.
	Tool *ToolNodeTool `json:"tool,omitempty" url:"tool,omitempty"`
	// This is the tool to call. To use a transient tool, send `tool` instead.
	ToolId *string `json:"toolId,omitempty" url:"toolId,omitempty"`
	Name   string  `json:"name" url:"name"`
	// This is whether or not the node is the start of the workflow.
	IsStart *bool `json:"isStart,omitempty" url:"isStart,omitempty"`
	// This is for metadata you want to store on the task.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolNode) GetTool() *ToolNodeTool {
	if t == nil {
		return nil
	}
	return t.Tool
}

func (t *ToolNode) GetToolId() *string {
	if t == nil {
		return nil
	}
	return t.ToolId
}

func (t *ToolNode) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolNode) GetIsStart() *bool {
	if t == nil {
		return nil
	}
	return t.IsStart
}

func (t *ToolNode) GetMetadata() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *ToolNode) Type() string {
	return t.type_
}

func (t *ToolNode) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolNode) UnmarshalJSON(data []byte) error {
	type embed ToolNode
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolNode(unmarshaler.embed)
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tool", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolNode) MarshalJSON() ([]byte, error) {
	type embed ToolNode
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "tool",
	}
	return json.Marshal(marshaler)
}

func (t *ToolNode) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the tool to call. To use an existing tool, send `toolId` instead.
type ToolNodeTool struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (t *ToolNodeTool) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if t == nil {
		return nil
	}
	return t.CreateApiRequestToolDto
}

func (t *ToolNodeTool) GetCreateBashToolDto() *CreateBashToolDto {
	if t == nil {
		return nil
	}
	return t.CreateBashToolDto
}

func (t *ToolNodeTool) GetCreateComputerToolDto() *CreateComputerToolDto {
	if t == nil {
		return nil
	}
	return t.CreateComputerToolDto
}

func (t *ToolNodeTool) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if t == nil {
		return nil
	}
	return t.CreateDtmfToolDto
}

func (t *ToolNodeTool) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateEndCallToolDto
}

func (t *ToolNodeTool) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if t == nil {
		return nil
	}
	return t.CreateFunctionToolDto
}

func (t *ToolNodeTool) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (t *ToolNodeTool) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarEventCreateToolDto
}

func (t *ToolNodeTool) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactCreateToolDto
}

func (t *ToolNodeTool) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactGetToolDto
}

func (t *ToolNodeTool) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (t *ToolNodeTool) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCreateEventToolDto
}

func (t *ToolNodeTool) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleSheetsRowAppendToolDto
}

func (t *ToolNodeTool) GetCreateMcpToolDto() *CreateMcpToolDto {
	if t == nil {
		return nil
	}
	return t.CreateMcpToolDto
}

func (t *ToolNodeTool) GetCreateQueryToolDto() *CreateQueryToolDto {
	if t == nil {
		return nil
	}
	return t.CreateQueryToolDto
}

func (t *ToolNodeTool) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSlackSendMessageToolDto
}

func (t *ToolNodeTool) GetCreateSmsToolDto() *CreateSmsToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSmsToolDto
}

func (t *ToolNodeTool) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTextEditorToolDto
}

func (t *ToolNodeTool) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTransferCallToolDto
}

func (t *ToolNodeTool) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		t.typ = "CreateApiRequestToolDto"
		t.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		t.typ = "CreateBashToolDto"
		t.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		t.typ = "CreateComputerToolDto"
		t.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.typ = "CreateDtmfToolDto"
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.typ = "CreateEndCallToolDto"
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.typ = "CreateFunctionToolDto"
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		t.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		t.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactCreateToolDto"
		t.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactGetToolDto"
		t.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		t.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCreateEventToolDto"
		t.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		t.typ = "CreateGoogleSheetsRowAppendToolDto"
		t.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		t.typ = "CreateMcpToolDto"
		t.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		t.typ = "CreateQueryToolDto"
		t.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		t.typ = "CreateSlackSendMessageToolDto"
		t.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		t.typ = "CreateSmsToolDto"
		t.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		t.typ = "CreateTextEditorToolDto"
		t.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.typ = "CreateTransferCallToolDto"
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolNodeTool) MarshalJSON() ([]byte, error) {
	if t.typ == "CreateApiRequestToolDto" || t.CreateApiRequestToolDto != nil {
		return json.Marshal(t.CreateApiRequestToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return json.Marshal(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return json.Marshal(t.CreateComputerToolDto)
	}
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactGetToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return json.Marshal(t.CreateMcpToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return json.Marshal(t.CreateQueryToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return json.Marshal(t.CreateSmsToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return json.Marshal(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolNodeToolVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *ToolNodeTool) Accept(visitor ToolNodeToolVisitor) error {
	if t.typ == "CreateApiRequestToolDto" || t.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(t.CreateApiRequestToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(t.CreateComputerToolDto)
	}
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(t.CreateGoHighLevelContactGetToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(t.CreateMcpToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(t.CreateQueryToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(t.CreateSmsToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolTemplateMetadata struct {
	CollectionType *string `json:"collectionType,omitempty" url:"collectionType,omitempty"`
	CollectionId   *string `json:"collectionId,omitempty" url:"collectionId,omitempty"`
	CollectionName *string `json:"collectionName,omitempty" url:"collectionName,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolTemplateMetadata) GetCollectionType() *string {
	if t == nil {
		return nil
	}
	return t.CollectionType
}

func (t *ToolTemplateMetadata) GetCollectionId() *string {
	if t == nil {
		return nil
	}
	return t.CollectionId
}

func (t *ToolTemplateMetadata) GetCollectionName() *string {
	if t == nil {
		return nil
	}
	return t.CollectionName
}

func (t *ToolTemplateMetadata) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolTemplateMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolTemplateMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolTemplateMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolTemplateMetadata) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolTemplateSetup struct {
	Title       string  `json:"title" url:"title"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	VideoUrl    *string `json:"videoUrl,omitempty" url:"videoUrl,omitempty"`
	DocsUrl     *string `json:"docsUrl,omitempty" url:"docsUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolTemplateSetup) GetTitle() string {
	if t == nil {
		return ""
	}
	return t.Title
}

func (t *ToolTemplateSetup) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *ToolTemplateSetup) GetVideoUrl() *string {
	if t == nil {
		return nil
	}
	return t.VideoUrl
}

func (t *ToolTemplateSetup) GetDocsUrl() *string {
	if t == nil {
		return nil
	}
	return t.DocsUrl
}

func (t *ToolTemplateSetup) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolTemplateSetup) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolTemplateSetup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolTemplateSetup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolTemplateSetup) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranscriptPlan struct {
	// This determines whether the transcript is stored in `call.artifact.transcript`. Defaults to true.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the name of the assistant in the transcript. Defaults to 'AI'.
	//
	// Usage:
	// - If you want to change the name of the assistant in the transcript, set this. Example, here is what the transcript would look like with `assistantName` set to 'Buyer':
	// ```
	// User: Hello, how are you?
	// Buyer: I'm fine.
	// User: Do you want to buy a car?
	// Buyer: No.
	// ```
	//
	// @default 'AI'
	AssistantName *string `json:"assistantName,omitempty" url:"assistantName,omitempty"`
	// This is the name of the user in the transcript. Defaults to 'User'.
	//
	// Usage:
	// - If you want to change the name of the user in the transcript, set this. Example, here is what the transcript would look like with `userName` set to 'Seller':
	// ```
	// Seller: Hello, how are you?
	// AI: I'm fine.
	// Seller: Do you want to buy a car?
	// AI: No.
	// ```
	//
	// @default 'User'
	UserName *string `json:"userName,omitempty" url:"userName,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TranscriptPlan) GetEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.Enabled
}

func (t *TranscriptPlan) GetAssistantName() *string {
	if t == nil {
		return nil
	}
	return t.AssistantName
}

func (t *TranscriptPlan) GetUserName() *string {
	if t == nil {
		return nil
	}
	return t.UserName
}

func (t *TranscriptPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TranscriptPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TranscriptPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TranscriptPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TranscriptPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranscriptionEndpointingPlan struct {
	// The minimum number of seconds to wait after transcription ending with punctuation before sending a request to the model. Defaults to 0.1.
	//
	// This setting exists because the transcriber punctuates the transcription when it's more confident that customer has completed a thought.
	//
	// @default 0.1
	OnPunctuationSeconds *float64 `json:"onPunctuationSeconds,omitempty" url:"onPunctuationSeconds,omitempty"`
	// The minimum number of seconds to wait after transcription ending without punctuation before sending a request to the model. Defaults to 1.5.
	//
	// This setting exists to catch the cases where the transcriber was not confident enough to punctuate the transcription, but the customer is done and has been silent for a long time.
	//
	// @default 1.5
	OnNoPunctuationSeconds *float64 `json:"onNoPunctuationSeconds,omitempty" url:"onNoPunctuationSeconds,omitempty"`
	// The minimum number of seconds to wait after transcription ending with a number before sending a request to the model. Defaults to 0.4.
	//
	// This setting exists because the transcriber will sometimes punctuate the transcription ending with a number, even though the customer hasn't uttered the full number. This happens commonly for long numbers when the customer reads the number in chunks.
	//
	// @default 0.5
	OnNumberSeconds *float64 `json:"onNumberSeconds,omitempty" url:"onNumberSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TranscriptionEndpointingPlan) GetOnPunctuationSeconds() *float64 {
	if t == nil {
		return nil
	}
	return t.OnPunctuationSeconds
}

func (t *TranscriptionEndpointingPlan) GetOnNoPunctuationSeconds() *float64 {
	if t == nil {
		return nil
	}
	return t.OnNoPunctuationSeconds
}

func (t *TranscriptionEndpointingPlan) GetOnNumberSeconds() *float64 {
	if t == nil {
		return nil
	}
	return t.OnNumberSeconds
}

func (t *TranscriptionEndpointingPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TranscriptionEndpointingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TranscriptionEndpointingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TranscriptionEndpointingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TranscriptionEndpointingPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferAssistantHookAction struct {
	// This is the type of action - must be "transfer"
	// This is the destination details for the transfer - can be a phone number or SIP URI
	Destination *TransferAssistantHookActionDestination `json:"destination,omitempty" url:"destination,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferAssistantHookAction) GetDestination() *TransferAssistantHookActionDestination {
	if t == nil {
		return nil
	}
	return t.Destination
}

func (t *TransferAssistantHookAction) Type() string {
	return t.type_
}

func (t *TransferAssistantHookAction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferAssistantHookAction) UnmarshalJSON(data []byte) error {
	type embed TransferAssistantHookAction
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferAssistantHookAction(unmarshaler.embed)
	if unmarshaler.Type != "transfer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "transfer", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferAssistantHookAction) MarshalJSON() ([]byte, error) {
	type embed TransferAssistantHookAction
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transfer",
	}
	return json.Marshal(marshaler)
}

func (t *TransferAssistantHookAction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the destination details for the transfer - can be a phone number or SIP URI
type TransferAssistantHookActionDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (t *TransferAssistantHookActionDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if t == nil {
		return nil
	}
	return t.TransferDestinationNumber
}

func (t *TransferAssistantHookActionDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if t == nil {
		return nil
	}
	return t.TransferDestinationSip
}

func (t *TransferAssistantHookActionDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		t.typ = "TransferDestinationNumber"
		t.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		t.typ = "TransferDestinationSip"
		t.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferAssistantHookActionDestination) MarshalJSON() ([]byte, error) {
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return json.Marshal(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return json.Marshal(t.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferAssistantHookActionDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (t *TransferAssistantHookActionDestination) Accept(visitor TransferAssistantHookActionDestinationVisitor) error {
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(t.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationAssistant struct {
	// This is spoken to the customer before connecting them to the destination.
	//
	// Usage:
	// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	//
	// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
	Message *TransferDestinationAssistantMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the mode to use for the transfer. Defaults to `rolling-history`.
	//
	// - `rolling-history`: This is the default mode. It keeps the entire conversation history and appends the new assistant's system message on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//
	//	Post-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//	  system: assistant2 system message
	//	  assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)
	//
	// - `swap-system-message-in-history`: This replaces the original system message with the new assistant's system message on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//
	//	Post-transfer:
	//	  system: assistant2 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//	  assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)
	//
	// - `delete-history`: This deletes the entire conversation history on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//
	//	Post-transfer:
	//	  system: assistant2 system message
	//	  assistant: assistant2 first message
	//	  user: Yes, please
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//
	// - `swap-system-message-in-history-and-remove-transfer-tool-messages`: This replaces the original system message with the new assistant's system message on transfer and removes transfer tool messages from conversation history sent to the LLM.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  transfer-tool
	//	  transfer-tool-result
	//	  assistant: (destination.message)
	//
	//	Post-transfer:
	//	  system: assistant2 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//	  assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)
	//
	// @default 'rolling-history'
	TransferMode *TransferMode `json:"transferMode,omitempty" url:"transferMode,omitempty"`
	// This is the assistant to transfer the call to.
	AssistantName string `json:"assistantName" url:"assistantName"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferDestinationAssistant) GetMessage() *TransferDestinationAssistantMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferDestinationAssistant) GetTransferMode() *TransferMode {
	if t == nil {
		return nil
	}
	return t.TransferMode
}

func (t *TransferDestinationAssistant) GetAssistantName() string {
	if t == nil {
		return ""
	}
	return t.AssistantName
}

func (t *TransferDestinationAssistant) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransferDestinationAssistant) Type() string {
	return t.type_
}

func (t *TransferDestinationAssistant) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationAssistant) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationAssistant
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationAssistant(unmarshaler.embed)
	if unmarshaler.Type != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "assistant", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationAssistant) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationAssistant
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "assistant",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationAssistant) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is spoken to the customer before connecting them to the destination.
//
// Usage:
// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
//
// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
type TransferDestinationAssistantMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferDestinationAssistantMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferDestinationAssistantMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferDestinationAssistantMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferDestinationAssistantMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationAssistantMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferDestinationAssistantMessage) Accept(visitor TransferDestinationAssistantMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationNumber struct {
	// This is spoken to the customer before connecting them to the destination.
	//
	// Usage:
	// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	//
	// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
	Message *TransferDestinationNumberMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.
	//
	// Use cases:
	// - `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.
	// - `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.
	//
	// If `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\+?[a-zA-Z0-9]+$/`).
	//
	// @default true (E164 check is enabled)
	NumberE164CheckEnabled *bool `json:"numberE164CheckEnabled,omitempty" url:"numberE164CheckEnabled,omitempty"`
	// This is the phone number to transfer the call to.
	Number string `json:"number" url:"number"`
	// This is the extension to dial after transferring the call to the `number`.
	Extension *string `json:"extension,omitempty" url:"extension,omitempty"`
	// This is the caller ID to use when transferring the call to the `number`.
	//
	// Usage:
	// - If not provided, the caller ID will be the number the call is coming from. Example, +14151111111 calls in to and the assistant transfers out to +16470000000. +16470000000 will see +14151111111 as the caller.
	// - To change this behavior, provide a `callerId`.
	// - Set to '{{customer.number}}' to always use the customer's number as the caller ID.
	// - Set to '{{phoneNumber.number}}' to always use the phone number of the assistant as the caller ID.
	// - Set to any E164 number to always use that number as the caller ID. This needs to be a number that is owned or verified by your Transport provider like Twilio.
	//
	// For Twilio, you can read up more here: https://www.twilio.com/docs/voice/twiml/dial#callerid
	CallerId *string `json:"callerId,omitempty" url:"callerId,omitempty"`
	// This configures how transfer is executed and the experience of the destination party receiving the call. Defaults to `blind-transfer`.
	//
	// @default `transferPlan.mode='blind-transfer'`
	TransferPlan *TransferPlan `json:"transferPlan,omitempty" url:"transferPlan,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferDestinationNumber) GetMessage() *TransferDestinationNumberMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferDestinationNumber) GetNumberE164CheckEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.NumberE164CheckEnabled
}

func (t *TransferDestinationNumber) GetNumber() string {
	if t == nil {
		return ""
	}
	return t.Number
}

func (t *TransferDestinationNumber) GetExtension() *string {
	if t == nil {
		return nil
	}
	return t.Extension
}

func (t *TransferDestinationNumber) GetCallerId() *string {
	if t == nil {
		return nil
	}
	return t.CallerId
}

func (t *TransferDestinationNumber) GetTransferPlan() *TransferPlan {
	if t == nil {
		return nil
	}
	return t.TransferPlan
}

func (t *TransferDestinationNumber) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransferDestinationNumber) Type() string {
	return t.type_
}

func (t *TransferDestinationNumber) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationNumber) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationNumber
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationNumber(unmarshaler.embed)
	if unmarshaler.Type != "number" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "number", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationNumber) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationNumber
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "number",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationNumber) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is spoken to the customer before connecting them to the destination.
//
// Usage:
// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
//
// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
type TransferDestinationNumberMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferDestinationNumberMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferDestinationNumberMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferDestinationNumberMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferDestinationNumberMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationNumberMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferDestinationNumberMessage) Accept(visitor TransferDestinationNumberMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationSip struct {
	// This is spoken to the customer before connecting them to the destination.
	//
	// Usage:
	// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	//
	// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
	Message *TransferDestinationSipMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the SIP URI to transfer the call to.
	SipUri string `json:"sipUri" url:"sipUri"`
	// This configures how transfer is executed and the experience of the destination party receiving the call. Defaults to `blind-transfer`.
	//
	// @default `transferPlan.mode='blind-transfer'`
	TransferPlan *TransferPlan `json:"transferPlan,omitempty" url:"transferPlan,omitempty"`
	// These are custom headers to be added to SIP refer during transfer call.
	SipHeaders map[string]interface{} `json:"sipHeaders,omitempty" url:"sipHeaders,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferDestinationSip) GetMessage() *TransferDestinationSipMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferDestinationSip) GetSipUri() string {
	if t == nil {
		return ""
	}
	return t.SipUri
}

func (t *TransferDestinationSip) GetTransferPlan() *TransferPlan {
	if t == nil {
		return nil
	}
	return t.TransferPlan
}

func (t *TransferDestinationSip) GetSipHeaders() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.SipHeaders
}

func (t *TransferDestinationSip) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransferDestinationSip) Type() string {
	return t.type_
}

func (t *TransferDestinationSip) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationSip) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationSip
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationSip(unmarshaler.embed)
	if unmarshaler.Type != "sip" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "sip", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationSip) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationSip
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "sip",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationSip) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is spoken to the customer before connecting them to the destination.
//
// Usage:
// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
//
// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
type TransferDestinationSipMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferDestinationSipMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferDestinationSipMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferDestinationSipMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferDestinationSipMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationSipMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferDestinationSipMessage) Accept(visitor TransferDestinationSipMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferFallbackPlan struct {
	// This is the message the assistant will deliver to the customer if the transfer fails.
	Message *TransferFallbackPlanMessage `json:"message,omitempty" url:"message,omitempty"`
	// This controls what happens after delivering the failure message to the customer.
	// - true: End the call after delivering the failure message (default)
	// - false: Keep the assistant on the call to continue handling the customer's request
	//
	// @default true
	EndCallEnabled *bool `json:"endCallEnabled,omitempty" url:"endCallEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferFallbackPlan) GetMessage() *TransferFallbackPlanMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferFallbackPlan) GetEndCallEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.EndCallEnabled
}

func (t *TransferFallbackPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferFallbackPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TransferFallbackPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransferFallbackPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferFallbackPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the message the assistant will deliver to the customer if the transfer fails.
type TransferFallbackPlanMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferFallbackPlanMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferFallbackPlanMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferFallbackPlanMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferFallbackPlanMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferFallbackPlanMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferFallbackPlanMessage) Accept(visitor TransferFallbackPlanMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferMode string

const (
	TransferModeRollingHistory             TransferMode = "rolling-history"
	TransferModeSwapSystemMessageInHistory TransferMode = "swap-system-message-in-history"
)

func NewTransferModeFromString(s string) (TransferMode, error) {
	switch s {
	case "rolling-history":
		return TransferModeRollingHistory, nil
	case "swap-system-message-in-history":
		return TransferModeSwapSystemMessageInHistory, nil
	}
	var t TransferMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransferMode) Ptr() *TransferMode {
	return &t
}

type TransferPhoneNumberHookAction struct {
	// This is the type of action - must be "transfer"
	// This is the destination details for the transfer - can be a phone number or SIP URI
	Destination *TransferPhoneNumberHookActionDestination `json:"destination,omitempty" url:"destination,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferPhoneNumberHookAction) GetDestination() *TransferPhoneNumberHookActionDestination {
	if t == nil {
		return nil
	}
	return t.Destination
}

func (t *TransferPhoneNumberHookAction) Type() string {
	return t.type_
}

func (t *TransferPhoneNumberHookAction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferPhoneNumberHookAction) UnmarshalJSON(data []byte) error {
	type embed TransferPhoneNumberHookAction
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferPhoneNumberHookAction(unmarshaler.embed)
	if unmarshaler.Type != "transfer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "transfer", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferPhoneNumberHookAction) MarshalJSON() ([]byte, error) {
	type embed TransferPhoneNumberHookAction
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transfer",
	}
	return json.Marshal(marshaler)
}

func (t *TransferPhoneNumberHookAction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the destination details for the transfer - can be a phone number or SIP URI
type TransferPhoneNumberHookActionDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (t *TransferPhoneNumberHookActionDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if t == nil {
		return nil
	}
	return t.TransferDestinationNumber
}

func (t *TransferPhoneNumberHookActionDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if t == nil {
		return nil
	}
	return t.TransferDestinationSip
}

func (t *TransferPhoneNumberHookActionDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		t.typ = "TransferDestinationNumber"
		t.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		t.typ = "TransferDestinationSip"
		t.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferPhoneNumberHookActionDestination) MarshalJSON() ([]byte, error) {
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return json.Marshal(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return json.Marshal(t.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferPhoneNumberHookActionDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (t *TransferPhoneNumberHookActionDestination) Accept(visitor TransferPhoneNumberHookActionDestinationVisitor) error {
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(t.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferPlan struct {
	// This configures how transfer is executed and the experience of the destination party receiving the call.
	//
	// Usage:
	// - `blind-transfer`: The assistant forwards the call to the destination without any message or summary.
	// - `blind-transfer-add-summary-to-sip-header`: The assistant forwards the call to the destination and adds a SIP header X-Transfer-Summary to the call to include the summary.
	// - `warm-transfer-say-message`: The assistant dials the destination, delivers the `message` to the destination party, connects the customer, and leaves the call.
	// - `warm-transfer-say-summary`: The assistant dials the destination, provides a summary of the call to the destination party, connects the customer, and leaves the call.
	// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`: The assistant dials the destination, waits for the operator to speak, delivers the `message` to the destination party, and then connects the customer.
	// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary`: The assistant dials the destination, waits for the operator to speak, provides a summary of the call to the destination party, and then connects the customer.
	// - `warm-transfer-twiml`: The assistant dials the destination, executes the twiml instructions on the destination call leg, connects the customer, and leaves the call.
	// - `warm-transfer-experimental`: The assistant puts the customer on hold, dials the destination, and if the destination answers (and is human), delivers a message or summary before connecting the customer. If the destination is unreachable or not human (e.g., with voicemail detection), the assistant delivers the `fallbackMessage` to the customer and optionally ends the call.
	//
	// @default 'blind-transfer'
	Mode TransferPlanMode `json:"mode" url:"mode"`
	// This is the message the assistant will deliver to the destination party before connecting the customer.
	//
	// Usage:
	// - Used only when `mode` is `blind-transfer-add-summary-to-sip-header`, `warm-transfer-say-message`, `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`, or `warm-transfer-experimental`.
	Message *TransferPlanMessage `json:"message,omitempty" url:"message,omitempty"`
	// This specifies the SIP verb to use while transferring the call.
	// - 'refer': Uses SIP REFER to transfer the call (default)
	// - 'bye': Ends current call with SIP BYE
	// - 'dial': Uses SIP DIAL to transfer the call
	SipVerb map[string]interface{} `json:"sipVerb,omitempty" url:"sipVerb,omitempty"`
	// This is the URL to an audio file played while the customer is on hold during transfer.
	//
	// Usage:
	// - Used only when `mode` is `warm-transfer-experimental`.
	// - Used when transferring calls to play hold audio for the customer.
	// - Must be a publicly accessible URL to an audio file.
	// - Supported formats: MP3 and WAV.
	// - If not provided, the default hold audio will be used.
	HoldAudioUrl *string `json:"holdAudioUrl,omitempty" url:"holdAudioUrl,omitempty"`
	// This is the TwiML instructions to execute on the destination call leg before connecting the customer.
	//
	// Usage:
	// - Used only when `mode` is `warm-transfer-twiml`.
	// - Supports only `Play`, `Say`, `Gather`, `Hangup` and `Pause` verbs.
	// - Maximum length is 4096 characters.
	//
	// Example:
	// ```
	// <Say voice="alice" language="en-US">Hello, transferring a customer to you.</Say>
	// <Pause length="2"/>
	// <Say>They called about billing questions.</Say>
	// ```
	Twiml *string `json:"twiml,omitempty" url:"twiml,omitempty"`
	// This is the plan for generating a summary of the call to present to the destination party.
	//
	// Usage:
	// - Used only when `mode` is `blind-transfer-add-summary-to-sip-header` or `warm-transfer-say-summary` or `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary` or `warm-transfer-experimental`.
	SummaryPlan *SummaryPlan `json:"summaryPlan,omitempty" url:"summaryPlan,omitempty"`
	// This flag includes the sipHeaders from above in the refer to sip uri as url encoded query params.
	//
	// @default false
	SipHeadersInReferToEnabled *bool `json:"sipHeadersInReferToEnabled,omitempty" url:"sipHeadersInReferToEnabled,omitempty"`
	// This configures the fallback plan when the transfer fails (destination unreachable, busy, or not human).
	//
	// Usage:
	// - Used only when `mode` is `warm-transfer-experimental`.
	// - If not provided when using `warm-transfer-experimental`, a default message will be used.
	FallbackPlan *TransferFallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferPlan) GetMode() TransferPlanMode {
	if t == nil {
		return ""
	}
	return t.Mode
}

func (t *TransferPlan) GetMessage() *TransferPlanMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferPlan) GetSipVerb() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.SipVerb
}

func (t *TransferPlan) GetHoldAudioUrl() *string {
	if t == nil {
		return nil
	}
	return t.HoldAudioUrl
}

func (t *TransferPlan) GetTwiml() *string {
	if t == nil {
		return nil
	}
	return t.Twiml
}

func (t *TransferPlan) GetSummaryPlan() *SummaryPlan {
	if t == nil {
		return nil
	}
	return t.SummaryPlan
}

func (t *TransferPlan) GetSipHeadersInReferToEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.SipHeadersInReferToEnabled
}

func (t *TransferPlan) GetFallbackPlan() *TransferFallbackPlan {
	if t == nil {
		return nil
	}
	return t.FallbackPlan
}

func (t *TransferPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TransferPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransferPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the message the assistant will deliver to the destination party before connecting the customer.
//
// Usage:
// - Used only when `mode` is `blind-transfer-add-summary-to-sip-header`, `warm-transfer-say-message`, `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`, or `warm-transfer-experimental`.
type TransferPlanMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferPlanMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferPlanMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferPlanMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferPlanMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferPlanMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferPlanMessage) Accept(visitor TransferPlanMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// This configures how transfer is executed and the experience of the destination party receiving the call.
//
// Usage:
// - `blind-transfer`: The assistant forwards the call to the destination without any message or summary.
// - `blind-transfer-add-summary-to-sip-header`: The assistant forwards the call to the destination and adds a SIP header X-Transfer-Summary to the call to include the summary.
// - `warm-transfer-say-message`: The assistant dials the destination, delivers the `message` to the destination party, connects the customer, and leaves the call.
// - `warm-transfer-say-summary`: The assistant dials the destination, provides a summary of the call to the destination party, connects the customer, and leaves the call.
// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`: The assistant dials the destination, waits for the operator to speak, delivers the `message` to the destination party, and then connects the customer.
// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary`: The assistant dials the destination, waits for the operator to speak, provides a summary of the call to the destination party, and then connects the customer.
// - `warm-transfer-twiml`: The assistant dials the destination, executes the twiml instructions on the destination call leg, connects the customer, and leaves the call.
// - `warm-transfer-experimental`: The assistant puts the customer on hold, dials the destination, and if the destination answers (and is human), delivers a message or summary before connecting the customer. If the destination is unreachable or not human (e.g., with voicemail detection), the assistant delivers the `fallbackMessage` to the customer and optionally ends the call.
//
// @default 'blind-transfer'
type TransferPlanMode string

const (
	TransferPlanModeBlindTransfer                                            TransferPlanMode = "blind-transfer"
	TransferPlanModeBlindTransferAddSummaryToSipHeader                       TransferPlanMode = "blind-transfer-add-summary-to-sip-header"
	TransferPlanModeWarmTransferSayMessage                                   TransferPlanMode = "warm-transfer-say-message"
	TransferPlanModeWarmTransferSaySummary                                   TransferPlanMode = "warm-transfer-say-summary"
	TransferPlanModeWarmTransferTwiml                                        TransferPlanMode = "warm-transfer-twiml"
	TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSayMessage TransferPlanMode = "warm-transfer-wait-for-operator-to-speak-first-and-then-say-message"
	TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSaySummary TransferPlanMode = "warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary"
	TransferPlanModeWarmTransferExperimental                                 TransferPlanMode = "warm-transfer-experimental"
)

func NewTransferPlanModeFromString(s string) (TransferPlanMode, error) {
	switch s {
	case "blind-transfer":
		return TransferPlanModeBlindTransfer, nil
	case "blind-transfer-add-summary-to-sip-header":
		return TransferPlanModeBlindTransferAddSummaryToSipHeader, nil
	case "warm-transfer-say-message":
		return TransferPlanModeWarmTransferSayMessage, nil
	case "warm-transfer-say-summary":
		return TransferPlanModeWarmTransferSaySummary, nil
	case "warm-transfer-twiml":
		return TransferPlanModeWarmTransferTwiml, nil
	case "warm-transfer-wait-for-operator-to-speak-first-and-then-say-message":
		return TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSayMessage, nil
	case "warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary":
		return TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSaySummary, nil
	case "warm-transfer-experimental":
		return TransferPlanModeWarmTransferExperimental, nil
	}
	var t TransferPlanMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransferPlanMode) Ptr() *TransferPlanMode {
	return &t
}

type TransportConfigurationTwilio struct {
	// The integer number of seconds that we should allow the phone to ring before assuming there is no answer.
	// The default is `60` seconds and the maximum is `600` seconds.
	// For some call flows, we will add a 5-second buffer to the timeout value you provide.
	// For this reason, a timeout value of 10 seconds could result in an actual timeout closer to 15 seconds.
	// You can set this to a short time, such as `15` seconds, to hang up before reaching an answering machine or voicemail.
	//
	// @default 60
	Timeout *float64 `json:"timeout,omitempty" url:"timeout,omitempty"`
	// Whether to record the call.
	// Can be `true` to record the phone call, or `false` to not.
	// The default is `false`.
	//
	// @default false
	Record *bool `json:"record,omitempty" url:"record,omitempty"`
	// The number of channels in the final recording.
	// Can be: `mono` or `dual`.
	// The default is `mono`.
	// `mono` records both legs of the call in a single channel of the recording file.
	// `dual` records each leg to a separate channel of the recording file.
	// The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
	//
	// @default 'mono'
	RecordingChannels *TransportConfigurationTwilioRecordingChannels `json:"recordingChannels,omitempty" url:"recordingChannels,omitempty"`
	provider          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransportConfigurationTwilio) GetTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.Timeout
}

func (t *TransportConfigurationTwilio) GetRecord() *bool {
	if t == nil {
		return nil
	}
	return t.Record
}

func (t *TransportConfigurationTwilio) GetRecordingChannels() *TransportConfigurationTwilioRecordingChannels {
	if t == nil {
		return nil
	}
	return t.RecordingChannels
}

func (t *TransportConfigurationTwilio) Provider() string {
	return t.provider
}

func (t *TransportConfigurationTwilio) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransportConfigurationTwilio) UnmarshalJSON(data []byte) error {
	type embed TransportConfigurationTwilio
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransportConfigurationTwilio(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransportConfigurationTwilio) MarshalJSON() ([]byte, error) {
	type embed TransportConfigurationTwilio
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TransportConfigurationTwilio) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The number of channels in the final recording.
// Can be: `mono` or `dual`.
// The default is `mono`.
// `mono` records both legs of the call in a single channel of the recording file.
// `dual` records each leg to a separate channel of the recording file.
// The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
//
// @default 'mono'
type TransportConfigurationTwilioRecordingChannels string

const (
	TransportConfigurationTwilioRecordingChannelsMono TransportConfigurationTwilioRecordingChannels = "mono"
	TransportConfigurationTwilioRecordingChannelsDual TransportConfigurationTwilioRecordingChannels = "dual"
)

func NewTransportConfigurationTwilioRecordingChannelsFromString(s string) (TransportConfigurationTwilioRecordingChannels, error) {
	switch s {
	case "mono":
		return TransportConfigurationTwilioRecordingChannelsMono, nil
	case "dual":
		return TransportConfigurationTwilioRecordingChannelsDual, nil
	}
	var t TransportConfigurationTwilioRecordingChannels
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransportConfigurationTwilioRecordingChannels) Ptr() *TransportConfigurationTwilioRecordingChannels {
	return &t
}

type TrieveCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrieveCredential) GetApiKey() string {
	if t == nil {
		return ""
	}
	return t.ApiKey
}

func (t *TrieveCredential) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TrieveCredential) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TrieveCredential) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TrieveCredential) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TrieveCredential) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TrieveCredential) Provider() string {
	return t.provider
}

func (t *TrieveCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrieveCredential) UnmarshalJSON(data []byte) error {
	type embed TrieveCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TrieveCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "trieve" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "trieve", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrieveCredential) MarshalJSON() ([]byte, error) {
	type embed TrieveCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Provider:  "trieve",
	}
	return json.Marshal(marshaler)
}

func (t *TrieveCredential) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioCredential struct {
	// This is not returned in the API.
	AuthToken *string `json:"authToken,omitempty" url:"authToken,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is not returned in the API.
	ApiSecret *string `json:"apiSecret,omitempty" url:"apiSecret,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name       *string `json:"name,omitempty" url:"name,omitempty"`
	AccountSid string  `json:"accountSid" url:"accountSid"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TwilioCredential) GetAuthToken() *string {
	if t == nil {
		return nil
	}
	return t.AuthToken
}

func (t *TwilioCredential) GetApiKey() *string {
	if t == nil {
		return nil
	}
	return t.ApiKey
}

func (t *TwilioCredential) GetApiSecret() *string {
	if t == nil {
		return nil
	}
	return t.ApiSecret
}

func (t *TwilioCredential) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TwilioCredential) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TwilioCredential) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TwilioCredential) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TwilioCredential) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TwilioCredential) GetAccountSid() string {
	if t == nil {
		return ""
	}
	return t.AccountSid
}

func (t *TwilioCredential) Provider() string {
	return t.provider
}

func (t *TwilioCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioCredential) UnmarshalJSON(data []byte) error {
	type embed TwilioCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TwilioCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioCredential) MarshalJSON() ([]byte, error) {
	type embed TwilioCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Provider:  "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TwilioCredential) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioVoicemailDetectionPlan struct {
	// This is the provider to use for voicemail detection.
	// These are the AMD messages from Twilio that are considered as voicemail. Default is ['machine_end_beep', 'machine_end_silence'].
	//
	// @default {Array} ['machine_end_beep', 'machine_end_silence']
	VoicemailDetectionTypes []TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem `json:"voicemailDetectionTypes,omitempty" url:"voicemailDetectionTypes,omitempty"`
	// This sets whether the assistant should detect voicemail. Defaults to true.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The number of seconds that Twilio should attempt to perform answering machine detection before timing out and returning AnsweredBy as unknown. Default is 30 seconds.
	//
	// Increasing this value will provide the engine more time to make a determination. This can be useful when DetectMessageEnd is provided in the MachineDetection parameter and there is an expectation of long answering machine greetings that can exceed 30 seconds.
	//
	// Decreasing this value will reduce the amount of time the engine has to make a determination. This can be particularly useful when the Enable option is provided in the MachineDetection parameter and you want to limit the time for initial detection.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 30
	MachineDetectionTimeout *float64 `json:"machineDetectionTimeout,omitempty" url:"machineDetectionTimeout,omitempty"`
	// The number of milliseconds that is used as the measuring stick for the length of the speech activity. Durations lower than this value will be interpreted as a human, longer as a machine. Default is 2400 milliseconds.
	//
	// Increasing this value will reduce the chance of a False Machine (detected machine, actually human) for a long human greeting (e.g., a business greeting) but increase the time it takes to detect a machine.
	//
	// Decreasing this value will reduce the chances of a False Human (detected human, actually machine) for short voicemail greetings. The value of this parameter may need to be reduced by more than 1000ms to detect very short voicemail greetings. A reduction of that significance can result in increased False Machine detections. Adjusting the MachineDetectionSpeechEndThreshold is likely the better approach for short voicemails. Decreasing MachineDetectionSpeechThreshold will also reduce the time it takes to detect a machine.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 2400
	MachineDetectionSpeechThreshold *float64 `json:"machineDetectionSpeechThreshold,omitempty" url:"machineDetectionSpeechThreshold,omitempty"`
	// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Default is 1200 milliseconds.
	//
	// Increasing this value will typically be used to better address the short voicemail greeting scenarios. For short voicemails, there is typically 1000-2000ms of audio followed by 1200-2400ms of silence and then additional audio before the beep. Increasing the MachineDetectionSpeechEndThreshold to ~2500ms will treat the 1200-2400ms of silence as a gap in the greeting but not the end of the greeting and will result in a machine detection. The downsides of such a change include:
	// - Increasing the delay for human detection by the amount you increase this parameter, e.g., a change of 1200ms to 2500ms increases human detection delay by 1300ms.
	// - Cases where a human has two utterances separated by a period of silence (e.g. a "Hello", then 2000ms of silence, and another "Hello") may be interpreted as a machine.
	//
	// Decreasing this value will result in faster human detection. The consequence is that it can lead to increased False Human (detected human, actually machine) detections because a silence gap in a voicemail greeting (not necessarily just in short voicemail scenarios) can be incorrectly interpreted as the end of speech.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 1200
	MachineDetectionSpeechEndThreshold *float64 `json:"machineDetectionSpeechEndThreshold,omitempty" url:"machineDetectionSpeechEndThreshold,omitempty"`
	// The number of milliseconds of initial silence after which an unknown AnsweredBy result will be returned. Default is 5000 milliseconds.
	//
	// Increasing this value will result in waiting for a longer period of initial silence before returning an 'unknown' AMD result.
	//
	// Decreasing this value will result in waiting for a shorter period of initial silence before returning an 'unknown' AMD result.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 5000
	MachineDetectionSilenceTimeout *float64 `json:"machineDetectionSilenceTimeout,omitempty" url:"machineDetectionSilenceTimeout,omitempty"`
	provider                       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TwilioVoicemailDetectionPlan) GetVoicemailDetectionTypes() []TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem {
	if t == nil {
		return nil
	}
	return t.VoicemailDetectionTypes
}

func (t *TwilioVoicemailDetectionPlan) GetEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.Enabled
}

func (t *TwilioVoicemailDetectionPlan) GetMachineDetectionTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionTimeout
}

func (t *TwilioVoicemailDetectionPlan) GetMachineDetectionSpeechThreshold() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionSpeechThreshold
}

func (t *TwilioVoicemailDetectionPlan) GetMachineDetectionSpeechEndThreshold() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionSpeechEndThreshold
}

func (t *TwilioVoicemailDetectionPlan) GetMachineDetectionSilenceTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionSilenceTimeout
}

func (t *TwilioVoicemailDetectionPlan) Provider() string {
	return t.provider
}

func (t *TwilioVoicemailDetectionPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioVoicemailDetectionPlan) UnmarshalJSON(data []byte) error {
	type embed TwilioVoicemailDetectionPlan
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TwilioVoicemailDetectionPlan(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioVoicemailDetectionPlan) MarshalJSON() ([]byte, error) {
	type embed TwilioVoicemailDetectionPlan
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TwilioVoicemailDetectionPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem string

const (
	TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineStart      TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem = "machine_start"
	TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemHuman             TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem = "human"
	TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemFax               TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem = "fax"
	TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemUnknown           TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem = "unknown"
	TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineEndBeep    TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem = "machine_end_beep"
	TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineEndSilence TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem = "machine_end_silence"
	TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineEndOther   TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem = "machine_end_other"
)

func NewTwilioVoicemailDetectionPlanVoicemailDetectionTypesItemFromString(s string) (TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem, error) {
	switch s {
	case "machine_start":
		return TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineStart, nil
	case "human":
		return TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemHuman, nil
	case "fax":
		return TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemFax, nil
	case "unknown":
		return TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemUnknown, nil
	case "machine_end_beep":
		return TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineEndBeep, nil
	case "machine_end_silence":
		return TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineEndSilence, nil
	case "machine_end_other":
		return TwilioVoicemailDetectionPlanVoicemailDetectionTypesItemMachineEndOther, nil
	}
	var t TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem) Ptr() *TwilioVoicemailDetectionPlanVoicemailDetectionTypesItem {
	return &t
}

type UpdateAnthropicCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAnthropicCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAnthropicCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAnthropicCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAnthropicCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAnthropicCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAnthropicCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAnthropicCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAnyscaleCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAnyscaleCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAnyscaleCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAnyscaleCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAnyscaleCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAnyscaleCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAnyscaleCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAnyscaleCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAssemblyAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAssemblyAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAssemblyAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAssemblyAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAssemblyAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAssemblyAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAssemblyAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAssemblyAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAzureCredentialDto struct {
	// This is the service being used in Azure.
	Service *UpdateAzureCredentialDtoService `json:"service,omitempty" url:"service,omitempty"`
	// This is the region of the Azure resource.
	Region *UpdateAzureCredentialDtoRegion `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.
	BucketPlan *AzureBlobStorageBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAzureCredentialDto) GetService() *UpdateAzureCredentialDtoService {
	if u == nil {
		return nil
	}
	return u.Service
}

func (u *UpdateAzureCredentialDto) GetRegion() *UpdateAzureCredentialDtoRegion {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateAzureCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAzureCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAzureCredentialDto) GetBucketPlan() *AzureBlobStorageBucketPlan {
	if u == nil {
		return nil
	}
	return u.BucketPlan
}

func (u *UpdateAzureCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAzureCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAzureCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAzureCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAzureCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the region of the Azure resource.
type UpdateAzureCredentialDtoRegion string

const (
	UpdateAzureCredentialDtoRegionAustralia      UpdateAzureCredentialDtoRegion = "australia"
	UpdateAzureCredentialDtoRegionCanadaeast     UpdateAzureCredentialDtoRegion = "canadaeast"
	UpdateAzureCredentialDtoRegionCanadacentral  UpdateAzureCredentialDtoRegion = "canadacentral"
	UpdateAzureCredentialDtoRegionEastus2        UpdateAzureCredentialDtoRegion = "eastus2"
	UpdateAzureCredentialDtoRegionEastus         UpdateAzureCredentialDtoRegion = "eastus"
	UpdateAzureCredentialDtoRegionFrance         UpdateAzureCredentialDtoRegion = "france"
	UpdateAzureCredentialDtoRegionIndia          UpdateAzureCredentialDtoRegion = "india"
	UpdateAzureCredentialDtoRegionJapaneast      UpdateAzureCredentialDtoRegion = "japaneast"
	UpdateAzureCredentialDtoRegionJapanwest      UpdateAzureCredentialDtoRegion = "japanwest"
	UpdateAzureCredentialDtoRegionUaenorth       UpdateAzureCredentialDtoRegion = "uaenorth"
	UpdateAzureCredentialDtoRegionNorthcentralus UpdateAzureCredentialDtoRegion = "northcentralus"
	UpdateAzureCredentialDtoRegionNorway         UpdateAzureCredentialDtoRegion = "norway"
	UpdateAzureCredentialDtoRegionSouthcentralus UpdateAzureCredentialDtoRegion = "southcentralus"
	UpdateAzureCredentialDtoRegionSwedencentral  UpdateAzureCredentialDtoRegion = "swedencentral"
	UpdateAzureCredentialDtoRegionSwitzerland    UpdateAzureCredentialDtoRegion = "switzerland"
	UpdateAzureCredentialDtoRegionUk             UpdateAzureCredentialDtoRegion = "uk"
	UpdateAzureCredentialDtoRegionWestus         UpdateAzureCredentialDtoRegion = "westus"
	UpdateAzureCredentialDtoRegionWestus3        UpdateAzureCredentialDtoRegion = "westus3"
)

func NewUpdateAzureCredentialDtoRegionFromString(s string) (UpdateAzureCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return UpdateAzureCredentialDtoRegionAustralia, nil
	case "canadaeast":
		return UpdateAzureCredentialDtoRegionCanadaeast, nil
	case "canadacentral":
		return UpdateAzureCredentialDtoRegionCanadacentral, nil
	case "eastus2":
		return UpdateAzureCredentialDtoRegionEastus2, nil
	case "eastus":
		return UpdateAzureCredentialDtoRegionEastus, nil
	case "france":
		return UpdateAzureCredentialDtoRegionFrance, nil
	case "india":
		return UpdateAzureCredentialDtoRegionIndia, nil
	case "japaneast":
		return UpdateAzureCredentialDtoRegionJapaneast, nil
	case "japanwest":
		return UpdateAzureCredentialDtoRegionJapanwest, nil
	case "uaenorth":
		return UpdateAzureCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return UpdateAzureCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return UpdateAzureCredentialDtoRegionNorway, nil
	case "southcentralus":
		return UpdateAzureCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return UpdateAzureCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return UpdateAzureCredentialDtoRegionSwitzerland, nil
	case "uk":
		return UpdateAzureCredentialDtoRegionUk, nil
	case "westus":
		return UpdateAzureCredentialDtoRegionWestus, nil
	case "westus3":
		return UpdateAzureCredentialDtoRegionWestus3, nil
	}
	var t UpdateAzureCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureCredentialDtoRegion) Ptr() *UpdateAzureCredentialDtoRegion {
	return &u
}

// This is the service being used in Azure.
type UpdateAzureCredentialDtoService string

const (
	UpdateAzureCredentialDtoServiceSpeech      UpdateAzureCredentialDtoService = "speech"
	UpdateAzureCredentialDtoServiceBlobStorage UpdateAzureCredentialDtoService = "blob_storage"
)

func NewUpdateAzureCredentialDtoServiceFromString(s string) (UpdateAzureCredentialDtoService, error) {
	switch s {
	case "speech":
		return UpdateAzureCredentialDtoServiceSpeech, nil
	case "blob_storage":
		return UpdateAzureCredentialDtoServiceBlobStorage, nil
	}
	var t UpdateAzureCredentialDtoService
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureCredentialDtoService) Ptr() *UpdateAzureCredentialDtoService {
	return &u
}

type UpdateAzureOpenAiCredentialDto struct {
	Region *UpdateAzureOpenAiCredentialDtoRegion      `json:"region,omitempty" url:"region,omitempty"`
	Models []UpdateAzureOpenAiCredentialDtoModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey *string `json:"openAIKey,omitempty" url:"openAIKey,omitempty"`
	// This is not returned in the API.
	OcpApimSubscriptionKey *string `json:"ocpApimSubscriptionKey,omitempty" url:"ocpApimSubscriptionKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name           *string `json:"name,omitempty" url:"name,omitempty"`
	OpenAiEndpoint *string `json:"openAIEndpoint,omitempty" url:"openAIEndpoint,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAzureOpenAiCredentialDto) GetRegion() *UpdateAzureOpenAiCredentialDtoRegion {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateAzureOpenAiCredentialDto) GetModels() []UpdateAzureOpenAiCredentialDtoModelsItem {
	if u == nil {
		return nil
	}
	return u.Models
}

func (u *UpdateAzureOpenAiCredentialDto) GetOpenAiKey() *string {
	if u == nil {
		return nil
	}
	return u.OpenAiKey
}

func (u *UpdateAzureOpenAiCredentialDto) GetOcpApimSubscriptionKey() *string {
	if u == nil {
		return nil
	}
	return u.OcpApimSubscriptionKey
}

func (u *UpdateAzureOpenAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAzureOpenAiCredentialDto) GetOpenAiEndpoint() *string {
	if u == nil {
		return nil
	}
	return u.OpenAiEndpoint
}

func (u *UpdateAzureOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAzureOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAzureOpenAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAzureOpenAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAzureOpenAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAzureOpenAiCredentialDtoModelsItem string

const (
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4120250414     UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4.1-2025-04-14"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt41Mini20250414 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4.1-mini-2025-04-14"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt41Nano20250414 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4.1-nano-2025-04-14"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20241120     UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-11-20"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240806     UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-08-06"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240513     UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-05-13"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-mini-2024-07-18"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-turbo-2024-04-09"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt40125Preview   UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0125-preview"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt41106Preview   UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-1106-preview"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt40613          UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0613"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125    UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-0125"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106    UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-1106"
)

func NewUpdateAzureOpenAiCredentialDtoModelsItemFromString(s string) (UpdateAzureOpenAiCredentialDtoModelsItem, error) {
	switch s {
	case "gpt-4.1-2025-04-14":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4120250414, nil
	case "gpt-4.1-mini-2025-04-14":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt41Mini20250414, nil
	case "gpt-4.1-nano-2025-04-14":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt41Nano20250414, nil
	case "gpt-4o-2024-11-20":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20241120, nil
	case "gpt-4o-2024-08-06":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240806, nil
	case "gpt-4o-2024-05-13":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240513, nil
	case "gpt-4o-mini-2024-07-18":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718, nil
	case "gpt-4-turbo-2024-04-09":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106, nil
	}
	var t UpdateAzureOpenAiCredentialDtoModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureOpenAiCredentialDtoModelsItem) Ptr() *UpdateAzureOpenAiCredentialDtoModelsItem {
	return &u
}

type UpdateAzureOpenAiCredentialDtoRegion string

const (
	UpdateAzureOpenAiCredentialDtoRegionAustralia      UpdateAzureOpenAiCredentialDtoRegion = "australia"
	UpdateAzureOpenAiCredentialDtoRegionCanadaeast     UpdateAzureOpenAiCredentialDtoRegion = "canadaeast"
	UpdateAzureOpenAiCredentialDtoRegionCanadacentral  UpdateAzureOpenAiCredentialDtoRegion = "canadacentral"
	UpdateAzureOpenAiCredentialDtoRegionEastus2        UpdateAzureOpenAiCredentialDtoRegion = "eastus2"
	UpdateAzureOpenAiCredentialDtoRegionEastus         UpdateAzureOpenAiCredentialDtoRegion = "eastus"
	UpdateAzureOpenAiCredentialDtoRegionFrance         UpdateAzureOpenAiCredentialDtoRegion = "france"
	UpdateAzureOpenAiCredentialDtoRegionIndia          UpdateAzureOpenAiCredentialDtoRegion = "india"
	UpdateAzureOpenAiCredentialDtoRegionJapaneast      UpdateAzureOpenAiCredentialDtoRegion = "japaneast"
	UpdateAzureOpenAiCredentialDtoRegionJapanwest      UpdateAzureOpenAiCredentialDtoRegion = "japanwest"
	UpdateAzureOpenAiCredentialDtoRegionUaenorth       UpdateAzureOpenAiCredentialDtoRegion = "uaenorth"
	UpdateAzureOpenAiCredentialDtoRegionNorthcentralus UpdateAzureOpenAiCredentialDtoRegion = "northcentralus"
	UpdateAzureOpenAiCredentialDtoRegionNorway         UpdateAzureOpenAiCredentialDtoRegion = "norway"
	UpdateAzureOpenAiCredentialDtoRegionSouthcentralus UpdateAzureOpenAiCredentialDtoRegion = "southcentralus"
	UpdateAzureOpenAiCredentialDtoRegionSwedencentral  UpdateAzureOpenAiCredentialDtoRegion = "swedencentral"
	UpdateAzureOpenAiCredentialDtoRegionSwitzerland    UpdateAzureOpenAiCredentialDtoRegion = "switzerland"
	UpdateAzureOpenAiCredentialDtoRegionUk             UpdateAzureOpenAiCredentialDtoRegion = "uk"
	UpdateAzureOpenAiCredentialDtoRegionWestus         UpdateAzureOpenAiCredentialDtoRegion = "westus"
	UpdateAzureOpenAiCredentialDtoRegionWestus3        UpdateAzureOpenAiCredentialDtoRegion = "westus3"
)

func NewUpdateAzureOpenAiCredentialDtoRegionFromString(s string) (UpdateAzureOpenAiCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return UpdateAzureOpenAiCredentialDtoRegionAustralia, nil
	case "canadaeast":
		return UpdateAzureOpenAiCredentialDtoRegionCanadaeast, nil
	case "canadacentral":
		return UpdateAzureOpenAiCredentialDtoRegionCanadacentral, nil
	case "eastus2":
		return UpdateAzureOpenAiCredentialDtoRegionEastus2, nil
	case "eastus":
		return UpdateAzureOpenAiCredentialDtoRegionEastus, nil
	case "france":
		return UpdateAzureOpenAiCredentialDtoRegionFrance, nil
	case "india":
		return UpdateAzureOpenAiCredentialDtoRegionIndia, nil
	case "japaneast":
		return UpdateAzureOpenAiCredentialDtoRegionJapaneast, nil
	case "japanwest":
		return UpdateAzureOpenAiCredentialDtoRegionJapanwest, nil
	case "uaenorth":
		return UpdateAzureOpenAiCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return UpdateAzureOpenAiCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return UpdateAzureOpenAiCredentialDtoRegionNorway, nil
	case "southcentralus":
		return UpdateAzureOpenAiCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return UpdateAzureOpenAiCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return UpdateAzureOpenAiCredentialDtoRegionSwitzerland, nil
	case "uk":
		return UpdateAzureOpenAiCredentialDtoRegionUk, nil
	case "westus":
		return UpdateAzureOpenAiCredentialDtoRegionWestus, nil
	case "westus3":
		return UpdateAzureOpenAiCredentialDtoRegionWestus3, nil
	}
	var t UpdateAzureOpenAiCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureOpenAiCredentialDtoRegion) Ptr() *UpdateAzureOpenAiCredentialDtoRegion {
	return &u
}

type UpdateByoSipTrunkCredentialDto struct {
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This can be used to configure the tech prefix on outbound calls. This is an advanced property.
	TechPrefix *string `json:"techPrefix,omitempty" url:"techPrefix,omitempty"`
	// This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.
	SipDiversionHeader *string `json:"sipDiversionHeader,omitempty" url:"sipDiversionHeader,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateByoSipTrunkCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateByoSipTrunkCredentialDto) GetGateways() []*SipTrunkGateway {
	if u == nil {
		return nil
	}
	return u.Gateways
}

func (u *UpdateByoSipTrunkCredentialDto) GetOutboundAuthenticationPlan() *SipTrunkOutboundAuthenticationPlan {
	if u == nil {
		return nil
	}
	return u.OutboundAuthenticationPlan
}

func (u *UpdateByoSipTrunkCredentialDto) GetOutboundLeadingPlusEnabled() *bool {
	if u == nil {
		return nil
	}
	return u.OutboundLeadingPlusEnabled
}

func (u *UpdateByoSipTrunkCredentialDto) GetTechPrefix() *string {
	if u == nil {
		return nil
	}
	return u.TechPrefix
}

func (u *UpdateByoSipTrunkCredentialDto) GetSipDiversionHeader() *string {
	if u == nil {
		return nil
	}
	return u.SipDiversionHeader
}

func (u *UpdateByoSipTrunkCredentialDto) GetSbcConfiguration() *SbcConfiguration {
	if u == nil {
		return nil
	}
	return u.SbcConfiguration
}

func (u *UpdateByoSipTrunkCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateByoSipTrunkCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateByoSipTrunkCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateByoSipTrunkCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateByoSipTrunkCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCartesiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCartesiaCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCartesiaCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCartesiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCartesiaCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCartesiaCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCartesiaCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCartesiaCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCerebrasCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCerebrasCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCerebrasCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCerebrasCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCerebrasCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCerebrasCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCerebrasCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCerebrasCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCloudflareCredentialDto struct {
	// Cloudflare Account Id.
	AccountId *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Cloudflare API Key / Token.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// Cloudflare Account Email.
	AccountEmail *string `json:"accountEmail,omitempty" url:"accountEmail,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in R2
	BucketPlan *CloudflareR2BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCloudflareCredentialDto) GetAccountId() *string {
	if u == nil {
		return nil
	}
	return u.AccountId
}

func (u *UpdateCloudflareCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCloudflareCredentialDto) GetAccountEmail() *string {
	if u == nil {
		return nil
	}
	return u.AccountEmail
}

func (u *UpdateCloudflareCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCloudflareCredentialDto) GetBucketPlan() *CloudflareR2BucketPlan {
	if u == nil {
		return nil
	}
	return u.BucketPlan
}

func (u *UpdateCloudflareCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCloudflareCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCloudflareCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCloudflareCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCloudflareCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCustomLlmCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCustomLlmCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCustomLlmCredentialDto) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if u == nil {
		return nil
	}
	return u.AuthenticationPlan
}

func (u *UpdateCustomLlmCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCustomLlmCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomLlmCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomLlmCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomLlmCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomLlmCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepInfraCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDeepInfraCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateDeepInfraCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateDeepInfraCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepInfraCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDeepInfraCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDeepInfraCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepInfraCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepSeekCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDeepSeekCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateDeepSeekCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateDeepSeekCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepSeekCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDeepSeekCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDeepSeekCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepSeekCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepgramCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDeepgramCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateDeepgramCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateDeepgramCredentialDto) GetApiUrl() *string {
	if u == nil {
		return nil
	}
	return u.ApiUrl
}

func (u *UpdateDeepgramCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepgramCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDeepgramCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDeepgramCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepgramCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateElevenLabsCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateElevenLabsCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateElevenLabsCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateElevenLabsCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateElevenLabsCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateElevenLabsCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateElevenLabsCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateElevenLabsCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGcpCredentialDto struct {
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGcpCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGcpCredentialDto) GetGcpKey() *GcpKey {
	if u == nil {
		return nil
	}
	return u.GcpKey
}

func (u *UpdateGcpCredentialDto) GetBucketPlan() *BucketPlan {
	if u == nil {
		return nil
	}
	return u.BucketPlan
}

func (u *UpdateGcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGcpCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGcpCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGcpCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGcpCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGladiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGladiaCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGladiaCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGladiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGladiaCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGladiaCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGladiaCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGladiaCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGoHighLevelCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoHighLevelCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelMcpCredentialDto struct {
	// This is the authentication session for the credential.
	AuthenticationSession *Oauth2AuthenticationSession `json:"authenticationSession,omitempty" url:"authenticationSession,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelMcpCredentialDto) GetAuthenticationSession() *Oauth2AuthenticationSession {
	if u == nil {
		return nil
	}
	return u.AuthenticationSession
}

func (u *UpdateGoHighLevelMcpCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoHighLevelMcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelMcpCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelMcpCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelMcpCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelMcpCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCalendarOAuth2AuthorizationCredentialDto struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId *string `json:"authorizationId,omitempty" url:"authorizationId,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCalendarOAuth2AuthorizationCredentialDto) GetAuthorizationId() *string {
	if u == nil {
		return nil
	}
	return u.AuthorizationId
}

func (u *UpdateGoogleCalendarOAuth2AuthorizationCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoogleCalendarOAuth2AuthorizationCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCalendarOAuth2AuthorizationCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCalendarOAuth2AuthorizationCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCalendarOAuth2AuthorizationCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCalendarOAuth2AuthorizationCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCalendarOAuth2ClientCredentialDto struct {
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCalendarOAuth2ClientCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoogleCalendarOAuth2ClientCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCalendarOAuth2ClientCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCalendarOAuth2ClientCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCalendarOAuth2ClientCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCalendarOAuth2ClientCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGoogleCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoogleCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleSheetsOAuth2AuthorizationCredentialDto struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId *string `json:"authorizationId,omitempty" url:"authorizationId,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleSheetsOAuth2AuthorizationCredentialDto) GetAuthorizationId() *string {
	if u == nil {
		return nil
	}
	return u.AuthorizationId
}

func (u *UpdateGoogleSheetsOAuth2AuthorizationCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoogleSheetsOAuth2AuthorizationCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleSheetsOAuth2AuthorizationCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleSheetsOAuth2AuthorizationCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleSheetsOAuth2AuthorizationCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleSheetsOAuth2AuthorizationCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGroqCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGroqCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGroqCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGroqCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGroqCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGroqCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGroqCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGroqCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateHumeCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateHumeCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateHumeCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateHumeCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateHumeCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateHumeCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateHumeCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateHumeCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateInflectionAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateInflectionAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateInflectionAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateInflectionAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateInflectionAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateInflectionAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateInflectionAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateInflectionAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateLangfuseCredentialDto struct {
	// The public key for Langfuse project. Eg: pk-lf-...
	PublicKey *string `json:"publicKey,omitempty" url:"publicKey,omitempty"`
	// The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// The host URL for Langfuse project. Eg: https://cloud.langfuse.com
	ApiUrl *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateLangfuseCredentialDto) GetPublicKey() *string {
	if u == nil {
		return nil
	}
	return u.PublicKey
}

func (u *UpdateLangfuseCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateLangfuseCredentialDto) GetApiUrl() *string {
	if u == nil {
		return nil
	}
	return u.ApiUrl
}

func (u *UpdateLangfuseCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateLangfuseCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLangfuseCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLangfuseCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLangfuseCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLangfuseCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateLmntCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateLmntCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateLmntCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateLmntCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLmntCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLmntCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLmntCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLmntCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMakeCredentialDto struct {
	// Team ID
	TeamId *string `json:"teamId,omitempty" url:"teamId,omitempty"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMakeCredentialDto) GetTeamId() *string {
	if u == nil {
		return nil
	}
	return u.TeamId
}

func (u *UpdateMakeCredentialDto) GetRegion() *string {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateMakeCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateMakeCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateMakeCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMakeCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMakeCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMakeCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMakeCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMistralCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMistralCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateMistralCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateMistralCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMistralCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMistralCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMistralCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMistralCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateNeuphonicCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateNeuphonicCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateNeuphonicCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateNeuphonicCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateNeuphonicCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateNeuphonicCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateNeuphonicCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateNeuphonicCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOpenAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOpenAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateOpenAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOpenAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOpenAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOpenAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOpenRouterCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOpenRouterCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateOpenRouterCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateOpenRouterCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOpenRouterCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOpenRouterCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOpenRouterCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOpenRouterCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOrgDto struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the ID of the subscription the org belongs to.
	SubscriptionId *string `json:"subscriptionId,omitempty" url:"subscriptionId,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
	Channel *UpdateOrgDtoChannel `json:"channel,omitempty" url:"channel,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`
	// Stores the information about the compliance plan enforced at the organization level. Currently pciEnabled is supported through this field.
	// When this is enabled, any logs, recordings, or transcriptions will be shipped to the customer endpoints if provided else lost.
	// At the end of the call, you will receive an end-of-call-report message to store on your server, if webhook is provided.
	// Defaults to false.
	// When PCI is enabled, only PCI-compliant Providers will be available for LLM, Voice and transcribers.
	// This is due to the compliance requirements of PCI. Other providers may not meet these requirements.
	CompliancePlan *CompliancePlan `json:"compliancePlan,omitempty" url:"compliancePlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOrgDto) GetHipaaEnabled() *bool {
	if u == nil {
		return nil
	}
	return u.HipaaEnabled
}

func (u *UpdateOrgDto) GetSubscriptionId() *string {
	if u == nil {
		return nil
	}
	return u.SubscriptionId
}

func (u *UpdateOrgDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateOrgDto) GetChannel() *UpdateOrgDtoChannel {
	if u == nil {
		return nil
	}
	return u.Channel
}

func (u *UpdateOrgDto) GetBillingLimit() *float64 {
	if u == nil {
		return nil
	}
	return u.BillingLimit
}

func (u *UpdateOrgDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateOrgDto) GetConcurrencyLimit() *float64 {
	if u == nil {
		return nil
	}
	return u.ConcurrencyLimit
}

func (u *UpdateOrgDto) GetCompliancePlan() *CompliancePlan {
	if u == nil {
		return nil
	}
	return u.CompliancePlan
}

func (u *UpdateOrgDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrgDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrgDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrgDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrgDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
type UpdateOrgDtoChannel string

const (
	UpdateOrgDtoChannelDefault UpdateOrgDtoChannel = "default"
	UpdateOrgDtoChannelWeekly  UpdateOrgDtoChannel = "weekly"
)

func NewUpdateOrgDtoChannelFromString(s string) (UpdateOrgDtoChannel, error) {
	switch s {
	case "default":
		return UpdateOrgDtoChannelDefault, nil
	case "weekly":
		return UpdateOrgDtoChannelWeekly, nil
	}
	var t UpdateOrgDtoChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateOrgDtoChannel) Ptr() *UpdateOrgDtoChannel {
	return &u
}

type UpdatePerplexityAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdatePerplexityAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdatePerplexityAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdatePerplexityAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePerplexityAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePerplexityAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePerplexityAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePerplexityAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePlayHtCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name   *string `json:"name,omitempty" url:"name,omitempty"`
	UserId *string `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdatePlayHtCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdatePlayHtCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdatePlayHtCredentialDto) GetUserId() *string {
	if u == nil {
		return nil
	}
	return u.UserId
}

func (u *UpdatePlayHtCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePlayHtCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePlayHtCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePlayHtCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePlayHtCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRimeAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateRimeAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateRimeAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateRimeAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateRimeAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateRimeAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateRimeAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateRimeAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRunpodCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateRunpodCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateRunpodCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateRunpodCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateRunpodCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateRunpodCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateRunpodCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateRunpodCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateS3CredentialDto struct {
	// AWS access key ID.
	AwsAccessKeyId *string `json:"awsAccessKeyId,omitempty" url:"awsAccessKeyId,omitempty"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey *string `json:"awsSecretAccessKey,omitempty" url:"awsSecretAccessKey,omitempty"`
	// AWS region in which the S3 bucket is located.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// AWS S3 bucket name.
	S3BucketName *string `json:"s3BucketName,omitempty" url:"s3BucketName,omitempty"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix *string `json:"s3PathPrefix,omitempty" url:"s3PathPrefix,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateS3CredentialDto) GetAwsAccessKeyId() *string {
	if u == nil {
		return nil
	}
	return u.AwsAccessKeyId
}

func (u *UpdateS3CredentialDto) GetAwsSecretAccessKey() *string {
	if u == nil {
		return nil
	}
	return u.AwsSecretAccessKey
}

func (u *UpdateS3CredentialDto) GetRegion() *string {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateS3CredentialDto) GetS3BucketName() *string {
	if u == nil {
		return nil
	}
	return u.S3BucketName
}

func (u *UpdateS3CredentialDto) GetS3PathPrefix() *string {
	if u == nil {
		return nil
	}
	return u.S3PathPrefix
}

func (u *UpdateS3CredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateS3CredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateS3CredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateS3CredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateS3CredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateS3CredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSlackOAuth2AuthorizationCredentialDto struct {
	// The authorization ID for the OAuth2 authorization
	AuthorizationId *string `json:"authorizationId,omitempty" url:"authorizationId,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSlackOAuth2AuthorizationCredentialDto) GetAuthorizationId() *string {
	if u == nil {
		return nil
	}
	return u.AuthorizationId
}

func (u *UpdateSlackOAuth2AuthorizationCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateSlackOAuth2AuthorizationCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSlackOAuth2AuthorizationCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSlackOAuth2AuthorizationCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSlackOAuth2AuthorizationCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSlackOAuth2AuthorizationCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSmallestAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSmallestAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateSmallestAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateSmallestAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSmallestAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSmallestAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSmallestAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSmallestAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSpeechmaticsCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSpeechmaticsCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateSpeechmaticsCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateSpeechmaticsCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSpeechmaticsCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSpeechmaticsCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSpeechmaticsCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSpeechmaticsCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSupabaseCredentialDto struct {
	// This is the name of credential. This is just for your reference.
	Name       *string             `json:"name,omitempty" url:"name,omitempty"`
	BucketPlan *SupabaseBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSupabaseCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateSupabaseCredentialDto) GetBucketPlan() *SupabaseBucketPlan {
	if u == nil {
		return nil
	}
	return u.BucketPlan
}

func (u *UpdateSupabaseCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSupabaseCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSupabaseCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSupabaseCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSupabaseCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTavusCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTavusCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateTavusCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTavusCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTavusCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTavusCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTavusCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTavusCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTogetherAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTogetherAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateTogetherAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTogetherAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTogetherAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTogetherAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTogetherAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTogetherAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTokenDto struct {
	// This is the tag for the token. It represents its scope.
	Tag *UpdateTokenDtoTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTokenDto) GetTag() *UpdateTokenDtoTag {
	if u == nil {
		return nil
	}
	return u.Tag
}

func (u *UpdateTokenDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTokenDto) GetRestrictions() *TokenRestrictions {
	if u == nil {
		return nil
	}
	return u.Restrictions
}

func (u *UpdateTokenDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTokenDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTokenDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTokenDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTokenDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the tag for the token. It represents its scope.
type UpdateTokenDtoTag string

const (
	UpdateTokenDtoTagPrivate UpdateTokenDtoTag = "private"
	UpdateTokenDtoTagPublic  UpdateTokenDtoTag = "public"
)

func NewUpdateTokenDtoTagFromString(s string) (UpdateTokenDtoTag, error) {
	switch s {
	case "private":
		return UpdateTokenDtoTagPrivate, nil
	case "public":
		return UpdateTokenDtoTagPublic, nil
	}
	var t UpdateTokenDtoTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateTokenDtoTag) Ptr() *UpdateTokenDtoTag {
	return &u
}

type UpdateToolTemplateDto struct {
	Details         *UpdateToolTemplateDtoDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *UpdateToolTemplateDtoProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata                 `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *UpdateToolTemplateDtoVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string                        `json:"name,omitempty" url:"name,omitempty"`
	Provider *UpdateToolTemplateDtoProvider `json:"provider,omitempty" url:"provider,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateToolTemplateDto) GetDetails() *UpdateToolTemplateDtoDetails {
	if u == nil {
		return nil
	}
	return u.Details
}

func (u *UpdateToolTemplateDto) GetProviderDetails() *UpdateToolTemplateDtoProviderDetails {
	if u == nil {
		return nil
	}
	return u.ProviderDetails
}

func (u *UpdateToolTemplateDto) GetMetadata() *ToolTemplateMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateToolTemplateDto) GetVisibility() *UpdateToolTemplateDtoVisibility {
	if u == nil {
		return nil
	}
	return u.Visibility
}

func (u *UpdateToolTemplateDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateToolTemplateDto) GetProvider() *UpdateToolTemplateDtoProvider {
	if u == nil {
		return nil
	}
	return u.Provider
}

func (u *UpdateToolTemplateDto) Type() string {
	return u.type_
}

func (u *UpdateToolTemplateDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateToolTemplateDto) UnmarshalJSON(data []byte) error {
	type embed UpdateToolTemplateDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateToolTemplateDto(unmarshaler.embed)
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "tool", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateToolTemplateDto) MarshalJSON() ([]byte, error) {
	type embed UpdateToolTemplateDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "tool",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateToolTemplateDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateToolTemplateDtoDetails struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (u *UpdateToolTemplateDtoDetails) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if u == nil {
		return nil
	}
	return u.CreateApiRequestToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateBashToolDto() *CreateBashToolDto {
	if u == nil {
		return nil
	}
	return u.CreateBashToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateComputerToolDto() *CreateComputerToolDto {
	if u == nil {
		return nil
	}
	return u.CreateComputerToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if u == nil {
		return nil
	}
	return u.CreateDtmfToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if u == nil {
		return nil
	}
	return u.CreateEndCallToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if u == nil {
		return nil
	}
	return u.CreateFunctionToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGoHighLevelCalendarEventCreateToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGoHighLevelContactCreateToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGoHighLevelContactGetToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGoogleCalendarCreateEventToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGoogleSheetsRowAppendToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateMcpToolDto() *CreateMcpToolDto {
	if u == nil {
		return nil
	}
	return u.CreateMcpToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateQueryToolDto() *CreateQueryToolDto {
	if u == nil {
		return nil
	}
	return u.CreateQueryToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if u == nil {
		return nil
	}
	return u.CreateSlackSendMessageToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateSmsToolDto() *CreateSmsToolDto {
	if u == nil {
		return nil
	}
	return u.CreateSmsToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if u == nil {
		return nil
	}
	return u.CreateTextEditorToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if u == nil {
		return nil
	}
	return u.CreateTransferCallToolDto
}

func (u *UpdateToolTemplateDtoDetails) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		u.typ = "CreateApiRequestToolDto"
		u.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		u.typ = "CreateBashToolDto"
		u.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		u.typ = "CreateComputerToolDto"
		u.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		u.typ = "CreateDtmfToolDto"
		u.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		u.typ = "CreateEndCallToolDto"
		u.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		u.typ = "CreateFunctionToolDto"
		u.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		u.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		u.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		u.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		u.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		u.typ = "CreateGoHighLevelContactCreateToolDto"
		u.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		u.typ = "CreateGoHighLevelContactGetToolDto"
		u.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		u.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		u.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		u.typ = "CreateGoogleCalendarCreateEventToolDto"
		u.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		u.typ = "CreateGoogleSheetsRowAppendToolDto"
		u.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		u.typ = "CreateMcpToolDto"
		u.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		u.typ = "CreateQueryToolDto"
		u.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		u.typ = "CreateSlackSendMessageToolDto"
		u.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		u.typ = "CreateSmsToolDto"
		u.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		u.typ = "CreateTextEditorToolDto"
		u.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		u.typ = "CreateTransferCallToolDto"
		u.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolTemplateDtoDetails) MarshalJSON() ([]byte, error) {
	if u.typ == "CreateApiRequestToolDto" || u.CreateApiRequestToolDto != nil {
		return json.Marshal(u.CreateApiRequestToolDto)
	}
	if u.typ == "CreateBashToolDto" || u.CreateBashToolDto != nil {
		return json.Marshal(u.CreateBashToolDto)
	}
	if u.typ == "CreateComputerToolDto" || u.CreateComputerToolDto != nil {
		return json.Marshal(u.CreateComputerToolDto)
	}
	if u.typ == "CreateDtmfToolDto" || u.CreateDtmfToolDto != nil {
		return json.Marshal(u.CreateDtmfToolDto)
	}
	if u.typ == "CreateEndCallToolDto" || u.CreateEndCallToolDto != nil {
		return json.Marshal(u.CreateEndCallToolDto)
	}
	if u.typ == "CreateFunctionToolDto" || u.CreateFunctionToolDto != nil {
		return json.Marshal(u.CreateFunctionToolDto)
	}
	if u.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || u.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(u.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if u.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || u.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(u.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if u.typ == "CreateGoHighLevelContactCreateToolDto" || u.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(u.CreateGoHighLevelContactCreateToolDto)
	}
	if u.typ == "CreateGoHighLevelContactGetToolDto" || u.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(u.CreateGoHighLevelContactGetToolDto)
	}
	if u.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || u.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(u.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if u.typ == "CreateGoogleCalendarCreateEventToolDto" || u.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(u.CreateGoogleCalendarCreateEventToolDto)
	}
	if u.typ == "CreateGoogleSheetsRowAppendToolDto" || u.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(u.CreateGoogleSheetsRowAppendToolDto)
	}
	if u.typ == "CreateMcpToolDto" || u.CreateMcpToolDto != nil {
		return json.Marshal(u.CreateMcpToolDto)
	}
	if u.typ == "CreateQueryToolDto" || u.CreateQueryToolDto != nil {
		return json.Marshal(u.CreateQueryToolDto)
	}
	if u.typ == "CreateSlackSendMessageToolDto" || u.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(u.CreateSlackSendMessageToolDto)
	}
	if u.typ == "CreateSmsToolDto" || u.CreateSmsToolDto != nil {
		return json.Marshal(u.CreateSmsToolDto)
	}
	if u.typ == "CreateTextEditorToolDto" || u.CreateTextEditorToolDto != nil {
		return json.Marshal(u.CreateTextEditorToolDto)
	}
	if u.typ == "CreateTransferCallToolDto" || u.CreateTransferCallToolDto != nil {
		return json.Marshal(u.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoDetailsVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (u *UpdateToolTemplateDtoDetails) Accept(visitor UpdateToolTemplateDtoDetailsVisitor) error {
	if u.typ == "CreateApiRequestToolDto" || u.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(u.CreateApiRequestToolDto)
	}
	if u.typ == "CreateBashToolDto" || u.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(u.CreateBashToolDto)
	}
	if u.typ == "CreateComputerToolDto" || u.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(u.CreateComputerToolDto)
	}
	if u.typ == "CreateDtmfToolDto" || u.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(u.CreateDtmfToolDto)
	}
	if u.typ == "CreateEndCallToolDto" || u.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(u.CreateEndCallToolDto)
	}
	if u.typ == "CreateFunctionToolDto" || u.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(u.CreateFunctionToolDto)
	}
	if u.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || u.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(u.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if u.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || u.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(u.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if u.typ == "CreateGoHighLevelContactCreateToolDto" || u.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(u.CreateGoHighLevelContactCreateToolDto)
	}
	if u.typ == "CreateGoHighLevelContactGetToolDto" || u.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(u.CreateGoHighLevelContactGetToolDto)
	}
	if u.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || u.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(u.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if u.typ == "CreateGoogleCalendarCreateEventToolDto" || u.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(u.CreateGoogleCalendarCreateEventToolDto)
	}
	if u.typ == "CreateGoogleSheetsRowAppendToolDto" || u.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(u.CreateGoogleSheetsRowAppendToolDto)
	}
	if u.typ == "CreateMcpToolDto" || u.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(u.CreateMcpToolDto)
	}
	if u.typ == "CreateQueryToolDto" || u.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(u.CreateQueryToolDto)
	}
	if u.typ == "CreateSlackSendMessageToolDto" || u.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(u.CreateSlackSendMessageToolDto)
	}
	if u.typ == "CreateSmsToolDto" || u.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(u.CreateSmsToolDto)
	}
	if u.typ == "CreateTextEditorToolDto" || u.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(u.CreateTextEditorToolDto)
	}
	if u.typ == "CreateTransferCallToolDto" || u.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(u.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoProvider string

const (
	UpdateToolTemplateDtoProviderMake        UpdateToolTemplateDtoProvider = "make"
	UpdateToolTemplateDtoProviderGohighlevel UpdateToolTemplateDtoProvider = "gohighlevel"
	UpdateToolTemplateDtoProviderFunction    UpdateToolTemplateDtoProvider = "function"
)

func NewUpdateToolTemplateDtoProviderFromString(s string) (UpdateToolTemplateDtoProvider, error) {
	switch s {
	case "make":
		return UpdateToolTemplateDtoProviderMake, nil
	case "gohighlevel":
		return UpdateToolTemplateDtoProviderGohighlevel, nil
	case "function":
		return UpdateToolTemplateDtoProviderFunction, nil
	}
	var t UpdateToolTemplateDtoProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateToolTemplateDtoProvider) Ptr() *UpdateToolTemplateDtoProvider {
	return &u
}

type UpdateToolTemplateDtoProviderDetails struct {
	MakeToolProviderDetails                            *MakeToolProviderDetails
	GhlToolProviderDetails                             *GhlToolProviderDetails
	FunctionToolProviderDetails                        *FunctionToolProviderDetails
	GoogleCalendarCreateEventToolProviderDetails       *GoogleCalendarCreateEventToolProviderDetails
	GoogleSheetsRowAppendToolProviderDetails           *GoogleSheetsRowAppendToolProviderDetails
	GoHighLevelCalendarAvailabilityToolProviderDetails *GoHighLevelCalendarAvailabilityToolProviderDetails
	GoHighLevelCalendarEventCreateToolProviderDetails  *GoHighLevelCalendarEventCreateToolProviderDetails
	GoHighLevelContactCreateToolProviderDetails        *GoHighLevelContactCreateToolProviderDetails
	GoHighLevelContactGetToolProviderDetails           *GoHighLevelContactGetToolProviderDetails

	typ string
}

func (u *UpdateToolTemplateDtoProviderDetails) GetMakeToolProviderDetails() *MakeToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.MakeToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGhlToolProviderDetails() *GhlToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GhlToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetFunctionToolProviderDetails() *FunctionToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.FunctionToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGoogleCalendarCreateEventToolProviderDetails() *GoogleCalendarCreateEventToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GoogleCalendarCreateEventToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGoogleSheetsRowAppendToolProviderDetails() *GoogleSheetsRowAppendToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GoogleSheetsRowAppendToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGoHighLevelCalendarAvailabilityToolProviderDetails() *GoHighLevelCalendarAvailabilityToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GoHighLevelCalendarAvailabilityToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGoHighLevelCalendarEventCreateToolProviderDetails() *GoHighLevelCalendarEventCreateToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GoHighLevelCalendarEventCreateToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGoHighLevelContactCreateToolProviderDetails() *GoHighLevelContactCreateToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GoHighLevelContactCreateToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGoHighLevelContactGetToolProviderDetails() *GoHighLevelContactGetToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GoHighLevelContactGetToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		u.typ = "MakeToolProviderDetails"
		u.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		u.typ = "GhlToolProviderDetails"
		u.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		u.typ = "FunctionToolProviderDetails"
		u.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	valueGoogleCalendarCreateEventToolProviderDetails := new(GoogleCalendarCreateEventToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventToolProviderDetails); err == nil {
		u.typ = "GoogleCalendarCreateEventToolProviderDetails"
		u.GoogleCalendarCreateEventToolProviderDetails = valueGoogleCalendarCreateEventToolProviderDetails
		return nil
	}
	valueGoogleSheetsRowAppendToolProviderDetails := new(GoogleSheetsRowAppendToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendToolProviderDetails); err == nil {
		u.typ = "GoogleSheetsRowAppendToolProviderDetails"
		u.GoogleSheetsRowAppendToolProviderDetails = valueGoogleSheetsRowAppendToolProviderDetails
		return nil
	}
	valueGoHighLevelCalendarAvailabilityToolProviderDetails := new(GoHighLevelCalendarAvailabilityToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityToolProviderDetails); err == nil {
		u.typ = "GoHighLevelCalendarAvailabilityToolProviderDetails"
		u.GoHighLevelCalendarAvailabilityToolProviderDetails = valueGoHighLevelCalendarAvailabilityToolProviderDetails
		return nil
	}
	valueGoHighLevelCalendarEventCreateToolProviderDetails := new(GoHighLevelCalendarEventCreateToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateToolProviderDetails); err == nil {
		u.typ = "GoHighLevelCalendarEventCreateToolProviderDetails"
		u.GoHighLevelCalendarEventCreateToolProviderDetails = valueGoHighLevelCalendarEventCreateToolProviderDetails
		return nil
	}
	valueGoHighLevelContactCreateToolProviderDetails := new(GoHighLevelContactCreateToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateToolProviderDetails); err == nil {
		u.typ = "GoHighLevelContactCreateToolProviderDetails"
		u.GoHighLevelContactCreateToolProviderDetails = valueGoHighLevelContactCreateToolProviderDetails
		return nil
	}
	valueGoHighLevelContactGetToolProviderDetails := new(GoHighLevelContactGetToolProviderDetails)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetToolProviderDetails); err == nil {
		u.typ = "GoHighLevelContactGetToolProviderDetails"
		u.GoHighLevelContactGetToolProviderDetails = valueGoHighLevelContactGetToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolTemplateDtoProviderDetails) MarshalJSON() ([]byte, error) {
	if u.typ == "MakeToolProviderDetails" || u.MakeToolProviderDetails != nil {
		return json.Marshal(u.MakeToolProviderDetails)
	}
	if u.typ == "GhlToolProviderDetails" || u.GhlToolProviderDetails != nil {
		return json.Marshal(u.GhlToolProviderDetails)
	}
	if u.typ == "FunctionToolProviderDetails" || u.FunctionToolProviderDetails != nil {
		return json.Marshal(u.FunctionToolProviderDetails)
	}
	if u.typ == "GoogleCalendarCreateEventToolProviderDetails" || u.GoogleCalendarCreateEventToolProviderDetails != nil {
		return json.Marshal(u.GoogleCalendarCreateEventToolProviderDetails)
	}
	if u.typ == "GoogleSheetsRowAppendToolProviderDetails" || u.GoogleSheetsRowAppendToolProviderDetails != nil {
		return json.Marshal(u.GoogleSheetsRowAppendToolProviderDetails)
	}
	if u.typ == "GoHighLevelCalendarAvailabilityToolProviderDetails" || u.GoHighLevelCalendarAvailabilityToolProviderDetails != nil {
		return json.Marshal(u.GoHighLevelCalendarAvailabilityToolProviderDetails)
	}
	if u.typ == "GoHighLevelCalendarEventCreateToolProviderDetails" || u.GoHighLevelCalendarEventCreateToolProviderDetails != nil {
		return json.Marshal(u.GoHighLevelCalendarEventCreateToolProviderDetails)
	}
	if u.typ == "GoHighLevelContactCreateToolProviderDetails" || u.GoHighLevelContactCreateToolProviderDetails != nil {
		return json.Marshal(u.GoHighLevelContactCreateToolProviderDetails)
	}
	if u.typ == "GoHighLevelContactGetToolProviderDetails" || u.GoHighLevelContactGetToolProviderDetails != nil {
		return json.Marshal(u.GoHighLevelContactGetToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
	VisitGoogleCalendarCreateEventToolProviderDetails(*GoogleCalendarCreateEventToolProviderDetails) error
	VisitGoogleSheetsRowAppendToolProviderDetails(*GoogleSheetsRowAppendToolProviderDetails) error
	VisitGoHighLevelCalendarAvailabilityToolProviderDetails(*GoHighLevelCalendarAvailabilityToolProviderDetails) error
	VisitGoHighLevelCalendarEventCreateToolProviderDetails(*GoHighLevelCalendarEventCreateToolProviderDetails) error
	VisitGoHighLevelContactCreateToolProviderDetails(*GoHighLevelContactCreateToolProviderDetails) error
	VisitGoHighLevelContactGetToolProviderDetails(*GoHighLevelContactGetToolProviderDetails) error
}

func (u *UpdateToolTemplateDtoProviderDetails) Accept(visitor UpdateToolTemplateDtoProviderDetailsVisitor) error {
	if u.typ == "MakeToolProviderDetails" || u.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(u.MakeToolProviderDetails)
	}
	if u.typ == "GhlToolProviderDetails" || u.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(u.GhlToolProviderDetails)
	}
	if u.typ == "FunctionToolProviderDetails" || u.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(u.FunctionToolProviderDetails)
	}
	if u.typ == "GoogleCalendarCreateEventToolProviderDetails" || u.GoogleCalendarCreateEventToolProviderDetails != nil {
		return visitor.VisitGoogleCalendarCreateEventToolProviderDetails(u.GoogleCalendarCreateEventToolProviderDetails)
	}
	if u.typ == "GoogleSheetsRowAppendToolProviderDetails" || u.GoogleSheetsRowAppendToolProviderDetails != nil {
		return visitor.VisitGoogleSheetsRowAppendToolProviderDetails(u.GoogleSheetsRowAppendToolProviderDetails)
	}
	if u.typ == "GoHighLevelCalendarAvailabilityToolProviderDetails" || u.GoHighLevelCalendarAvailabilityToolProviderDetails != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityToolProviderDetails(u.GoHighLevelCalendarAvailabilityToolProviderDetails)
	}
	if u.typ == "GoHighLevelCalendarEventCreateToolProviderDetails" || u.GoHighLevelCalendarEventCreateToolProviderDetails != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateToolProviderDetails(u.GoHighLevelCalendarEventCreateToolProviderDetails)
	}
	if u.typ == "GoHighLevelContactCreateToolProviderDetails" || u.GoHighLevelContactCreateToolProviderDetails != nil {
		return visitor.VisitGoHighLevelContactCreateToolProviderDetails(u.GoHighLevelContactCreateToolProviderDetails)
	}
	if u.typ == "GoHighLevelContactGetToolProviderDetails" || u.GoHighLevelContactGetToolProviderDetails != nil {
		return visitor.VisitGoHighLevelContactGetToolProviderDetails(u.GoHighLevelContactGetToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoVisibility string

const (
	UpdateToolTemplateDtoVisibilityPublic  UpdateToolTemplateDtoVisibility = "public"
	UpdateToolTemplateDtoVisibilityPrivate UpdateToolTemplateDtoVisibility = "private"
)

func NewUpdateToolTemplateDtoVisibilityFromString(s string) (UpdateToolTemplateDtoVisibility, error) {
	switch s {
	case "public":
		return UpdateToolTemplateDtoVisibilityPublic, nil
	case "private":
		return UpdateToolTemplateDtoVisibilityPrivate, nil
	}
	var t UpdateToolTemplateDtoVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateToolTemplateDtoVisibility) Ptr() *UpdateToolTemplateDtoVisibility {
	return &u
}

type UpdateTrieveCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTrieveCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateTrieveCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTrieveCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTrieveCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTrieveCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTrieveCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTrieveCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTwilioCredentialDto struct {
	// This is not returned in the API.
	AuthToken *string `json:"authToken,omitempty" url:"authToken,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is not returned in the API.
	ApiSecret *string `json:"apiSecret,omitempty" url:"apiSecret,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name       *string `json:"name,omitempty" url:"name,omitempty"`
	AccountSid *string `json:"accountSid,omitempty" url:"accountSid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTwilioCredentialDto) GetAuthToken() *string {
	if u == nil {
		return nil
	}
	return u.AuthToken
}

func (u *UpdateTwilioCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateTwilioCredentialDto) GetApiSecret() *string {
	if u == nil {
		return nil
	}
	return u.ApiSecret
}

func (u *UpdateTwilioCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTwilioCredentialDto) GetAccountSid() *string {
	if u == nil {
		return nil
	}
	return u.AccountSid
}

func (u *UpdateTwilioCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTwilioCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTwilioCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTwilioCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTwilioCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateUserRoleDto struct {
	UserId string                `json:"userId" url:"userId"`
	Role   UpdateUserRoleDtoRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateUserRoleDto) GetUserId() string {
	if u == nil {
		return ""
	}
	return u.UserId
}

func (u *UpdateUserRoleDto) GetRole() UpdateUserRoleDtoRole {
	if u == nil {
		return ""
	}
	return u.Role
}

func (u *UpdateUserRoleDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateUserRoleDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateUserRoleDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateUserRoleDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateUserRoleDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateUserRoleDtoRole string

const (
	UpdateUserRoleDtoRoleAdmin  UpdateUserRoleDtoRole = "admin"
	UpdateUserRoleDtoRoleEditor UpdateUserRoleDtoRole = "editor"
	UpdateUserRoleDtoRoleViewer UpdateUserRoleDtoRole = "viewer"
)

func NewUpdateUserRoleDtoRoleFromString(s string) (UpdateUserRoleDtoRole, error) {
	switch s {
	case "admin":
		return UpdateUserRoleDtoRoleAdmin, nil
	case "editor":
		return UpdateUserRoleDtoRoleEditor, nil
	case "viewer":
		return UpdateUserRoleDtoRoleViewer, nil
	}
	var t UpdateUserRoleDtoRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateUserRoleDtoRole) Ptr() *UpdateUserRoleDtoRole {
	return &u
}

type UpdateVonageCredentialDto struct {
	// This is not returned in the API.
	ApiSecret *string `json:"apiSecret,omitempty" url:"apiSecret,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name   *string `json:"name,omitempty" url:"name,omitempty"`
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateVonageCredentialDto) GetApiSecret() *string {
	if u == nil {
		return nil
	}
	return u.ApiSecret
}

func (u *UpdateVonageCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateVonageCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateVonageCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateVonageCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateVonageCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateVonageCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateVonageCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateWebhookCredentialDto struct {
	// This is the authentication plan. Currently supports OAuth2 RFC 6749.
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateWebhookCredentialDto) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if u == nil {
		return nil
	}
	return u.AuthenticationPlan
}

func (u *UpdateWebhookCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateWebhookCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWebhookCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWebhookCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWebhookCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWebhookCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateXAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateXAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateXAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateXAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateXAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateXAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateXAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateXAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type User struct {
	// This is the unique identifier for the profile or user.
	Id string `json:"id" url:"id"`
	// This is the ISO 8601 date-time string of when the profile was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the profile was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the email of the user that is associated with the profile.
	Email string `json:"email" url:"email"`
	// This is the full name of the user that is associated with the profile.
	FullName *string `json:"fullName,omitempty" url:"fullName,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetId() string {
	if u == nil {
		return ""
	}
	return u.Id
}

func (u *User) GetCreatedAt() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.CreatedAt
}

func (u *User) GetUpdatedAt() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.UpdatedAt
}

func (u *User) GetEmail() string {
	if u == nil {
		return ""
	}
	return u.Email
}

func (u *User) GetFullName() *string {
	if u == nil {
		return nil
	}
	return u.FullName
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*u),
		CreatedAt: internal.NewDateTime(u.CreatedAt),
		UpdatedAt: internal.NewDateTime(u.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserMessage struct {
	// The role of the user in the conversation.
	Role string `json:"role" url:"role"`
	// The message content from the user.
	Message string `json:"message" url:"message"`
	// The timestamp when the message was sent.
	Time float64 `json:"time" url:"time"`
	// The timestamp when the message ended.
	EndTime float64 `json:"endTime" url:"endTime"`
	// The number of seconds from the start of the conversation.
	SecondsFromStart float64 `json:"secondsFromStart" url:"secondsFromStart"`
	// The duration of the message in seconds.
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserMessage) GetRole() string {
	if u == nil {
		return ""
	}
	return u.Role
}

func (u *UserMessage) GetMessage() string {
	if u == nil {
		return ""
	}
	return u.Message
}

func (u *UserMessage) GetTime() float64 {
	if u == nil {
		return 0
	}
	return u.Time
}

func (u *UserMessage) GetEndTime() float64 {
	if u == nil {
		return 0
	}
	return u.EndTime
}

func (u *UserMessage) GetSecondsFromStart() float64 {
	if u == nil {
		return 0
	}
	return u.SecondsFromStart
}

func (u *UserMessage) GetDuration() *float64 {
	if u == nil {
		return nil
	}
	return u.Duration
}

func (u *UserMessage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler UserMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessage) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VapiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*VapiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	// This is the workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.
	Workflow *WorkflowUserEditable `json:"workflow,omitempty" url:"workflow,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VapiModel) GetMessages() []*OpenAiMessage {
	if v == nil {
		return nil
	}
	return v.Messages
}

func (v *VapiModel) GetTools() []*VapiModelToolsItem {
	if v == nil {
		return nil
	}
	return v.Tools
}

func (v *VapiModel) GetToolIds() []string {
	if v == nil {
		return nil
	}
	return v.ToolIds
}

func (v *VapiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if v == nil {
		return nil
	}
	return v.KnowledgeBase
}

func (v *VapiModel) GetKnowledgeBaseId() *string {
	if v == nil {
		return nil
	}
	return v.KnowledgeBaseId
}

func (v *VapiModel) GetWorkflowId() *string {
	if v == nil {
		return nil
	}
	return v.WorkflowId
}

func (v *VapiModel) GetWorkflow() *WorkflowUserEditable {
	if v == nil {
		return nil
	}
	return v.Workflow
}

func (v *VapiModel) GetModel() string {
	if v == nil {
		return ""
	}
	return v.Model
}

func (v *VapiModel) GetTemperature() *float64 {
	if v == nil {
		return nil
	}
	return v.Temperature
}

func (v *VapiModel) GetMaxTokens() *float64 {
	if v == nil {
		return nil
	}
	return v.MaxTokens
}

func (v *VapiModel) GetEmotionRecognitionEnabled() *bool {
	if v == nil {
		return nil
	}
	return v.EmotionRecognitionEnabled
}

func (v *VapiModel) GetNumFastTurns() *float64 {
	if v == nil {
		return nil
	}
	return v.NumFastTurns
}

func (v *VapiModel) Provider() string {
	return v.provider
}

func (v *VapiModel) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiModel) UnmarshalJSON(data []byte) error {
	type embed VapiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VapiModel(unmarshaler.embed)
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vapi", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiModel) MarshalJSON() ([]byte, error) {
	type embed VapiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*v),
		Provider: "vapi",
	}
	return json.Marshal(marshaler)
}

func (v *VapiModel) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VapiModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (v *VapiModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if v == nil {
		return nil
	}
	return v.CreateApiRequestToolDto
}

func (v *VapiModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if v == nil {
		return nil
	}
	return v.CreateBashToolDto
}

func (v *VapiModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if v == nil {
		return nil
	}
	return v.CreateComputerToolDto
}

func (v *VapiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if v == nil {
		return nil
	}
	return v.CreateDtmfToolDto
}

func (v *VapiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if v == nil {
		return nil
	}
	return v.CreateEndCallToolDto
}

func (v *VapiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if v == nil {
		return nil
	}
	return v.CreateFunctionToolDto
}

func (v *VapiModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (v *VapiModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGoHighLevelCalendarEventCreateToolDto
}

func (v *VapiModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGoHighLevelContactCreateToolDto
}

func (v *VapiModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGoHighLevelContactGetToolDto
}

func (v *VapiModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (v *VapiModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGoogleCalendarCreateEventToolDto
}

func (v *VapiModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGoogleSheetsRowAppendToolDto
}

func (v *VapiModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if v == nil {
		return nil
	}
	return v.CreateMcpToolDto
}

func (v *VapiModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if v == nil {
		return nil
	}
	return v.CreateQueryToolDto
}

func (v *VapiModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if v == nil {
		return nil
	}
	return v.CreateSlackSendMessageToolDto
}

func (v *VapiModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if v == nil {
		return nil
	}
	return v.CreateSmsToolDto
}

func (v *VapiModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if v == nil {
		return nil
	}
	return v.CreateTextEditorToolDto
}

func (v *VapiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if v == nil {
		return nil
	}
	return v.CreateTransferCallToolDto
}

func (v *VapiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		v.typ = "CreateApiRequestToolDto"
		v.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		v.typ = "CreateBashToolDto"
		v.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		v.typ = "CreateComputerToolDto"
		v.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		v.typ = "CreateDtmfToolDto"
		v.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		v.typ = "CreateEndCallToolDto"
		v.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		v.typ = "CreateFunctionToolDto"
		v.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		v.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		v.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		v.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		v.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		v.typ = "CreateGoHighLevelContactCreateToolDto"
		v.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		v.typ = "CreateGoHighLevelContactGetToolDto"
		v.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		v.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		v.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		v.typ = "CreateGoogleCalendarCreateEventToolDto"
		v.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		v.typ = "CreateGoogleSheetsRowAppendToolDto"
		v.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		v.typ = "CreateMcpToolDto"
		v.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		v.typ = "CreateQueryToolDto"
		v.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		v.typ = "CreateSlackSendMessageToolDto"
		v.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		v.typ = "CreateSmsToolDto"
		v.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		v.typ = "CreateTextEditorToolDto"
		v.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		v.typ = "CreateTransferCallToolDto"
		v.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VapiModelToolsItem) MarshalJSON() ([]byte, error) {
	if v.typ == "CreateApiRequestToolDto" || v.CreateApiRequestToolDto != nil {
		return json.Marshal(v.CreateApiRequestToolDto)
	}
	if v.typ == "CreateBashToolDto" || v.CreateBashToolDto != nil {
		return json.Marshal(v.CreateBashToolDto)
	}
	if v.typ == "CreateComputerToolDto" || v.CreateComputerToolDto != nil {
		return json.Marshal(v.CreateComputerToolDto)
	}
	if v.typ == "CreateDtmfToolDto" || v.CreateDtmfToolDto != nil {
		return json.Marshal(v.CreateDtmfToolDto)
	}
	if v.typ == "CreateEndCallToolDto" || v.CreateEndCallToolDto != nil {
		return json.Marshal(v.CreateEndCallToolDto)
	}
	if v.typ == "CreateFunctionToolDto" || v.CreateFunctionToolDto != nil {
		return json.Marshal(v.CreateFunctionToolDto)
	}
	if v.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || v.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(v.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if v.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || v.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(v.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if v.typ == "CreateGoHighLevelContactCreateToolDto" || v.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(v.CreateGoHighLevelContactCreateToolDto)
	}
	if v.typ == "CreateGoHighLevelContactGetToolDto" || v.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(v.CreateGoHighLevelContactGetToolDto)
	}
	if v.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || v.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(v.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if v.typ == "CreateGoogleCalendarCreateEventToolDto" || v.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(v.CreateGoogleCalendarCreateEventToolDto)
	}
	if v.typ == "CreateGoogleSheetsRowAppendToolDto" || v.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(v.CreateGoogleSheetsRowAppendToolDto)
	}
	if v.typ == "CreateMcpToolDto" || v.CreateMcpToolDto != nil {
		return json.Marshal(v.CreateMcpToolDto)
	}
	if v.typ == "CreateQueryToolDto" || v.CreateQueryToolDto != nil {
		return json.Marshal(v.CreateQueryToolDto)
	}
	if v.typ == "CreateSlackSendMessageToolDto" || v.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(v.CreateSlackSendMessageToolDto)
	}
	if v.typ == "CreateSmsToolDto" || v.CreateSmsToolDto != nil {
		return json.Marshal(v.CreateSmsToolDto)
	}
	if v.typ == "CreateTextEditorToolDto" || v.CreateTextEditorToolDto != nil {
		return json.Marshal(v.CreateTextEditorToolDto)
	}
	if v.typ == "CreateTransferCallToolDto" || v.CreateTransferCallToolDto != nil {
		return json.Marshal(v.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (v *VapiModelToolsItem) Accept(visitor VapiModelToolsItemVisitor) error {
	if v.typ == "CreateApiRequestToolDto" || v.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(v.CreateApiRequestToolDto)
	}
	if v.typ == "CreateBashToolDto" || v.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(v.CreateBashToolDto)
	}
	if v.typ == "CreateComputerToolDto" || v.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(v.CreateComputerToolDto)
	}
	if v.typ == "CreateDtmfToolDto" || v.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(v.CreateDtmfToolDto)
	}
	if v.typ == "CreateEndCallToolDto" || v.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(v.CreateEndCallToolDto)
	}
	if v.typ == "CreateFunctionToolDto" || v.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(v.CreateFunctionToolDto)
	}
	if v.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || v.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(v.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if v.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || v.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(v.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if v.typ == "CreateGoHighLevelContactCreateToolDto" || v.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(v.CreateGoHighLevelContactCreateToolDto)
	}
	if v.typ == "CreateGoHighLevelContactGetToolDto" || v.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(v.CreateGoHighLevelContactGetToolDto)
	}
	if v.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || v.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(v.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if v.typ == "CreateGoogleCalendarCreateEventToolDto" || v.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(v.CreateGoogleCalendarCreateEventToolDto)
	}
	if v.typ == "CreateGoogleSheetsRowAppendToolDto" || v.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(v.CreateGoogleSheetsRowAppendToolDto)
	}
	if v.typ == "CreateMcpToolDto" || v.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(v.CreateMcpToolDto)
	}
	if v.typ == "CreateQueryToolDto" || v.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(v.CreateQueryToolDto)
	}
	if v.typ == "CreateSlackSendMessageToolDto" || v.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(v.CreateSlackSendMessageToolDto)
	}
	if v.typ == "CreateSmsToolDto" || v.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(v.CreateSmsToolDto)
	}
	if v.typ == "CreateTextEditorToolDto" || v.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(v.CreateTextEditorToolDto)
	}
	if v.typ == "CreateTransferCallToolDto" || v.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(v.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiSmartEndpointingPlan struct {
	// This is the provider for the smart endpointing plan.
	Provider VapiSmartEndpointingPlanProvider `json:"provider" url:"provider"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VapiSmartEndpointingPlan) GetProvider() VapiSmartEndpointingPlanProvider {
	if v == nil {
		return ""
	}
	return v.Provider
}

func (v *VapiSmartEndpointingPlan) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiSmartEndpointingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler VapiSmartEndpointingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VapiSmartEndpointingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiSmartEndpointingPlan) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// This is the provider for the smart endpointing plan.
type VapiSmartEndpointingPlanProvider string

const (
	VapiSmartEndpointingPlanProviderVapi    VapiSmartEndpointingPlanProvider = "vapi"
	VapiSmartEndpointingPlanProviderLivekit VapiSmartEndpointingPlanProvider = "livekit"
)

func NewVapiSmartEndpointingPlanProviderFromString(s string) (VapiSmartEndpointingPlanProvider, error) {
	switch s {
	case "vapi":
		return VapiSmartEndpointingPlanProviderVapi, nil
	case "livekit":
		return VapiSmartEndpointingPlanProviderLivekit, nil
	}
	var t VapiSmartEndpointingPlanProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VapiSmartEndpointingPlanProvider) Ptr() *VapiSmartEndpointingPlanProvider {
	return &v
}

type VapiVoice struct {
	// This is the flag to toggle voice caching for the assistant.
	CachingEnabled *bool `json:"cachingEnabled,omitempty" url:"cachingEnabled,omitempty"`
	// This is the voice provider that will be used.
	// The voices provided by Vapi
	VoiceId VapiVoiceVoiceId `json:"voiceId" url:"voiceId"`
	// This is the speed multiplier that will be used.
	//
	// @default 1
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the language code (ISO 639-1) that will be used.
	//
	// @default 'en-US'
	Language *VapiVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VapiVoice) GetCachingEnabled() *bool {
	if v == nil {
		return nil
	}
	return v.CachingEnabled
}

func (v *VapiVoice) GetVoiceId() VapiVoiceVoiceId {
	if v == nil {
		return ""
	}
	return v.VoiceId
}

func (v *VapiVoice) GetSpeed() *float64 {
	if v == nil {
		return nil
	}
	return v.Speed
}

func (v *VapiVoice) GetLanguage() *VapiVoiceLanguage {
	if v == nil {
		return nil
	}
	return v.Language
}

func (v *VapiVoice) GetChunkPlan() *ChunkPlan {
	if v == nil {
		return nil
	}
	return v.ChunkPlan
}

func (v *VapiVoice) GetFallbackPlan() *FallbackPlan {
	if v == nil {
		return nil
	}
	return v.FallbackPlan
}

func (v *VapiVoice) Provider() string {
	return v.provider
}

func (v *VapiVoice) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiVoice) UnmarshalJSON(data []byte) error {
	type embed VapiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VapiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vapi", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiVoice) MarshalJSON() ([]byte, error) {
	type embed VapiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*v),
		Provider: "vapi",
	}
	return json.Marshal(marshaler)
}

func (v *VapiVoice) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// This is the language code (ISO 639-1) that will be used.
//
// @default 'en-US'
type VapiVoiceLanguage string

const (
	VapiVoiceLanguageEnUs VapiVoiceLanguage = "en-US"
	VapiVoiceLanguageEnGb VapiVoiceLanguage = "en-GB"
	VapiVoiceLanguageEnAu VapiVoiceLanguage = "en-AU"
	VapiVoiceLanguageEnCa VapiVoiceLanguage = "en-CA"
	VapiVoiceLanguageJa   VapiVoiceLanguage = "ja"
	VapiVoiceLanguageZh   VapiVoiceLanguage = "zh"
	VapiVoiceLanguageDe   VapiVoiceLanguage = "de"
	VapiVoiceLanguageHi   VapiVoiceLanguage = "hi"
	VapiVoiceLanguageFrFr VapiVoiceLanguage = "fr-FR"
	VapiVoiceLanguageFrCa VapiVoiceLanguage = "fr-CA"
	VapiVoiceLanguageKo   VapiVoiceLanguage = "ko"
	VapiVoiceLanguagePtBr VapiVoiceLanguage = "pt-BR"
	VapiVoiceLanguagePtPt VapiVoiceLanguage = "pt-PT"
	VapiVoiceLanguageIt   VapiVoiceLanguage = "it"
	VapiVoiceLanguageEsEs VapiVoiceLanguage = "es-ES"
	VapiVoiceLanguageEsMx VapiVoiceLanguage = "es-MX"
	VapiVoiceLanguageId   VapiVoiceLanguage = "id"
	VapiVoiceLanguageNl   VapiVoiceLanguage = "nl"
	VapiVoiceLanguageTr   VapiVoiceLanguage = "tr"
	VapiVoiceLanguageFil  VapiVoiceLanguage = "fil"
	VapiVoiceLanguagePl   VapiVoiceLanguage = "pl"
	VapiVoiceLanguageSv   VapiVoiceLanguage = "sv"
	VapiVoiceLanguageBg   VapiVoiceLanguage = "bg"
	VapiVoiceLanguageRo   VapiVoiceLanguage = "ro"
	VapiVoiceLanguageArSa VapiVoiceLanguage = "ar-SA"
	VapiVoiceLanguageArAe VapiVoiceLanguage = "ar-AE"
	VapiVoiceLanguageCs   VapiVoiceLanguage = "cs"
	VapiVoiceLanguageEl   VapiVoiceLanguage = "el"
	VapiVoiceLanguageFi   VapiVoiceLanguage = "fi"
	VapiVoiceLanguageHr   VapiVoiceLanguage = "hr"
	VapiVoiceLanguageMs   VapiVoiceLanguage = "ms"
	VapiVoiceLanguageSk   VapiVoiceLanguage = "sk"
	VapiVoiceLanguageDa   VapiVoiceLanguage = "da"
	VapiVoiceLanguageTa   VapiVoiceLanguage = "ta"
	VapiVoiceLanguageUk   VapiVoiceLanguage = "uk"
	VapiVoiceLanguageRu   VapiVoiceLanguage = "ru"
	VapiVoiceLanguageHu   VapiVoiceLanguage = "hu"
	VapiVoiceLanguageNo   VapiVoiceLanguage = "no"
	VapiVoiceLanguageVi   VapiVoiceLanguage = "vi"
)

func NewVapiVoiceLanguageFromString(s string) (VapiVoiceLanguage, error) {
	switch s {
	case "en-US":
		return VapiVoiceLanguageEnUs, nil
	case "en-GB":
		return VapiVoiceLanguageEnGb, nil
	case "en-AU":
		return VapiVoiceLanguageEnAu, nil
	case "en-CA":
		return VapiVoiceLanguageEnCa, nil
	case "ja":
		return VapiVoiceLanguageJa, nil
	case "zh":
		return VapiVoiceLanguageZh, nil
	case "de":
		return VapiVoiceLanguageDe, nil
	case "hi":
		return VapiVoiceLanguageHi, nil
	case "fr-FR":
		return VapiVoiceLanguageFrFr, nil
	case "fr-CA":
		return VapiVoiceLanguageFrCa, nil
	case "ko":
		return VapiVoiceLanguageKo, nil
	case "pt-BR":
		return VapiVoiceLanguagePtBr, nil
	case "pt-PT":
		return VapiVoiceLanguagePtPt, nil
	case "it":
		return VapiVoiceLanguageIt, nil
	case "es-ES":
		return VapiVoiceLanguageEsEs, nil
	case "es-MX":
		return VapiVoiceLanguageEsMx, nil
	case "id":
		return VapiVoiceLanguageId, nil
	case "nl":
		return VapiVoiceLanguageNl, nil
	case "tr":
		return VapiVoiceLanguageTr, nil
	case "fil":
		return VapiVoiceLanguageFil, nil
	case "pl":
		return VapiVoiceLanguagePl, nil
	case "sv":
		return VapiVoiceLanguageSv, nil
	case "bg":
		return VapiVoiceLanguageBg, nil
	case "ro":
		return VapiVoiceLanguageRo, nil
	case "ar-SA":
		return VapiVoiceLanguageArSa, nil
	case "ar-AE":
		return VapiVoiceLanguageArAe, nil
	case "cs":
		return VapiVoiceLanguageCs, nil
	case "el":
		return VapiVoiceLanguageEl, nil
	case "fi":
		return VapiVoiceLanguageFi, nil
	case "hr":
		return VapiVoiceLanguageHr, nil
	case "ms":
		return VapiVoiceLanguageMs, nil
	case "sk":
		return VapiVoiceLanguageSk, nil
	case "da":
		return VapiVoiceLanguageDa, nil
	case "ta":
		return VapiVoiceLanguageTa, nil
	case "uk":
		return VapiVoiceLanguageUk, nil
	case "ru":
		return VapiVoiceLanguageRu, nil
	case "hu":
		return VapiVoiceLanguageHu, nil
	case "no":
		return VapiVoiceLanguageNo, nil
	case "vi":
		return VapiVoiceLanguageVi, nil
	}
	var t VapiVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VapiVoiceLanguage) Ptr() *VapiVoiceLanguage {
	return &v
}

// The voices provided by Vapi
type VapiVoiceVoiceId string

const (
	VapiVoiceVoiceIdElliot   VapiVoiceVoiceId = "Elliot"
	VapiVoiceVoiceIdKylie    VapiVoiceVoiceId = "Kylie"
	VapiVoiceVoiceIdRohan    VapiVoiceVoiceId = "Rohan"
	VapiVoiceVoiceIdLily     VapiVoiceVoiceId = "Lily"
	VapiVoiceVoiceIdSavannah VapiVoiceVoiceId = "Savannah"
	VapiVoiceVoiceIdHana     VapiVoiceVoiceId = "Hana"
	VapiVoiceVoiceIdNeha     VapiVoiceVoiceId = "Neha"
	VapiVoiceVoiceIdCole     VapiVoiceVoiceId = "Cole"
	VapiVoiceVoiceIdHarry    VapiVoiceVoiceId = "Harry"
	VapiVoiceVoiceIdPaige    VapiVoiceVoiceId = "Paige"
	VapiVoiceVoiceIdSpencer  VapiVoiceVoiceId = "Spencer"
)

func NewVapiVoiceVoiceIdFromString(s string) (VapiVoiceVoiceId, error) {
	switch s {
	case "Elliot":
		return VapiVoiceVoiceIdElliot, nil
	case "Kylie":
		return VapiVoiceVoiceIdKylie, nil
	case "Rohan":
		return VapiVoiceVoiceIdRohan, nil
	case "Lily":
		return VapiVoiceVoiceIdLily, nil
	case "Savannah":
		return VapiVoiceVoiceIdSavannah, nil
	case "Hana":
		return VapiVoiceVoiceIdHana, nil
	case "Neha":
		return VapiVoiceVoiceIdNeha, nil
	case "Cole":
		return VapiVoiceVoiceIdCole, nil
	case "Harry":
		return VapiVoiceVoiceIdHarry, nil
	case "Paige":
		return VapiVoiceVoiceIdPaige, nil
	case "Spencer":
		return VapiVoiceVoiceIdSpencer, nil
	}
	var t VapiVoiceVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VapiVoiceVoiceId) Ptr() *VapiVoiceVoiceId {
	return &v
}

type VapiVoicemailDetectionPlan struct {
	// This is the maximum duration from the start of the call that we will wait for a voicemail beep, before speaking our message
	//
	// - If we detect a voicemail beep before this, we will speak the message at that point.
	//
	// - Setting too low a value means that the bot will start speaking its voicemail message too early. If it does so before the actual beep, it will get cut off. You should definitely tune this to your use case.
	//
	// @default 30
	// @min 0
	// @max 60
	BeepMaxAwaitSeconds *float64 `json:"beepMaxAwaitSeconds,omitempty" url:"beepMaxAwaitSeconds,omitempty"`
	// This is the provider to use for voicemail detection.
	// This is the backoff plan for the voicemail detection.
	BackoffPlan *VoicemailDetectionBackoffPlan `json:"backoffPlan,omitempty" url:"backoffPlan,omitempty"`
	provider    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VapiVoicemailDetectionPlan) GetBeepMaxAwaitSeconds() *float64 {
	if v == nil {
		return nil
	}
	return v.BeepMaxAwaitSeconds
}

func (v *VapiVoicemailDetectionPlan) GetBackoffPlan() *VoicemailDetectionBackoffPlan {
	if v == nil {
		return nil
	}
	return v.BackoffPlan
}

func (v *VapiVoicemailDetectionPlan) Provider() string {
	return v.provider
}

func (v *VapiVoicemailDetectionPlan) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiVoicemailDetectionPlan) UnmarshalJSON(data []byte) error {
	type embed VapiVoicemailDetectionPlan
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VapiVoicemailDetectionPlan(unmarshaler.embed)
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vapi", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiVoicemailDetectionPlan) MarshalJSON() ([]byte, error) {
	type embed VapiVoicemailDetectionPlan
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*v),
		Provider: "vapi",
	}
	return json.Marshal(marshaler)
}

func (v *VapiVoicemailDetectionPlan) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VariableExtractionPlan struct {
	Output []*VariableExtractionSchema `json:"output,omitempty" url:"output,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VariableExtractionPlan) GetOutput() []*VariableExtractionSchema {
	if v == nil {
		return nil
	}
	return v.Output
}

func (v *VariableExtractionPlan) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VariableExtractionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler VariableExtractionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VariableExtractionPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VariableExtractionPlan) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VariableExtractionSchema struct {
	// This is the type of output you'd like.
	//
	// `string`, `number`, `boolean` are primitive types.
	Type VariableExtractionSchemaType `json:"type" url:"type"`
	// This is the title of the variable.
	//
	// It can only contain letters, numbers, and underscores.
	Title string `json:"title" url:"title"`
	// This is the description to help the model understand what it needs to output.
	Description string `json:"description" url:"description"`
	// This is the enum values to choose from. Only used if the type is `string`.
	Enum []string `json:"enum,omitempty" url:"enum,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VariableExtractionSchema) GetType() VariableExtractionSchemaType {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *VariableExtractionSchema) GetTitle() string {
	if v == nil {
		return ""
	}
	return v.Title
}

func (v *VariableExtractionSchema) GetDescription() string {
	if v == nil {
		return ""
	}
	return v.Description
}

func (v *VariableExtractionSchema) GetEnum() []string {
	if v == nil {
		return nil
	}
	return v.Enum
}

func (v *VariableExtractionSchema) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VariableExtractionSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler VariableExtractionSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VariableExtractionSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VariableExtractionSchema) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// This is the type of output you'd like.
//
// `string`, `number`, `boolean` are primitive types.
type VariableExtractionSchemaType string

const (
	VariableExtractionSchemaTypeString  VariableExtractionSchemaType = "string"
	VariableExtractionSchemaTypeNumber  VariableExtractionSchemaType = "number"
	VariableExtractionSchemaTypeInteger VariableExtractionSchemaType = "integer"
	VariableExtractionSchemaTypeBoolean VariableExtractionSchemaType = "boolean"
)

func NewVariableExtractionSchemaTypeFromString(s string) (VariableExtractionSchemaType, error) {
	switch s {
	case "string":
		return VariableExtractionSchemaTypeString, nil
	case "number":
		return VariableExtractionSchemaTypeNumber, nil
	case "integer":
		return VariableExtractionSchemaTypeInteger, nil
	case "boolean":
		return VariableExtractionSchemaTypeBoolean, nil
	}
	var t VariableExtractionSchemaType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VariableExtractionSchemaType) Ptr() *VariableExtractionSchemaType {
	return &v
}

type VoiceLibrary struct {
	// This is the voice provider that will be used.
	Provider map[string]interface{} `json:"provider,omitempty" url:"provider,omitempty"`
	// The ID of the voice provided by the provider.
	ProviderId *string `json:"providerId,omitempty" url:"providerId,omitempty"`
	// The unique slug of the voice.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// The name of the voice.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The language of the voice.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The language code of the voice.
	LanguageCode *string `json:"languageCode,omitempty" url:"languageCode,omitempty"`
	// The model of the voice.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The supported models of the voice.
	SupportedModels *string `json:"supportedModels,omitempty" url:"supportedModels,omitempty"`
	// The gender of the voice.
	Gender *VoiceLibraryGender `json:"gender,omitempty" url:"gender,omitempty"`
	// The accent of the voice.
	Accent *string `json:"accent,omitempty" url:"accent,omitempty"`
	// The preview URL of the voice.
	PreviewUrl *string `json:"previewUrl,omitempty" url:"previewUrl,omitempty"`
	// The description of the voice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The credential ID of the voice.
	CredentialId *string `json:"credentialId,omitempty" url:"credentialId,omitempty"`
	// The unique identifier for the voice library.
	Id string `json:"id" url:"id"`
	// The unique identifier for the organization that this voice library belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// The Public voice is shared accross all the organizations.
	IsPublic bool `json:"isPublic" url:"isPublic"`
	// The deletion status of the voice.
	IsDeleted bool `json:"isDeleted" url:"isDeleted"`
	// The ISO 8601 date-time string of when the voice library was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The ISO 8601 date-time string of when the voice library was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoiceLibrary) GetProvider() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Provider
}

func (v *VoiceLibrary) GetProviderId() *string {
	if v == nil {
		return nil
	}
	return v.ProviderId
}

func (v *VoiceLibrary) GetSlug() *string {
	if v == nil {
		return nil
	}
	return v.Slug
}

func (v *VoiceLibrary) GetName() *string {
	if v == nil {
		return nil
	}
	return v.Name
}

func (v *VoiceLibrary) GetLanguage() *string {
	if v == nil {
		return nil
	}
	return v.Language
}

func (v *VoiceLibrary) GetLanguageCode() *string {
	if v == nil {
		return nil
	}
	return v.LanguageCode
}

func (v *VoiceLibrary) GetModel() *string {
	if v == nil {
		return nil
	}
	return v.Model
}

func (v *VoiceLibrary) GetSupportedModels() *string {
	if v == nil {
		return nil
	}
	return v.SupportedModels
}

func (v *VoiceLibrary) GetGender() *VoiceLibraryGender {
	if v == nil {
		return nil
	}
	return v.Gender
}

func (v *VoiceLibrary) GetAccent() *string {
	if v == nil {
		return nil
	}
	return v.Accent
}

func (v *VoiceLibrary) GetPreviewUrl() *string {
	if v == nil {
		return nil
	}
	return v.PreviewUrl
}

func (v *VoiceLibrary) GetDescription() *string {
	if v == nil {
		return nil
	}
	return v.Description
}

func (v *VoiceLibrary) GetCredentialId() *string {
	if v == nil {
		return nil
	}
	return v.CredentialId
}

func (v *VoiceLibrary) GetId() string {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *VoiceLibrary) GetOrgId() string {
	if v == nil {
		return ""
	}
	return v.OrgId
}

func (v *VoiceLibrary) GetIsPublic() bool {
	if v == nil {
		return false
	}
	return v.IsPublic
}

func (v *VoiceLibrary) GetIsDeleted() bool {
	if v == nil {
		return false
	}
	return v.IsDeleted
}

func (v *VoiceLibrary) GetCreatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.CreatedAt
}

func (v *VoiceLibrary) GetUpdatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.UpdatedAt
}

func (v *VoiceLibrary) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceLibrary) UnmarshalJSON(data []byte) error {
	type embed VoiceLibrary
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VoiceLibrary(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceLibrary) MarshalJSON() ([]byte, error) {
	type embed VoiceLibrary
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*v),
		CreatedAt: internal.NewDateTime(v.CreatedAt),
		UpdatedAt: internal.NewDateTime(v.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (v *VoiceLibrary) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The gender of the voice.
type VoiceLibraryGender string

const (
	VoiceLibraryGenderMale   VoiceLibraryGender = "male"
	VoiceLibraryGenderFemale VoiceLibraryGender = "female"
)

func NewVoiceLibraryGenderFromString(s string) (VoiceLibraryGender, error) {
	switch s {
	case "male":
		return VoiceLibraryGenderMale, nil
	case "female":
		return VoiceLibraryGenderFemale, nil
	}
	var t VoiceLibraryGender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VoiceLibraryGender) Ptr() *VoiceLibraryGender {
	return &v
}

type VoiceLibraryVoiceResponse struct {
	VoiceId       string                 `json:"voiceId" url:"voiceId"`
	Name          string                 `json:"name" url:"name"`
	PublicOwnerId *string                `json:"publicOwnerId,omitempty" url:"publicOwnerId,omitempty"`
	Description   *string                `json:"description,omitempty" url:"description,omitempty"`
	Gender        *string                `json:"gender,omitempty" url:"gender,omitempty"`
	Age           map[string]interface{} `json:"age,omitempty" url:"age,omitempty"`
	Accent        *string                `json:"accent,omitempty" url:"accent,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoiceLibraryVoiceResponse) GetVoiceId() string {
	if v == nil {
		return ""
	}
	return v.VoiceId
}

func (v *VoiceLibraryVoiceResponse) GetName() string {
	if v == nil {
		return ""
	}
	return v.Name
}

func (v *VoiceLibraryVoiceResponse) GetPublicOwnerId() *string {
	if v == nil {
		return nil
	}
	return v.PublicOwnerId
}

func (v *VoiceLibraryVoiceResponse) GetDescription() *string {
	if v == nil {
		return nil
	}
	return v.Description
}

func (v *VoiceLibraryVoiceResponse) GetGender() *string {
	if v == nil {
		return nil
	}
	return v.Gender
}

func (v *VoiceLibraryVoiceResponse) GetAge() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Age
}

func (v *VoiceLibraryVoiceResponse) GetAccent() *string {
	if v == nil {
		return nil
	}
	return v.Accent
}

func (v *VoiceLibraryVoiceResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceLibraryVoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceLibraryVoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceLibraryVoiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceLibraryVoiceResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoicemailDetectionBackoffPlan struct {
	// This is the number of seconds to wait before starting the first retry attempt.
	StartAtSeconds *float64 `json:"startAtSeconds,omitempty" url:"startAtSeconds,omitempty"`
	// This is the interval in seconds between retry attempts.
	FrequencySeconds *float64 `json:"frequencySeconds,omitempty" url:"frequencySeconds,omitempty"`
	// This is the maximum number of retry attempts before giving up.
	MaxRetries *float64 `json:"maxRetries,omitempty" url:"maxRetries,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoicemailDetectionBackoffPlan) GetStartAtSeconds() *float64 {
	if v == nil {
		return nil
	}
	return v.StartAtSeconds
}

func (v *VoicemailDetectionBackoffPlan) GetFrequencySeconds() *float64 {
	if v == nil {
		return nil
	}
	return v.FrequencySeconds
}

func (v *VoicemailDetectionBackoffPlan) GetMaxRetries() *float64 {
	if v == nil {
		return nil
	}
	return v.MaxRetries
}

func (v *VoicemailDetectionBackoffPlan) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoicemailDetectionBackoffPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler VoicemailDetectionBackoffPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoicemailDetectionBackoffPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoicemailDetectionBackoffPlan) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VonageCredential struct {
	// This is not returned in the API.
	VonageApplicationPrivateKey string `json:"vonageApplicationPrivateKey" url:"vonageApplicationPrivateKey"`
	// This is not returned in the API.
	ApiSecret string `json:"apiSecret" url:"apiSecret"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the Vonage Application ID for the credential.
	//
	// Only relevant for Vonage credentials.
	VonageApplicationId string `json:"vonageApplicationId" url:"vonageApplicationId"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	ApiKey   string  `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VonageCredential) GetVonageApplicationPrivateKey() string {
	if v == nil {
		return ""
	}
	return v.VonageApplicationPrivateKey
}

func (v *VonageCredential) GetApiSecret() string {
	if v == nil {
		return ""
	}
	return v.ApiSecret
}

func (v *VonageCredential) GetId() string {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *VonageCredential) GetOrgId() string {
	if v == nil {
		return ""
	}
	return v.OrgId
}

func (v *VonageCredential) GetCreatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.CreatedAt
}

func (v *VonageCredential) GetUpdatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.UpdatedAt
}

func (v *VonageCredential) GetVonageApplicationId() string {
	if v == nil {
		return ""
	}
	return v.VonageApplicationId
}

func (v *VonageCredential) GetName() *string {
	if v == nil {
		return nil
	}
	return v.Name
}

func (v *VonageCredential) GetApiKey() string {
	if v == nil {
		return ""
	}
	return v.ApiKey
}

func (v *VonageCredential) Provider() string {
	return v.provider
}

func (v *VonageCredential) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VonageCredential) UnmarshalJSON(data []byte) error {
	type embed VonageCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VonageCredential(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vonage", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VonageCredential) MarshalJSON() ([]byte, error) {
	type embed VonageCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*v),
		CreatedAt: internal.NewDateTime(v.CreatedAt),
		UpdatedAt: internal.NewDateTime(v.UpdatedAt),
		Provider:  "vonage",
	}
	return json.Marshal(marshaler)
}

func (v *VonageCredential) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WebhookCredential struct {
	// This is the authentication plan. Currently supports OAuth2 RFC 6749.
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the authentication session for the credential. Available for credentials that have an authentication plan.
	AuthenticationSession *Oauth2AuthenticationSession `json:"authenticationSession,omitempty" url:"authenticationSession,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookCredential) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if w == nil {
		return nil
	}
	return w.AuthenticationPlan
}

func (w *WebhookCredential) GetId() string {
	if w == nil {
		return ""
	}
	return w.Id
}

func (w *WebhookCredential) GetOrgId() string {
	if w == nil {
		return ""
	}
	return w.OrgId
}

func (w *WebhookCredential) GetCreatedAt() time.Time {
	if w == nil {
		return time.Time{}
	}
	return w.CreatedAt
}

func (w *WebhookCredential) GetUpdatedAt() time.Time {
	if w == nil {
		return time.Time{}
	}
	return w.UpdatedAt
}

func (w *WebhookCredential) GetAuthenticationSession() *Oauth2AuthenticationSession {
	if w == nil {
		return nil
	}
	return w.AuthenticationSession
}

func (w *WebhookCredential) GetName() *string {
	if w == nil {
		return nil
	}
	return w.Name
}

func (w *WebhookCredential) Provider() string {
	return w.provider
}

func (w *WebhookCredential) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookCredential) UnmarshalJSON(data []byte) error {
	type embed WebhookCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WebhookCredential(unmarshaler.embed)
	w.CreatedAt = unmarshaler.CreatedAt.Time()
	w.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "webhook" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", w, "webhook", unmarshaler.Provider)
	}
	w.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *w, "provider")
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookCredential) MarshalJSON() ([]byte, error) {
	type embed WebhookCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*w),
		CreatedAt: internal.NewDateTime(w.CreatedAt),
		UpdatedAt: internal.NewDateTime(w.UpdatedAt),
		Provider:  "webhook",
	}
	return json.Marshal(marshaler)
}

func (w *WebhookCredential) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WorkflowAnthropicModel struct {
	// This is the provider of the model (`anthropic`).
	// This is the specific model that will be used.
	Model WorkflowAnthropicModelModel `json:"model" url:"model"`
	// This is the optional configuration for Anthropic's thinking feature.
	//
	// - Only applicable for `claude-3-7-sonnet-20250219` model.
	// - If provided, `maxTokens` must be greater than `thinking.budgetTokens`.
	Thinking *AnthropicThinkingConfig `json:"thinking,omitempty" url:"thinking,omitempty"`
	// This is the temperature of the model.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WorkflowAnthropicModel) GetModel() WorkflowAnthropicModelModel {
	if w == nil {
		return ""
	}
	return w.Model
}

func (w *WorkflowAnthropicModel) GetThinking() *AnthropicThinkingConfig {
	if w == nil {
		return nil
	}
	return w.Thinking
}

func (w *WorkflowAnthropicModel) GetTemperature() *float64 {
	if w == nil {
		return nil
	}
	return w.Temperature
}

func (w *WorkflowAnthropicModel) GetMaxTokens() *float64 {
	if w == nil {
		return nil
	}
	return w.MaxTokens
}

func (w *WorkflowAnthropicModel) Provider() string {
	return w.provider
}

func (w *WorkflowAnthropicModel) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkflowAnthropicModel) UnmarshalJSON(data []byte) error {
	type embed WorkflowAnthropicModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WorkflowAnthropicModel(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", w, "anthropic", unmarshaler.Provider)
	}
	w.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *w, "provider")
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkflowAnthropicModel) MarshalJSON() ([]byte, error) {
	type embed WorkflowAnthropicModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*w),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (w *WorkflowAnthropicModel) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// This is the specific model that will be used.
type WorkflowAnthropicModelModel string

const (
	WorkflowAnthropicModelModelClaude3Opus20240229    WorkflowAnthropicModelModel = "claude-3-opus-20240229"
	WorkflowAnthropicModelModelClaude3Sonnet20240229  WorkflowAnthropicModelModel = "claude-3-sonnet-20240229"
	WorkflowAnthropicModelModelClaude3Haiku20240307   WorkflowAnthropicModelModel = "claude-3-haiku-20240307"
	WorkflowAnthropicModelModelClaude35Sonnet20240620 WorkflowAnthropicModelModel = "claude-3-5-sonnet-20240620"
	WorkflowAnthropicModelModelClaude35Sonnet20241022 WorkflowAnthropicModelModel = "claude-3-5-sonnet-20241022"
	WorkflowAnthropicModelModelClaude35Haiku20241022  WorkflowAnthropicModelModel = "claude-3-5-haiku-20241022"
	WorkflowAnthropicModelModelClaude37Sonnet20250219 WorkflowAnthropicModelModel = "claude-3-7-sonnet-20250219"
)

func NewWorkflowAnthropicModelModelFromString(s string) (WorkflowAnthropicModelModel, error) {
	switch s {
	case "claude-3-opus-20240229":
		return WorkflowAnthropicModelModelClaude3Opus20240229, nil
	case "claude-3-sonnet-20240229":
		return WorkflowAnthropicModelModelClaude3Sonnet20240229, nil
	case "claude-3-haiku-20240307":
		return WorkflowAnthropicModelModelClaude3Haiku20240307, nil
	case "claude-3-5-sonnet-20240620":
		return WorkflowAnthropicModelModelClaude35Sonnet20240620, nil
	case "claude-3-5-sonnet-20241022":
		return WorkflowAnthropicModelModelClaude35Sonnet20241022, nil
	case "claude-3-5-haiku-20241022":
		return WorkflowAnthropicModelModelClaude35Haiku20241022, nil
	case "claude-3-7-sonnet-20250219":
		return WorkflowAnthropicModelModelClaude37Sonnet20250219, nil
	}
	var t WorkflowAnthropicModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkflowAnthropicModelModel) Ptr() *WorkflowAnthropicModelModel {
	return &w
}

type WorkflowOpenAiModel struct {
	// This is the provider of the model (`openai`).
	// This is the specific OpenAI model that will be used.
	Model WorkflowOpenAiModelModel `json:"model" url:"model"`
	// This is the temperature of the model.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max tokens of the model.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WorkflowOpenAiModel) GetModel() WorkflowOpenAiModelModel {
	if w == nil {
		return ""
	}
	return w.Model
}

func (w *WorkflowOpenAiModel) GetTemperature() *float64 {
	if w == nil {
		return nil
	}
	return w.Temperature
}

func (w *WorkflowOpenAiModel) GetMaxTokens() *float64 {
	if w == nil {
		return nil
	}
	return w.MaxTokens
}

func (w *WorkflowOpenAiModel) Provider() string {
	return w.provider
}

func (w *WorkflowOpenAiModel) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkflowOpenAiModel) UnmarshalJSON(data []byte) error {
	type embed WorkflowOpenAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WorkflowOpenAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", w, "openai", unmarshaler.Provider)
	}
	w.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *w, "provider")
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkflowOpenAiModel) MarshalJSON() ([]byte, error) {
	type embed WorkflowOpenAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*w),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (w *WorkflowOpenAiModel) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// This is the specific OpenAI model that will be used.
type WorkflowOpenAiModelModel string

const (
	WorkflowOpenAiModelModelGpt41                            WorkflowOpenAiModelModel = "gpt-4.1"
	WorkflowOpenAiModelModelGpt41Mini                        WorkflowOpenAiModelModel = "gpt-4.1-mini"
	WorkflowOpenAiModelModelGpt41Nano                        WorkflowOpenAiModelModel = "gpt-4.1-nano"
	WorkflowOpenAiModelModelGpt45Preview                     WorkflowOpenAiModelModel = "gpt-4.5-preview"
	WorkflowOpenAiModelModelChatgpt4OLatest                  WorkflowOpenAiModelModel = "chatgpt-4o-latest"
	WorkflowOpenAiModelModelO3                               WorkflowOpenAiModelModel = "o3"
	WorkflowOpenAiModelModelO3Mini                           WorkflowOpenAiModelModel = "o3-mini"
	WorkflowOpenAiModelModelO4Mini                           WorkflowOpenAiModelModel = "o4-mini"
	WorkflowOpenAiModelModelO1Preview                        WorkflowOpenAiModelModel = "o1-preview"
	WorkflowOpenAiModelModelO1Preview20240912                WorkflowOpenAiModelModel = "o1-preview-2024-09-12"
	WorkflowOpenAiModelModelO1Mini                           WorkflowOpenAiModelModel = "o1-mini"
	WorkflowOpenAiModelModelO1Mini20240912                   WorkflowOpenAiModelModel = "o1-mini-2024-09-12"
	WorkflowOpenAiModelModelGpt4ORealtimePreview20241001     WorkflowOpenAiModelModel = "gpt-4o-realtime-preview-2024-10-01"
	WorkflowOpenAiModelModelGpt4ORealtimePreview20241217     WorkflowOpenAiModelModel = "gpt-4o-realtime-preview-2024-12-17"
	WorkflowOpenAiModelModelGpt4OMiniRealtimePreview20241217 WorkflowOpenAiModelModel = "gpt-4o-mini-realtime-preview-2024-12-17"
	WorkflowOpenAiModelModelGpt4OMini20240718                WorkflowOpenAiModelModel = "gpt-4o-mini-2024-07-18"
	WorkflowOpenAiModelModelGpt4OMini                        WorkflowOpenAiModelModel = "gpt-4o-mini"
	WorkflowOpenAiModelModelGpt4O                            WorkflowOpenAiModelModel = "gpt-4o"
	WorkflowOpenAiModelModelGpt4O20240513                    WorkflowOpenAiModelModel = "gpt-4o-2024-05-13"
	WorkflowOpenAiModelModelGpt4O20240806                    WorkflowOpenAiModelModel = "gpt-4o-2024-08-06"
	WorkflowOpenAiModelModelGpt4O20241120                    WorkflowOpenAiModelModel = "gpt-4o-2024-11-20"
	WorkflowOpenAiModelModelGpt4Turbo                        WorkflowOpenAiModelModel = "gpt-4-turbo"
	WorkflowOpenAiModelModelGpt4Turbo20240409                WorkflowOpenAiModelModel = "gpt-4-turbo-2024-04-09"
	WorkflowOpenAiModelModelGpt4TurboPreview                 WorkflowOpenAiModelModel = "gpt-4-turbo-preview"
	WorkflowOpenAiModelModelGpt40125Preview                  WorkflowOpenAiModelModel = "gpt-4-0125-preview"
	WorkflowOpenAiModelModelGpt41106Preview                  WorkflowOpenAiModelModel = "gpt-4-1106-preview"
	WorkflowOpenAiModelModelGpt4                             WorkflowOpenAiModelModel = "gpt-4"
	WorkflowOpenAiModelModelGpt40613                         WorkflowOpenAiModelModel = "gpt-4-0613"
	WorkflowOpenAiModelModelGpt35Turbo                       WorkflowOpenAiModelModel = "gpt-3.5-turbo"
	WorkflowOpenAiModelModelGpt35Turbo0125                   WorkflowOpenAiModelModel = "gpt-3.5-turbo-0125"
	WorkflowOpenAiModelModelGpt35Turbo1106                   WorkflowOpenAiModelModel = "gpt-3.5-turbo-1106"
	WorkflowOpenAiModelModelGpt35Turbo16K                    WorkflowOpenAiModelModel = "gpt-3.5-turbo-16k"
	WorkflowOpenAiModelModelGpt35Turbo0613                   WorkflowOpenAiModelModel = "gpt-3.5-turbo-0613"
)

func NewWorkflowOpenAiModelModelFromString(s string) (WorkflowOpenAiModelModel, error) {
	switch s {
	case "gpt-4.1":
		return WorkflowOpenAiModelModelGpt41, nil
	case "gpt-4.1-mini":
		return WorkflowOpenAiModelModelGpt41Mini, nil
	case "gpt-4.1-nano":
		return WorkflowOpenAiModelModelGpt41Nano, nil
	case "gpt-4.5-preview":
		return WorkflowOpenAiModelModelGpt45Preview, nil
	case "chatgpt-4o-latest":
		return WorkflowOpenAiModelModelChatgpt4OLatest, nil
	case "o3":
		return WorkflowOpenAiModelModelO3, nil
	case "o3-mini":
		return WorkflowOpenAiModelModelO3Mini, nil
	case "o4-mini":
		return WorkflowOpenAiModelModelO4Mini, nil
	case "o1-preview":
		return WorkflowOpenAiModelModelO1Preview, nil
	case "o1-preview-2024-09-12":
		return WorkflowOpenAiModelModelO1Preview20240912, nil
	case "o1-mini":
		return WorkflowOpenAiModelModelO1Mini, nil
	case "o1-mini-2024-09-12":
		return WorkflowOpenAiModelModelO1Mini20240912, nil
	case "gpt-4o-realtime-preview-2024-10-01":
		return WorkflowOpenAiModelModelGpt4ORealtimePreview20241001, nil
	case "gpt-4o-realtime-preview-2024-12-17":
		return WorkflowOpenAiModelModelGpt4ORealtimePreview20241217, nil
	case "gpt-4o-mini-realtime-preview-2024-12-17":
		return WorkflowOpenAiModelModelGpt4OMiniRealtimePreview20241217, nil
	case "gpt-4o-mini-2024-07-18":
		return WorkflowOpenAiModelModelGpt4OMini20240718, nil
	case "gpt-4o-mini":
		return WorkflowOpenAiModelModelGpt4OMini, nil
	case "gpt-4o":
		return WorkflowOpenAiModelModelGpt4O, nil
	case "gpt-4o-2024-05-13":
		return WorkflowOpenAiModelModelGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return WorkflowOpenAiModelModelGpt4O20240806, nil
	case "gpt-4o-2024-11-20":
		return WorkflowOpenAiModelModelGpt4O20241120, nil
	case "gpt-4-turbo":
		return WorkflowOpenAiModelModelGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return WorkflowOpenAiModelModelGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return WorkflowOpenAiModelModelGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return WorkflowOpenAiModelModelGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return WorkflowOpenAiModelModelGpt41106Preview, nil
	case "gpt-4":
		return WorkflowOpenAiModelModelGpt4, nil
	case "gpt-4-0613":
		return WorkflowOpenAiModelModelGpt40613, nil
	case "gpt-3.5-turbo":
		return WorkflowOpenAiModelModelGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return WorkflowOpenAiModelModelGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return WorkflowOpenAiModelModelGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return WorkflowOpenAiModelModelGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return WorkflowOpenAiModelModelGpt35Turbo0613, nil
	}
	var t WorkflowOpenAiModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkflowOpenAiModelModel) Ptr() *WorkflowOpenAiModelModel {
	return &w
}

type WorkflowUserEditable struct {
	Nodes []*WorkflowUserEditableNodesItem `json:"nodes,omitempty" url:"nodes,omitempty"`
	// These are the options for the workflow's LLM.
	Model *WorkflowUserEditableModel `json:"model,omitempty" url:"model,omitempty"`
	Name  string                     `json:"name" url:"name"`
	Edges []*Edge                    `json:"edges,omitempty" url:"edges,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WorkflowUserEditable) GetNodes() []*WorkflowUserEditableNodesItem {
	if w == nil {
		return nil
	}
	return w.Nodes
}

func (w *WorkflowUserEditable) GetModel() *WorkflowUserEditableModel {
	if w == nil {
		return nil
	}
	return w.Model
}

func (w *WorkflowUserEditable) GetName() string {
	if w == nil {
		return ""
	}
	return w.Name
}

func (w *WorkflowUserEditable) GetEdges() []*Edge {
	if w == nil {
		return nil
	}
	return w.Edges
}

func (w *WorkflowUserEditable) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkflowUserEditable) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkflowUserEditable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkflowUserEditable(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkflowUserEditable) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// These are the options for the workflow's LLM.
type WorkflowUserEditableModel struct {
	WorkflowOpenAiModel    *WorkflowOpenAiModel
	WorkflowAnthropicModel *WorkflowAnthropicModel

	typ string
}

func (w *WorkflowUserEditableModel) GetWorkflowOpenAiModel() *WorkflowOpenAiModel {
	if w == nil {
		return nil
	}
	return w.WorkflowOpenAiModel
}

func (w *WorkflowUserEditableModel) GetWorkflowAnthropicModel() *WorkflowAnthropicModel {
	if w == nil {
		return nil
	}
	return w.WorkflowAnthropicModel
}

func (w *WorkflowUserEditableModel) UnmarshalJSON(data []byte) error {
	valueWorkflowOpenAiModel := new(WorkflowOpenAiModel)
	if err := json.Unmarshal(data, &valueWorkflowOpenAiModel); err == nil {
		w.typ = "WorkflowOpenAiModel"
		w.WorkflowOpenAiModel = valueWorkflowOpenAiModel
		return nil
	}
	valueWorkflowAnthropicModel := new(WorkflowAnthropicModel)
	if err := json.Unmarshal(data, &valueWorkflowAnthropicModel); err == nil {
		w.typ = "WorkflowAnthropicModel"
		w.WorkflowAnthropicModel = valueWorkflowAnthropicModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, w)
}

func (w WorkflowUserEditableModel) MarshalJSON() ([]byte, error) {
	if w.typ == "WorkflowOpenAiModel" || w.WorkflowOpenAiModel != nil {
		return json.Marshal(w.WorkflowOpenAiModel)
	}
	if w.typ == "WorkflowAnthropicModel" || w.WorkflowAnthropicModel != nil {
		return json.Marshal(w.WorkflowAnthropicModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", w)
}

type WorkflowUserEditableModelVisitor interface {
	VisitWorkflowOpenAiModel(*WorkflowOpenAiModel) error
	VisitWorkflowAnthropicModel(*WorkflowAnthropicModel) error
}

func (w *WorkflowUserEditableModel) Accept(visitor WorkflowUserEditableModelVisitor) error {
	if w.typ == "WorkflowOpenAiModel" || w.WorkflowOpenAiModel != nil {
		return visitor.VisitWorkflowOpenAiModel(w.WorkflowOpenAiModel)
	}
	if w.typ == "WorkflowAnthropicModel" || w.WorkflowAnthropicModel != nil {
		return visitor.VisitWorkflowAnthropicModel(w.WorkflowAnthropicModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", w)
}

type WorkflowUserEditableNodesItem struct {
	ConversationNode *ConversationNode
	ToolNode         *ToolNode

	typ string
}

func (w *WorkflowUserEditableNodesItem) GetConversationNode() *ConversationNode {
	if w == nil {
		return nil
	}
	return w.ConversationNode
}

func (w *WorkflowUserEditableNodesItem) GetToolNode() *ToolNode {
	if w == nil {
		return nil
	}
	return w.ToolNode
}

func (w *WorkflowUserEditableNodesItem) UnmarshalJSON(data []byte) error {
	valueConversationNode := new(ConversationNode)
	if err := json.Unmarshal(data, &valueConversationNode); err == nil {
		w.typ = "ConversationNode"
		w.ConversationNode = valueConversationNode
		return nil
	}
	valueToolNode := new(ToolNode)
	if err := json.Unmarshal(data, &valueToolNode); err == nil {
		w.typ = "ToolNode"
		w.ToolNode = valueToolNode
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, w)
}

func (w WorkflowUserEditableNodesItem) MarshalJSON() ([]byte, error) {
	if w.typ == "ConversationNode" || w.ConversationNode != nil {
		return json.Marshal(w.ConversationNode)
	}
	if w.typ == "ToolNode" || w.ToolNode != nil {
		return json.Marshal(w.ToolNode)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", w)
}

type WorkflowUserEditableNodesItemVisitor interface {
	VisitConversationNode(*ConversationNode) error
	VisitToolNode(*ToolNode) error
}

func (w *WorkflowUserEditableNodesItem) Accept(visitor WorkflowUserEditableNodesItemVisitor) error {
	if w.typ == "ConversationNode" || w.ConversationNode != nil {
		return visitor.VisitConversationNode(w.ConversationNode)
	}
	if w.typ == "ToolNode" || w.ToolNode != nil {
		return visitor.VisitToolNode(w.ToolNode)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", w)
}

type XAiCredential struct {
	// This is the api key for Grok in XAi's console. Get it from here: https://console.x.ai
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (x *XAiCredential) GetApiKey() string {
	if x == nil {
		return ""
	}
	return x.ApiKey
}

func (x *XAiCredential) GetId() string {
	if x == nil {
		return ""
	}
	return x.Id
}

func (x *XAiCredential) GetOrgId() string {
	if x == nil {
		return ""
	}
	return x.OrgId
}

func (x *XAiCredential) GetCreatedAt() time.Time {
	if x == nil {
		return time.Time{}
	}
	return x.CreatedAt
}

func (x *XAiCredential) GetUpdatedAt() time.Time {
	if x == nil {
		return time.Time{}
	}
	return x.UpdatedAt
}

func (x *XAiCredential) GetName() *string {
	if x == nil {
		return nil
	}
	return x.Name
}

func (x *XAiCredential) Provider() string {
	return x.provider
}

func (x *XAiCredential) GetExtraProperties() map[string]interface{} {
	return x.extraProperties
}

func (x *XAiCredential) UnmarshalJSON(data []byte) error {
	type embed XAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*x),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*x = XAiCredential(unmarshaler.embed)
	x.CreatedAt = unmarshaler.CreatedAt.Time()
	x.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "xai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", x, "xai", unmarshaler.Provider)
	}
	x.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *x, "provider")
	if err != nil {
		return err
	}
	x.extraProperties = extraProperties
	x.rawJSON = json.RawMessage(data)
	return nil
}

func (x *XAiCredential) MarshalJSON() ([]byte, error) {
	type embed XAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*x),
		CreatedAt: internal.NewDateTime(x.CreatedAt),
		UpdatedAt: internal.NewDateTime(x.UpdatedAt),
		Provider:  "xai",
	}
	return json.Marshal(marshaler)
}

func (x *XAiCredential) String() string {
	if len(x.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(x.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(x); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", x)
}

type XaiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*XaiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model XaiModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (x *XaiModel) GetMessages() []*OpenAiMessage {
	if x == nil {
		return nil
	}
	return x.Messages
}

func (x *XaiModel) GetTools() []*XaiModelToolsItem {
	if x == nil {
		return nil
	}
	return x.Tools
}

func (x *XaiModel) GetToolIds() []string {
	if x == nil {
		return nil
	}
	return x.ToolIds
}

func (x *XaiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if x == nil {
		return nil
	}
	return x.KnowledgeBase
}

func (x *XaiModel) GetKnowledgeBaseId() *string {
	if x == nil {
		return nil
	}
	return x.KnowledgeBaseId
}

func (x *XaiModel) GetModel() XaiModelModel {
	if x == nil {
		return ""
	}
	return x.Model
}

func (x *XaiModel) GetTemperature() *float64 {
	if x == nil {
		return nil
	}
	return x.Temperature
}

func (x *XaiModel) GetMaxTokens() *float64 {
	if x == nil {
		return nil
	}
	return x.MaxTokens
}

func (x *XaiModel) GetEmotionRecognitionEnabled() *bool {
	if x == nil {
		return nil
	}
	return x.EmotionRecognitionEnabled
}

func (x *XaiModel) GetNumFastTurns() *float64 {
	if x == nil {
		return nil
	}
	return x.NumFastTurns
}

func (x *XaiModel) Provider() string {
	return x.provider
}

func (x *XaiModel) GetExtraProperties() map[string]interface{} {
	return x.extraProperties
}

func (x *XaiModel) UnmarshalJSON(data []byte) error {
	type embed XaiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*x),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*x = XaiModel(unmarshaler.embed)
	if unmarshaler.Provider != "xai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", x, "xai", unmarshaler.Provider)
	}
	x.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *x, "provider")
	if err != nil {
		return err
	}
	x.extraProperties = extraProperties
	x.rawJSON = json.RawMessage(data)
	return nil
}

func (x *XaiModel) MarshalJSON() ([]byte, error) {
	type embed XaiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*x),
		Provider: "xai",
	}
	return json.Marshal(marshaler)
}

func (x *XaiModel) String() string {
	if len(x.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(x.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(x); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", x)
}

// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
type XaiModelModel string

const (
	XaiModelModelGrokBeta XaiModelModel = "grok-beta"
	XaiModelModelGrok2    XaiModelModel = "grok-2"
	XaiModelModelGrok3    XaiModelModel = "grok-3"
)

func NewXaiModelModelFromString(s string) (XaiModelModel, error) {
	switch s {
	case "grok-beta":
		return XaiModelModelGrokBeta, nil
	case "grok-2":
		return XaiModelModelGrok2, nil
	case "grok-3":
		return XaiModelModelGrok3, nil
	}
	var t XaiModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (x XaiModelModel) Ptr() *XaiModelModel {
	return &x
}

type XaiModelToolsItem struct {
	CreateApiRequestToolDto                      *CreateApiRequestToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto

	typ string
}

func (x *XaiModelToolsItem) GetCreateApiRequestToolDto() *CreateApiRequestToolDto {
	if x == nil {
		return nil
	}
	return x.CreateApiRequestToolDto
}

func (x *XaiModelToolsItem) GetCreateBashToolDto() *CreateBashToolDto {
	if x == nil {
		return nil
	}
	return x.CreateBashToolDto
}

func (x *XaiModelToolsItem) GetCreateComputerToolDto() *CreateComputerToolDto {
	if x == nil {
		return nil
	}
	return x.CreateComputerToolDto
}

func (x *XaiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if x == nil {
		return nil
	}
	return x.CreateDtmfToolDto
}

func (x *XaiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if x == nil {
		return nil
	}
	return x.CreateEndCallToolDto
}

func (x *XaiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if x == nil {
		return nil
	}
	return x.CreateFunctionToolDto
}

func (x *XaiModelToolsItem) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (x *XaiModelToolsItem) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGoHighLevelCalendarEventCreateToolDto
}

func (x *XaiModelToolsItem) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGoHighLevelContactCreateToolDto
}

func (x *XaiModelToolsItem) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGoHighLevelContactGetToolDto
}

func (x *XaiModelToolsItem) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (x *XaiModelToolsItem) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGoogleCalendarCreateEventToolDto
}

func (x *XaiModelToolsItem) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGoogleSheetsRowAppendToolDto
}

func (x *XaiModelToolsItem) GetCreateMcpToolDto() *CreateMcpToolDto {
	if x == nil {
		return nil
	}
	return x.CreateMcpToolDto
}

func (x *XaiModelToolsItem) GetCreateQueryToolDto() *CreateQueryToolDto {
	if x == nil {
		return nil
	}
	return x.CreateQueryToolDto
}

func (x *XaiModelToolsItem) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if x == nil {
		return nil
	}
	return x.CreateSlackSendMessageToolDto
}

func (x *XaiModelToolsItem) GetCreateSmsToolDto() *CreateSmsToolDto {
	if x == nil {
		return nil
	}
	return x.CreateSmsToolDto
}

func (x *XaiModelToolsItem) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if x == nil {
		return nil
	}
	return x.CreateTextEditorToolDto
}

func (x *XaiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if x == nil {
		return nil
	}
	return x.CreateTransferCallToolDto
}

func (x *XaiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateApiRequestToolDto := new(CreateApiRequestToolDto)
	if err := json.Unmarshal(data, &valueCreateApiRequestToolDto); err == nil {
		x.typ = "CreateApiRequestToolDto"
		x.CreateApiRequestToolDto = valueCreateApiRequestToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		x.typ = "CreateBashToolDto"
		x.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		x.typ = "CreateComputerToolDto"
		x.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		x.typ = "CreateDtmfToolDto"
		x.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		x.typ = "CreateEndCallToolDto"
		x.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		x.typ = "CreateFunctionToolDto"
		x.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		x.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		x.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		x.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		x.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		x.typ = "CreateGoHighLevelContactCreateToolDto"
		x.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		x.typ = "CreateGoHighLevelContactGetToolDto"
		x.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		x.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		x.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		x.typ = "CreateGoogleCalendarCreateEventToolDto"
		x.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		x.typ = "CreateGoogleSheetsRowAppendToolDto"
		x.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		x.typ = "CreateMcpToolDto"
		x.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		x.typ = "CreateQueryToolDto"
		x.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		x.typ = "CreateSlackSendMessageToolDto"
		x.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		x.typ = "CreateSmsToolDto"
		x.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		x.typ = "CreateTextEditorToolDto"
		x.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		x.typ = "CreateTransferCallToolDto"
		x.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, x)
}

func (x XaiModelToolsItem) MarshalJSON() ([]byte, error) {
	if x.typ == "CreateApiRequestToolDto" || x.CreateApiRequestToolDto != nil {
		return json.Marshal(x.CreateApiRequestToolDto)
	}
	if x.typ == "CreateBashToolDto" || x.CreateBashToolDto != nil {
		return json.Marshal(x.CreateBashToolDto)
	}
	if x.typ == "CreateComputerToolDto" || x.CreateComputerToolDto != nil {
		return json.Marshal(x.CreateComputerToolDto)
	}
	if x.typ == "CreateDtmfToolDto" || x.CreateDtmfToolDto != nil {
		return json.Marshal(x.CreateDtmfToolDto)
	}
	if x.typ == "CreateEndCallToolDto" || x.CreateEndCallToolDto != nil {
		return json.Marshal(x.CreateEndCallToolDto)
	}
	if x.typ == "CreateFunctionToolDto" || x.CreateFunctionToolDto != nil {
		return json.Marshal(x.CreateFunctionToolDto)
	}
	if x.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || x.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(x.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if x.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || x.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(x.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if x.typ == "CreateGoHighLevelContactCreateToolDto" || x.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(x.CreateGoHighLevelContactCreateToolDto)
	}
	if x.typ == "CreateGoHighLevelContactGetToolDto" || x.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(x.CreateGoHighLevelContactGetToolDto)
	}
	if x.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || x.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(x.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if x.typ == "CreateGoogleCalendarCreateEventToolDto" || x.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(x.CreateGoogleCalendarCreateEventToolDto)
	}
	if x.typ == "CreateGoogleSheetsRowAppendToolDto" || x.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(x.CreateGoogleSheetsRowAppendToolDto)
	}
	if x.typ == "CreateMcpToolDto" || x.CreateMcpToolDto != nil {
		return json.Marshal(x.CreateMcpToolDto)
	}
	if x.typ == "CreateQueryToolDto" || x.CreateQueryToolDto != nil {
		return json.Marshal(x.CreateQueryToolDto)
	}
	if x.typ == "CreateSlackSendMessageToolDto" || x.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(x.CreateSlackSendMessageToolDto)
	}
	if x.typ == "CreateSmsToolDto" || x.CreateSmsToolDto != nil {
		return json.Marshal(x.CreateSmsToolDto)
	}
	if x.typ == "CreateTextEditorToolDto" || x.CreateTextEditorToolDto != nil {
		return json.Marshal(x.CreateTextEditorToolDto)
	}
	if x.typ == "CreateTransferCallToolDto" || x.CreateTransferCallToolDto != nil {
		return json.Marshal(x.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", x)
}

type XaiModelToolsItemVisitor interface {
	VisitCreateApiRequestToolDto(*CreateApiRequestToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (x *XaiModelToolsItem) Accept(visitor XaiModelToolsItemVisitor) error {
	if x.typ == "CreateApiRequestToolDto" || x.CreateApiRequestToolDto != nil {
		return visitor.VisitCreateApiRequestToolDto(x.CreateApiRequestToolDto)
	}
	if x.typ == "CreateBashToolDto" || x.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(x.CreateBashToolDto)
	}
	if x.typ == "CreateComputerToolDto" || x.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(x.CreateComputerToolDto)
	}
	if x.typ == "CreateDtmfToolDto" || x.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(x.CreateDtmfToolDto)
	}
	if x.typ == "CreateEndCallToolDto" || x.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(x.CreateEndCallToolDto)
	}
	if x.typ == "CreateFunctionToolDto" || x.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(x.CreateFunctionToolDto)
	}
	if x.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || x.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(x.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if x.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || x.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(x.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if x.typ == "CreateGoHighLevelContactCreateToolDto" || x.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(x.CreateGoHighLevelContactCreateToolDto)
	}
	if x.typ == "CreateGoHighLevelContactGetToolDto" || x.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(x.CreateGoHighLevelContactGetToolDto)
	}
	if x.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || x.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(x.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if x.typ == "CreateGoogleCalendarCreateEventToolDto" || x.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(x.CreateGoogleCalendarCreateEventToolDto)
	}
	if x.typ == "CreateGoogleSheetsRowAppendToolDto" || x.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(x.CreateGoogleSheetsRowAppendToolDto)
	}
	if x.typ == "CreateMcpToolDto" || x.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(x.CreateMcpToolDto)
	}
	if x.typ == "CreateQueryToolDto" || x.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(x.CreateQueryToolDto)
	}
	if x.typ == "CreateSlackSendMessageToolDto" || x.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(x.CreateSlackSendMessageToolDto)
	}
	if x.typ == "CreateSmsToolDto" || x.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(x.CreateSmsToolDto)
	}
	if x.typ == "CreateTextEditorToolDto" || x.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(x.CreateTextEditorToolDto)
	}
	if x.typ == "CreateTransferCallToolDto" || x.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(x.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", x)
}
