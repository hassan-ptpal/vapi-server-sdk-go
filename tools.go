// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"

	internal "github.com/hassan-ptpal/vapi-server-sdk-go/internal"
)

type ToolsListRequest struct {
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`
}

type BashTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*BashToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// The name of the tool, fixed to 'bash'
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BashTool) GetAsync() *bool {
	if b == nil {
		return nil
	}
	return b.Async
}

func (b *BashTool) GetMessages() []*BashToolMessagesItem {
	if b == nil {
		return nil
	}
	return b.Messages
}

func (b *BashTool) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *BashTool) GetOrgId() string {
	if b == nil {
		return ""
	}
	return b.OrgId
}

func (b *BashTool) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *BashTool) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BashTool) GetFunction() *OpenAiFunction {
	if b == nil {
		return nil
	}
	return b.Function
}

func (b *BashTool) GetServer() *Server {
	if b == nil {
		return nil
	}
	return b.Server
}

func (b *BashTool) Type() string {
	return b.type_
}

func (b *BashTool) SubType() string {
	return b.subType
}

func (b *BashTool) Name() string {
	return b.name
}

func (b *BashTool) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BashTool) UnmarshalJSON(data []byte) error {
	type embed BashTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
		SubType   string             `json:"subType"`
		Name      string             `json:"name"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BashTool(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "bash" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bash", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	if unmarshaler.SubType != "bash_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bash_20241022", unmarshaler.SubType)
	}
	b.subType = unmarshaler.SubType
	if unmarshaler.Name != "bash" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "bash", unmarshaler.Name)
	}
	b.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type", "subType", "name")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BashTool) MarshalJSON() ([]byte, error) {
	type embed BashTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
		SubType   string             `json:"subType"`
		Name      string             `json:"name"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
		Type:      "bash",
		SubType:   "bash_20241022",
		Name:      "bash",
	}
	return json.Marshal(marshaler)
}

func (b *BashTool) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BashToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (b *BashToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if b == nil {
		return nil
	}
	return b.ToolMessageStart
}

func (b *BashToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if b == nil {
		return nil
	}
	return b.ToolMessageComplete
}

func (b *BashToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if b == nil {
		return nil
	}
	return b.ToolMessageFailed
}

func (b *BashToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if b == nil {
		return nil
	}
	return b.ToolMessageDelayed
}

func (b *BashToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		b.typ = "ToolMessageStart"
		b.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		b.typ = "ToolMessageComplete"
		b.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		b.typ = "ToolMessageFailed"
		b.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		b.typ = "ToolMessageDelayed"
		b.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BashToolMessagesItem) MarshalJSON() ([]byte, error) {
	if b.typ == "ToolMessageStart" || b.ToolMessageStart != nil {
		return json.Marshal(b.ToolMessageStart)
	}
	if b.typ == "ToolMessageComplete" || b.ToolMessageComplete != nil {
		return json.Marshal(b.ToolMessageComplete)
	}
	if b.typ == "ToolMessageFailed" || b.ToolMessageFailed != nil {
		return json.Marshal(b.ToolMessageFailed)
	}
	if b.typ == "ToolMessageDelayed" || b.ToolMessageDelayed != nil {
		return json.Marshal(b.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BashToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (b *BashToolMessagesItem) Accept(visitor BashToolMessagesItemVisitor) error {
	if b.typ == "ToolMessageStart" || b.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(b.ToolMessageStart)
	}
	if b.typ == "ToolMessageComplete" || b.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(b.ToolMessageComplete)
	}
	if b.typ == "ToolMessageFailed" || b.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(b.ToolMessageFailed)
	}
	if b.typ == "ToolMessageDelayed" || b.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(b.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type ComputerTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*ComputerToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// The name of the tool, fixed to 'computer'
	// The display width in pixels
	DisplayWidthPx float64 `json:"displayWidthPx" url:"displayWidthPx"`
	// The display height in pixels
	DisplayHeightPx float64 `json:"displayHeightPx" url:"displayHeightPx"`
	// Optional display number
	DisplayNumber *float64 `json:"displayNumber,omitempty" url:"displayNumber,omitempty"`
	type_         string
	subType       string
	name          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ComputerTool) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *ComputerTool) GetMessages() []*ComputerToolMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ComputerTool) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *ComputerTool) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *ComputerTool) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *ComputerTool) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *ComputerTool) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *ComputerTool) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *ComputerTool) GetDisplayWidthPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayWidthPx
}

func (c *ComputerTool) GetDisplayHeightPx() float64 {
	if c == nil {
		return 0
	}
	return c.DisplayHeightPx
}

func (c *ComputerTool) GetDisplayNumber() *float64 {
	if c == nil {
		return nil
	}
	return c.DisplayNumber
}

func (c *ComputerTool) Type() string {
	return c.type_
}

func (c *ComputerTool) SubType() string {
	return c.subType
}

func (c *ComputerTool) Name() string {
	return c.name
}

func (c *ComputerTool) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComputerTool) UnmarshalJSON(data []byte) error {
	type embed ComputerTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
		SubType   string             `json:"subType"`
		Name      string             `json:"name"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ComputerTool(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "computer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	if unmarshaler.SubType != "computer_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer_20241022", unmarshaler.SubType)
	}
	c.subType = unmarshaler.SubType
	if unmarshaler.Name != "computer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "computer", unmarshaler.Name)
	}
	c.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type", "subType", "name")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComputerTool) MarshalJSON() ([]byte, error) {
	type embed ComputerTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
		SubType   string             `json:"subType"`
		Name      string             `json:"name"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Type:      "computer",
		SubType:   "computer_20241022",
		Name:      "computer",
	}
	return json.Marshal(marshaler)
}

func (c *ComputerTool) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ComputerToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *ComputerToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *ComputerToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *ComputerToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *ComputerToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *ComputerToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ComputerToolMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ComputerToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *ComputerToolMessagesItem) Accept(visitor ComputerToolMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGhlToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGhlToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata *GhlToolMetadata                `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGhlToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGhlToolDto) GetMessages() []*CreateGhlToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGhlToolDto) GetMetadata() *GhlToolMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateGhlToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGhlToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGhlToolDto) Type() string {
	return c.type_
}

func (c *CreateGhlToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGhlToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGhlToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGhlToolDto(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "ghl", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGhlToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGhlToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGhlToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGhlToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGhlToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGhlToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGhlToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGhlToolDtoMessagesItem) Accept(visitor CreateGhlToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateMakeToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateMakeToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata *MakeToolMetadata                `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateMakeToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateMakeToolDto) GetMessages() []*CreateMakeToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateMakeToolDto) GetMetadata() *MakeToolMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateMakeToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateMakeToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateMakeToolDto) Type() string {
	return c.type_
}

func (c *CreateMakeToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMakeToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateMakeToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMakeToolDto(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "make", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMakeToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateMakeToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMakeToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateMakeToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateMakeToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateMakeToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateMakeToolDtoMessagesItem) Accept(visitor CreateMakeToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateOutputToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateOutputToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOutputToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateOutputToolDto) GetMessages() []*CreateOutputToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateOutputToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateOutputToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateOutputToolDto) Type() string {
	return c.type_
}

func (c *CreateOutputToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOutputToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateOutputToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOutputToolDto(unmarshaler.embed)
	if unmarshaler.Type != "output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "output", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOutputToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateOutputToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "output",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOutputToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOutputToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateOutputToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateOutputToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateOutputToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateOutputToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateOutputToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateOutputToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateOutputToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateOutputToolDtoMessagesItem) Accept(visitor CreateOutputToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type DtmfTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*DtmfToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DtmfTool) GetAsync() *bool {
	if d == nil {
		return nil
	}
	return d.Async
}

func (d *DtmfTool) GetMessages() []*DtmfToolMessagesItem {
	if d == nil {
		return nil
	}
	return d.Messages
}

func (d *DtmfTool) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DtmfTool) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DtmfTool) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DtmfTool) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DtmfTool) GetFunction() *OpenAiFunction {
	if d == nil {
		return nil
	}
	return d.Function
}

func (d *DtmfTool) GetServer() *Server {
	if d == nil {
		return nil
	}
	return d.Server
}

func (d *DtmfTool) Type() string {
	return d.type_
}

func (d *DtmfTool) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DtmfTool) UnmarshalJSON(data []byte) error {
	type embed DtmfTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DtmfTool(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "dtmf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "dtmf", unmarshaler.Type)
	}
	d.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "type")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DtmfTool) MarshalJSON() ([]byte, error) {
	type embed DtmfTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Type:      "dtmf",
	}
	return json.Marshal(marshaler)
}

func (d *DtmfTool) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DtmfToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (d *DtmfToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if d == nil {
		return nil
	}
	return d.ToolMessageStart
}

func (d *DtmfToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if d == nil {
		return nil
	}
	return d.ToolMessageComplete
}

func (d *DtmfToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if d == nil {
		return nil
	}
	return d.ToolMessageFailed
}

func (d *DtmfToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if d == nil {
		return nil
	}
	return d.ToolMessageDelayed
}

func (d *DtmfToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		d.typ = "ToolMessageStart"
		d.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		d.typ = "ToolMessageComplete"
		d.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		d.typ = "ToolMessageFailed"
		d.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		d.typ = "ToolMessageDelayed"
		d.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DtmfToolMessagesItem) MarshalJSON() ([]byte, error) {
	if d.typ == "ToolMessageStart" || d.ToolMessageStart != nil {
		return json.Marshal(d.ToolMessageStart)
	}
	if d.typ == "ToolMessageComplete" || d.ToolMessageComplete != nil {
		return json.Marshal(d.ToolMessageComplete)
	}
	if d.typ == "ToolMessageFailed" || d.ToolMessageFailed != nil {
		return json.Marshal(d.ToolMessageFailed)
	}
	if d.typ == "ToolMessageDelayed" || d.ToolMessageDelayed != nil {
		return json.Marshal(d.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtmfToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (d *DtmfToolMessagesItem) Accept(visitor DtmfToolMessagesItemVisitor) error {
	if d.typ == "ToolMessageStart" || d.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(d.ToolMessageStart)
	}
	if d.typ == "ToolMessageComplete" || d.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(d.ToolMessageComplete)
	}
	if d.typ == "ToolMessageFailed" || d.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(d.ToolMessageFailed)
	}
	if d.typ == "ToolMessageDelayed" || d.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(d.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type EndCallTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*EndCallToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EndCallTool) GetAsync() *bool {
	if e == nil {
		return nil
	}
	return e.Async
}

func (e *EndCallTool) GetMessages() []*EndCallToolMessagesItem {
	if e == nil {
		return nil
	}
	return e.Messages
}

func (e *EndCallTool) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *EndCallTool) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *EndCallTool) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EndCallTool) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *EndCallTool) GetFunction() *OpenAiFunction {
	if e == nil {
		return nil
	}
	return e.Function
}

func (e *EndCallTool) GetServer() *Server {
	if e == nil {
		return nil
	}
	return e.Server
}

func (e *EndCallTool) Type() string {
	return e.type_
}

func (e *EndCallTool) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndCallTool) UnmarshalJSON(data []byte) error {
	type embed EndCallTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EndCallTool(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "endCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "endCall", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EndCallTool) MarshalJSON() ([]byte, error) {
	type embed EndCallTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
		Type:      "endCall",
	}
	return json.Marshal(marshaler)
}

func (e *EndCallTool) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EndCallToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (e *EndCallToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if e == nil {
		return nil
	}
	return e.ToolMessageStart
}

func (e *EndCallToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if e == nil {
		return nil
	}
	return e.ToolMessageComplete
}

func (e *EndCallToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if e == nil {
		return nil
	}
	return e.ToolMessageFailed
}

func (e *EndCallToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if e == nil {
		return nil
	}
	return e.ToolMessageDelayed
}

func (e *EndCallToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		e.typ = "ToolMessageStart"
		e.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		e.typ = "ToolMessageComplete"
		e.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		e.typ = "ToolMessageFailed"
		e.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		e.typ = "ToolMessageDelayed"
		e.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EndCallToolMessagesItem) MarshalJSON() ([]byte, error) {
	if e.typ == "ToolMessageStart" || e.ToolMessageStart != nil {
		return json.Marshal(e.ToolMessageStart)
	}
	if e.typ == "ToolMessageComplete" || e.ToolMessageComplete != nil {
		return json.Marshal(e.ToolMessageComplete)
	}
	if e.typ == "ToolMessageFailed" || e.ToolMessageFailed != nil {
		return json.Marshal(e.ToolMessageFailed)
	}
	if e.typ == "ToolMessageDelayed" || e.ToolMessageDelayed != nil {
		return json.Marshal(e.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EndCallToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (e *EndCallToolMessagesItem) Accept(visitor EndCallToolMessagesItemVisitor) error {
	if e.typ == "ToolMessageStart" || e.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(e.ToolMessageStart)
	}
	if e.typ == "ToolMessageComplete" || e.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(e.ToolMessageComplete)
	}
	if e.typ == "ToolMessageFailed" || e.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(e.ToolMessageFailed)
	}
	if e.typ == "ToolMessageDelayed" || e.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(e.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type FunctionTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*FunctionToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FunctionTool) GetAsync() *bool {
	if f == nil {
		return nil
	}
	return f.Async
}

func (f *FunctionTool) GetMessages() []*FunctionToolMessagesItem {
	if f == nil {
		return nil
	}
	return f.Messages
}

func (f *FunctionTool) GetId() string {
	if f == nil {
		return ""
	}
	return f.Id
}

func (f *FunctionTool) GetOrgId() string {
	if f == nil {
		return ""
	}
	return f.OrgId
}

func (f *FunctionTool) GetCreatedAt() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.CreatedAt
}

func (f *FunctionTool) GetUpdatedAt() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.UpdatedAt
}

func (f *FunctionTool) GetFunction() *OpenAiFunction {
	if f == nil {
		return nil
	}
	return f.Function
}

func (f *FunctionTool) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FunctionTool) Type() string {
	return f.type_
}

func (f *FunctionTool) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionTool) UnmarshalJSON(data []byte) error {
	type embed FunctionTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionTool(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.Time()
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionTool) MarshalJSON() ([]byte, error) {
	type embed FunctionTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*f),
		CreatedAt: internal.NewDateTime(f.CreatedAt),
		UpdatedAt: internal.NewDateTime(f.UpdatedAt),
		Type:      "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionTool) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (f *FunctionToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if f == nil {
		return nil
	}
	return f.ToolMessageStart
}

func (f *FunctionToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if f == nil {
		return nil
	}
	return f.ToolMessageComplete
}

func (f *FunctionToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if f == nil {
		return nil
	}
	return f.ToolMessageFailed
}

func (f *FunctionToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if f == nil {
		return nil
	}
	return f.ToolMessageDelayed
}

func (f *FunctionToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		f.typ = "ToolMessageStart"
		f.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		f.typ = "ToolMessageComplete"
		f.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		f.typ = "ToolMessageFailed"
		f.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		f.typ = "ToolMessageDelayed"
		f.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FunctionToolMessagesItem) MarshalJSON() ([]byte, error) {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return json.Marshal(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return json.Marshal(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return json.Marshal(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return json.Marshal(f.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (f *FunctionToolMessagesItem) Accept(visitor FunctionToolMessagesItemVisitor) error {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(f.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type GhlTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GhlToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server   *Server          `json:"server,omitempty" url:"server,omitempty"`
	Metadata *GhlToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GhlTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GhlTool) GetMessages() []*GhlToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GhlTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GhlTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GhlTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GhlTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GhlTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GhlTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GhlTool) GetMetadata() *GhlToolMetadata {
	if g == nil {
		return nil
	}
	return g.Metadata
}

func (g *GhlTool) Type() string {
	return g.type_
}

func (g *GhlTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlTool) UnmarshalJSON(data []byte) error {
	type embed GhlTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlTool) MarshalJSON() ([]byte, error) {
	type embed GhlTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GhlToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GhlToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GhlToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GhlToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GhlToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GhlToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GhlToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GhlToolMessagesItem) Accept(visitor GhlToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GhlToolMetadata struct {
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	LocationId *string `json:"locationId,omitempty" url:"locationId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GhlToolMetadata) GetWorkflowId() *string {
	if g == nil {
		return nil
	}
	return g.WorkflowId
}

func (g *GhlToolMetadata) GetLocationId() *string {
	if g == nil {
		return nil
	}
	return g.LocationId
}

func (g *GhlToolMetadata) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler GhlToolMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GhlToolMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolMetadata) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarAvailabilityTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelCalendarAvailabilityToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarAvailabilityTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelCalendarAvailabilityTool) GetMessages() []*GoHighLevelCalendarAvailabilityToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelCalendarAvailabilityTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelCalendarAvailabilityTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelCalendarAvailabilityTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelCalendarAvailabilityTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelCalendarAvailabilityTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelCalendarAvailabilityTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelCalendarAvailabilityTool) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarAvailabilityTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarAvailabilityTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarAvailabilityTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarAvailabilityTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.availability.check", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarAvailabilityTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarAvailabilityTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.calendar.availability.check",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCalendarAvailabilityTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarAvailabilityToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelCalendarAvailabilityToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarAvailabilityToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelCalendarAvailabilityToolMessagesItem) Accept(visitor GoHighLevelCalendarAvailabilityToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarEventCreateTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelCalendarEventCreateToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCalendarEventCreateTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelCalendarEventCreateTool) GetMessages() []*GoHighLevelCalendarEventCreateToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelCalendarEventCreateTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelCalendarEventCreateTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelCalendarEventCreateTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelCalendarEventCreateTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelCalendarEventCreateTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelCalendarEventCreateTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelCalendarEventCreateTool) Type() string {
	return g.type_
}

func (g *GoHighLevelCalendarEventCreateTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCalendarEventCreateTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCalendarEventCreateTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCalendarEventCreateTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCalendarEventCreateTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCalendarEventCreateTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCalendarEventCreateTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelCalendarEventCreateToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelCalendarEventCreateToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelCalendarEventCreateToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelCalendarEventCreateToolMessagesItem) Accept(visitor GoHighLevelCalendarEventCreateToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactCreateTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelContactCreateToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactCreateTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelContactCreateTool) GetMessages() []*GoHighLevelContactCreateToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelContactCreateTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelContactCreateTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelContactCreateTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelContactCreateTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelContactCreateTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelContactCreateTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelContactCreateTool) Type() string {
	return g.type_
}

func (g *GoHighLevelContactCreateTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactCreateTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactCreateTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactCreateTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.contact.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactCreateTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactCreateTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.contact.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelContactCreateTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactCreateToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelContactCreateToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelContactCreateToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelContactCreateToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactCreateToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelContactCreateToolMessagesItem) Accept(visitor GoHighLevelContactCreateToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactGetTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoHighLevelContactGetToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelContactGetTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoHighLevelContactGetTool) GetMessages() []*GoHighLevelContactGetToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoHighLevelContactGetTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelContactGetTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelContactGetTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelContactGetTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelContactGetTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoHighLevelContactGetTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoHighLevelContactGetTool) Type() string {
	return g.type_
}

func (g *GoHighLevelContactGetTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelContactGetTool) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelContactGetTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelContactGetTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "gohighlevel.contact.get" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel.contact.get", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelContactGetTool) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelContactGetTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "gohighlevel.contact.get",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelContactGetTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoHighLevelContactGetToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoHighLevelContactGetToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoHighLevelContactGetToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoHighLevelContactGetToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoHighLevelContactGetToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoHighLevelContactGetToolMessagesItem) Accept(visitor GoHighLevelContactGetToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarCheckAvailabilityTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleCalendarCheckAvailabilityToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarCheckAvailabilityTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoogleCalendarCheckAvailabilityTool) GetMessages() []*GoogleCalendarCheckAvailabilityToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleCalendarCheckAvailabilityTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCalendarCheckAvailabilityTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCalendarCheckAvailabilityTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCalendarCheckAvailabilityTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCalendarCheckAvailabilityTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoogleCalendarCheckAvailabilityTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoogleCalendarCheckAvailabilityTool) Type() string {
	return g.type_
}

func (g *GoogleCalendarCheckAvailabilityTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarCheckAvailabilityTool) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarCheckAvailabilityTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarCheckAvailabilityTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "google.calendar.availability.check" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.availability.check", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarCheckAvailabilityTool) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarCheckAvailabilityTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "google.calendar.availability.check",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCalendarCheckAvailabilityTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarCheckAvailabilityToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleCalendarCheckAvailabilityToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarCheckAvailabilityToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleCalendarCheckAvailabilityToolMessagesItem) Accept(visitor GoogleCalendarCheckAvailabilityToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarCreateEventTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleCalendarCreateEventToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCalendarCreateEventTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoogleCalendarCreateEventTool) GetMessages() []*GoogleCalendarCreateEventToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleCalendarCreateEventTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCalendarCreateEventTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCalendarCreateEventTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCalendarCreateEventTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCalendarCreateEventTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoogleCalendarCreateEventTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoogleCalendarCreateEventTool) Type() string {
	return g.type_
}

func (g *GoogleCalendarCreateEventTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCalendarCreateEventTool) UnmarshalJSON(data []byte) error {
	type embed GoogleCalendarCreateEventTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCalendarCreateEventTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "google.calendar.event.create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.calendar.event.create", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCalendarCreateEventTool) MarshalJSON() ([]byte, error) {
	type embed GoogleCalendarCreateEventTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "google.calendar.event.create",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCalendarCreateEventTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCalendarCreateEventToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleCalendarCreateEventToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleCalendarCreateEventToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleCalendarCreateEventToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleCalendarCreateEventToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleCalendarCreateEventToolMessagesItem) Accept(visitor GoogleCalendarCreateEventToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleSheetsRowAppendTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GoogleSheetsRowAppendToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleSheetsRowAppendTool) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GoogleSheetsRowAppendTool) GetMessages() []*GoogleSheetsRowAppendToolMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleSheetsRowAppendTool) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleSheetsRowAppendTool) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleSheetsRowAppendTool) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleSheetsRowAppendTool) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleSheetsRowAppendTool) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GoogleSheetsRowAppendTool) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GoogleSheetsRowAppendTool) Type() string {
	return g.type_
}

func (g *GoogleSheetsRowAppendTool) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleSheetsRowAppendTool) UnmarshalJSON(data []byte) error {
	type embed GoogleSheetsRowAppendTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleSheetsRowAppendTool(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "google.sheets.row.append" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google.sheets.row.append", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleSheetsRowAppendTool) MarshalJSON() ([]byte, error) {
	type embed GoogleSheetsRowAppendTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Type:      "google.sheets.row.append",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleSheetsRowAppendTool) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleSheetsRowAppendToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GoogleSheetsRowAppendToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GoogleSheetsRowAppendToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleSheetsRowAppendToolMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleSheetsRowAppendToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GoogleSheetsRowAppendToolMessagesItem) Accept(visitor GoogleSheetsRowAppendToolMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type MakeTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*MakeToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server   *Server           `json:"server,omitempty" url:"server,omitempty"`
	Metadata *MakeToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeTool) GetAsync() *bool {
	if m == nil {
		return nil
	}
	return m.Async
}

func (m *MakeTool) GetMessages() []*MakeToolMessagesItem {
	if m == nil {
		return nil
	}
	return m.Messages
}

func (m *MakeTool) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *MakeTool) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *MakeTool) GetCreatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.CreatedAt
}

func (m *MakeTool) GetUpdatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.UpdatedAt
}

func (m *MakeTool) GetFunction() *OpenAiFunction {
	if m == nil {
		return nil
	}
	return m.Function
}

func (m *MakeTool) GetServer() *Server {
	if m == nil {
		return nil
	}
	return m.Server
}

func (m *MakeTool) GetMetadata() *MakeToolMetadata {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *MakeTool) Type() string {
	return m.type_
}

func (m *MakeTool) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeTool) UnmarshalJSON(data []byte) error {
	type embed MakeTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeTool(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeTool) MarshalJSON() ([]byte, error) {
	type embed MakeTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*m),
		CreatedAt: internal.NewDateTime(m.CreatedAt),
		UpdatedAt: internal.NewDateTime(m.UpdatedAt),
		Type:      "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeTool) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (m *MakeToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if m == nil {
		return nil
	}
	return m.ToolMessageStart
}

func (m *MakeToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if m == nil {
		return nil
	}
	return m.ToolMessageComplete
}

func (m *MakeToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if m == nil {
		return nil
	}
	return m.ToolMessageFailed
}

func (m *MakeToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if m == nil {
		return nil
	}
	return m.ToolMessageDelayed
}

func (m *MakeToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		m.typ = "ToolMessageStart"
		m.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		m.typ = "ToolMessageComplete"
		m.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		m.typ = "ToolMessageFailed"
		m.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		m.typ = "ToolMessageDelayed"
		m.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MakeToolMessagesItem) MarshalJSON() ([]byte, error) {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return json.Marshal(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return json.Marshal(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return json.Marshal(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return json.Marshal(m.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MakeToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (m *MakeToolMessagesItem) Accept(visitor MakeToolMessagesItemVisitor) error {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(m.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MakeToolMetadata struct {
	ScenarioId    *float64 `json:"scenarioId,omitempty" url:"scenarioId,omitempty"`
	TriggerHookId *float64 `json:"triggerHookId,omitempty" url:"triggerHookId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeToolMetadata) GetScenarioId() *float64 {
	if m == nil {
		return nil
	}
	return m.ScenarioId
}

func (m *MakeToolMetadata) GetTriggerHookId() *float64 {
	if m == nil {
		return nil
	}
	return m.TriggerHookId
}

func (m *MakeToolMetadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler MakeToolMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MakeToolMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolMetadata) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type McpTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*McpToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *McpTool) GetAsync() *bool {
	if m == nil {
		return nil
	}
	return m.Async
}

func (m *McpTool) GetMessages() []*McpToolMessagesItem {
	if m == nil {
		return nil
	}
	return m.Messages
}

func (m *McpTool) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *McpTool) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *McpTool) GetCreatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.CreatedAt
}

func (m *McpTool) GetUpdatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.UpdatedAt
}

func (m *McpTool) GetFunction() *OpenAiFunction {
	if m == nil {
		return nil
	}
	return m.Function
}

func (m *McpTool) GetServer() *Server {
	if m == nil {
		return nil
	}
	return m.Server
}

func (m *McpTool) Type() string {
	return m.type_
}

func (m *McpTool) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *McpTool) UnmarshalJSON(data []byte) error {
	type embed McpTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = McpTool(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "mcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "mcp", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *McpTool) MarshalJSON() ([]byte, error) {
	type embed McpTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*m),
		CreatedAt: internal.NewDateTime(m.CreatedAt),
		UpdatedAt: internal.NewDateTime(m.UpdatedAt),
		Type:      "mcp",
	}
	return json.Marshal(marshaler)
}

func (m *McpTool) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type McpToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (m *McpToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if m == nil {
		return nil
	}
	return m.ToolMessageStart
}

func (m *McpToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if m == nil {
		return nil
	}
	return m.ToolMessageComplete
}

func (m *McpToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if m == nil {
		return nil
	}
	return m.ToolMessageFailed
}

func (m *McpToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if m == nil {
		return nil
	}
	return m.ToolMessageDelayed
}

func (m *McpToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		m.typ = "ToolMessageStart"
		m.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		m.typ = "ToolMessageComplete"
		m.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		m.typ = "ToolMessageFailed"
		m.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		m.typ = "ToolMessageDelayed"
		m.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m McpToolMessagesItem) MarshalJSON() ([]byte, error) {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return json.Marshal(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return json.Marshal(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return json.Marshal(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return json.Marshal(m.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type McpToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (m *McpToolMessagesItem) Accept(visitor McpToolMessagesItemVisitor) error {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(m.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type OutputTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*OutputToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OutputTool) GetAsync() *bool {
	if o == nil {
		return nil
	}
	return o.Async
}

func (o *OutputTool) GetMessages() []*OutputToolMessagesItem {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *OutputTool) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *OutputTool) GetOrgId() string {
	if o == nil {
		return ""
	}
	return o.OrgId
}

func (o *OutputTool) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *OutputTool) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *OutputTool) GetFunction() *OpenAiFunction {
	if o == nil {
		return nil
	}
	return o.Function
}

func (o *OutputTool) GetServer() *Server {
	if o == nil {
		return nil
	}
	return o.Server
}

func (o *OutputTool) Type() string {
	return o.type_
}

func (o *OutputTool) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputTool) UnmarshalJSON(data []byte) error {
	type embed OutputTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OutputTool(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "output", unmarshaler.Type)
	}
	o.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "type")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OutputTool) MarshalJSON() ([]byte, error) {
	type embed OutputTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*o),
		CreatedAt: internal.NewDateTime(o.CreatedAt),
		UpdatedAt: internal.NewDateTime(o.UpdatedAt),
		Type:      "output",
	}
	return json.Marshal(marshaler)
}

func (o *OutputTool) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (o *OutputToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if o == nil {
		return nil
	}
	return o.ToolMessageStart
}

func (o *OutputToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if o == nil {
		return nil
	}
	return o.ToolMessageComplete
}

func (o *OutputToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if o == nil {
		return nil
	}
	return o.ToolMessageFailed
}

func (o *OutputToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if o == nil {
		return nil
	}
	return o.ToolMessageDelayed
}

func (o *OutputToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		o.typ = "ToolMessageStart"
		o.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		o.typ = "ToolMessageComplete"
		o.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		o.typ = "ToolMessageFailed"
		o.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		o.typ = "ToolMessageDelayed"
		o.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OutputToolMessagesItem) MarshalJSON() ([]byte, error) {
	if o.typ == "ToolMessageStart" || o.ToolMessageStart != nil {
		return json.Marshal(o.ToolMessageStart)
	}
	if o.typ == "ToolMessageComplete" || o.ToolMessageComplete != nil {
		return json.Marshal(o.ToolMessageComplete)
	}
	if o.typ == "ToolMessageFailed" || o.ToolMessageFailed != nil {
		return json.Marshal(o.ToolMessageFailed)
	}
	if o.typ == "ToolMessageDelayed" || o.ToolMessageDelayed != nil {
		return json.Marshal(o.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OutputToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (o *OutputToolMessagesItem) Accept(visitor OutputToolMessagesItemVisitor) error {
	if o.typ == "ToolMessageStart" || o.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(o.ToolMessageStart)
	}
	if o.typ == "ToolMessageComplete" || o.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(o.ToolMessageComplete)
	}
	if o.typ == "ToolMessageFailed" || o.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(o.ToolMessageFailed)
	}
	if o.typ == "ToolMessageDelayed" || o.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(o.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type QueryTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*QueryToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The knowledge bases to query
	KnowledgeBases []*KnowledgeBase `json:"knowledgeBases,omitempty" url:"knowledgeBases,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryTool) GetAsync() *bool {
	if q == nil {
		return nil
	}
	return q.Async
}

func (q *QueryTool) GetMessages() []*QueryToolMessagesItem {
	if q == nil {
		return nil
	}
	return q.Messages
}

func (q *QueryTool) GetKnowledgeBases() []*KnowledgeBase {
	if q == nil {
		return nil
	}
	return q.KnowledgeBases
}

func (q *QueryTool) GetId() string {
	if q == nil {
		return ""
	}
	return q.Id
}

func (q *QueryTool) GetOrgId() string {
	if q == nil {
		return ""
	}
	return q.OrgId
}

func (q *QueryTool) GetCreatedAt() time.Time {
	if q == nil {
		return time.Time{}
	}
	return q.CreatedAt
}

func (q *QueryTool) GetUpdatedAt() time.Time {
	if q == nil {
		return time.Time{}
	}
	return q.UpdatedAt
}

func (q *QueryTool) GetFunction() *OpenAiFunction {
	if q == nil {
		return nil
	}
	return q.Function
}

func (q *QueryTool) GetServer() *Server {
	if q == nil {
		return nil
	}
	return q.Server
}

func (q *QueryTool) Type() string {
	return q.type_
}

func (q *QueryTool) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryTool) UnmarshalJSON(data []byte) error {
	type embed QueryTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*q),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*q = QueryTool(unmarshaler.embed)
	q.CreatedAt = unmarshaler.CreatedAt.Time()
	q.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "query" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", q, "query", unmarshaler.Type)
	}
	q.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *q, "type")
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryTool) MarshalJSON() ([]byte, error) {
	type embed QueryTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*q),
		CreatedAt: internal.NewDateTime(q.CreatedAt),
		UpdatedAt: internal.NewDateTime(q.UpdatedAt),
		Type:      "query",
	}
	return json.Marshal(marshaler)
}

func (q *QueryTool) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (q *QueryToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if q == nil {
		return nil
	}
	return q.ToolMessageStart
}

func (q *QueryToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if q == nil {
		return nil
	}
	return q.ToolMessageComplete
}

func (q *QueryToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if q == nil {
		return nil
	}
	return q.ToolMessageFailed
}

func (q *QueryToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if q == nil {
		return nil
	}
	return q.ToolMessageDelayed
}

func (q *QueryToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		q.typ = "ToolMessageStart"
		q.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		q.typ = "ToolMessageComplete"
		q.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		q.typ = "ToolMessageFailed"
		q.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		q.typ = "ToolMessageDelayed"
		q.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryToolMessagesItem) MarshalJSON() ([]byte, error) {
	if q.typ == "ToolMessageStart" || q.ToolMessageStart != nil {
		return json.Marshal(q.ToolMessageStart)
	}
	if q.typ == "ToolMessageComplete" || q.ToolMessageComplete != nil {
		return json.Marshal(q.ToolMessageComplete)
	}
	if q.typ == "ToolMessageFailed" || q.ToolMessageFailed != nil {
		return json.Marshal(q.ToolMessageFailed)
	}
	if q.typ == "ToolMessageDelayed" || q.ToolMessageDelayed != nil {
		return json.Marshal(q.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (q *QueryToolMessagesItem) Accept(visitor QueryToolMessagesItemVisitor) error {
	if q.typ == "ToolMessageStart" || q.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(q.ToolMessageStart)
	}
	if q.typ == "ToolMessageComplete" || q.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(q.ToolMessageComplete)
	}
	if q.typ == "ToolMessageFailed" || q.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(q.ToolMessageFailed)
	}
	if q.typ == "ToolMessageDelayed" || q.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(q.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type SlackSendMessageTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*SlackSendMessageToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SlackSendMessageTool) GetAsync() *bool {
	if s == nil {
		return nil
	}
	return s.Async
}

func (s *SlackSendMessageTool) GetMessages() []*SlackSendMessageToolMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SlackSendMessageTool) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SlackSendMessageTool) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SlackSendMessageTool) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SlackSendMessageTool) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SlackSendMessageTool) GetFunction() *OpenAiFunction {
	if s == nil {
		return nil
	}
	return s.Function
}

func (s *SlackSendMessageTool) GetServer() *Server {
	if s == nil {
		return nil
	}
	return s.Server
}

func (s *SlackSendMessageTool) Type() string {
	return s.type_
}

func (s *SlackSendMessageTool) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SlackSendMessageTool) UnmarshalJSON(data []byte) error {
	type embed SlackSendMessageTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SlackSendMessageTool(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "slack.message.send" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "slack.message.send", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlackSendMessageTool) MarshalJSON() ([]byte, error) {
	type embed SlackSendMessageTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Type:      "slack.message.send",
	}
	return json.Marshal(marshaler)
}

func (s *SlackSendMessageTool) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SlackSendMessageToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if s == nil {
		return nil
	}
	return s.ToolMessageStart
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if s == nil {
		return nil
	}
	return s.ToolMessageComplete
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if s == nil {
		return nil
	}
	return s.ToolMessageFailed
}

func (s *SlackSendMessageToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if s == nil {
		return nil
	}
	return s.ToolMessageDelayed
}

func (s *SlackSendMessageToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		s.typ = "ToolMessageStart"
		s.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		s.typ = "ToolMessageComplete"
		s.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		s.typ = "ToolMessageFailed"
		s.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		s.typ = "ToolMessageDelayed"
		s.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SlackSendMessageToolMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return json.Marshal(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return json.Marshal(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return json.Marshal(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return json.Marshal(s.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SlackSendMessageToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (s *SlackSendMessageToolMessagesItem) Accept(visitor SlackSendMessageToolMessagesItemVisitor) error {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(s.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SmsTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*SmsToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SmsTool) GetAsync() *bool {
	if s == nil {
		return nil
	}
	return s.Async
}

func (s *SmsTool) GetMessages() []*SmsToolMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SmsTool) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SmsTool) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SmsTool) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SmsTool) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SmsTool) GetFunction() *OpenAiFunction {
	if s == nil {
		return nil
	}
	return s.Function
}

func (s *SmsTool) GetServer() *Server {
	if s == nil {
		return nil
	}
	return s.Server
}

func (s *SmsTool) Type() string {
	return s.type_
}

func (s *SmsTool) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SmsTool) UnmarshalJSON(data []byte) error {
	type embed SmsTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SmsTool(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "sms" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "sms", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SmsTool) MarshalJSON() ([]byte, error) {
	type embed SmsTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Type:      "sms",
	}
	return json.Marshal(marshaler)
}

func (s *SmsTool) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SmsToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (s *SmsToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if s == nil {
		return nil
	}
	return s.ToolMessageStart
}

func (s *SmsToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if s == nil {
		return nil
	}
	return s.ToolMessageComplete
}

func (s *SmsToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if s == nil {
		return nil
	}
	return s.ToolMessageFailed
}

func (s *SmsToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if s == nil {
		return nil
	}
	return s.ToolMessageDelayed
}

func (s *SmsToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		s.typ = "ToolMessageStart"
		s.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		s.typ = "ToolMessageComplete"
		s.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		s.typ = "ToolMessageFailed"
		s.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		s.typ = "ToolMessageDelayed"
		s.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SmsToolMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return json.Marshal(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return json.Marshal(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return json.Marshal(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return json.Marshal(s.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SmsToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (s *SmsToolMessagesItem) Accept(visitor SmsToolMessagesItemVisitor) error {
	if s.typ == "ToolMessageStart" || s.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(s.ToolMessageStart)
	}
	if s.typ == "ToolMessageComplete" || s.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(s.ToolMessageComplete)
	}
	if s.typ == "ToolMessageFailed" || s.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(s.ToolMessageFailed)
	}
	if s.typ == "ToolMessageDelayed" || s.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(s.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type TextEditorTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*TextEditorToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// The name of the tool, fixed to 'str_replace_editor'
	type_   string
	subType string
	name    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TextEditorTool) GetAsync() *bool {
	if t == nil {
		return nil
	}
	return t.Async
}

func (t *TextEditorTool) GetMessages() []*TextEditorToolMessagesItem {
	if t == nil {
		return nil
	}
	return t.Messages
}

func (t *TextEditorTool) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TextEditorTool) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TextEditorTool) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TextEditorTool) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TextEditorTool) GetFunction() *OpenAiFunction {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *TextEditorTool) GetServer() *Server {
	if t == nil {
		return nil
	}
	return t.Server
}

func (t *TextEditorTool) Type() string {
	return t.type_
}

func (t *TextEditorTool) SubType() string {
	return t.subType
}

func (t *TextEditorTool) Name() string {
	return t.name
}

func (t *TextEditorTool) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextEditorTool) UnmarshalJSON(data []byte) error {
	type embed TextEditorTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
		SubType   string             `json:"subType"`
		Name      string             `json:"name"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextEditorTool(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "textEditor" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "textEditor", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	if unmarshaler.SubType != "text_editor_20241022" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "text_editor_20241022", unmarshaler.SubType)
	}
	t.subType = unmarshaler.SubType
	if unmarshaler.Name != "str_replace_editor" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "str_replace_editor", unmarshaler.Name)
	}
	t.name = unmarshaler.Name
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type", "subType", "name")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextEditorTool) MarshalJSON() ([]byte, error) {
	type embed TextEditorTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
		SubType   string             `json:"subType"`
		Name      string             `json:"name"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "textEditor",
		SubType:   "text_editor_20241022",
		Name:      "str_replace_editor",
	}
	return json.Marshal(marshaler)
}

func (t *TextEditorTool) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextEditorToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (t *TextEditorToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if t == nil {
		return nil
	}
	return t.ToolMessageStart
}

func (t *TextEditorToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if t == nil {
		return nil
	}
	return t.ToolMessageComplete
}

func (t *TextEditorToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if t == nil {
		return nil
	}
	return t.ToolMessageFailed
}

func (t *TextEditorToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if t == nil {
		return nil
	}
	return t.ToolMessageDelayed
}

func (t *TextEditorToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		t.typ = "ToolMessageStart"
		t.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.typ = "ToolMessageComplete"
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.typ = "ToolMessageFailed"
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		t.typ = "ToolMessageDelayed"
		t.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TextEditorToolMessagesItem) MarshalJSON() ([]byte, error) {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return json.Marshal(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return json.Marshal(t.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TextEditorToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (t *TextEditorToolMessagesItem) Accept(visitor TextEditorToolMessagesItemVisitor) error {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(t.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallTool struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*TransferCallToolMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*TransferCallToolDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the unique identifier for the tool.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the organization that this tool belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the tool was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the tool was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferCallTool) GetAsync() *bool {
	if t == nil {
		return nil
	}
	return t.Async
}

func (t *TransferCallTool) GetMessages() []*TransferCallToolMessagesItem {
	if t == nil {
		return nil
	}
	return t.Messages
}

func (t *TransferCallTool) GetDestinations() []*TransferCallToolDestinationsItem {
	if t == nil {
		return nil
	}
	return t.Destinations
}

func (t *TransferCallTool) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TransferCallTool) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TransferCallTool) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransferCallTool) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransferCallTool) GetFunction() *OpenAiFunction {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *TransferCallTool) GetServer() *Server {
	if t == nil {
		return nil
	}
	return t.Server
}

func (t *TransferCallTool) Type() string {
	return t.type_
}

func (t *TransferCallTool) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferCallTool) UnmarshalJSON(data []byte) error {
	type embed TransferCallTool
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferCallTool(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "transferCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "transferCall", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferCallTool) MarshalJSON() ([]byte, error) {
	type embed TransferCallTool
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "transferCall",
	}
	return json.Marshal(marshaler)
}

func (t *TransferCallTool) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferCallToolDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (t *TransferCallToolDestinationsItem) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if t == nil {
		return nil
	}
	return t.TransferDestinationAssistant
}

func (t *TransferCallToolDestinationsItem) GetTransferDestinationNumber() *TransferDestinationNumber {
	if t == nil {
		return nil
	}
	return t.TransferDestinationNumber
}

func (t *TransferCallToolDestinationsItem) GetTransferDestinationSip() *TransferDestinationSip {
	if t == nil {
		return nil
	}
	return t.TransferDestinationSip
}

func (t *TransferCallToolDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		t.typ = "TransferDestinationAssistant"
		t.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		t.typ = "TransferDestinationNumber"
		t.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		t.typ = "TransferDestinationSip"
		t.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferCallToolDestinationsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "TransferDestinationAssistant" || t.TransferDestinationAssistant != nil {
		return json.Marshal(t.TransferDestinationAssistant)
	}
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return json.Marshal(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return json.Marshal(t.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (t *TransferCallToolDestinationsItem) Accept(visitor TransferCallToolDestinationsItemVisitor) error {
	if t.typ == "TransferDestinationAssistant" || t.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(t.TransferDestinationAssistant)
	}
	if t.typ == "TransferDestinationNumber" || t.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(t.TransferDestinationNumber)
	}
	if t.typ == "TransferDestinationSip" || t.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(t.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (t *TransferCallToolMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if t == nil {
		return nil
	}
	return t.ToolMessageStart
}

func (t *TransferCallToolMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if t == nil {
		return nil
	}
	return t.ToolMessageComplete
}

func (t *TransferCallToolMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if t == nil {
		return nil
	}
	return t.ToolMessageFailed
}

func (t *TransferCallToolMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if t == nil {
		return nil
	}
	return t.ToolMessageDelayed
}

func (t *TransferCallToolMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		t.typ = "ToolMessageStart"
		t.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.typ = "ToolMessageComplete"
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.typ = "ToolMessageFailed"
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		t.typ = "ToolMessageDelayed"
		t.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferCallToolMessagesItem) MarshalJSON() ([]byte, error) {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return json.Marshal(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return json.Marshal(t.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferCallToolMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (t *TransferCallToolMessagesItem) Accept(visitor TransferCallToolMessagesItemVisitor) error {
	if t.typ == "ToolMessageStart" || t.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(t.ToolMessageStart)
	}
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	if t.typ == "ToolMessageDelayed" || t.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(t.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type UpdateBashToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateBashToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType *string `json:"subType,omitempty" url:"subType,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// The name of the tool, fixed to 'bash'
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateBashToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateBashToolDto) GetMessages() []*UpdateBashToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateBashToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateBashToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateBashToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBashToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBashToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBashToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBashToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateBashToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateBashToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateBashToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateBashToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateBashToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateBashToolDtoMessagesItem) Accept(visitor UpdateBashToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateComputerToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateComputerToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType *string `json:"subType,omitempty" url:"subType,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// The name of the tool, fixed to 'computer'
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The display width in pixels
	DisplayWidthPx *float64 `json:"displayWidthPx,omitempty" url:"displayWidthPx,omitempty"`
	// The display height in pixels
	DisplayHeightPx *float64 `json:"displayHeightPx,omitempty" url:"displayHeightPx,omitempty"`
	// Optional display number
	DisplayNumber *float64 `json:"displayNumber,omitempty" url:"displayNumber,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateComputerToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateComputerToolDto) GetMessages() []*UpdateComputerToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateComputerToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateComputerToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateComputerToolDto) GetDisplayWidthPx() *float64 {
	if u == nil {
		return nil
	}
	return u.DisplayWidthPx
}

func (u *UpdateComputerToolDto) GetDisplayHeightPx() *float64 {
	if u == nil {
		return nil
	}
	return u.DisplayHeightPx
}

func (u *UpdateComputerToolDto) GetDisplayNumber() *float64 {
	if u == nil {
		return nil
	}
	return u.DisplayNumber
}

func (u *UpdateComputerToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateComputerToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateComputerToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateComputerToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateComputerToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateComputerToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateComputerToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateComputerToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateComputerToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateComputerToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateComputerToolDtoMessagesItem) Accept(visitor UpdateComputerToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateDtmfToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateDtmfToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDtmfToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateDtmfToolDto) GetMessages() []*UpdateDtmfToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateDtmfToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateDtmfToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateDtmfToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDtmfToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDtmfToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDtmfToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDtmfToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDtmfToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateDtmfToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateDtmfToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateDtmfToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateDtmfToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateDtmfToolDtoMessagesItem) Accept(visitor UpdateDtmfToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateEndCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateEndCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateEndCallToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateEndCallToolDto) GetMessages() []*UpdateEndCallToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateEndCallToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateEndCallToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateEndCallToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateEndCallToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateEndCallToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateEndCallToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateEndCallToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateEndCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateEndCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateEndCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateEndCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateEndCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateEndCallToolDtoMessagesItem) Accept(visitor UpdateEndCallToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateFunctionToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateFunctionToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateFunctionToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateFunctionToolDto) GetMessages() []*UpdateFunctionToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateFunctionToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateFunctionToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateFunctionToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateFunctionToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateFunctionToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateFunctionToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateFunctionToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateFunctionToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateFunctionToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateFunctionToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateFunctionToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateFunctionToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateFunctionToolDtoMessagesItem) Accept(visitor UpdateFunctionToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGhlToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGhlToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server   *Server          `json:"server,omitempty" url:"server,omitempty"`
	Metadata *GhlToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGhlToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGhlToolDto) GetMessages() []*UpdateGhlToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGhlToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGhlToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGhlToolDto) GetMetadata() *GhlToolMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateGhlToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGhlToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGhlToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGhlToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGhlToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGhlToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGhlToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGhlToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGhlToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGhlToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGhlToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGhlToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGhlToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGhlToolDtoMessagesItem) Accept(visitor UpdateGhlToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelCalendarAvailabilityToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetMessages() []*UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelCalendarAvailabilityToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelCalendarAvailabilityToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelCalendarAvailabilityToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelCalendarEventCreateToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetMessages() []*UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelCalendarEventCreateToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelCalendarEventCreateToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelCalendarEventCreateToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelContactCreateToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelContactCreateToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetMessages() []*UpdateGoHighLevelContactCreateToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGoHighLevelContactCreateToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelContactCreateToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelContactCreateToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelContactCreateToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelContactCreateToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelContactCreateToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelContactCreateToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelContactCreateToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelContactCreateToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelContactCreateToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelContactGetToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoHighLevelContactGetToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelContactGetToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGoHighLevelContactGetToolDto) GetMessages() []*UpdateGoHighLevelContactGetToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoHighLevelContactGetToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGoHighLevelContactGetToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGoHighLevelContactGetToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelContactGetToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelContactGetToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelContactGetToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelContactGetToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelContactGetToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoHighLevelContactGetToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoHighLevelContactGetToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoHighLevelContactGetToolDtoMessagesItem) Accept(visitor UpdateGoHighLevelContactGetToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleCalendarCheckAvailabilityToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetMessages() []*UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCalendarCheckAvailabilityToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCalendarCheckAvailabilityToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItem) Accept(visitor UpdateGoogleCalendarCheckAvailabilityToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleCalendarCreateEventToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoogleCalendarCreateEventToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetMessages() []*UpdateGoogleCalendarCreateEventToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGoogleCalendarCreateEventToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCalendarCreateEventToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCalendarCreateEventToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCalendarCreateEventToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCalendarCreateEventToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCalendarCreateEventToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoogleCalendarCreateEventToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleCalendarCreateEventToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoogleCalendarCreateEventToolDtoMessagesItem) Accept(visitor UpdateGoogleCalendarCreateEventToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleSheetsRowAppendToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateGoogleSheetsRowAppendToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetMessages() []*UpdateGoogleSheetsRowAppendToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateGoogleSheetsRowAppendToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleSheetsRowAppendToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleSheetsRowAppendToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleSheetsRowAppendToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleSheetsRowAppendToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleSheetsRowAppendToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateGoogleSheetsRowAppendToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateGoogleSheetsRowAppendToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateGoogleSheetsRowAppendToolDtoMessagesItem) Accept(visitor UpdateGoogleSheetsRowAppendToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateMakeToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateMakeToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server   *Server           `json:"server,omitempty" url:"server,omitempty"`
	Metadata *MakeToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMakeToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateMakeToolDto) GetMessages() []*UpdateMakeToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateMakeToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateMakeToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateMakeToolDto) GetMetadata() *MakeToolMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateMakeToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMakeToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMakeToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMakeToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMakeToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMakeToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateMakeToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateMakeToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateMakeToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateMakeToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateMakeToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateMakeToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateMakeToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateMakeToolDtoMessagesItem) Accept(visitor UpdateMakeToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateMcpToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateMcpToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMcpToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateMcpToolDto) GetMessages() []*UpdateMcpToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateMcpToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateMcpToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateMcpToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMcpToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMcpToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMcpToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMcpToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMcpToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateMcpToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateMcpToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateMcpToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateMcpToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateMcpToolDtoMessagesItem) Accept(visitor UpdateMcpToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateOutputToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateOutputToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOutputToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateOutputToolDto) GetMessages() []*UpdateOutputToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateOutputToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateOutputToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateOutputToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOutputToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOutputToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOutputToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOutputToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOutputToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateOutputToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateOutputToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateOutputToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateOutputToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateOutputToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateOutputToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateOutputToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateOutputToolDtoMessagesItem) Accept(visitor UpdateOutputToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateQueryToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateQueryToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The knowledge bases to query
	KnowledgeBases []*KnowledgeBase `json:"knowledgeBases,omitempty" url:"knowledgeBases,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateQueryToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateQueryToolDto) GetMessages() []*UpdateQueryToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateQueryToolDto) GetKnowledgeBases() []*KnowledgeBase {
	if u == nil {
		return nil
	}
	return u.KnowledgeBases
}

func (u *UpdateQueryToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateQueryToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateQueryToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateQueryToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateQueryToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateQueryToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateQueryToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateQueryToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateQueryToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateQueryToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateQueryToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateQueryToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateQueryToolDtoMessagesItem) Accept(visitor UpdateQueryToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateSlackSendMessageToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateSlackSendMessageToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSlackSendMessageToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateSlackSendMessageToolDto) GetMessages() []*UpdateSlackSendMessageToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateSlackSendMessageToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateSlackSendMessageToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateSlackSendMessageToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSlackSendMessageToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSlackSendMessageToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSlackSendMessageToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSlackSendMessageToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSlackSendMessageToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateSlackSendMessageToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateSlackSendMessageToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateSlackSendMessageToolDtoMessagesItem) Accept(visitor UpdateSlackSendMessageToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateSmsToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateSmsToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSmsToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateSmsToolDto) GetMessages() []*UpdateSmsToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateSmsToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateSmsToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateSmsToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSmsToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSmsToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSmsToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSmsToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSmsToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateSmsToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateSmsToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateSmsToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateSmsToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateSmsToolDtoMessagesItem) Accept(visitor UpdateSmsToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTextEditorToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateTextEditorToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The sub type of tool.
	SubType *string `json:"subType,omitempty" url:"subType,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// The name of the tool, fixed to 'str_replace_editor'
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTextEditorToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateTextEditorToolDto) GetMessages() []*UpdateTextEditorToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateTextEditorToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateTextEditorToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateTextEditorToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTextEditorToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTextEditorToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTextEditorToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTextEditorToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTextEditorToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateTextEditorToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateTextEditorToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTextEditorToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTextEditorToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateTextEditorToolDtoMessagesItem) Accept(visitor UpdateTextEditorToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTransferCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*UpdateTransferCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*UpdateTransferCallToolDtoDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTransferCallToolDto) GetAsync() *bool {
	if u == nil {
		return nil
	}
	return u.Async
}

func (u *UpdateTransferCallToolDto) GetMessages() []*UpdateTransferCallToolDtoMessagesItem {
	if u == nil {
		return nil
	}
	return u.Messages
}

func (u *UpdateTransferCallToolDto) GetDestinations() []*UpdateTransferCallToolDtoDestinationsItem {
	if u == nil {
		return nil
	}
	return u.Destinations
}

func (u *UpdateTransferCallToolDto) GetFunction() *OpenAiFunction {
	if u == nil {
		return nil
	}
	return u.Function
}

func (u *UpdateTransferCallToolDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateTransferCallToolDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTransferCallToolDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTransferCallToolDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTransferCallToolDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTransferCallToolDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTransferCallToolDtoDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (u *UpdateTransferCallToolDtoDestinationsItem) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if u == nil {
		return nil
	}
	return u.TransferDestinationAssistant
}

func (u *UpdateTransferCallToolDtoDestinationsItem) GetTransferDestinationNumber() *TransferDestinationNumber {
	if u == nil {
		return nil
	}
	return u.TransferDestinationNumber
}

func (u *UpdateTransferCallToolDtoDestinationsItem) GetTransferDestinationSip() *TransferDestinationSip {
	if u == nil {
		return nil
	}
	return u.TransferDestinationSip
}

func (u *UpdateTransferCallToolDtoDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		u.typ = "TransferDestinationAssistant"
		u.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		u.typ = "TransferDestinationNumber"
		u.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		u.typ = "TransferDestinationSip"
		u.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTransferCallToolDtoDestinationsItem) MarshalJSON() ([]byte, error) {
	if u.typ == "TransferDestinationAssistant" || u.TransferDestinationAssistant != nil {
		return json.Marshal(u.TransferDestinationAssistant)
	}
	if u.typ == "TransferDestinationNumber" || u.TransferDestinationNumber != nil {
		return json.Marshal(u.TransferDestinationNumber)
	}
	if u.typ == "TransferDestinationSip" || u.TransferDestinationSip != nil {
		return json.Marshal(u.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTransferCallToolDtoDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (u *UpdateTransferCallToolDtoDestinationsItem) Accept(visitor UpdateTransferCallToolDtoDestinationsItemVisitor) error {
	if u.typ == "TransferDestinationAssistant" || u.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(u.TransferDestinationAssistant)
	}
	if u.typ == "TransferDestinationNumber" || u.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(u.TransferDestinationNumber)
	}
	if u.typ == "TransferDestinationSip" || u.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(u.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTransferCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if u == nil {
		return nil
	}
	return u.ToolMessageStart
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if u == nil {
		return nil
	}
	return u.ToolMessageComplete
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if u == nil {
		return nil
	}
	return u.ToolMessageFailed
}

func (u *UpdateTransferCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if u == nil {
		return nil
	}
	return u.ToolMessageDelayed
}

func (u *UpdateTransferCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		u.typ = "ToolMessageStart"
		u.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		u.typ = "ToolMessageComplete"
		u.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		u.typ = "ToolMessageFailed"
		u.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		u.typ = "ToolMessageDelayed"
		u.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTransferCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return json.Marshal(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return json.Marshal(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return json.Marshal(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return json.Marshal(u.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTransferCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (u *UpdateTransferCallToolDtoMessagesItem) Accept(visitor UpdateTransferCallToolDtoMessagesItemVisitor) error {
	if u.typ == "ToolMessageStart" || u.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(u.ToolMessageStart)
	}
	if u.typ == "ToolMessageComplete" || u.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(u.ToolMessageComplete)
	}
	if u.typ == "ToolMessageFailed" || u.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(u.ToolMessageFailed)
	}
	if u.typ == "ToolMessageDelayed" || u.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(u.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type ToolsCreateRequest struct {
	CreateDtmfToolDto                            *CreateDtmfToolDto
	CreateEndCallToolDto                         *CreateEndCallToolDto
	CreateFunctionToolDto                        *CreateFunctionToolDto
	CreateGhlToolDto                             *CreateGhlToolDto
	CreateMakeToolDto                            *CreateMakeToolDto
	CreateTransferCallToolDto                    *CreateTransferCallToolDto
	CreateOutputToolDto                          *CreateOutputToolDto
	CreateBashToolDto                            *CreateBashToolDto
	CreateComputerToolDto                        *CreateComputerToolDto
	CreateTextEditorToolDto                      *CreateTextEditorToolDto
	CreateQueryToolDto                           *CreateQueryToolDto
	CreateGoogleCalendarCreateEventToolDto       *CreateGoogleCalendarCreateEventToolDto
	CreateGoogleSheetsRowAppendToolDto           *CreateGoogleSheetsRowAppendToolDto
	CreateGoogleCalendarCheckAvailabilityToolDto *CreateGoogleCalendarCheckAvailabilityToolDto
	CreateSlackSendMessageToolDto                *CreateSlackSendMessageToolDto
	CreateSmsToolDto                             *CreateSmsToolDto
	CreateMcpToolDto                             *CreateMcpToolDto
	CreateGoHighLevelCalendarAvailabilityToolDto *CreateGoHighLevelCalendarAvailabilityToolDto
	CreateGoHighLevelCalendarEventCreateToolDto  *CreateGoHighLevelCalendarEventCreateToolDto
	CreateGoHighLevelContactCreateToolDto        *CreateGoHighLevelContactCreateToolDto
	CreateGoHighLevelContactGetToolDto           *CreateGoHighLevelContactGetToolDto

	typ string
}

func (t *ToolsCreateRequest) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if t == nil {
		return nil
	}
	return t.CreateDtmfToolDto
}

func (t *ToolsCreateRequest) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateEndCallToolDto
}

func (t *ToolsCreateRequest) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if t == nil {
		return nil
	}
	return t.CreateFunctionToolDto
}

func (t *ToolsCreateRequest) GetCreateGhlToolDto() *CreateGhlToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGhlToolDto
}

func (t *ToolsCreateRequest) GetCreateMakeToolDto() *CreateMakeToolDto {
	if t == nil {
		return nil
	}
	return t.CreateMakeToolDto
}

func (t *ToolsCreateRequest) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTransferCallToolDto
}

func (t *ToolsCreateRequest) GetCreateOutputToolDto() *CreateOutputToolDto {
	if t == nil {
		return nil
	}
	return t.CreateOutputToolDto
}

func (t *ToolsCreateRequest) GetCreateBashToolDto() *CreateBashToolDto {
	if t == nil {
		return nil
	}
	return t.CreateBashToolDto
}

func (t *ToolsCreateRequest) GetCreateComputerToolDto() *CreateComputerToolDto {
	if t == nil {
		return nil
	}
	return t.CreateComputerToolDto
}

func (t *ToolsCreateRequest) GetCreateTextEditorToolDto() *CreateTextEditorToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTextEditorToolDto
}

func (t *ToolsCreateRequest) GetCreateQueryToolDto() *CreateQueryToolDto {
	if t == nil {
		return nil
	}
	return t.CreateQueryToolDto
}

func (t *ToolsCreateRequest) GetCreateGoogleCalendarCreateEventToolDto() *CreateGoogleCalendarCreateEventToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCreateEventToolDto
}

func (t *ToolsCreateRequest) GetCreateGoogleSheetsRowAppendToolDto() *CreateGoogleSheetsRowAppendToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleSheetsRowAppendToolDto
}

func (t *ToolsCreateRequest) GetCreateGoogleCalendarCheckAvailabilityToolDto() *CreateGoogleCalendarCheckAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoogleCalendarCheckAvailabilityToolDto
}

func (t *ToolsCreateRequest) GetCreateSlackSendMessageToolDto() *CreateSlackSendMessageToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSlackSendMessageToolDto
}

func (t *ToolsCreateRequest) GetCreateSmsToolDto() *CreateSmsToolDto {
	if t == nil {
		return nil
	}
	return t.CreateSmsToolDto
}

func (t *ToolsCreateRequest) GetCreateMcpToolDto() *CreateMcpToolDto {
	if t == nil {
		return nil
	}
	return t.CreateMcpToolDto
}

func (t *ToolsCreateRequest) GetCreateGoHighLevelCalendarAvailabilityToolDto() *CreateGoHighLevelCalendarAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarAvailabilityToolDto
}

func (t *ToolsCreateRequest) GetCreateGoHighLevelCalendarEventCreateToolDto() *CreateGoHighLevelCalendarEventCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelCalendarEventCreateToolDto
}

func (t *ToolsCreateRequest) GetCreateGoHighLevelContactCreateToolDto() *CreateGoHighLevelContactCreateToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactCreateToolDto
}

func (t *ToolsCreateRequest) GetCreateGoHighLevelContactGetToolDto() *CreateGoHighLevelContactGetToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGoHighLevelContactGetToolDto
}

func (t *ToolsCreateRequest) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.typ = "CreateDtmfToolDto"
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.typ = "CreateEndCallToolDto"
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.typ = "CreateFunctionToolDto"
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		t.typ = "CreateGhlToolDto"
		t.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		t.typ = "CreateMakeToolDto"
		t.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.typ = "CreateTransferCallToolDto"
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	valueCreateOutputToolDto := new(CreateOutputToolDto)
	if err := json.Unmarshal(data, &valueCreateOutputToolDto); err == nil {
		t.typ = "CreateOutputToolDto"
		t.CreateOutputToolDto = valueCreateOutputToolDto
		return nil
	}
	valueCreateBashToolDto := new(CreateBashToolDto)
	if err := json.Unmarshal(data, &valueCreateBashToolDto); err == nil {
		t.typ = "CreateBashToolDto"
		t.CreateBashToolDto = valueCreateBashToolDto
		return nil
	}
	valueCreateComputerToolDto := new(CreateComputerToolDto)
	if err := json.Unmarshal(data, &valueCreateComputerToolDto); err == nil {
		t.typ = "CreateComputerToolDto"
		t.CreateComputerToolDto = valueCreateComputerToolDto
		return nil
	}
	valueCreateTextEditorToolDto := new(CreateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueCreateTextEditorToolDto); err == nil {
		t.typ = "CreateTextEditorToolDto"
		t.CreateTextEditorToolDto = valueCreateTextEditorToolDto
		return nil
	}
	valueCreateQueryToolDto := new(CreateQueryToolDto)
	if err := json.Unmarshal(data, &valueCreateQueryToolDto); err == nil {
		t.typ = "CreateQueryToolDto"
		t.CreateQueryToolDto = valueCreateQueryToolDto
		return nil
	}
	valueCreateGoogleCalendarCreateEventToolDto := new(CreateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCreateEventToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCreateEventToolDto"
		t.CreateGoogleCalendarCreateEventToolDto = valueCreateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueCreateGoogleSheetsRowAppendToolDto := new(CreateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleSheetsRowAppendToolDto); err == nil {
		t.typ = "CreateGoogleSheetsRowAppendToolDto"
		t.CreateGoogleSheetsRowAppendToolDto = valueCreateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueCreateGoogleCalendarCheckAvailabilityToolDto := new(CreateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		t.typ = "CreateGoogleCalendarCheckAvailabilityToolDto"
		t.CreateGoogleCalendarCheckAvailabilityToolDto = valueCreateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueCreateSlackSendMessageToolDto := new(CreateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueCreateSlackSendMessageToolDto); err == nil {
		t.typ = "CreateSlackSendMessageToolDto"
		t.CreateSlackSendMessageToolDto = valueCreateSlackSendMessageToolDto
		return nil
	}
	valueCreateSmsToolDto := new(CreateSmsToolDto)
	if err := json.Unmarshal(data, &valueCreateSmsToolDto); err == nil {
		t.typ = "CreateSmsToolDto"
		t.CreateSmsToolDto = valueCreateSmsToolDto
		return nil
	}
	valueCreateMcpToolDto := new(CreateMcpToolDto)
	if err := json.Unmarshal(data, &valueCreateMcpToolDto); err == nil {
		t.typ = "CreateMcpToolDto"
		t.CreateMcpToolDto = valueCreateMcpToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarAvailabilityToolDto := new(CreateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarAvailabilityToolDto"
		t.CreateGoHighLevelCalendarAvailabilityToolDto = valueCreateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueCreateGoHighLevelCalendarEventCreateToolDto := new(CreateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCalendarEventCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelCalendarEventCreateToolDto"
		t.CreateGoHighLevelCalendarEventCreateToolDto = valueCreateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactCreateToolDto := new(CreateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactCreateToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactCreateToolDto"
		t.CreateGoHighLevelContactCreateToolDto = valueCreateGoHighLevelContactCreateToolDto
		return nil
	}
	valueCreateGoHighLevelContactGetToolDto := new(CreateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelContactGetToolDto); err == nil {
		t.typ = "CreateGoHighLevelContactGetToolDto"
		t.CreateGoHighLevelContactGetToolDto = valueCreateGoHighLevelContactGetToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolsCreateRequest) MarshalJSON() ([]byte, error) {
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGhlToolDto" || t.CreateGhlToolDto != nil {
		return json.Marshal(t.CreateGhlToolDto)
	}
	if t.typ == "CreateMakeToolDto" || t.CreateMakeToolDto != nil {
		return json.Marshal(t.CreateMakeToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	if t.typ == "CreateOutputToolDto" || t.CreateOutputToolDto != nil {
		return json.Marshal(t.CreateOutputToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return json.Marshal(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return json.Marshal(t.CreateComputerToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return json.Marshal(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return json.Marshal(t.CreateQueryToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return json.Marshal(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return json.Marshal(t.CreateSmsToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return json.Marshal(t.CreateMcpToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(t.CreateGoHighLevelContactGetToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsCreateRequestVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
	VisitCreateOutputToolDto(*CreateOutputToolDto) error
	VisitCreateBashToolDto(*CreateBashToolDto) error
	VisitCreateComputerToolDto(*CreateComputerToolDto) error
	VisitCreateTextEditorToolDto(*CreateTextEditorToolDto) error
	VisitCreateQueryToolDto(*CreateQueryToolDto) error
	VisitCreateGoogleCalendarCreateEventToolDto(*CreateGoogleCalendarCreateEventToolDto) error
	VisitCreateGoogleSheetsRowAppendToolDto(*CreateGoogleSheetsRowAppendToolDto) error
	VisitCreateGoogleCalendarCheckAvailabilityToolDto(*CreateGoogleCalendarCheckAvailabilityToolDto) error
	VisitCreateSlackSendMessageToolDto(*CreateSlackSendMessageToolDto) error
	VisitCreateSmsToolDto(*CreateSmsToolDto) error
	VisitCreateMcpToolDto(*CreateMcpToolDto) error
	VisitCreateGoHighLevelCalendarAvailabilityToolDto(*CreateGoHighLevelCalendarAvailabilityToolDto) error
	VisitCreateGoHighLevelCalendarEventCreateToolDto(*CreateGoHighLevelCalendarEventCreateToolDto) error
	VisitCreateGoHighLevelContactCreateToolDto(*CreateGoHighLevelContactCreateToolDto) error
	VisitCreateGoHighLevelContactGetToolDto(*CreateGoHighLevelContactGetToolDto) error
}

func (t *ToolsCreateRequest) Accept(visitor ToolsCreateRequestVisitor) error {
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGhlToolDto" || t.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(t.CreateGhlToolDto)
	}
	if t.typ == "CreateMakeToolDto" || t.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(t.CreateMakeToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	if t.typ == "CreateOutputToolDto" || t.CreateOutputToolDto != nil {
		return visitor.VisitCreateOutputToolDto(t.CreateOutputToolDto)
	}
	if t.typ == "CreateBashToolDto" || t.CreateBashToolDto != nil {
		return visitor.VisitCreateBashToolDto(t.CreateBashToolDto)
	}
	if t.typ == "CreateComputerToolDto" || t.CreateComputerToolDto != nil {
		return visitor.VisitCreateComputerToolDto(t.CreateComputerToolDto)
	}
	if t.typ == "CreateTextEditorToolDto" || t.CreateTextEditorToolDto != nil {
		return visitor.VisitCreateTextEditorToolDto(t.CreateTextEditorToolDto)
	}
	if t.typ == "CreateQueryToolDto" || t.CreateQueryToolDto != nil {
		return visitor.VisitCreateQueryToolDto(t.CreateQueryToolDto)
	}
	if t.typ == "CreateGoogleCalendarCreateEventToolDto" || t.CreateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCreateEventToolDto(t.CreateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "CreateGoogleSheetsRowAppendToolDto" || t.CreateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitCreateGoogleSheetsRowAppendToolDto(t.CreateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "CreateGoogleCalendarCheckAvailabilityToolDto" || t.CreateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitCreateGoogleCalendarCheckAvailabilityToolDto(t.CreateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "CreateSlackSendMessageToolDto" || t.CreateSlackSendMessageToolDto != nil {
		return visitor.VisitCreateSlackSendMessageToolDto(t.CreateSlackSendMessageToolDto)
	}
	if t.typ == "CreateSmsToolDto" || t.CreateSmsToolDto != nil {
		return visitor.VisitCreateSmsToolDto(t.CreateSmsToolDto)
	}
	if t.typ == "CreateMcpToolDto" || t.CreateMcpToolDto != nil {
		return visitor.VisitCreateMcpToolDto(t.CreateMcpToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarAvailabilityToolDto" || t.CreateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarAvailabilityToolDto(t.CreateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "CreateGoHighLevelCalendarEventCreateToolDto" || t.CreateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelCalendarEventCreateToolDto(t.CreateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactCreateToolDto" || t.CreateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactCreateToolDto(t.CreateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "CreateGoHighLevelContactGetToolDto" || t.CreateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitCreateGoHighLevelContactGetToolDto(t.CreateGoHighLevelContactGetToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsCreateResponse struct {
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	GhlTool                             *GhlTool
	MakeTool                            *MakeTool
	TransferCallTool                    *TransferCallTool
	OutputTool                          *OutputTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (t *ToolsCreateResponse) GetDtmfTool() *DtmfTool {
	if t == nil {
		return nil
	}
	return t.DtmfTool
}

func (t *ToolsCreateResponse) GetEndCallTool() *EndCallTool {
	if t == nil {
		return nil
	}
	return t.EndCallTool
}

func (t *ToolsCreateResponse) GetFunctionTool() *FunctionTool {
	if t == nil {
		return nil
	}
	return t.FunctionTool
}

func (t *ToolsCreateResponse) GetGhlTool() *GhlTool {
	if t == nil {
		return nil
	}
	return t.GhlTool
}

func (t *ToolsCreateResponse) GetMakeTool() *MakeTool {
	if t == nil {
		return nil
	}
	return t.MakeTool
}

func (t *ToolsCreateResponse) GetTransferCallTool() *TransferCallTool {
	if t == nil {
		return nil
	}
	return t.TransferCallTool
}

func (t *ToolsCreateResponse) GetOutputTool() *OutputTool {
	if t == nil {
		return nil
	}
	return t.OutputTool
}

func (t *ToolsCreateResponse) GetBashTool() *BashTool {
	if t == nil {
		return nil
	}
	return t.BashTool
}

func (t *ToolsCreateResponse) GetComputerTool() *ComputerTool {
	if t == nil {
		return nil
	}
	return t.ComputerTool
}

func (t *ToolsCreateResponse) GetTextEditorTool() *TextEditorTool {
	if t == nil {
		return nil
	}
	return t.TextEditorTool
}

func (t *ToolsCreateResponse) GetQueryTool() *QueryTool {
	if t == nil {
		return nil
	}
	return t.QueryTool
}

func (t *ToolsCreateResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCreateEventTool
}

func (t *ToolsCreateResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if t == nil {
		return nil
	}
	return t.GoogleSheetsRowAppendTool
}

func (t *ToolsCreateResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCheckAvailabilityTool
}

func (t *ToolsCreateResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if t == nil {
		return nil
	}
	return t.SlackSendMessageTool
}

func (t *ToolsCreateResponse) GetSmsTool() *SmsTool {
	if t == nil {
		return nil
	}
	return t.SmsTool
}

func (t *ToolsCreateResponse) GetMcpTool() *McpTool {
	if t == nil {
		return nil
	}
	return t.McpTool
}

func (t *ToolsCreateResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarAvailabilityTool
}

func (t *ToolsCreateResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarEventCreateTool
}

func (t *ToolsCreateResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactCreateTool
}

func (t *ToolsCreateResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactGetTool
}

func (t *ToolsCreateResponse) UnmarshalJSON(data []byte) error {
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		t.typ = "DtmfTool"
		t.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		t.typ = "EndCallTool"
		t.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		t.typ = "FunctionTool"
		t.FunctionTool = valueFunctionTool
		return nil
	}
	valueGhlTool := new(GhlTool)
	if err := json.Unmarshal(data, &valueGhlTool); err == nil {
		t.typ = "GhlTool"
		t.GhlTool = valueGhlTool
		return nil
	}
	valueMakeTool := new(MakeTool)
	if err := json.Unmarshal(data, &valueMakeTool); err == nil {
		t.typ = "MakeTool"
		t.MakeTool = valueMakeTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		t.typ = "TransferCallTool"
		t.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueOutputTool := new(OutputTool)
	if err := json.Unmarshal(data, &valueOutputTool); err == nil {
		t.typ = "OutputTool"
		t.OutputTool = valueOutputTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		t.typ = "BashTool"
		t.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		t.typ = "ComputerTool"
		t.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		t.typ = "TextEditorTool"
		t.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		t.typ = "QueryTool"
		t.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		t.typ = "GoogleCalendarCreateEventTool"
		t.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		t.typ = "GoogleSheetsRowAppendTool"
		t.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		t.typ = "GoogleCalendarCheckAvailabilityTool"
		t.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		t.typ = "SlackSendMessageTool"
		t.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		t.typ = "SmsTool"
		t.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		t.typ = "McpTool"
		t.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		t.typ = "GoHighLevelCalendarAvailabilityTool"
		t.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		t.typ = "GoHighLevelCalendarEventCreateTool"
		t.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		t.typ = "GoHighLevelContactCreateTool"
		t.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		t.typ = "GoHighLevelContactGetTool"
		t.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolsCreateResponse) MarshalJSON() ([]byte, error) {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return json.Marshal(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return json.Marshal(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return json.Marshal(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return json.Marshal(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return json.Marshal(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return json.Marshal(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return json.Marshal(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return json.Marshal(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return json.Marshal(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return json.Marshal(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return json.Marshal(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return json.Marshal(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return json.Marshal(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return json.Marshal(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return json.Marshal(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return json.Marshal(t.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsCreateResponseVisitor interface {
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitGhlTool(*GhlTool) error
	VisitMakeTool(*MakeTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitOutputTool(*OutputTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (t *ToolsCreateResponse) Accept(visitor ToolsCreateResponseVisitor) error {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return visitor.VisitDtmfTool(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return visitor.VisitEndCallTool(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return visitor.VisitFunctionTool(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return visitor.VisitGhlTool(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return visitor.VisitMakeTool(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return visitor.VisitOutputTool(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return visitor.VisitBashTool(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return visitor.VisitComputerTool(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return visitor.VisitQueryTool(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return visitor.VisitSmsTool(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return visitor.VisitMcpTool(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(t.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsDeleteResponse struct {
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	GhlTool                             *GhlTool
	MakeTool                            *MakeTool
	TransferCallTool                    *TransferCallTool
	OutputTool                          *OutputTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (t *ToolsDeleteResponse) GetDtmfTool() *DtmfTool {
	if t == nil {
		return nil
	}
	return t.DtmfTool
}

func (t *ToolsDeleteResponse) GetEndCallTool() *EndCallTool {
	if t == nil {
		return nil
	}
	return t.EndCallTool
}

func (t *ToolsDeleteResponse) GetFunctionTool() *FunctionTool {
	if t == nil {
		return nil
	}
	return t.FunctionTool
}

func (t *ToolsDeleteResponse) GetGhlTool() *GhlTool {
	if t == nil {
		return nil
	}
	return t.GhlTool
}

func (t *ToolsDeleteResponse) GetMakeTool() *MakeTool {
	if t == nil {
		return nil
	}
	return t.MakeTool
}

func (t *ToolsDeleteResponse) GetTransferCallTool() *TransferCallTool {
	if t == nil {
		return nil
	}
	return t.TransferCallTool
}

func (t *ToolsDeleteResponse) GetOutputTool() *OutputTool {
	if t == nil {
		return nil
	}
	return t.OutputTool
}

func (t *ToolsDeleteResponse) GetBashTool() *BashTool {
	if t == nil {
		return nil
	}
	return t.BashTool
}

func (t *ToolsDeleteResponse) GetComputerTool() *ComputerTool {
	if t == nil {
		return nil
	}
	return t.ComputerTool
}

func (t *ToolsDeleteResponse) GetTextEditorTool() *TextEditorTool {
	if t == nil {
		return nil
	}
	return t.TextEditorTool
}

func (t *ToolsDeleteResponse) GetQueryTool() *QueryTool {
	if t == nil {
		return nil
	}
	return t.QueryTool
}

func (t *ToolsDeleteResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCreateEventTool
}

func (t *ToolsDeleteResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if t == nil {
		return nil
	}
	return t.GoogleSheetsRowAppendTool
}

func (t *ToolsDeleteResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCheckAvailabilityTool
}

func (t *ToolsDeleteResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if t == nil {
		return nil
	}
	return t.SlackSendMessageTool
}

func (t *ToolsDeleteResponse) GetSmsTool() *SmsTool {
	if t == nil {
		return nil
	}
	return t.SmsTool
}

func (t *ToolsDeleteResponse) GetMcpTool() *McpTool {
	if t == nil {
		return nil
	}
	return t.McpTool
}

func (t *ToolsDeleteResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarAvailabilityTool
}

func (t *ToolsDeleteResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarEventCreateTool
}

func (t *ToolsDeleteResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactCreateTool
}

func (t *ToolsDeleteResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactGetTool
}

func (t *ToolsDeleteResponse) UnmarshalJSON(data []byte) error {
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		t.typ = "DtmfTool"
		t.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		t.typ = "EndCallTool"
		t.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		t.typ = "FunctionTool"
		t.FunctionTool = valueFunctionTool
		return nil
	}
	valueGhlTool := new(GhlTool)
	if err := json.Unmarshal(data, &valueGhlTool); err == nil {
		t.typ = "GhlTool"
		t.GhlTool = valueGhlTool
		return nil
	}
	valueMakeTool := new(MakeTool)
	if err := json.Unmarshal(data, &valueMakeTool); err == nil {
		t.typ = "MakeTool"
		t.MakeTool = valueMakeTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		t.typ = "TransferCallTool"
		t.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueOutputTool := new(OutputTool)
	if err := json.Unmarshal(data, &valueOutputTool); err == nil {
		t.typ = "OutputTool"
		t.OutputTool = valueOutputTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		t.typ = "BashTool"
		t.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		t.typ = "ComputerTool"
		t.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		t.typ = "TextEditorTool"
		t.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		t.typ = "QueryTool"
		t.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		t.typ = "GoogleCalendarCreateEventTool"
		t.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		t.typ = "GoogleSheetsRowAppendTool"
		t.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		t.typ = "GoogleCalendarCheckAvailabilityTool"
		t.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		t.typ = "SlackSendMessageTool"
		t.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		t.typ = "SmsTool"
		t.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		t.typ = "McpTool"
		t.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		t.typ = "GoHighLevelCalendarAvailabilityTool"
		t.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		t.typ = "GoHighLevelCalendarEventCreateTool"
		t.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		t.typ = "GoHighLevelContactCreateTool"
		t.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		t.typ = "GoHighLevelContactGetTool"
		t.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolsDeleteResponse) MarshalJSON() ([]byte, error) {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return json.Marshal(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return json.Marshal(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return json.Marshal(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return json.Marshal(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return json.Marshal(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return json.Marshal(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return json.Marshal(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return json.Marshal(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return json.Marshal(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return json.Marshal(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return json.Marshal(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return json.Marshal(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return json.Marshal(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return json.Marshal(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return json.Marshal(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return json.Marshal(t.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsDeleteResponseVisitor interface {
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitGhlTool(*GhlTool) error
	VisitMakeTool(*MakeTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitOutputTool(*OutputTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (t *ToolsDeleteResponse) Accept(visitor ToolsDeleteResponseVisitor) error {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return visitor.VisitDtmfTool(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return visitor.VisitEndCallTool(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return visitor.VisitFunctionTool(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return visitor.VisitGhlTool(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return visitor.VisitMakeTool(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return visitor.VisitOutputTool(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return visitor.VisitBashTool(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return visitor.VisitComputerTool(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return visitor.VisitQueryTool(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return visitor.VisitSmsTool(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return visitor.VisitMcpTool(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(t.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsGetResponse struct {
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	GhlTool                             *GhlTool
	MakeTool                            *MakeTool
	TransferCallTool                    *TransferCallTool
	OutputTool                          *OutputTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (t *ToolsGetResponse) GetDtmfTool() *DtmfTool {
	if t == nil {
		return nil
	}
	return t.DtmfTool
}

func (t *ToolsGetResponse) GetEndCallTool() *EndCallTool {
	if t == nil {
		return nil
	}
	return t.EndCallTool
}

func (t *ToolsGetResponse) GetFunctionTool() *FunctionTool {
	if t == nil {
		return nil
	}
	return t.FunctionTool
}

func (t *ToolsGetResponse) GetGhlTool() *GhlTool {
	if t == nil {
		return nil
	}
	return t.GhlTool
}

func (t *ToolsGetResponse) GetMakeTool() *MakeTool {
	if t == nil {
		return nil
	}
	return t.MakeTool
}

func (t *ToolsGetResponse) GetTransferCallTool() *TransferCallTool {
	if t == nil {
		return nil
	}
	return t.TransferCallTool
}

func (t *ToolsGetResponse) GetOutputTool() *OutputTool {
	if t == nil {
		return nil
	}
	return t.OutputTool
}

func (t *ToolsGetResponse) GetBashTool() *BashTool {
	if t == nil {
		return nil
	}
	return t.BashTool
}

func (t *ToolsGetResponse) GetComputerTool() *ComputerTool {
	if t == nil {
		return nil
	}
	return t.ComputerTool
}

func (t *ToolsGetResponse) GetTextEditorTool() *TextEditorTool {
	if t == nil {
		return nil
	}
	return t.TextEditorTool
}

func (t *ToolsGetResponse) GetQueryTool() *QueryTool {
	if t == nil {
		return nil
	}
	return t.QueryTool
}

func (t *ToolsGetResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCreateEventTool
}

func (t *ToolsGetResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if t == nil {
		return nil
	}
	return t.GoogleSheetsRowAppendTool
}

func (t *ToolsGetResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCheckAvailabilityTool
}

func (t *ToolsGetResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if t == nil {
		return nil
	}
	return t.SlackSendMessageTool
}

func (t *ToolsGetResponse) GetSmsTool() *SmsTool {
	if t == nil {
		return nil
	}
	return t.SmsTool
}

func (t *ToolsGetResponse) GetMcpTool() *McpTool {
	if t == nil {
		return nil
	}
	return t.McpTool
}

func (t *ToolsGetResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarAvailabilityTool
}

func (t *ToolsGetResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarEventCreateTool
}

func (t *ToolsGetResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactCreateTool
}

func (t *ToolsGetResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactGetTool
}

func (t *ToolsGetResponse) UnmarshalJSON(data []byte) error {
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		t.typ = "DtmfTool"
		t.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		t.typ = "EndCallTool"
		t.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		t.typ = "FunctionTool"
		t.FunctionTool = valueFunctionTool
		return nil
	}
	valueGhlTool := new(GhlTool)
	if err := json.Unmarshal(data, &valueGhlTool); err == nil {
		t.typ = "GhlTool"
		t.GhlTool = valueGhlTool
		return nil
	}
	valueMakeTool := new(MakeTool)
	if err := json.Unmarshal(data, &valueMakeTool); err == nil {
		t.typ = "MakeTool"
		t.MakeTool = valueMakeTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		t.typ = "TransferCallTool"
		t.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueOutputTool := new(OutputTool)
	if err := json.Unmarshal(data, &valueOutputTool); err == nil {
		t.typ = "OutputTool"
		t.OutputTool = valueOutputTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		t.typ = "BashTool"
		t.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		t.typ = "ComputerTool"
		t.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		t.typ = "TextEditorTool"
		t.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		t.typ = "QueryTool"
		t.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		t.typ = "GoogleCalendarCreateEventTool"
		t.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		t.typ = "GoogleSheetsRowAppendTool"
		t.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		t.typ = "GoogleCalendarCheckAvailabilityTool"
		t.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		t.typ = "SlackSendMessageTool"
		t.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		t.typ = "SmsTool"
		t.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		t.typ = "McpTool"
		t.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		t.typ = "GoHighLevelCalendarAvailabilityTool"
		t.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		t.typ = "GoHighLevelCalendarEventCreateTool"
		t.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		t.typ = "GoHighLevelContactCreateTool"
		t.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		t.typ = "GoHighLevelContactGetTool"
		t.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolsGetResponse) MarshalJSON() ([]byte, error) {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return json.Marshal(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return json.Marshal(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return json.Marshal(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return json.Marshal(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return json.Marshal(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return json.Marshal(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return json.Marshal(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return json.Marshal(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return json.Marshal(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return json.Marshal(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return json.Marshal(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return json.Marshal(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return json.Marshal(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return json.Marshal(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return json.Marshal(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return json.Marshal(t.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsGetResponseVisitor interface {
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitGhlTool(*GhlTool) error
	VisitMakeTool(*MakeTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitOutputTool(*OutputTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (t *ToolsGetResponse) Accept(visitor ToolsGetResponseVisitor) error {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return visitor.VisitDtmfTool(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return visitor.VisitEndCallTool(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return visitor.VisitFunctionTool(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return visitor.VisitGhlTool(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return visitor.VisitMakeTool(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return visitor.VisitOutputTool(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return visitor.VisitBashTool(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return visitor.VisitComputerTool(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return visitor.VisitQueryTool(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return visitor.VisitSmsTool(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return visitor.VisitMcpTool(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(t.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsListResponseItem struct {
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	GhlTool                             *GhlTool
	MakeTool                            *MakeTool
	TransferCallTool                    *TransferCallTool
	OutputTool                          *OutputTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (t *ToolsListResponseItem) GetDtmfTool() *DtmfTool {
	if t == nil {
		return nil
	}
	return t.DtmfTool
}

func (t *ToolsListResponseItem) GetEndCallTool() *EndCallTool {
	if t == nil {
		return nil
	}
	return t.EndCallTool
}

func (t *ToolsListResponseItem) GetFunctionTool() *FunctionTool {
	if t == nil {
		return nil
	}
	return t.FunctionTool
}

func (t *ToolsListResponseItem) GetGhlTool() *GhlTool {
	if t == nil {
		return nil
	}
	return t.GhlTool
}

func (t *ToolsListResponseItem) GetMakeTool() *MakeTool {
	if t == nil {
		return nil
	}
	return t.MakeTool
}

func (t *ToolsListResponseItem) GetTransferCallTool() *TransferCallTool {
	if t == nil {
		return nil
	}
	return t.TransferCallTool
}

func (t *ToolsListResponseItem) GetOutputTool() *OutputTool {
	if t == nil {
		return nil
	}
	return t.OutputTool
}

func (t *ToolsListResponseItem) GetBashTool() *BashTool {
	if t == nil {
		return nil
	}
	return t.BashTool
}

func (t *ToolsListResponseItem) GetComputerTool() *ComputerTool {
	if t == nil {
		return nil
	}
	return t.ComputerTool
}

func (t *ToolsListResponseItem) GetTextEditorTool() *TextEditorTool {
	if t == nil {
		return nil
	}
	return t.TextEditorTool
}

func (t *ToolsListResponseItem) GetQueryTool() *QueryTool {
	if t == nil {
		return nil
	}
	return t.QueryTool
}

func (t *ToolsListResponseItem) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCreateEventTool
}

func (t *ToolsListResponseItem) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if t == nil {
		return nil
	}
	return t.GoogleSheetsRowAppendTool
}

func (t *ToolsListResponseItem) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCheckAvailabilityTool
}

func (t *ToolsListResponseItem) GetSlackSendMessageTool() *SlackSendMessageTool {
	if t == nil {
		return nil
	}
	return t.SlackSendMessageTool
}

func (t *ToolsListResponseItem) GetSmsTool() *SmsTool {
	if t == nil {
		return nil
	}
	return t.SmsTool
}

func (t *ToolsListResponseItem) GetMcpTool() *McpTool {
	if t == nil {
		return nil
	}
	return t.McpTool
}

func (t *ToolsListResponseItem) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarAvailabilityTool
}

func (t *ToolsListResponseItem) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarEventCreateTool
}

func (t *ToolsListResponseItem) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactCreateTool
}

func (t *ToolsListResponseItem) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactGetTool
}

func (t *ToolsListResponseItem) UnmarshalJSON(data []byte) error {
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		t.typ = "DtmfTool"
		t.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		t.typ = "EndCallTool"
		t.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		t.typ = "FunctionTool"
		t.FunctionTool = valueFunctionTool
		return nil
	}
	valueGhlTool := new(GhlTool)
	if err := json.Unmarshal(data, &valueGhlTool); err == nil {
		t.typ = "GhlTool"
		t.GhlTool = valueGhlTool
		return nil
	}
	valueMakeTool := new(MakeTool)
	if err := json.Unmarshal(data, &valueMakeTool); err == nil {
		t.typ = "MakeTool"
		t.MakeTool = valueMakeTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		t.typ = "TransferCallTool"
		t.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueOutputTool := new(OutputTool)
	if err := json.Unmarshal(data, &valueOutputTool); err == nil {
		t.typ = "OutputTool"
		t.OutputTool = valueOutputTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		t.typ = "BashTool"
		t.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		t.typ = "ComputerTool"
		t.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		t.typ = "TextEditorTool"
		t.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		t.typ = "QueryTool"
		t.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		t.typ = "GoogleCalendarCreateEventTool"
		t.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		t.typ = "GoogleSheetsRowAppendTool"
		t.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		t.typ = "GoogleCalendarCheckAvailabilityTool"
		t.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		t.typ = "SlackSendMessageTool"
		t.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		t.typ = "SmsTool"
		t.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		t.typ = "McpTool"
		t.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		t.typ = "GoHighLevelCalendarAvailabilityTool"
		t.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		t.typ = "GoHighLevelCalendarEventCreateTool"
		t.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		t.typ = "GoHighLevelContactCreateTool"
		t.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		t.typ = "GoHighLevelContactGetTool"
		t.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolsListResponseItem) MarshalJSON() ([]byte, error) {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return json.Marshal(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return json.Marshal(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return json.Marshal(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return json.Marshal(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return json.Marshal(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return json.Marshal(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return json.Marshal(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return json.Marshal(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return json.Marshal(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return json.Marshal(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return json.Marshal(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return json.Marshal(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return json.Marshal(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return json.Marshal(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return json.Marshal(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return json.Marshal(t.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsListResponseItemVisitor interface {
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitGhlTool(*GhlTool) error
	VisitMakeTool(*MakeTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitOutputTool(*OutputTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (t *ToolsListResponseItem) Accept(visitor ToolsListResponseItemVisitor) error {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return visitor.VisitDtmfTool(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return visitor.VisitEndCallTool(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return visitor.VisitFunctionTool(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return visitor.VisitGhlTool(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return visitor.VisitMakeTool(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return visitor.VisitOutputTool(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return visitor.VisitBashTool(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return visitor.VisitComputerTool(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return visitor.VisitQueryTool(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return visitor.VisitSmsTool(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return visitor.VisitMcpTool(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(t.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsUpdateRequest struct {
	UpdateDtmfToolDto                            *UpdateDtmfToolDto
	UpdateEndCallToolDto                         *UpdateEndCallToolDto
	UpdateFunctionToolDto                        *UpdateFunctionToolDto
	UpdateGhlToolDto                             *UpdateGhlToolDto
	UpdateMakeToolDto                            *UpdateMakeToolDto
	UpdateTransferCallToolDto                    *UpdateTransferCallToolDto
	UpdateOutputToolDto                          *UpdateOutputToolDto
	UpdateBashToolDto                            *UpdateBashToolDto
	UpdateComputerToolDto                        *UpdateComputerToolDto
	UpdateTextEditorToolDto                      *UpdateTextEditorToolDto
	UpdateQueryToolDto                           *UpdateQueryToolDto
	UpdateGoogleCalendarCreateEventToolDto       *UpdateGoogleCalendarCreateEventToolDto
	UpdateGoogleSheetsRowAppendToolDto           *UpdateGoogleSheetsRowAppendToolDto
	UpdateGoogleCalendarCheckAvailabilityToolDto *UpdateGoogleCalendarCheckAvailabilityToolDto
	UpdateSlackSendMessageToolDto                *UpdateSlackSendMessageToolDto
	UpdateSmsToolDto                             *UpdateSmsToolDto
	UpdateMcpToolDto                             *UpdateMcpToolDto
	UpdateGoHighLevelCalendarAvailabilityToolDto *UpdateGoHighLevelCalendarAvailabilityToolDto
	UpdateGoHighLevelCalendarEventCreateToolDto  *UpdateGoHighLevelCalendarEventCreateToolDto
	UpdateGoHighLevelContactCreateToolDto        *UpdateGoHighLevelContactCreateToolDto
	UpdateGoHighLevelContactGetToolDto           *UpdateGoHighLevelContactGetToolDto

	typ string
}

func (t *ToolsUpdateRequest) GetUpdateDtmfToolDto() *UpdateDtmfToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateDtmfToolDto
}

func (t *ToolsUpdateRequest) GetUpdateEndCallToolDto() *UpdateEndCallToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateEndCallToolDto
}

func (t *ToolsUpdateRequest) GetUpdateFunctionToolDto() *UpdateFunctionToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateFunctionToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGhlToolDto() *UpdateGhlToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGhlToolDto
}

func (t *ToolsUpdateRequest) GetUpdateMakeToolDto() *UpdateMakeToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateMakeToolDto
}

func (t *ToolsUpdateRequest) GetUpdateTransferCallToolDto() *UpdateTransferCallToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateTransferCallToolDto
}

func (t *ToolsUpdateRequest) GetUpdateOutputToolDto() *UpdateOutputToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateOutputToolDto
}

func (t *ToolsUpdateRequest) GetUpdateBashToolDto() *UpdateBashToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateBashToolDto
}

func (t *ToolsUpdateRequest) GetUpdateComputerToolDto() *UpdateComputerToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateComputerToolDto
}

func (t *ToolsUpdateRequest) GetUpdateTextEditorToolDto() *UpdateTextEditorToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateTextEditorToolDto
}

func (t *ToolsUpdateRequest) GetUpdateQueryToolDto() *UpdateQueryToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateQueryToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGoogleCalendarCreateEventToolDto() *UpdateGoogleCalendarCreateEventToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGoogleCalendarCreateEventToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGoogleSheetsRowAppendToolDto() *UpdateGoogleSheetsRowAppendToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGoogleSheetsRowAppendToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGoogleCalendarCheckAvailabilityToolDto() *UpdateGoogleCalendarCheckAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGoogleCalendarCheckAvailabilityToolDto
}

func (t *ToolsUpdateRequest) GetUpdateSlackSendMessageToolDto() *UpdateSlackSendMessageToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateSlackSendMessageToolDto
}

func (t *ToolsUpdateRequest) GetUpdateSmsToolDto() *UpdateSmsToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateSmsToolDto
}

func (t *ToolsUpdateRequest) GetUpdateMcpToolDto() *UpdateMcpToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateMcpToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGoHighLevelCalendarAvailabilityToolDto() *UpdateGoHighLevelCalendarAvailabilityToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGoHighLevelCalendarAvailabilityToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGoHighLevelCalendarEventCreateToolDto() *UpdateGoHighLevelCalendarEventCreateToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGoHighLevelCalendarEventCreateToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGoHighLevelContactCreateToolDto() *UpdateGoHighLevelContactCreateToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGoHighLevelContactCreateToolDto
}

func (t *ToolsUpdateRequest) GetUpdateGoHighLevelContactGetToolDto() *UpdateGoHighLevelContactGetToolDto {
	if t == nil {
		return nil
	}
	return t.UpdateGoHighLevelContactGetToolDto
}

func (t *ToolsUpdateRequest) UnmarshalJSON(data []byte) error {
	valueUpdateDtmfToolDto := new(UpdateDtmfToolDto)
	if err := json.Unmarshal(data, &valueUpdateDtmfToolDto); err == nil {
		t.typ = "UpdateDtmfToolDto"
		t.UpdateDtmfToolDto = valueUpdateDtmfToolDto
		return nil
	}
	valueUpdateEndCallToolDto := new(UpdateEndCallToolDto)
	if err := json.Unmarshal(data, &valueUpdateEndCallToolDto); err == nil {
		t.typ = "UpdateEndCallToolDto"
		t.UpdateEndCallToolDto = valueUpdateEndCallToolDto
		return nil
	}
	valueUpdateFunctionToolDto := new(UpdateFunctionToolDto)
	if err := json.Unmarshal(data, &valueUpdateFunctionToolDto); err == nil {
		t.typ = "UpdateFunctionToolDto"
		t.UpdateFunctionToolDto = valueUpdateFunctionToolDto
		return nil
	}
	valueUpdateGhlToolDto := new(UpdateGhlToolDto)
	if err := json.Unmarshal(data, &valueUpdateGhlToolDto); err == nil {
		t.typ = "UpdateGhlToolDto"
		t.UpdateGhlToolDto = valueUpdateGhlToolDto
		return nil
	}
	valueUpdateMakeToolDto := new(UpdateMakeToolDto)
	if err := json.Unmarshal(data, &valueUpdateMakeToolDto); err == nil {
		t.typ = "UpdateMakeToolDto"
		t.UpdateMakeToolDto = valueUpdateMakeToolDto
		return nil
	}
	valueUpdateTransferCallToolDto := new(UpdateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueUpdateTransferCallToolDto); err == nil {
		t.typ = "UpdateTransferCallToolDto"
		t.UpdateTransferCallToolDto = valueUpdateTransferCallToolDto
		return nil
	}
	valueUpdateOutputToolDto := new(UpdateOutputToolDto)
	if err := json.Unmarshal(data, &valueUpdateOutputToolDto); err == nil {
		t.typ = "UpdateOutputToolDto"
		t.UpdateOutputToolDto = valueUpdateOutputToolDto
		return nil
	}
	valueUpdateBashToolDto := new(UpdateBashToolDto)
	if err := json.Unmarshal(data, &valueUpdateBashToolDto); err == nil {
		t.typ = "UpdateBashToolDto"
		t.UpdateBashToolDto = valueUpdateBashToolDto
		return nil
	}
	valueUpdateComputerToolDto := new(UpdateComputerToolDto)
	if err := json.Unmarshal(data, &valueUpdateComputerToolDto); err == nil {
		t.typ = "UpdateComputerToolDto"
		t.UpdateComputerToolDto = valueUpdateComputerToolDto
		return nil
	}
	valueUpdateTextEditorToolDto := new(UpdateTextEditorToolDto)
	if err := json.Unmarshal(data, &valueUpdateTextEditorToolDto); err == nil {
		t.typ = "UpdateTextEditorToolDto"
		t.UpdateTextEditorToolDto = valueUpdateTextEditorToolDto
		return nil
	}
	valueUpdateQueryToolDto := new(UpdateQueryToolDto)
	if err := json.Unmarshal(data, &valueUpdateQueryToolDto); err == nil {
		t.typ = "UpdateQueryToolDto"
		t.UpdateQueryToolDto = valueUpdateQueryToolDto
		return nil
	}
	valueUpdateGoogleCalendarCreateEventToolDto := new(UpdateGoogleCalendarCreateEventToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoogleCalendarCreateEventToolDto); err == nil {
		t.typ = "UpdateGoogleCalendarCreateEventToolDto"
		t.UpdateGoogleCalendarCreateEventToolDto = valueUpdateGoogleCalendarCreateEventToolDto
		return nil
	}
	valueUpdateGoogleSheetsRowAppendToolDto := new(UpdateGoogleSheetsRowAppendToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoogleSheetsRowAppendToolDto); err == nil {
		t.typ = "UpdateGoogleSheetsRowAppendToolDto"
		t.UpdateGoogleSheetsRowAppendToolDto = valueUpdateGoogleSheetsRowAppendToolDto
		return nil
	}
	valueUpdateGoogleCalendarCheckAvailabilityToolDto := new(UpdateGoogleCalendarCheckAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoogleCalendarCheckAvailabilityToolDto); err == nil {
		t.typ = "UpdateGoogleCalendarCheckAvailabilityToolDto"
		t.UpdateGoogleCalendarCheckAvailabilityToolDto = valueUpdateGoogleCalendarCheckAvailabilityToolDto
		return nil
	}
	valueUpdateSlackSendMessageToolDto := new(UpdateSlackSendMessageToolDto)
	if err := json.Unmarshal(data, &valueUpdateSlackSendMessageToolDto); err == nil {
		t.typ = "UpdateSlackSendMessageToolDto"
		t.UpdateSlackSendMessageToolDto = valueUpdateSlackSendMessageToolDto
		return nil
	}
	valueUpdateSmsToolDto := new(UpdateSmsToolDto)
	if err := json.Unmarshal(data, &valueUpdateSmsToolDto); err == nil {
		t.typ = "UpdateSmsToolDto"
		t.UpdateSmsToolDto = valueUpdateSmsToolDto
		return nil
	}
	valueUpdateMcpToolDto := new(UpdateMcpToolDto)
	if err := json.Unmarshal(data, &valueUpdateMcpToolDto); err == nil {
		t.typ = "UpdateMcpToolDto"
		t.UpdateMcpToolDto = valueUpdateMcpToolDto
		return nil
	}
	valueUpdateGoHighLevelCalendarAvailabilityToolDto := new(UpdateGoHighLevelCalendarAvailabilityToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelCalendarAvailabilityToolDto); err == nil {
		t.typ = "UpdateGoHighLevelCalendarAvailabilityToolDto"
		t.UpdateGoHighLevelCalendarAvailabilityToolDto = valueUpdateGoHighLevelCalendarAvailabilityToolDto
		return nil
	}
	valueUpdateGoHighLevelCalendarEventCreateToolDto := new(UpdateGoHighLevelCalendarEventCreateToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelCalendarEventCreateToolDto); err == nil {
		t.typ = "UpdateGoHighLevelCalendarEventCreateToolDto"
		t.UpdateGoHighLevelCalendarEventCreateToolDto = valueUpdateGoHighLevelCalendarEventCreateToolDto
		return nil
	}
	valueUpdateGoHighLevelContactCreateToolDto := new(UpdateGoHighLevelContactCreateToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelContactCreateToolDto); err == nil {
		t.typ = "UpdateGoHighLevelContactCreateToolDto"
		t.UpdateGoHighLevelContactCreateToolDto = valueUpdateGoHighLevelContactCreateToolDto
		return nil
	}
	valueUpdateGoHighLevelContactGetToolDto := new(UpdateGoHighLevelContactGetToolDto)
	if err := json.Unmarshal(data, &valueUpdateGoHighLevelContactGetToolDto); err == nil {
		t.typ = "UpdateGoHighLevelContactGetToolDto"
		t.UpdateGoHighLevelContactGetToolDto = valueUpdateGoHighLevelContactGetToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolsUpdateRequest) MarshalJSON() ([]byte, error) {
	if t.typ == "UpdateDtmfToolDto" || t.UpdateDtmfToolDto != nil {
		return json.Marshal(t.UpdateDtmfToolDto)
	}
	if t.typ == "UpdateEndCallToolDto" || t.UpdateEndCallToolDto != nil {
		return json.Marshal(t.UpdateEndCallToolDto)
	}
	if t.typ == "UpdateFunctionToolDto" || t.UpdateFunctionToolDto != nil {
		return json.Marshal(t.UpdateFunctionToolDto)
	}
	if t.typ == "UpdateGhlToolDto" || t.UpdateGhlToolDto != nil {
		return json.Marshal(t.UpdateGhlToolDto)
	}
	if t.typ == "UpdateMakeToolDto" || t.UpdateMakeToolDto != nil {
		return json.Marshal(t.UpdateMakeToolDto)
	}
	if t.typ == "UpdateTransferCallToolDto" || t.UpdateTransferCallToolDto != nil {
		return json.Marshal(t.UpdateTransferCallToolDto)
	}
	if t.typ == "UpdateOutputToolDto" || t.UpdateOutputToolDto != nil {
		return json.Marshal(t.UpdateOutputToolDto)
	}
	if t.typ == "UpdateBashToolDto" || t.UpdateBashToolDto != nil {
		return json.Marshal(t.UpdateBashToolDto)
	}
	if t.typ == "UpdateComputerToolDto" || t.UpdateComputerToolDto != nil {
		return json.Marshal(t.UpdateComputerToolDto)
	}
	if t.typ == "UpdateTextEditorToolDto" || t.UpdateTextEditorToolDto != nil {
		return json.Marshal(t.UpdateTextEditorToolDto)
	}
	if t.typ == "UpdateQueryToolDto" || t.UpdateQueryToolDto != nil {
		return json.Marshal(t.UpdateQueryToolDto)
	}
	if t.typ == "UpdateGoogleCalendarCreateEventToolDto" || t.UpdateGoogleCalendarCreateEventToolDto != nil {
		return json.Marshal(t.UpdateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "UpdateGoogleSheetsRowAppendToolDto" || t.UpdateGoogleSheetsRowAppendToolDto != nil {
		return json.Marshal(t.UpdateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "UpdateGoogleCalendarCheckAvailabilityToolDto" || t.UpdateGoogleCalendarCheckAvailabilityToolDto != nil {
		return json.Marshal(t.UpdateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "UpdateSlackSendMessageToolDto" || t.UpdateSlackSendMessageToolDto != nil {
		return json.Marshal(t.UpdateSlackSendMessageToolDto)
	}
	if t.typ == "UpdateSmsToolDto" || t.UpdateSmsToolDto != nil {
		return json.Marshal(t.UpdateSmsToolDto)
	}
	if t.typ == "UpdateMcpToolDto" || t.UpdateMcpToolDto != nil {
		return json.Marshal(t.UpdateMcpToolDto)
	}
	if t.typ == "UpdateGoHighLevelCalendarAvailabilityToolDto" || t.UpdateGoHighLevelCalendarAvailabilityToolDto != nil {
		return json.Marshal(t.UpdateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "UpdateGoHighLevelCalendarEventCreateToolDto" || t.UpdateGoHighLevelCalendarEventCreateToolDto != nil {
		return json.Marshal(t.UpdateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "UpdateGoHighLevelContactCreateToolDto" || t.UpdateGoHighLevelContactCreateToolDto != nil {
		return json.Marshal(t.UpdateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "UpdateGoHighLevelContactGetToolDto" || t.UpdateGoHighLevelContactGetToolDto != nil {
		return json.Marshal(t.UpdateGoHighLevelContactGetToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsUpdateRequestVisitor interface {
	VisitUpdateDtmfToolDto(*UpdateDtmfToolDto) error
	VisitUpdateEndCallToolDto(*UpdateEndCallToolDto) error
	VisitUpdateFunctionToolDto(*UpdateFunctionToolDto) error
	VisitUpdateGhlToolDto(*UpdateGhlToolDto) error
	VisitUpdateMakeToolDto(*UpdateMakeToolDto) error
	VisitUpdateTransferCallToolDto(*UpdateTransferCallToolDto) error
	VisitUpdateOutputToolDto(*UpdateOutputToolDto) error
	VisitUpdateBashToolDto(*UpdateBashToolDto) error
	VisitUpdateComputerToolDto(*UpdateComputerToolDto) error
	VisitUpdateTextEditorToolDto(*UpdateTextEditorToolDto) error
	VisitUpdateQueryToolDto(*UpdateQueryToolDto) error
	VisitUpdateGoogleCalendarCreateEventToolDto(*UpdateGoogleCalendarCreateEventToolDto) error
	VisitUpdateGoogleSheetsRowAppendToolDto(*UpdateGoogleSheetsRowAppendToolDto) error
	VisitUpdateGoogleCalendarCheckAvailabilityToolDto(*UpdateGoogleCalendarCheckAvailabilityToolDto) error
	VisitUpdateSlackSendMessageToolDto(*UpdateSlackSendMessageToolDto) error
	VisitUpdateSmsToolDto(*UpdateSmsToolDto) error
	VisitUpdateMcpToolDto(*UpdateMcpToolDto) error
	VisitUpdateGoHighLevelCalendarAvailabilityToolDto(*UpdateGoHighLevelCalendarAvailabilityToolDto) error
	VisitUpdateGoHighLevelCalendarEventCreateToolDto(*UpdateGoHighLevelCalendarEventCreateToolDto) error
	VisitUpdateGoHighLevelContactCreateToolDto(*UpdateGoHighLevelContactCreateToolDto) error
	VisitUpdateGoHighLevelContactGetToolDto(*UpdateGoHighLevelContactGetToolDto) error
}

func (t *ToolsUpdateRequest) Accept(visitor ToolsUpdateRequestVisitor) error {
	if t.typ == "UpdateDtmfToolDto" || t.UpdateDtmfToolDto != nil {
		return visitor.VisitUpdateDtmfToolDto(t.UpdateDtmfToolDto)
	}
	if t.typ == "UpdateEndCallToolDto" || t.UpdateEndCallToolDto != nil {
		return visitor.VisitUpdateEndCallToolDto(t.UpdateEndCallToolDto)
	}
	if t.typ == "UpdateFunctionToolDto" || t.UpdateFunctionToolDto != nil {
		return visitor.VisitUpdateFunctionToolDto(t.UpdateFunctionToolDto)
	}
	if t.typ == "UpdateGhlToolDto" || t.UpdateGhlToolDto != nil {
		return visitor.VisitUpdateGhlToolDto(t.UpdateGhlToolDto)
	}
	if t.typ == "UpdateMakeToolDto" || t.UpdateMakeToolDto != nil {
		return visitor.VisitUpdateMakeToolDto(t.UpdateMakeToolDto)
	}
	if t.typ == "UpdateTransferCallToolDto" || t.UpdateTransferCallToolDto != nil {
		return visitor.VisitUpdateTransferCallToolDto(t.UpdateTransferCallToolDto)
	}
	if t.typ == "UpdateOutputToolDto" || t.UpdateOutputToolDto != nil {
		return visitor.VisitUpdateOutputToolDto(t.UpdateOutputToolDto)
	}
	if t.typ == "UpdateBashToolDto" || t.UpdateBashToolDto != nil {
		return visitor.VisitUpdateBashToolDto(t.UpdateBashToolDto)
	}
	if t.typ == "UpdateComputerToolDto" || t.UpdateComputerToolDto != nil {
		return visitor.VisitUpdateComputerToolDto(t.UpdateComputerToolDto)
	}
	if t.typ == "UpdateTextEditorToolDto" || t.UpdateTextEditorToolDto != nil {
		return visitor.VisitUpdateTextEditorToolDto(t.UpdateTextEditorToolDto)
	}
	if t.typ == "UpdateQueryToolDto" || t.UpdateQueryToolDto != nil {
		return visitor.VisitUpdateQueryToolDto(t.UpdateQueryToolDto)
	}
	if t.typ == "UpdateGoogleCalendarCreateEventToolDto" || t.UpdateGoogleCalendarCreateEventToolDto != nil {
		return visitor.VisitUpdateGoogleCalendarCreateEventToolDto(t.UpdateGoogleCalendarCreateEventToolDto)
	}
	if t.typ == "UpdateGoogleSheetsRowAppendToolDto" || t.UpdateGoogleSheetsRowAppendToolDto != nil {
		return visitor.VisitUpdateGoogleSheetsRowAppendToolDto(t.UpdateGoogleSheetsRowAppendToolDto)
	}
	if t.typ == "UpdateGoogleCalendarCheckAvailabilityToolDto" || t.UpdateGoogleCalendarCheckAvailabilityToolDto != nil {
		return visitor.VisitUpdateGoogleCalendarCheckAvailabilityToolDto(t.UpdateGoogleCalendarCheckAvailabilityToolDto)
	}
	if t.typ == "UpdateSlackSendMessageToolDto" || t.UpdateSlackSendMessageToolDto != nil {
		return visitor.VisitUpdateSlackSendMessageToolDto(t.UpdateSlackSendMessageToolDto)
	}
	if t.typ == "UpdateSmsToolDto" || t.UpdateSmsToolDto != nil {
		return visitor.VisitUpdateSmsToolDto(t.UpdateSmsToolDto)
	}
	if t.typ == "UpdateMcpToolDto" || t.UpdateMcpToolDto != nil {
		return visitor.VisitUpdateMcpToolDto(t.UpdateMcpToolDto)
	}
	if t.typ == "UpdateGoHighLevelCalendarAvailabilityToolDto" || t.UpdateGoHighLevelCalendarAvailabilityToolDto != nil {
		return visitor.VisitUpdateGoHighLevelCalendarAvailabilityToolDto(t.UpdateGoHighLevelCalendarAvailabilityToolDto)
	}
	if t.typ == "UpdateGoHighLevelCalendarEventCreateToolDto" || t.UpdateGoHighLevelCalendarEventCreateToolDto != nil {
		return visitor.VisitUpdateGoHighLevelCalendarEventCreateToolDto(t.UpdateGoHighLevelCalendarEventCreateToolDto)
	}
	if t.typ == "UpdateGoHighLevelContactCreateToolDto" || t.UpdateGoHighLevelContactCreateToolDto != nil {
		return visitor.VisitUpdateGoHighLevelContactCreateToolDto(t.UpdateGoHighLevelContactCreateToolDto)
	}
	if t.typ == "UpdateGoHighLevelContactGetToolDto" || t.UpdateGoHighLevelContactGetToolDto != nil {
		return visitor.VisitUpdateGoHighLevelContactGetToolDto(t.UpdateGoHighLevelContactGetToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsUpdateResponse struct {
	DtmfTool                            *DtmfTool
	EndCallTool                         *EndCallTool
	FunctionTool                        *FunctionTool
	GhlTool                             *GhlTool
	MakeTool                            *MakeTool
	TransferCallTool                    *TransferCallTool
	OutputTool                          *OutputTool
	BashTool                            *BashTool
	ComputerTool                        *ComputerTool
	TextEditorTool                      *TextEditorTool
	QueryTool                           *QueryTool
	GoogleCalendarCreateEventTool       *GoogleCalendarCreateEventTool
	GoogleSheetsRowAppendTool           *GoogleSheetsRowAppendTool
	GoogleCalendarCheckAvailabilityTool *GoogleCalendarCheckAvailabilityTool
	SlackSendMessageTool                *SlackSendMessageTool
	SmsTool                             *SmsTool
	McpTool                             *McpTool
	GoHighLevelCalendarAvailabilityTool *GoHighLevelCalendarAvailabilityTool
	GoHighLevelCalendarEventCreateTool  *GoHighLevelCalendarEventCreateTool
	GoHighLevelContactCreateTool        *GoHighLevelContactCreateTool
	GoHighLevelContactGetTool           *GoHighLevelContactGetTool

	typ string
}

func (t *ToolsUpdateResponse) GetDtmfTool() *DtmfTool {
	if t == nil {
		return nil
	}
	return t.DtmfTool
}

func (t *ToolsUpdateResponse) GetEndCallTool() *EndCallTool {
	if t == nil {
		return nil
	}
	return t.EndCallTool
}

func (t *ToolsUpdateResponse) GetFunctionTool() *FunctionTool {
	if t == nil {
		return nil
	}
	return t.FunctionTool
}

func (t *ToolsUpdateResponse) GetGhlTool() *GhlTool {
	if t == nil {
		return nil
	}
	return t.GhlTool
}

func (t *ToolsUpdateResponse) GetMakeTool() *MakeTool {
	if t == nil {
		return nil
	}
	return t.MakeTool
}

func (t *ToolsUpdateResponse) GetTransferCallTool() *TransferCallTool {
	if t == nil {
		return nil
	}
	return t.TransferCallTool
}

func (t *ToolsUpdateResponse) GetOutputTool() *OutputTool {
	if t == nil {
		return nil
	}
	return t.OutputTool
}

func (t *ToolsUpdateResponse) GetBashTool() *BashTool {
	if t == nil {
		return nil
	}
	return t.BashTool
}

func (t *ToolsUpdateResponse) GetComputerTool() *ComputerTool {
	if t == nil {
		return nil
	}
	return t.ComputerTool
}

func (t *ToolsUpdateResponse) GetTextEditorTool() *TextEditorTool {
	if t == nil {
		return nil
	}
	return t.TextEditorTool
}

func (t *ToolsUpdateResponse) GetQueryTool() *QueryTool {
	if t == nil {
		return nil
	}
	return t.QueryTool
}

func (t *ToolsUpdateResponse) GetGoogleCalendarCreateEventTool() *GoogleCalendarCreateEventTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCreateEventTool
}

func (t *ToolsUpdateResponse) GetGoogleSheetsRowAppendTool() *GoogleSheetsRowAppendTool {
	if t == nil {
		return nil
	}
	return t.GoogleSheetsRowAppendTool
}

func (t *ToolsUpdateResponse) GetGoogleCalendarCheckAvailabilityTool() *GoogleCalendarCheckAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoogleCalendarCheckAvailabilityTool
}

func (t *ToolsUpdateResponse) GetSlackSendMessageTool() *SlackSendMessageTool {
	if t == nil {
		return nil
	}
	return t.SlackSendMessageTool
}

func (t *ToolsUpdateResponse) GetSmsTool() *SmsTool {
	if t == nil {
		return nil
	}
	return t.SmsTool
}

func (t *ToolsUpdateResponse) GetMcpTool() *McpTool {
	if t == nil {
		return nil
	}
	return t.McpTool
}

func (t *ToolsUpdateResponse) GetGoHighLevelCalendarAvailabilityTool() *GoHighLevelCalendarAvailabilityTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarAvailabilityTool
}

func (t *ToolsUpdateResponse) GetGoHighLevelCalendarEventCreateTool() *GoHighLevelCalendarEventCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelCalendarEventCreateTool
}

func (t *ToolsUpdateResponse) GetGoHighLevelContactCreateTool() *GoHighLevelContactCreateTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactCreateTool
}

func (t *ToolsUpdateResponse) GetGoHighLevelContactGetTool() *GoHighLevelContactGetTool {
	if t == nil {
		return nil
	}
	return t.GoHighLevelContactGetTool
}

func (t *ToolsUpdateResponse) UnmarshalJSON(data []byte) error {
	valueDtmfTool := new(DtmfTool)
	if err := json.Unmarshal(data, &valueDtmfTool); err == nil {
		t.typ = "DtmfTool"
		t.DtmfTool = valueDtmfTool
		return nil
	}
	valueEndCallTool := new(EndCallTool)
	if err := json.Unmarshal(data, &valueEndCallTool); err == nil {
		t.typ = "EndCallTool"
		t.EndCallTool = valueEndCallTool
		return nil
	}
	valueFunctionTool := new(FunctionTool)
	if err := json.Unmarshal(data, &valueFunctionTool); err == nil {
		t.typ = "FunctionTool"
		t.FunctionTool = valueFunctionTool
		return nil
	}
	valueGhlTool := new(GhlTool)
	if err := json.Unmarshal(data, &valueGhlTool); err == nil {
		t.typ = "GhlTool"
		t.GhlTool = valueGhlTool
		return nil
	}
	valueMakeTool := new(MakeTool)
	if err := json.Unmarshal(data, &valueMakeTool); err == nil {
		t.typ = "MakeTool"
		t.MakeTool = valueMakeTool
		return nil
	}
	valueTransferCallTool := new(TransferCallTool)
	if err := json.Unmarshal(data, &valueTransferCallTool); err == nil {
		t.typ = "TransferCallTool"
		t.TransferCallTool = valueTransferCallTool
		return nil
	}
	valueOutputTool := new(OutputTool)
	if err := json.Unmarshal(data, &valueOutputTool); err == nil {
		t.typ = "OutputTool"
		t.OutputTool = valueOutputTool
		return nil
	}
	valueBashTool := new(BashTool)
	if err := json.Unmarshal(data, &valueBashTool); err == nil {
		t.typ = "BashTool"
		t.BashTool = valueBashTool
		return nil
	}
	valueComputerTool := new(ComputerTool)
	if err := json.Unmarshal(data, &valueComputerTool); err == nil {
		t.typ = "ComputerTool"
		t.ComputerTool = valueComputerTool
		return nil
	}
	valueTextEditorTool := new(TextEditorTool)
	if err := json.Unmarshal(data, &valueTextEditorTool); err == nil {
		t.typ = "TextEditorTool"
		t.TextEditorTool = valueTextEditorTool
		return nil
	}
	valueQueryTool := new(QueryTool)
	if err := json.Unmarshal(data, &valueQueryTool); err == nil {
		t.typ = "QueryTool"
		t.QueryTool = valueQueryTool
		return nil
	}
	valueGoogleCalendarCreateEventTool := new(GoogleCalendarCreateEventTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCreateEventTool); err == nil {
		t.typ = "GoogleCalendarCreateEventTool"
		t.GoogleCalendarCreateEventTool = valueGoogleCalendarCreateEventTool
		return nil
	}
	valueGoogleSheetsRowAppendTool := new(GoogleSheetsRowAppendTool)
	if err := json.Unmarshal(data, &valueGoogleSheetsRowAppendTool); err == nil {
		t.typ = "GoogleSheetsRowAppendTool"
		t.GoogleSheetsRowAppendTool = valueGoogleSheetsRowAppendTool
		return nil
	}
	valueGoogleCalendarCheckAvailabilityTool := new(GoogleCalendarCheckAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoogleCalendarCheckAvailabilityTool); err == nil {
		t.typ = "GoogleCalendarCheckAvailabilityTool"
		t.GoogleCalendarCheckAvailabilityTool = valueGoogleCalendarCheckAvailabilityTool
		return nil
	}
	valueSlackSendMessageTool := new(SlackSendMessageTool)
	if err := json.Unmarshal(data, &valueSlackSendMessageTool); err == nil {
		t.typ = "SlackSendMessageTool"
		t.SlackSendMessageTool = valueSlackSendMessageTool
		return nil
	}
	valueSmsTool := new(SmsTool)
	if err := json.Unmarshal(data, &valueSmsTool); err == nil {
		t.typ = "SmsTool"
		t.SmsTool = valueSmsTool
		return nil
	}
	valueMcpTool := new(McpTool)
	if err := json.Unmarshal(data, &valueMcpTool); err == nil {
		t.typ = "McpTool"
		t.McpTool = valueMcpTool
		return nil
	}
	valueGoHighLevelCalendarAvailabilityTool := new(GoHighLevelCalendarAvailabilityTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarAvailabilityTool); err == nil {
		t.typ = "GoHighLevelCalendarAvailabilityTool"
		t.GoHighLevelCalendarAvailabilityTool = valueGoHighLevelCalendarAvailabilityTool
		return nil
	}
	valueGoHighLevelCalendarEventCreateTool := new(GoHighLevelCalendarEventCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelCalendarEventCreateTool); err == nil {
		t.typ = "GoHighLevelCalendarEventCreateTool"
		t.GoHighLevelCalendarEventCreateTool = valueGoHighLevelCalendarEventCreateTool
		return nil
	}
	valueGoHighLevelContactCreateTool := new(GoHighLevelContactCreateTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactCreateTool); err == nil {
		t.typ = "GoHighLevelContactCreateTool"
		t.GoHighLevelContactCreateTool = valueGoHighLevelContactCreateTool
		return nil
	}
	valueGoHighLevelContactGetTool := new(GoHighLevelContactGetTool)
	if err := json.Unmarshal(data, &valueGoHighLevelContactGetTool); err == nil {
		t.typ = "GoHighLevelContactGetTool"
		t.GoHighLevelContactGetTool = valueGoHighLevelContactGetTool
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolsUpdateResponse) MarshalJSON() ([]byte, error) {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return json.Marshal(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return json.Marshal(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return json.Marshal(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return json.Marshal(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return json.Marshal(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return json.Marshal(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return json.Marshal(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return json.Marshal(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return json.Marshal(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return json.Marshal(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return json.Marshal(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return json.Marshal(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return json.Marshal(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return json.Marshal(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return json.Marshal(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return json.Marshal(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return json.Marshal(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return json.Marshal(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return json.Marshal(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return json.Marshal(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return json.Marshal(t.GoHighLevelContactGetTool)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolsUpdateResponseVisitor interface {
	VisitDtmfTool(*DtmfTool) error
	VisitEndCallTool(*EndCallTool) error
	VisitFunctionTool(*FunctionTool) error
	VisitGhlTool(*GhlTool) error
	VisitMakeTool(*MakeTool) error
	VisitTransferCallTool(*TransferCallTool) error
	VisitOutputTool(*OutputTool) error
	VisitBashTool(*BashTool) error
	VisitComputerTool(*ComputerTool) error
	VisitTextEditorTool(*TextEditorTool) error
	VisitQueryTool(*QueryTool) error
	VisitGoogleCalendarCreateEventTool(*GoogleCalendarCreateEventTool) error
	VisitGoogleSheetsRowAppendTool(*GoogleSheetsRowAppendTool) error
	VisitGoogleCalendarCheckAvailabilityTool(*GoogleCalendarCheckAvailabilityTool) error
	VisitSlackSendMessageTool(*SlackSendMessageTool) error
	VisitSmsTool(*SmsTool) error
	VisitMcpTool(*McpTool) error
	VisitGoHighLevelCalendarAvailabilityTool(*GoHighLevelCalendarAvailabilityTool) error
	VisitGoHighLevelCalendarEventCreateTool(*GoHighLevelCalendarEventCreateTool) error
	VisitGoHighLevelContactCreateTool(*GoHighLevelContactCreateTool) error
	VisitGoHighLevelContactGetTool(*GoHighLevelContactGetTool) error
}

func (t *ToolsUpdateResponse) Accept(visitor ToolsUpdateResponseVisitor) error {
	if t.typ == "DtmfTool" || t.DtmfTool != nil {
		return visitor.VisitDtmfTool(t.DtmfTool)
	}
	if t.typ == "EndCallTool" || t.EndCallTool != nil {
		return visitor.VisitEndCallTool(t.EndCallTool)
	}
	if t.typ == "FunctionTool" || t.FunctionTool != nil {
		return visitor.VisitFunctionTool(t.FunctionTool)
	}
	if t.typ == "GhlTool" || t.GhlTool != nil {
		return visitor.VisitGhlTool(t.GhlTool)
	}
	if t.typ == "MakeTool" || t.MakeTool != nil {
		return visitor.VisitMakeTool(t.MakeTool)
	}
	if t.typ == "TransferCallTool" || t.TransferCallTool != nil {
		return visitor.VisitTransferCallTool(t.TransferCallTool)
	}
	if t.typ == "OutputTool" || t.OutputTool != nil {
		return visitor.VisitOutputTool(t.OutputTool)
	}
	if t.typ == "BashTool" || t.BashTool != nil {
		return visitor.VisitBashTool(t.BashTool)
	}
	if t.typ == "ComputerTool" || t.ComputerTool != nil {
		return visitor.VisitComputerTool(t.ComputerTool)
	}
	if t.typ == "TextEditorTool" || t.TextEditorTool != nil {
		return visitor.VisitTextEditorTool(t.TextEditorTool)
	}
	if t.typ == "QueryTool" || t.QueryTool != nil {
		return visitor.VisitQueryTool(t.QueryTool)
	}
	if t.typ == "GoogleCalendarCreateEventTool" || t.GoogleCalendarCreateEventTool != nil {
		return visitor.VisitGoogleCalendarCreateEventTool(t.GoogleCalendarCreateEventTool)
	}
	if t.typ == "GoogleSheetsRowAppendTool" || t.GoogleSheetsRowAppendTool != nil {
		return visitor.VisitGoogleSheetsRowAppendTool(t.GoogleSheetsRowAppendTool)
	}
	if t.typ == "GoogleCalendarCheckAvailabilityTool" || t.GoogleCalendarCheckAvailabilityTool != nil {
		return visitor.VisitGoogleCalendarCheckAvailabilityTool(t.GoogleCalendarCheckAvailabilityTool)
	}
	if t.typ == "SlackSendMessageTool" || t.SlackSendMessageTool != nil {
		return visitor.VisitSlackSendMessageTool(t.SlackSendMessageTool)
	}
	if t.typ == "SmsTool" || t.SmsTool != nil {
		return visitor.VisitSmsTool(t.SmsTool)
	}
	if t.typ == "McpTool" || t.McpTool != nil {
		return visitor.VisitMcpTool(t.McpTool)
	}
	if t.typ == "GoHighLevelCalendarAvailabilityTool" || t.GoHighLevelCalendarAvailabilityTool != nil {
		return visitor.VisitGoHighLevelCalendarAvailabilityTool(t.GoHighLevelCalendarAvailabilityTool)
	}
	if t.typ == "GoHighLevelCalendarEventCreateTool" || t.GoHighLevelCalendarEventCreateTool != nil {
		return visitor.VisitGoHighLevelCalendarEventCreateTool(t.GoHighLevelCalendarEventCreateTool)
	}
	if t.typ == "GoHighLevelContactCreateTool" || t.GoHighLevelContactCreateTool != nil {
		return visitor.VisitGoHighLevelContactCreateTool(t.GoHighLevelContactCreateTool)
	}
	if t.typ == "GoHighLevelContactGetTool" || t.GoHighLevelContactGetTool != nil {
		return visitor.VisitGoHighLevelContactGetTool(t.GoHighLevelContactGetTool)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}
